C51 COMPILER V9.51   MGR_ISP                                                               11/17/2023 14:48:45 PAGE 1   


C51 COMPILER V9.51, COMPILATION OF MODULE MGR_ISP
OBJECT MODULE PLACED IN mgr_isp.OBJ
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.exe mgr_isp.c DB OE BR INTVECTOR(0X4000) LARGE NOAREGS DEBUG OBJECTEXTEND SB DF
                    -(CLK_FREQUENCY=24,C_DERIVATIVE_C8051F5x) OR CD LC LARGE OT(5,SPEED) INCDIR(c:\SiLabs\MCU\Inc;D:\micom_diag\mcnex_diagnos
                    -tic_bit\CANGEN_MCNEX;D:\micom_diag\mcnex_diagnostic_bit\CanBSW)

line level    source

   1          /*_____ I N C L U D E __________________________________________*/
   2          #include "compiler_defs.h"
   1      =1  //-----------------------------------------------------------------------------
   2      =1  // compiler_defs.h
   3      =1  //-----------------------------------------------------------------------------
   4      =1  // Portions of this file are copyright Maarten Brock
   5      =1  // http://sdcc.sourceforge.net
   6      =1  // Portions of this file are copyright 2010, Silicon Laboratories, Inc.
   7      =1  // http://www.silabs.com
   8      =1  //
   9      =1  // GNU LGPL boilerplate:
  10      =1  /** This library is free software; you can redistribute it and/or
  11      =1    * modify it under the terms of the GNU Lesser General Public
  12      =1    * License as published by the Free Software Foundation; either
  13      =1    * version 2.1 of the License, or (at your option) any later version.
  14      =1    *
  15      =1    * This library is distributed in the hope that it will be useful,
  16      =1    * but WITHOUT ANY WARRANTY; without even the implied warranty of
  17      =1    * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
  18      =1    * Lesser General Public License for more details.
  19      =1    *
  20      =1    * You should have received a copy of the GNU Lesser General Public
  21      =1    * License along with this library; if not, write to the Free Software
  22      =1    * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
  23      =1    *
  24      =1    * In other words, you are welcome to use, share and improve this program.
  25      =1    * You are forbidden to forbid anyone else to use, share and improve
  26      =1    * what you give them. Help stamp out software-hoarding!
  27      =1  **/
  28      =1  // Program Description:
  29      =1  //
  30      =1  // **Important Note**: This header file should be included before including
  31      =1  // a device-specific header file such as C8051F300_defs.h.
  32      =1  //
  33      =1  // Macro definitions to accomodate 8051 compiler differences in specifying
  34      =1  // special function registers and other 8051-specific features such as NOP
  35      =1  // generation, and locating variables in memory-specific segments.  The
  36      =1  // compilers are identified by their unique predefined macros. See also:
  37      =1  // http://predef.sourceforge.net/precomp.html
  38      =1  //
  39      =1  // SBIT and SFR define special bit and special function registers at the given
  40      =1  // address. SFR16 and SFR32 define sfr combinations at adjacent addresses in
  41      =1  // little-endian format. SFR16E and SFR32E define sfr combinations without
  42      =1  // prerequisite byte order or adjacency. None of these multi-byte sfr
  43      =1  // combinations will guarantee the order in which they are accessed when read
  44      =1  // or written.
  45      =1  //
  46      =1  // SFR16X and SFR32X for 16 bit and 32 bit xdata registers are not defined
  47      =1  // to avoid portability issues because of compiler endianness.
  48      =1  //
  49      =1  // Example:
  50      =1  // // my_mcu.c: main 'c' file for my mcu
  51      =1  // #include <compiler_defs.h>  // this file
C51 COMPILER V9.51   MGR_ISP                                                               11/17/2023 14:48:45 PAGE 2   

  52      =1  // #include <C8051xxxx_defs.h> // SFR definitions for specific MCU target
  53      =1  //
  54      =1  // SBIT  (P0_1, 0x80, 1);      // Port 0 pin 1
  55      =1  // SFR   (P0, 0x80);           // Port 0
  56      =1  // SFRX  (CPUCS, 0xE600);      // Cypress FX2 Control and Status register in
  57      =1  //                             // xdata memory at 0xE600
  58      =1  // SFR16 (TMR2, 0xCC);         // Timer 2, lsb at 0xCC, msb at 0xCD
  59      =1  // SFR16E(TMR0, 0x8C8A);       // Timer 0, lsb at 0x8A, msb at 0x8C
  60      =1  // SFR32 (MAC0ACC, 0x93);      // SiLabs C8051F120 32 bits MAC0 Accumulator,
  61      =1  //                             // lsb at 0x93, msb at 0x96
  62      =1  // SFR32E(SUMR, 0xE5E4E3E2);   // TI MSC1210 SUMR 32 bits Summation register,
  63      =1  //                             // lsb at 0xE2, msb at 0xE5
  64      =1  //
  65      =1  // Target:         C8051xxxx
  66      =1  // Tool chain:     Generic
  67      =1  // Command Line:   None
  68      =1  // 
  69      =1  // Release 2.6 - 14 DEC 2012 (GO)
  70      =1  //        -Added define for deprecated SDCC keyword 'at'
  71      =1  // Release 2.5 - 12 SEP 2012 (TP)
  72      =1  //    -Added defines for deprecated SDCC keywords bit and code
  73      =1  // Release 2.4 - 27 AUG 2012 (TP)
  74      =1  //    -Added defines for deprecated SDCC keywords interrupt, _asm, and _endasm
  75      =1  // Release 2.3 - 27 MAY 2010 (DM)
  76      =1  //    -Removed 'LOCATED_VARIABLE' pragma from Keil because it is not supported
  77      =1  // Release 2.2 - 06 APR 2010 (ES)
  78      =1  //    -Removed 'PATHINCLUDE' pragma from Raisonance section
  79      =1  // Release 2.1 - 16 JUL 2009 (ES)
  80      =1  //    -Added SEGMENT_POINTER macro definitions for SDCC, Keil, and Raisonance
  81      =1  //    -Added LOCATED_VARIABLE_NO_INIT macro definitions for Raisonance
  82      =1  // Release 2.0 - 19 MAY 2009 (ES)
  83      =1  //    -Added LOCATED_VARIABLE_NO_INIT macro definitions for SDCC and Keil
  84      =1  // Release 1.9 - 23 OCT 2008 (ES)
  85      =1  //    -Updated Hi-Tech INTERRUPT and INTERRUPT_USING macro definitions
  86      =1  //    -Added SFR16 macro defintion for Hi-Tech
  87      =1  // Release 1.8 - 31 JUL 2008 (ES)
  88      =1  //    -Added INTERRUPT_USING and FUNCTION_USING macro's
  89      =1  //    -Added macro's for IAR
  90      =1  //    -Corrected Union definitions for Hi-Tech and added SFR16 macro defintion
  91      =1  // Release 1.7 - 11 SEP 2007 (BW)
  92      =1  //    -Added support for Raisonance EVAL 03.03.42 and Tasking Eval 7.2r1
  93      =1  // Release 1.6 - 27 AUG 2007 (BW)
  94      =1  //    -Updated copyright notice per agreement with Maartin Brock
  95      =1  //    -Added SDCC 2.7.0 "compiler.h" bug fixes
  96      =1  //    -Added memory segment defines (SEG_XDATA, for example)
  97      =1  // Release 1.5 - 24 AUG 2007 (BW)
  98      =1  //    -Added support for NOP () macro
  99      =1  //    -Added support for Hi-Tech ver 9.01
 100      =1  // Release 1.4 - 07 AUG 2007 (PKC)
 101      =1  //    -Removed FID and fixed formatting.
 102      =1  // Release 1.3 - 30 SEP 2007 (TP)
 103      =1  //    -Added INTERRUPT_PROTO_USING to properly support ISR context switching
 104      =1  //     under SDCC.
 105      =1  // Release 1.2 - (BW)
 106      =1  //    -Added support for U8,U16,U32,S8,S16,S32,UU16,UU32 data types
 107      =1  // Release 1.1 - (BW)
 108      =1  //    -Added support for INTERRUPT, INTERRUPT_USING, INTERRUPT_PROTO,
 109      =1  //     SEGMENT_VARIABLE, VARIABLE_SEGMENT_POINTER,
 110      =1  //     SEGMENT_VARIABLE_SEGMENT_POINTER, and LOCATED_VARIABLE
 111      =1  // Release 1.0 - 29 SEP 2006 (PKC)
 112      =1  //    -Initial revision
 113      =1  
C51 COMPILER V9.51   MGR_ISP                                                               11/17/2023 14:48:45 PAGE 3   

 114      =1  //-----------------------------------------------------------------------------
 115      =1  // Header File Preprocessor Directive
 116      =1  //-----------------------------------------------------------------------------
 117      =1  
 118      =1  #ifndef COMPILER_DEFS_H
 119      =1  #define COMPILER_DEFS_H
 120      =1  
 121      =1  //-----------------------------------------------------------------------------
 122      =1  // Macro definitions
 123      =1  //-----------------------------------------------------------------------------
 124      =1  
 125      =1  // SDCC - Small Device C Compiler
 126      =1  // http://sdcc.sourceforge.net
 127      =1  
 128      =1  #if defined SDCC
           =1 
           =1 #if (SDCC >= 300)
           =1 
           =1 #define interrupt __interrupt
           =1 #define _asm __asm
           =1 #define _endasm __endasm
           =1 #define bit __bit
           =1 #define code __code
           =1 #define at __at
           =1 
           =1 #endif
           =1 
           =1 # define SEG_GENERIC
           =1 # define SEG_FAR   __xdata
           =1 # define SEG_DATA  __data
           =1 # define SEG_NEAR  __data
           =1 # define SEG_IDATA __idata
           =1 # define SEG_XDATA __xdata
           =1 # define SEG_PDATA __pdata
           =1 # define SEG_CODE  __code
           =1 # define SEG_BDATA __bdata
           =1 
           =1 # define SBIT(name, addr, bit)  __sbit  __at(addr+bit)                  name
           =1 # define SFR(name, addr)        __sfr   __at(addr)                      name
           =1 # define SFRX(name, addr)       xdata volatile unsigned char __at(addr) name
           =1 # define SFR16(name, addr)      __sfr16 __at(((addr+1U)<<8) | addr)     name
           =1 # define SFR16E(name, fulladdr) __sfr16 __at(fulladdr)                  name
           =1 # define SFR32(name, addr)      __sfr32 __at(((addr+3UL)<<24) | ((addr+2UL)<<16) | ((addr+1UL)<<8) | addr)
             - name
           =1 # define SFR32E(name, fulladdr) __sfr32 __at(fulladdr)                  name
           =1 
           =1 # define INTERRUPT(name, vector) void name (void) interrupt (vector)
           =1 # define INTERRUPT_USING(name, vector, regnum) void name (void) interrupt (vector) using (regnum)
           =1 # define INTERRUPT_PROTO(name, vector) void name (void) interrupt (vector)
           =1 # define INTERRUPT_PROTO_USING(name, vector, regnum) void name (void) interrupt (vector) using (regnum)
           =1 
           =1 # define FUNCTION_USING(name, return_value, parameter, regnum) return_value name (parameter) using (regnum
             -)
           =1 # define FUNCTION_PROTO_USING(name, return_value, parameter, regnum) return_value name (parameter) using (
             -regnum)
           =1 // Note: Parameter must be either 'void' or include a variable type and name. (Ex: char temp_variable)
           =1 
           =1 # define SEGMENT_VARIABLE(name, vartype, locsegment) locsegment vartype name
           =1 # define VARIABLE_SEGMENT_POINTER(name, vartype, targsegment) targsegment vartype * name
           =1 # define SEGMENT_VARIABLE_SEGMENT_POINTER(name, vartype, targsegment, locsegment) targsegment vartype * lo
             -csegment name
           =1 # define SEGMENT_POINTER(name, vartype, locsegment) vartype * locsegment name
C51 COMPILER V9.51   MGR_ISP                                                               11/17/2023 14:48:45 PAGE 4   

           =1 # define LOCATED_VARIABLE(name, vartype, locsegment, addr, init) locsegment at (addr) vartype name = init
           =1 # define LOCATED_VARIABLE_NO_INIT(name, vartype, locsegment, addr) locsegment at (addr) vartype name
           =1 
           =1 // used with UU16
           =1 # define LSB 0
           =1 # define MSB 1
           =1 
           =1 // used with UU32 (b0 is least-significant byte)
           =1 //# define b0 0
           =1 //# define b1 1
           =1 //# define b2 2
           =1 //# define b3 3
           =1 
           =1 typedef unsigned char U8;
           =1 typedef unsigned int U16;
           =1 typedef unsigned long U32;
           =1 
           =1 typedef signed char S8;
           =1 typedef signed int S16;
           =1 typedef signed long S32;
           =1 
           =1 typedef union UU16
           =1 {
           =1    U16 U16;
           =1    S16 S16;
           =1    U8 U8[2];
           =1    S8 S8[2];
           =1 } UU16;
           =1 
           =1 typedef union UU32
           =1 {
           =1    U32 U32;
           =1    S32 S32;
           =1    UU16 UU16[2];
           =1    U16 U16[2];
           =1    S16 S16[2];
           =1    U8 U8[4];
           =1    S8 S8[4];
           =1 } UU32;
           =1 
           =1 // NOP () macro support
           =1 #define NOP() _asm NOP _endasm
           =1 
           =1 
           =1 //-----------------------------------------------------------------------------
           =1 
           =1 // Raisonance (must be placed before Keil C51)
           =1 // http://www.raisonance.com
           =1 
           =1 #elif defined __RC51__
           =1 
           =1 //#error Raisonance C51 detected.
           =1 
           =1 # define SEG_GENERIC generic     //SEG_GENERIC only applies to pointers in Raisonance, not variables.
           =1 # define SEG_FAR   xdata
           =1 # define SEG_DATA  data
           =1 # define SEG_NEAR  data
           =1 # define SEG_IDATA idata
           =1 # define SEG_XDATA xdata
           =1 # define SEG_PDATA pdata
           =1 # define SEG_CODE  code
           =1 # define SEG_BDATA bdata
C51 COMPILER V9.51   MGR_ISP                                                               11/17/2023 14:48:45 PAGE 5   

           =1 
           =1 # define SBIT(name, addr, bit)  at (addr+bit) sbit         name
           =1 # define SFR(name, addr)        sfr at addr                name
           =1 # define SFR16(name, addr)      sfr16 at addr              name
           =1 # define SFR16E(name, fulladdr) /* not supported */
           =1 # define SFR32(name, fulladdr)  /* not supported */
           =1 # define SFR32E(name, fulladdr) /* not supported */
           =1 
           =1 # define INTERRUPT(name, vector) void name (void) interrupt vector
           =1 # define INTERRUPT_USING(name, vector, regnum) void name (void) interrupt vector using regnum
           =1 # define INTERRUPT_PROTO(name, vector) void name (void)
           =1 # define INTERRUPT_PROTO_USING(name, vector, regnum) void name (void)
           =1 
           =1 # define FUNCTION_USING(name, return_value, parameter, regnum) return_value name (parameter) using regnum
           =1 # define FUNCTION_PROTO_USING(name, return_value, parameter, regnum) return_value name (parameter)
           =1 // Note: Parameter must be either 'void' or include a variable type and name. (Ex: char temp_variable)
           =1 
           =1 # define SEGMENT_VARIABLE(name, vartype, locsegment) vartype locsegment name
           =1 # define VARIABLE_SEGMENT_POINTER(name, vartype, targsegment) vartype targsegment * name
           =1 # define SEGMENT_VARIABLE_SEGMENT_POINTER(name, vartype, targsegment, locsegment) vartype targsegment * lo
             -csegment name
           =1 # define SEGMENT_POINTER(name, vartype, locsegment) vartype * locsegment name
           =1 # define LOCATED_VARIABLE(name, vartype, locsegment, addr, init) at addr locsegment vartype name
           =1 # define LOCATED_VARIABLE_NO_INIT(name, vartype, locsegment, addr) at addr locsegment vartype name
           =1 
           =1 
           =1 // used with UU16
           =1 # define LSB 1
           =1 # define MSB 0
           =1 
           =1 // used with UU32 (b0 is least-significant byte)
           =1 //# define b0 3
           =1 //# define b1 2
           =1 //# define b2 1
           =1 //# define b3 0
           =1 
           =1 typedef unsigned char U8;
           =1 typedef unsigned int U16;
           =1 typedef unsigned long U32;
           =1 
           =1 typedef signed char S8;
           =1 typedef signed int S16;
           =1 typedef signed long S32;
           =1 
           =1 typedef union UU16
           =1 {
           =1    U16 U16;
           =1    S16 S16;
           =1    U8 U8[2];
           =1    S8 S8[2];
           =1 } UU16;
           =1 
           =1 typedef union UU32
           =1 {
           =1    U32 U32;
           =1    S32 S32;
           =1    UU16 UU16[2];
           =1    U16 U16[2];
           =1    S16 S16[2];
           =1    U8 U8[4];
           =1    S8 S8[4];
           =1 } UU32;
C51 COMPILER V9.51   MGR_ISP                                                               11/17/2023 14:48:45 PAGE 6   

           =1 
           =1 // NOP () macro support -- NOP is opcode 0x00
           =1 #define NOP() asm { 0x00 }
           =1 
           =1 
           =1 //-----------------------------------------------------------------------------
           =1 
           =1 
           =1 // Keil C51
           =1 // http://www.keil.com
           =1 
           =1 #elif defined __C51__
 307      =1  
 308      =1  //#error Keil C51 detected.
 309      =1  
 310      =1  # define SEG_GENERIC
 311      =1  # define SEG_FAR   xdata
 312      =1  # define SEG_DATA  data
 313      =1  # define SEG_NEAR  data
 314      =1  # define SEG_IDATA idata
 315      =1  # define SEG_XDATA xdata
 316      =1  # define SEG_PDATA pdata
 317      =1  # define SEG_CODE  code
 318      =1  # define SEG_BDATA bdata
 319      =1  
 320      =1  # define SBIT(name, addr, bit)  sbit  name = addr^bit
 321      =1  # define SFR(name, addr)        sfr   name = addr
 322      =1  # define SFR16(name, addr)      sfr16 name = addr
 323      =1  # define SFR16E(name, fulladdr) /* not supported */
 324      =1  # define SFR32(name, fulladdr)  /* not supported */
 325      =1  # define SFR32E(name, fulladdr) /* not supported */
 326      =1  
 327      =1  # define INTERRUPT(name, vector) void name (void) interrupt vector
 328      =1  # define INTERRUPT_USING(name, vector, regnum) void name (void) interrupt vector using regnum
 329      =1  # define INTERRUPT_PROTO(name, vector) void name (void)
 330      =1  # define INTERRUPT_PROTO_USING(name, vector, regnum) void name (void)
 331      =1  
 332      =1  # define FUNCTION_USING(name, return_value, parameter, regnum) return_value name (parameter) using regnum
 333      =1  # define FUNCTION_PROTO_USING(name, return_value, parameter, regnum) return_value name (parameter)
 334      =1  // Note: Parameter must be either 'void' or include a variable type and name. (Ex: char temp_variable)
 335      =1  
 336      =1  # define SEGMENT_VARIABLE(name, vartype, locsegment) vartype locsegment name
 337      =1  # define VARIABLE_SEGMENT_POINTER(name, vartype, targsegment) vartype targsegment * name
 338      =1  # define SEGMENT_VARIABLE_SEGMENT_POINTER(name, vartype, targsegment, locsegment) vartype targsegment * lo
             -csegment name
 339      =1  # define SEGMENT_POINTER(name, vartype, locsegment) vartype * locsegment name
 340      =1  # define LOCATED_VARIABLE_NO_INIT(name, vartype, locsegment, addr) vartype locsegment name _at_ addr
 341      =1  
 342      =1  // used with UU16
 343      =1  # define LSB 1
 344      =1  # define MSB 0
 345      =1  
 346      =1  // used with UU32 (b0 is least-significant byte)
 347      =1  //# define b0 3
 348      =1  // define b1 2
 349      =1  //# define b2 1
 350      =1  //# define b3 0
 351      =1  
 352      =1  typedef unsigned char U8;
 353      =1  typedef unsigned int U16;
 354      =1  typedef unsigned long U32;
 355      =1  
C51 COMPILER V9.51   MGR_ISP                                                               11/17/2023 14:48:45 PAGE 7   

 356      =1  typedef signed char S8;
 357      =1  typedef signed int S16;
 358      =1  typedef signed long S32;
 359      =1  
 360      =1  typedef union UU16
 361      =1  {
 362      =1     U16 U16;
 363      =1     S16 S16;
 364      =1     U8 U8[2];
 365      =1     S8 S8[2];
 366      =1  } UU16;
 367      =1  
 368      =1  typedef union UU32
 369      =1  {
 370      =1     U32 U32;
 371      =1     S32 S32;
 372      =1     UU16 UU16[2];
 373      =1     U16 U16[2];
 374      =1     S16 S16[2];
 375      =1     U8 U8[4];
 376      =1     S8 S8[4];
 377      =1  } UU32;
 378      =1  
 379      =1  // NOP () macro support
 380      =1  extern void _nop_ (void);
 381      =1  #define NOP() _nop_()
 382      =1  
 383      =1  //-----------------------------------------------------------------------------
 384      =1  
 385      =1  // Hi-Tech 8051
 386      =1  // http://www.htsoft.com
 387      =1  
 388      =1  #elif defined HI_TECH_C
           =1 
           =1 # define SEG_GENERIC
           =1 # define SEG_FAR   far
           =1 # define SEG_DATA  data
           =1 # define SEG_NEAR  near
           =1 # define SEG_IDATA idata
           =1 # define SEG_XDATA xdata
           =1 # define SEG_PDATA pdata
           =1 # define SEG_CODE  code
           =1 # define SEG_BDATA bdata
           =1 
           =1 
           =1 # define SBIT(name, addr, thebit) static volatile bit name @ (addr + thebit)
           =1 # define SFR(name, addr)          static volatile unsigned char name @ addr
           =1 # define SFR16(name, addr)        static volatile unsigned int name @ addr
           =1 # define SFR16E(name, fulladdr) /* not supported */
           =1 # define SFR32(name, fulladdr)  /* not supported */
           =1 # define SFR32E(name, fulladdr) /* not supported */
           =1 
           =1 # define INTERRUPT(name, vector)       void name (void) interrupt vector
           =1 # define INTERRUPT_PROTO(name, vector)
           =1 # define INTERRUPT_USING(name, vector, regnum) void name (void) interrupt vector using regnum
           =1 # define INTERRUPT_PROTO_USING(name, vector, regnum)
           =1 
           =1 # define FUNCTION_USING(name, return_value, parameter, regnum) /* not supported */
           =1 # define FUNCTION_PROTO_USING(name, return_value, parameter, regnum) /* not supported */
           =1 // Note: Hi-Tech does not support functions using different register banks. Register
           =1 //       banks can only be specified in interrupts. If a function is called from
           =1 //       inside an interrupt, it will use the same register bank as the interrupt.
C51 COMPILER V9.51   MGR_ISP                                                               11/17/2023 14:48:45 PAGE 8   

           =1 
           =1 # define SEGMENT_VARIABLE(name, vartype, locsegment) locsegment vartype name
           =1 # define VARIABLE_SEGMENT_POINTER(name, vartype, targsegment) targsegment vartype * name
           =1 # define SEGMENT_VARIABLE_SEGMENT_POINTER(name, vartype, targsegment, locsegment) targsegment vartype * lo
             -csegment name
           =1 # define LOCATED_VARIABLE(name, vartype, locsegment, addr, init) locsegment vartype name @ addr
           =1 
           =1 // used with UU16
           =1 # define LSB 0
           =1 # define MSB 1
           =1 
           =1 // used with UU32 (b0 is least-significant byte)
           =1 # define b0 0
           =1 # define b1 1
           =1 # define b2 2
           =1 # define b3 3
           =1 
           =1 typedef unsigned char U8;
           =1 typedef unsigned int U16;
           =1 typedef unsigned long U32;
           =1 
           =1 typedef signed char S8;
           =1 typedef signed int S16;
           =1 typedef signed long S32;
           =1 
           =1 typedef union UU16
           =1 {
           =1    U16 U16;
           =1    S16 S16;
           =1    U8 U8[2];
           =1    S8 S8[2];
           =1 } UU16;
           =1 
           =1 typedef union UU32
           =1 {
           =1    U32 U32;
           =1    S32 S32;
           =1    UU16 UU16[2];
           =1    U16 U16[2];
           =1    S16 S16[2];
           =1    U8 U8[4];
           =1    S8 S8[4];
           =1 } UU32;
           =1 
           =1 // NOP () macro support
           =1 #define NOP() asm(" nop ")
           =1 
           =1 //-----------------------------------------------------------------------------
           =1 
           =1 // Tasking / Altium
           =1 // http://www.altium.com/tasking
           =1 
           =1 
           =1 #elif defined _CC51
           =1 
           =1 # define SEG_GENERIC
           =1 # define SEG_FAR   _xdat
           =1 # define SEG_DATA  _data
           =1 # define SEG_NEAR  _data
           =1 # define SEG_IDATA _idat
           =1 # define SEG_XDATA _xdat
           =1 # define SEG_PDATA _pdat
C51 COMPILER V9.51   MGR_ISP                                                               11/17/2023 14:48:45 PAGE 9   

           =1 # define SEG_CODE  _rom
           =1 # define SEG_BDATA _bdat
           =1 
           =1 # define SBIT(name, addr, bit)  _sfrbit  name _at(addr+bit)
           =1 # define SFR(name, addr)        _sfrbyte name _at(addr)
           =1 # define SFRX(name, addr)       _xdat volatile unsigned char name _at(addr)
           =1 #if _CC51 > 71
           =1 # define SFR16(name, addr)      _sfrword _little name _at(addr)
           =1 #else
           =1 # define SFR16(name, addr)      /* not supported */
           =1 #endif
           =1 # define SFR16E(name, fulladdr) /* not supported */
           =1 # define SFR32(name, fulladdr)  /* not supported */
           =1 # define SFR32E(name, fulladdr) /* not supported */
           =1 
           =1 # define INTERRUPT(name, vector) _interrupt (vector) void name (void)
           =1 # define INTERRUPT_USING(name, vector, regnum) _interrupt (vector) _using(regnum) void name (void)
           =1 # define INTERRUPT_PROTO(name, vector) _interrupt (vector) void name (void)
           =1 # define INTERRUPT_PROTO_USING(name, vector, regnum) _interrupt (vector) _using(regnum) void name (void)
           =1 
           =1 // When calling FUNCTION_USING in Tasking, the function must be called from an interrupt or Main which
           =1 // is also using the same register bank. If not, the compiler will generate an error.
           =1 # define FUNCTION_USING(name, return_value, parameter, regnum) _using(regnum) return_value name (parameter
             -)
           =1 # define FUNCTION_PROTO_USING(name, return_value, parameter, regnum) _using(regnum) return_value name (par
             -ameter)
           =1 // Note: Parameter must be either 'void' or include a variable type and name. (Ex: char temp_variable)
           =1 
           =1 # define SEGMENT_VARIABLE(name, vartype, locsegment) vartype locsegment name
           =1 # define VARIABLE_SEGMENT_POINTER(name, vartype, targsegment) vartype targsegment * name
           =1 # define SEGMENT_VARIABLE_SEGMENT_POINTER(name, vartype, targsegment, locsegment) vartype targsegment * lo
             -csegment name
           =1 # define LOCATED_VARIABLE(name, vartype, locsegment, addr, init) vartype locsegment name _at( addr )
           =1 
           =1 // used with UU16
           =1 # define LSB 1
           =1 # define MSB 0
           =1 
           =1 // used with UU32 (b0 is least-significant byte)
           =1 //# define b0 3
           =1 //# define b1 2
           =1 //# define b2 1
           =1 //# define b3 0
           =1 
           =1 typedef unsigned char U8;
           =1 typedef unsigned int U16;
           =1 typedef unsigned long U32;
           =1 
           =1 typedef signed char S8;
           =1 typedef signed int S16;
           =1 typedef signed long S32;
           =1 
           =1 typedef union UU16
           =1 {
           =1    U16 U16;
           =1    S16 S16;
           =1    U8 U8[2];
           =1    S8 S8[2];
           =1 } UU16;
           =1 
           =1 typedef union UU32
           =1 {
C51 COMPILER V9.51   MGR_ISP                                                               11/17/2023 14:48:45 PAGE 10  

           =1    U32 U32;
           =1    S32 S32;
           =1    UU16 UU16[2];
           =1    U16 U16[2];
           =1    S16 S16[2];
           =1    U8 U8[4];
           =1    S8 S8[4];
           =1 } UU32;
           =1 
           =1 // NOP () macro support
           =1 extern void _nop (void);
           =1 #define NOP() _nop()
           =1 
           =1 //-----------------------------------------------------------------------------
           =1 
           =1 
           =1 // IAR 8051
           =1 // http://www.iar.com
           =1 
           =1 #elif defined __ICC8051__
           =1 
           =1 #include <stdbool.h>
           =1 #include <intrinsics.h>
           =1 
           =1 # define SBIT(name, addr, bit)  __bit __no_init volatile bool name @ (addr+bit)
           =1 # define SFR(name, addr)        __sfr __no_init volatile unsigned char name @ addr
           =1 # define SFRX(name, addr)       __xdata __no_init volatile unsigned char name @ addr
           =1 # define SFR16(name, addr)      __sfr __no_init volatile unsigned int  name @ addr
           =1 # define SFR16E(name, fulladdr) /* not supported */
           =1 # define SFR32(name, fulladdr) /* not supported */
           =1 # define SFR32E(name, fulladdr) /* not supported */
           =1 
           =1 # define SEG_GENERIC __generic
           =1 # define SEG_FAR  __xdata
           =1 # define SEG_DATA __data
           =1 # define SEG_NEAR __data
           =1 # define SEG_IDATA __idata
           =1 # define SEG_XDATA __xdata
           =1 # define SEG_PDATA __pdata
           =1 # define SEG_CODE  __code
           =1 # define SEG_BDATA __bdata
           =1 
           =1 #define bit bool
           =1 
           =1 # define _PPTOSTR_(x) #x
           =1 # define _PPARAM_(address) _PPTOSTR_(vector=address * 8 + 3)
           =1 # define _PPARAM2_(regbank) _PPTOSTR_(register_bank=regbank)
           =1 # define INTERRUPT(name, vector) _Pragma(_PPARAM_(vector)) __interrupt void name(void)
           =1 # define INTERRUPT_PROTO(name, vector)  __interrupt void name(void)
           =1 # define INTERRUPT_USING(name, vector, regnum) _Pragma(_PPARAM2_(regnum)) _Pragma(_PPARAM_(vector)) __inte
             -rrupt void name(void)
           =1 # define INTERRUPT_PROTO_USING(name, vector, regnum) __interrupt void name(void)
           =1 
           =1 # define FUNCTION_USING(name, return_value, parameter, regnum) /* not supported */
           =1 # define FUNCTION_PROTO_USING(name, return_value, parameter, regnum) /* not supported */
           =1 // Note: IAR does not support functions using different register banks. Register
           =1 //       banks can only be specified in interrupts. If a function is called from
           =1 //       inside an interrupt, it will use the same register bank as the interrupt.
           =1 
           =1 # define SEGMENT_VARIABLE(name, vartype, locsegment)  locsegment vartype name
           =1 # define VARIABLE_SEGMENT_POINTER(name, vartype, targsegment) vartype targsegment  * name
           =1 # define SEGMENT_VARIABLE_SEGMENT_POINTER(name, vartype, targsegment, locsegment) vartype targsegment * lo
C51 COMPILER V9.51   MGR_ISP                                                               11/17/2023 14:48:45 PAGE 11  

             -csegment name
           =1 
           =1 # define LOCATED_VARIABLE(name, vartype, locsegment, addr, init) locsegment __no_init vartype name @ addr
           =1 
           =1 // used with UU16
           =1 # define LSB 0
           =1 # define MSB 1
           =1 
           =1 // used with UU32 (b0 is least-significant byte)
           =1 //# define b0 0
           =1 //# define b1 1
           =1 //# define b2 2
           =1 //# define b3 3
           =1 
           =1 typedef unsigned char U8;
           =1 typedef unsigned int U16;
           =1 typedef unsigned long U32;
           =1 
           =1 typedef signed char S8;
           =1 typedef signed int S16;
           =1 typedef signed long S32;
           =1 
           =1 typedef union UU16
           =1 {
           =1    U16 U16;
           =1    S16 S16;
           =1    U8 U8[2];
           =1    S8 S8[2];
           =1 } UU16;
           =1 
           =1 typedef union UU32
           =1 {
           =1    U32 U32;
           =1    S32 S32;
           =1    UU16 UU16[2];
           =1    U16 U16[2];
           =1    S16 S16[2];
           =1    U8 U8[4];
           =1    S8 S8[4];
           =1 } UU32;
           =1 
           =1 
           =1 #define NOP() __no_operation();
           =1 //-----------------------------------------------------------------------------
           =1 
           =1 // Crossware
           =1 // http://www.crossware.com
           =1 
           =1 #elif defined _XC51_VER
           =1 # define SBIT(name, addr, bit)  _sfrbit  name = (addr+bit)
           =1 # define SFR(name, addr)        _sfr     name = addr
           =1 # define SFR16(name, addr)      _sfrword name = addr
           =1 # define SFR16E(name, fulladdr) /* not supported */
           =1 # define SFR32(name, fulladdr)  /* not supported */
           =1 # define SFR32E(name, fulladdr) /* not supported */
           =1 
           =1 //-----------------------------------------------------------------------------
           =1 
           =1 // Wickenhäuser
           =1 // http://www.wickenhaeuser.de
           =1 
           =1 #elif defined __UC__
C51 COMPILER V9.51   MGR_ISP                                                               11/17/2023 14:48:45 PAGE 12  

           =1 # define SBIT(name, addr, bit)  unsigned char bit  name @ (addr+bit)
           =1 # define SFR(name, addr)        near unsigned char name @ addr
           =1 # define SFR16(name, addr)      /* not supported */
           =1 # define SFR16E(name, fulladdr) /* not supported */
           =1 # define SFR32(name, fulladdr)  /* not supported */
           =1 # define SFR32E(name, fulladdr) /* not supported */
           =1 
           =1 //-----------------------------------------------------------------------------
           =1 
           =1 // Default
           =1 // Unknown compiler
           =1 
           =1 #else
           =1 # warning unrecognized compiler
           =1 # define SBIT(name, addr, bit)  volatile bool           name
           =1 # define SFR(name, addr)        volatile unsigned char  name
           =1 # define SFRX(name, addr)       volatile unsigned char  name
           =1 # define SFR16(name, addr)      volatile unsigned short name
           =1 # define SFR16E(name, fulladdr) volatile unsigned short name
           =1 # define SFR32(name, fulladdr)  volatile unsigned long  name
           =1 # define SFR32E(name, fulladdr) volatile unsigned long  name
           =1 
           =1 #endif
 683      =1  
 684      =1  //-----------------------------------------------------------------------------
 685      =1  // Header File PreProcessor Directive
 686      =1  //-----------------------------------------------------------------------------
 687      =1  
 688      =1  #endif                                 // #define COMPILER_DEFS_H
 689      =1  
 690      =1  //-----------------------------------------------------------------------------
 691      =1  // End Of File
 692      =1  //-----------------------------------------------------------------------------
   3          #include "C8051F580_defs.h"
   1      =1  //-----------------------------------------------------------------------------
   2      =1  // C8051F580_defs.h
   3      =1  //-----------------------------------------------------------------------------
   4      =1  // Copyright 2008, Silicon Laboratories, Inc.
   5      =1  // http://www.silabs.com
   6      =1  //
   7      =1  // Program Description:
   8      =1  //
   9      =1  // Register/bit definitions for the C8051F58x family.
  10      =1  // **Important Note**: The compiler_defs.h header file should be included
  11      =1  // before including this header file.
  12      =1  //
  13      =1  // Target:         C8051F580/1/2/3/4/5/6/7,8/9-F590/1
  14      =1  // Tool chain:     Generic
  15      =1  // Command Line:   None
  16      =1  //
  17      =1  // Release 0.6 - 20 AUG 2012 (TP)
  18      =1  //    -Added #define for _XPAGE to provide support for SDCC memory paging
  19      =1  //     (pdata)
  20      =1  //
  21      =1  // Release 0.5 - 10 SEP 2011 (GP)
  22      =1  //    - Fixed SFR16 definition for CAN0IF2MC
  23      =1  //
  24      =1  // Release 0.4 - 08 OCT 2010 (TP)
  25      =1  //    - Fixed bit definitions for SCON0
  26      =1  //
  27      =1  // Release 0.3 - 01 APR 2009 (GP)
  28      =1  //    - Added SN0-SN3
C51 COMPILER V9.51   MGR_ISP                                                               11/17/2023 14:48:45 PAGE 13  

  29      =1  //
  30      =1  // Release 0.2 - 29 JUL 2008 (ADT)
  31      =1  //    - Added Timer 4 bit definitions
  32      =1  //
  33      =1  // Release 0.1 - 09 JUL 2008 (GP)
  34      =1  //    - Initial Revision
  35      =1  //
  36      =1  //-----------------------------------------------------------------------------
  37      =1  // Header File Preprocessor Directive
  38      =1  //-----------------------------------------------------------------------------
  39      =1  
  40      =1  #ifndef C8051F580_DEFS_H
  41      =1  #define C8051F580_DEFS_H
  42      =1  
  43      =1  //-----------------------------------------------------------------------------
  44      =1  // Page 0, Page 1 and Page F Registers
  45      =1  //-----------------------------------------------------------------------------
  46      =1  
  47      =1  SFR (P0, 0x80);                        // Port 0 Latch
  48      =1  SFR (SP, 0x81);                        // Stack Pointer
  49      =1  SFR (DPL, 0x82);                       // Data Pointer Low
  50      =1  SFR (DPH, 0x83);                       // Data Pointer High
  51      =1  SFR (SFR0CN, 0x84);                    // SFR Page Control
  52      =1  SFR (SFRNEXT, 0x85);                   // SFR stack next page
  53      =1  SFR (SFRLAST, 0x86);                   // SFR stack last page
  54      =1  SFR (PCON, 0x87);                      // Power Control
  55      =1  SFR (TCON, 0x88);                      // Timer/Counter Control
  56      =1  SFR (TMOD, 0x89);                      // Timer/Counter Mode
  57      =1  SFR (TL0, 0x8A);                       // Timer/Counter 0 Low
  58      =1  SFR (TL1, 0x8B);                       // Timer/Counter 1 Low
  59      =1  SFR (TH0, 0x8C);                       // Timer/Counter 0 High
  60      =1  SFR (TH1, 0x8D);                       // Timer/Counter 1 High
  61      =1  SFR (CKCON, 0x8E);                     // Clock Control
  62      =1  SFR (PSCTL, 0x8F);                     // Program Store R/W Control
  63      =1  SFR (CLKSEL, 0x8F);                    // System clock select
  64      =1  SFR (P1, 0x90);                        // Port 1 Latch
  65      =1  SFR (TMR3CN, 0x91);                    // Timer/Counter 3 Control
  66      =1  SFR (TMR5CN, 0x91);                    // Timer/Counter 5 Control
  67      =1  SFR (TMR3RLL, 0x92);                   // Timer/Counter 3 Reload Low
  68      =1  SFR (TMR5CAPL, 0x92);                  // Timer/Counter 5 Capture Low
  69      =1  SFR (TMR3RLH, 0x93);                   // Timer/Counter 3 Reload High
  70      =1  SFR (TMR5CAPH, 0x93);                  // Timer/Counter 5 Capture High
  71      =1  SFR (TMR3L, 0x94);                     // Timer/Counter 3 Low
  72      =1  SFR (TMR5L, 0x94);                     // Timer/Counter 5 Low
  73      =1  SFR (TMR3H, 0x95);                     // Timer/Counter 3 High
  74      =1  SFR (TMR5H, 0x95);                     // Timer/Counter 5 High
  75      =1  SFR (TMR5CF, 0x96);                    // Timer/Counter 5 Configuration
  76      =1  SFR (CLKMUL, 0x97);                    // Clock Multiplier
  77      =1  SFR (SCON0, 0x98);                     // UART0 Control
  78      =1  SFR (SCON1, 0x98);                     // UART1 Control
  79      =1  SFR (SBUF0, 0x99);                     // UART0 Data Buffer
  80      =1  SFR (SBUF1, 0x99);                     // UART1 Data Buffer
  81      =1  SFR (CPT0CN, 0x9A);                    // Comparator 0 Control
  82      =1  SFR (CPT2CN, 0x9A);                    // Comparator 2 Control
  83      =1  SFR (CPT0MD, 0x9B);                    // Comparator 0 Mode
  84      =1  SFR (CPT2MD, 0x9B);                    // Comparator 2 Mode
  85      =1  SFR (CPT0MX, 0x9C);                    // Comparator 0 Mux
  86      =1  SFR (CPT2MX, 0x9C);                    // Comparator 2 Mux
  87      =1  SFR (CPT1CN, 0x9D);                    // Comparator 1 Control
  88      =1  SFR (CPT1MD, 0x9E);                    // Comparator 0 Mode
  89      =1  SFR (OSCIFIN, 0x9E);                   // Internal Oscillator Fine Control
  90      =1  SFR (CPT1MX, 0x9F);                    // Comparator 1 Mux
C51 COMPILER V9.51   MGR_ISP                                                               11/17/2023 14:48:45 PAGE 14  

  91      =1  SFR (OSCXCN, 0x9F);                    // External Oscillator Control
  92      =1  SFR (P2, 0xA0);                        // Port 2 Latch
  93      =1  SFR (SPI0CFG, 0xA1);                   // SPI0 Configuration
  94      =1  SFR (OSCICN, 0xA1);                    // Internal Oscillator Control
  95      =1  SFR (SPI0CKR, 0xA2);                   // SPI0 Clock rate control
  96      =1  SFR (OSCICRS, 0xA2);                   // Internal Oscillator Coarse Control
  97      =1  SFR (SPI0DAT, 0xA3);                   // SPI0 Data Buffer
  98      =1  SFR (P0MDOUT, 0xA4);                   // Port 0 Output Mode
  99      =1  SFR (P1MDOUT, 0xA5);                   // Port 1 Output Mode
 100      =1  SFR (P2MDOUT, 0xA6);                   // Port 2 Output Mode
 101      =1  SFR (SFRPAGE, 0xA7);                   // SFR Page Select
 102      =1  SFR (IE, 0xA8);                        // Interrupt Enable
 103      =1  SFR (SMOD0, 0xA9);                     // Serial Port 0 Control
 104      =1  SFR (EMI0CN, 0xAA);                    // EMIF Control
 105      =1  SFR (EMI0TC, 0xAA);                    // EMIF Timing control
 106      =1  SFR (SBCON0, 0xAB);                    // UART0 Baud Rate Generator Control
 107      =1  SFR (SBRLL0, 0xAC);                    // UART0 Baud Rate Generator Low
 108      =1  SFR (SBRLH0, 0xAD);                    // UART0 Baud Rate Generator High
 109      =1  SFR (P3MAT, 0xAE);                     // Port 3 Match
 110      =1  SFR (P3MDOUT, 0xAE);                   // Port 3 Mode
 111      =1  SFR (P3MASK, 0xAF);                    // Port 3 Mask
 112      =1  SFR (P4MDOUT, 0xAF);                   // Port 4 Mode
 113      =1  SFR (P3, 0xB0);                        // Port 3 Latch
 114      =1  SFR (P2MAT, 0xB1);                     // Port 2 Match
 115      =1  SFR (P2MASK, 0xB2);                    // Port 2 Mask
 116      =1  SFR (EMI0CF, 0xB2);                    // EMIF Configuration
 117      =1  SFR (P4, 0xB5);                        // Port 4 Latch
 118      =1  SFR (FLSCL, 0xB6);                     // Flash Scale
 119      =1  SFR (FLKEY, 0xB7);                     // Flash access limit
 120      =1  SFR (IP, 0xB8);                        // Interrupt Priority
 121      =1  SFR (SMB0ADR, 0xB9);                   // SMBus0 Slave address
 122      =1  SFR (ADC0TK, 0xBA);                    // ADC0 Tracking Mode Select
 123      =1  SFR (SMB0ADM, 0xBA);                   // SMBus0 Address Mask
 124      =1  SFR (ADC0MX, 0xBB);                    // AMUX0 Channel select
 125      =1  SFR (ADC0CF, 0xBC);                    // AMUX0 Channel configuration
 126      =1  SFR (ADC0L, 0xBD);                     // ADC0 Data Low
 127      =1  SFR (ADC0H, 0xBE);                     // ADC0 Data High
 128      =1  SFR (SMB0CN, 0xC0);                    // SMBus0 Control
 129      =1  SFR (SMB0CF, 0xC1);                    // SMBus0 Configuration
 130      =1  SFR (SMB0DAT, 0xC2);                   // SMBus0 Data
 131      =1  SFR (ADC0GTL, 0xC3);                   // ADC0 Greater-Than Compare Low
 132      =1  SFR (ADC0GTH, 0xC4);                   // ADC0 Greater-Than Compare High
 133      =1  SFR (ADC0LTL, 0xC5);                   // ADC0 Less-Than Compare Word Low
 134      =1  SFR (ADC0LTH, 0xC6);                   // ADC0 Less-Than Compare Word High
 135      =1  SFR (XBR3, 0xC6);                      // Port I/O Crossbar Control 3
 136      =1  SFR (XBR2, 0xC7);                      // Port I/O Crossbar Control 2
 137      =1  SFR (TMR2CN, 0xC8);                    // Timer/Counter 2 Control
 138      =1  SFR (TMR4CN, 0xC8);                    // Timer/Counter 4 Control
 139      =1  SFR (REG0CN, 0xC9);                    // Regulator Control
 140      =1  SFR (LIN0CF, 0xC9);                    // LIN 0 Configuration
 141      =1  SFR (TMR4CF, 0xC9);                    // Timer/Counter 4 Configuration
 142      =1  SFR (TMR2RLL, 0xCA);                   // Timer/Counter 2 Reload Low
 143      =1  SFR (TMR4CAPL, 0xCA);                  // Timer/Counter 4 Capture Low
 144      =1  SFR (TMR2RLH, 0xCB);                   // Timer/Counter 2 Reload High
 145      =1  SFR (TMR4CAPH, 0xCB);                  // Timer/Counter 4 Capture High
 146      =1  SFR (TMR2L, 0xCC);                     // Timer/Counter 2 Low
 147      =1  SFR (TMR4L, 0xCC);                     // Timer/Counter 4 Low
 148      =1  SFR (TMR2H, 0xCD);                     // Timer/Counter 2 High
 149      =1  SFR (TMR4H, 0xCD);                     // Timer/Counter 4 High
 150      =1  SFR (PCA0CPL5, 0xCE);                  // PCA0 Capture 5 Low
 151      =1  SFR (PCA1CPL11, 0xCE);                 // PCA1 Capture 11 Low
 152      =1  SFR (PCA0CPH5, 0xCF);                  // PCA0 Capture 5 High
C51 COMPILER V9.51   MGR_ISP                                                               11/17/2023 14:48:45 PAGE 15  

 153      =1  SFR (PCA1CPH11, 0xCF);                 // PCA1 Capture 11 High
 154      =1  SFR (PSW, 0xD0);                       // Program Status Word
 155      =1  SFR (REF0CN, 0xD1);                    // Voltage Reference Control
 156      =1  SFR (LIN0DAT, 0xD2);                   // LIN0 Data
 157      =1  SFR (LIN0ADR, 0xD3);                   // LIN0 Address
 158      =1  SFR (P0SKIP, 0xD4);                    // Port 0 Skip
 159      =1  SFR (P1SKIP, 0xD5);                    // Port 1 Skip
 160      =1  SFR (P2SKIP, 0xD6);                    // Port 2 Skip
 161      =1  SFR (P3SKIP, 0xD7);                    // Port 3 Skip
 162      =1  SFR (PCA0CN, 0xD8);                    // PCA0 Control
 163      =1  SFR (PCA1CN, 0xD8);                    // PCA1 Control
 164      =1  SFR (PCA0MD, 0xD9);                    // PCA0 Mode
 165      =1  SFR (PCA1MD, 0xD9);                    // PCA1 Mode
 166      =1  SFR (PCA0PWM, 0xD9);                   // PCA0 PWM Control
 167      =1  SFR (PCA0CPM0, 0xDA);                  // PCA0 Module 0 Mode
 168      =1  SFR (PCA1CPM6, 0xDA);                  // PCA1 Module 6 Mode
 169      =1  SFR (PCA1PWM, 0xDA);                   // PCA1 PWM Control
 170      =1  SFR (PCA0CPM1, 0xDB);                  // PCA0 Module 1  Mode
 171      =1  SFR (PCA1CPM7, 0xDB);                  // PCA1 Module 7  Mode
 172      =1  SFR (PCA0CPM2, 0xDC);                  // PCA0 Module 2  Mode
 173      =1  SFR (PCA1CPM8, 0xDC);                  // PCA1 Module 8  Mode
 174      =1  SFR (PCA0CPM3, 0xDD);                  // PCA0 Module 3  Mode
 175      =1  SFR (PCA1CPM9, 0xDD);                  // PCA1 Module 9  Mode
 176      =1  SFR (PCA0CPM4, 0xDE);                  // PCA0 Module 4  Mode
 177      =1  SFR (PCA1CPM10, 0xDE);                  // PCA1 Module 10 Mode
 178      =1  SFR (PCA0CPM5, 0xDF);                  // PCA0 Module 5  Mode
 179      =1  SFR (PCA1CPM11, 0xDF);                  // PCA1 Module 11 Mode
 180      =1  SFR (ACC, 0xE0);                       // Accumulator
 181      =1  SFR (XBR0, 0xE1);                      // Port I/O Crossbar Control 0
 182      =1  SFR (XBR1, 0xE2);                      // Port I/O Crossbar Control 1
 183      =1  SFR (CCH0CN, 0xE3);                    // Cache control
 184      =1  SFR (IT01CF, 0xE4);                    // INT0/INT1 Configuration
 185      =1  SFR (EIE1, 0xE6);                      // Extended Interrupt Enable 2
 186      =1  SFR (EIE2, 0xE7);                      // Extended Interrupt Enable 2
 187      =1  SFR (ADC0CN, 0xE8);                    // ADC0 Control
 188      =1  SFR (PCA0CPL1, 0xE9);                  // PCA0 Capture 1 Low
 189      =1  SFR (PCA1CPL1, 0xE9);                  // PCA1 Capture 7 Low
 190      =1  SFR (PCA0CPH1, 0xEA);                  // PCA0 Capture 1 High
 191      =1  SFR (PCA1CPH1, 0xEA);                  // PCA1 Capture 7 High
 192      =1  SFR (PCA0CPL2, 0xEB);                  // PCA0 Capture 2 Low
 193      =1  SFR (PCA1CPL2, 0xEB);                  // PCA1 Capture 8 Low
 194      =1  SFR (PCA0CPH2, 0xEC);                  // PCA0 Capture 2 High
 195      =1  SFR (PCA1CPH2, 0xEC);                  // PCA1 Capture 8 High
 196      =1  SFR (PCA0CPL3, 0xED);                  // PCA0 Capture 3 Low
 197      =1  SFR (PCA1CPL3, 0xED);                  // PCA1 Capture 9 Low
 198      =1  SFR (PCA0CPH3, 0xEE);                  // PCA0 Capture 3 High
 199      =1  SFR (PCA1CPH3, 0xEE);                  // PCA1 Capture 9 High
 200      =1  SFR (RSTSRC, 0xEF);                    // Reset Source Configuration/Status
 201      =1  SFR (B, 0xF0);                         // B Register
 202      =1  SFR (P0MAT, 0xF1);                     // Port 0 Match
 203      =1  SFR (P0MDIN, 0xF1);                    // Port 0 Input Mode
 204      =1  SFR (P0MASK, 0xF2);                    // Port 0 Mask
 205      =1  SFR (P1MDIN, 0xF2);                    // Port 1 Input Mode
 206      =1  SFR (P1MAT, 0xF3);                     // Port 1 Match
 207      =1  SFR (P2MDIN, 0xF3);                    // Port 2 Input Mode
 208      =1  SFR (P1MASK, 0xF4);                    // Port 1 Mask
 209      =1  SFR (P3MDIN, 0xF4);                    // Port 3 Input Mode
 210      =1  SFR (PSBANK, 0xF5);                    // Program Space Bank Select
 211      =1  SFR (EIP1, 0xF6);                      // External Interrupt Priority 1
 212      =1  SFR (EIP2, 0xF7);                      // External Interrupt Priority 2
 213      =1  SFR (SPI0CN, 0xF8);                    // SPI0 Control
 214      =1  SFR (PCA0L, 0xF9);                     // PCA0 Counter Low
C51 COMPILER V9.51   MGR_ISP                                                               11/17/2023 14:48:45 PAGE 16  

 215      =1  SFR (PCA1L, 0xF9);                     // PCA1 Counter Low
 216      =1  SFR (SN0, 0xF9);                       // Serial Number 0
 217      =1  SFR (PCA0H, 0xFA);                     // PCA0 Counter High
 218      =1  SFR (PCA1H, 0xFA);                     // PCA1 Counter High
 219      =1  SFR (SN1, 0xFA);                       // Serial Number 1
 220      =1  SFR (PCA0CPL0, 0xFB);                  // PCA0 Capture 0 Low
 221      =1  SFR (PCA1CPL6, 0xFB);                  // PCA1 Capture 6 Low
 222      =1  SFR (SN2, 0xFB);                       // Serial Number 2
 223      =1  SFR (PCA0CPH0, 0xFC);                  // PCA0 Capture 0 High
 224      =1  SFR (PCA1CPH6, 0xFC);                  // PCA1 Capture 6 High
 225      =1  SFR (SN3, 0xFC);                       // Serial Number 3
 226      =1  SFR (PCA0CPL4, 0xFD);                  // PCA0 Capture 4 Low
 227      =1  SFR (PCA1CPL10, 0xFD);                 // PCA1 Capture 10 Low
 228      =1  SFR (PCA0CPH4, 0xFE);                  // PCA0 Capture 4 High
 229      =1  SFR (PCA1CPH10, 0xFE);                 // PCA1 Capture 10 High
 230      =1  SFR (VDM0CN, 0xFF);                    // VDD Monitor Control
 231      =1  
 232      =1  //-----------------------------------------------------------------------------
 233      =1  // Page C (CAN0) Registers
 234      =1  //-----------------------------------------------------------------------------
 235      =1  
 236      =1  SFR (CAN0CFG, 0x92);                   // CAN0 Clock Configuration
 237      =1  SFR (CAN0STAT, 0x94);                  // Status Register Low Byte
 238      =1  SFR (CAN0ERRL, 0x96);                  // Error Counter Low Byte
 239      =1  SFR (CAN0ERRH, 0x97);                  // Error Counter High Byte
 240      =1  SFR (CAN0BTL, 0x9A);                   // Bit Timing Register Low Byte
 241      =1  SFR (CAN0BTH, 0x9B);                   // Bit Timing Register High Byte
 242      =1  SFR (CAN0IIDL, 0x9C);                  // Interrupt Register Low Byte
 243      =1  SFR (CAN0IIDH, 0x9D);                  // Interrupt Register High Byte
 244      =1  SFR (CAN0TST, 0x9E);                   // Test Register Low Byte
 245      =1  SFR (CAN0BRPE, 0xA1);                  // BRP Extension Register Low Byte
 246      =1  SFR (CAN0TR1L, 0xA2);                  // Transmission Request 1 Low Byte
 247      =1  SFR (CAN0TR1H, 0xA3);                  // Transmission Request 1 High Byte
 248      =1  SFR (CAN0TR2L, 0xA4);                  // Transmission Request 2 Low Byte
 249      =1  SFR (CAN0TR2H, 0xA5);                  // Transmission Request 2 High Byte
 250      =1  SFR (CAN0ND1L, 0xAA);                  // New Data 1 Low Byte
 251      =1  SFR (CAN0ND1H, 0xAB);                  // New Data 1 High Byte
 252      =1  SFR (CAN0ND2L, 0xAC);                  // New Data 2 Low Byte
 253      =1  SFR (CAN0ND2H, 0xAD);                  // New Data 2 High Byte
 254      =1  SFR (CAN0IP1L, 0xAE);                  // Interrupt Pending 1 Low Byte
 255      =1  SFR (CAN0IP1H, 0xAF);                  // Interrupt Pending 1 High Byte
 256      =1  SFR (CAN0IP2L, 0xB2);                  // Interrupt Pending 2 Low Byte
 257      =1  SFR (CAN0IP2H, 0xB3);                  // Interrupt Pending 2 High Byte
 258      =1  SFR (CAN0MV1L, 0xBA);                  // Message Valid 1 Low Byte
 259      =1  SFR (CAN0MV1H, 0xBB);                  // Message Valid 1 High Byte
 260      =1  SFR (CAN0MV2L, 0xBC);                  // Message Valid 2 Low Byte
 261      =1  SFR (CAN0MV2H, 0xBD);                  // Message Valid 2 High Byte
 262      =1  SFR (CAN0IF1CRL, 0xBE);                // IF1 Command Request Low Byte
 263      =1  SFR (CAN0IF1CRH, 0xBF);                // IF1 Command Request High Byte
 264      =1  SFR (CAN0CN, 0xC0);                    // CAN Control Register Low Byte
 265      =1  SFR (CAN0IF1CML, 0xC2);                // IF1 Command Mask Low Byte
 266      =1  SFR (CAN0IF1CMH, 0xC3);                // IF1 Command Mask High Byte
 267      =1  SFR (CAN0IF1M1L, 0xC4);                // IF1 Mask 1 Low Byte
 268      =1  SFR (CAN0IF1M1H, 0xC5);                // IF1 Mask 1 High Byte
 269      =1  SFR (CAN0IF1M2L, 0xC6);                // IF1 Mask 2 Low Byte
 270      =1  SFR (CAN0IF1M2H, 0xC7);                // IF1 Mask 2 High Byte
 271      =1  SFR (CAN0IF1A1L, 0xCA);                // IF1 Arbitration 1 Low Byte
 272      =1  SFR (CAN0IF1A1H, 0xCB);                // IF1 Arbitration 1 High Byte
 273      =1  SFR (CAN0IF1A2L, 0xCC);                // IF1 Arbitration 2 Low Byte
 274      =1  SFR (CAN0IF1A2H, 0xCD);                // IF1 Arbitration 2 High Byte
 275      =1  SFR (CAN0IF2MCL, 0xCE);                // IF2 Message Control Low Byte
 276      =1  SFR (CAN0IF2MCH, 0xCF);                // IF2 Message Control High Byte
C51 COMPILER V9.51   MGR_ISP                                                               11/17/2023 14:48:45 PAGE 17  

 277      =1  SFR (CAN0IF1MCL, 0xD2);                // IF1 Message Control Low Byte
 278      =1  SFR (CAN0IF1MCH, 0xD3);                // IF1 Message Control High Byte
 279      =1  SFR (CAN0IF1DA1L, 0xD4);               // IF1 Data A 1 Low Byte
 280      =1  SFR (CAN0IF1DA1H, 0xD5);               // IF1 Data A 1 High Byte
 281      =1  SFR (CAN0IF1DA2L, 0xD6);               // IF1 Data A 2 Low Byte
 282      =1  SFR (CAN0IF1DA2H, 0xD7);               // IF1 Data A 2 High Byte
 283      =1  SFR (CAN0IF1DB1L, 0xDA);               // IF1 Data B 1 Low Byte
 284      =1  SFR (CAN0IF1DB1H, 0xDB);               // IF1 Data B 1 High Byte
 285      =1  SFR (CAN0IF1DB2L, 0xDC);               // IF1 Data B 2 Low Byte
 286      =1  SFR (CAN0IF1DB2H, 0xDD);               // IF1 Data B 2 High Byte
 287      =1  SFR (CAN0IF2CRL, 0xDE);                // IF2 Command Request Low Byte
 288      =1  SFR (CAN0IF2CRH, 0xDF);                // IF2 Command Request High Byte
 289      =1  SFR (CAN0IF2CML, 0xE2);                // IF2 Command Mask Low Byte
 290      =1  SFR (CAN0IF2CMH, 0xE3);                // IF2 Command Mask High Byte
 291      =1  SFR (CAN0IF2M1L, 0xEA);                // IF2 Mask 1 Low Byte
 292      =1  SFR (CAN0IF2M1H, 0xEB);                // IF2 Mask 1 High Byte
 293      =1  SFR (CAN0IF2M2L, 0xEC);                // IF2 Mask 2 Low Byte
 294      =1  SFR (CAN0IF2M2H, 0xED);                // IF2 Mask 2 High Byte
 295      =1  SFR (CAN0IF2A1L, 0xEE);                // IF2 Arbitration 1 Low Byte
 296      =1  SFR (CAN0IF2A1H, 0xEF);                // IF2 Arbitration 1 High Byte
 297      =1  SFR (CAN0IF2A2L, 0xF2);                // IF2 Arbitration 2 Low Byte
 298      =1  SFR (CAN0IF2A2H, 0xF3);                // IF2 Arbitration 2 High Byte
 299      =1  SFR (CAN0IF2DA1L, 0xF6);               // IF2 Data A 1 Low Byte
 300      =1  SFR (CAN0IF2DA1H, 0xF7);               // IF2 Data A 1 High Byte
 301      =1  SFR (CAN0IF2DA2L, 0xFA);               // IF2 Data A 2 Low Byte
 302      =1  SFR (CAN0IF2DA2H, 0xFB);               // IF2 Data A 2 High Byte
 303      =1  SFR (CAN0IF2DB1L, 0xFC);               // IF2 Data B 1 Low Byte
 304      =1  SFR (CAN0IF2DB1H, 0xFD);               // IF2 Data B 1 High Byte
 305      =1  SFR (CAN0IF2DB2L, 0xFE);               // IF2 Data B 2 Low Byte
 306      =1  SFR (CAN0IF2DB2H, 0xFF);               // IF2 Data B 2 High Byte
 307      =1  
 308      =1  
 309      =1  //-----------------------------------------------------------------------------
 310      =1  // 16-bit Register Definitions (might not be supported by all compilers)
 311      =1  //-----------------------------------------------------------------------------
 312      =1  
 313      =1  SFR16 (DP, 0x82);                      // Data Pointer
 314      =1  SFR16 (TMR3RL, 0x92);                  // Timer 3 Reload
 315      =1  SFR16 (TMR5CAP, 0x92);                 // Timer 5 Capture
 316      =1  SFR16 (TMR3, 0x94);                    // Timer 3 Capture / Reload
 317      =1  SFR16 (TMR5, 0x94);                    // Timer 5
 318      =1  SFR16 (SBRL0, 0xAC);                   // UART0 Reload
 319      =1  SFR16 (ADC0, 0xBD);                    // ADC0 data
 320      =1  SFR16 (ADC0GT, 0xC3);                  // ADC0 Greater Than Window
 321      =1  SFR16 (ADC0LT, 0xC5);                  // ADC0 Less Than Window
 322      =1  SFR16 (TMR2RL, 0xCA);                  // Timer 2 Reload
 323      =1  SFR16 (TMR4CAP, 0xCA);                 // Timer 4 Capture
 324      =1  SFR16 (TMR2, 0xCC);                    // Timer 2 Capture / Reload
 325      =1  SFR16 (TMR4, 0xCC);                    // Timer 4
 326      =1  SFR16 (PCA0CP5, 0xCE);                 // PCA0 Module 5 Capture
 327      =1  SFR16 (PCA1CP11, 0xCE);                // PCA1 Module 11 Capture
 328      =1  SFR16 (PCA0CP1, 0xE9);                 // PCA0 Module 1 Capture
 329      =1  SFR16 (PCA1CP7, 0xE9);                 // PCA1 Module 7 Capture
 330      =1  SFR16 (PCA0CP2, 0xEB);                 // PCA0 Module 2 Capture
 331      =1  SFR16 (PCA1CP8, 0xEB);                 // PCA1 Module 8 Capture
 332      =1  SFR16 (PCA0CP3, 0xED);                 // PCA0 Module 3 Capture
 333      =1  SFR16 (PCA1CP9, 0xED);                 // PCA1 Module 9 Capture
 334      =1  SFR16 (PCA0, 0xF9);                    // PCA0 Counter
 335      =1  SFR16 (PCA1, 0xF9);                    // PCA1 Counter
 336      =1  SFR16 (PCA0CP0, 0xFB);                 // PCA0 Module 0 Capture
 337      =1  SFR16 (PCA1CP6, 0xFB);                 // PCA1 Module 6 Capture
 338      =1  SFR16 (PCA0CP4, 0xFD);                 // PCA0 Module 4 Capture
C51 COMPILER V9.51   MGR_ISP                                                               11/17/2023 14:48:45 PAGE 18  

 339      =1  SFR16 (PCA1CP10, 0xFD);                 // PCA1 Module 10 Capture
 340      =1  
 341      =1  SFR16 (CAN0ERR, 0x96);                 // Error Counter
 342      =1  SFR16 (CAN0BT, 0x9A);                  // Bit Timing Register
 343      =1  SFR16 (CAN0IID, 0x9C);                 // Interrupt Register
 344      =1  SFR16 (CAN0TR1, 0xA2);                 // Transmission Request 1
 345      =1  SFR16 (CAN0TR2, 0xA4);                 // Transmission Request 2
 346      =1  SFR16 (CAN0ND1, 0xAA);                 // New Data 1
 347      =1  SFR16 (CAN0ND2, 0xAC);                 // New Data 2
 348      =1  SFR16 (CAN0IP1, 0xAE);                 // Interrupt Pending 1
 349      =1  SFR16 (CAN0IP2, 0xB2);                 // Interrupt Pending 2
 350      =1  SFR16 (CAN0MV1, 0xBA);                 // Message Valid 1
 351      =1  SFR16 (CAN0MV2, 0xBC);                 // Message Valid 2
 352      =1  SFR16 (CAN0IF1CR, 0xBE);               // IF1 Command Request
 353      =1  SFR16 (CAN0IF1CM, 0xC2);               // IF1 Command Mask
 354      =1  SFR16 (CAN0IF1M1, 0xC4);               // IF1 Mask 1
 355      =1  SFR16 (CAN0IF1M2, 0xC6);               // IF1 Mask 2
 356      =1  SFR16 (CAN0IF1A1, 0xCA);               // IF1 Arbitration 1
 357      =1  SFR16 (CAN0IF1A2, 0xCC);               // IF1 Arbitration 2
 358      =1  SFR16 (CAN0IF1MC, 0xD2);               // IF1 Message Control
 359      =1  SFR16 (CAN0IF1DA1, 0xD4);              // IF1 Data A 1
 360      =1  SFR16 (CAN0IF1DA2, 0xD6);              // IF1 Data A 2
 361      =1  SFR16 (CAN0IF1DB1, 0xDA);              // IF1 Data B 1
 362      =1  SFR16 (CAN0IF1DB2, 0xDC);              // IF1 Data B 2
 363      =1  SFR16 (CAN0IF2CR, 0xDE);               // IF2 Command Request
 364      =1  SFR16 (CAN0IF2CM, 0xE2);               // IF2 Command Mask
 365      =1  SFR16 (CAN0IF2M1, 0xEA);               // IF2 Mask 1
 366      =1  SFR16 (CAN0IF2M2, 0xEC);               // IF2 Mask 2
 367      =1  SFR16 (CAN0IF2A1, 0xEE);               // IF2 Arbitration 1
 368      =1  SFR16 (CAN0IF2A2, 0xF2);               // IF2 Arbitration 2
 369      =1  SFR16 (CAN0IF2MC, 0xCE);               // IF2 Message Control
 370      =1  SFR16 (CAN0IF2DA1, 0xF6);              // IF2 Data A 1
 371      =1  SFR16 (CAN0IF2DA2, 0xFA);              // IF2 Data A 2
 372      =1  SFR16 (CAN0IF2DB1, 0xFC);              // IF2 Data B 1
 373      =1  SFR16 (CAN0IF2DB2, 0xFE);              // IF2 Data B 2
 374      =1  
 375      =1  //-----------------------------------------------------------------------------
 376      =1  // LIN0 Indirect Registers
 377      =1  //-----------------------------------------------------------------------------
 378      =1  
 379      =1  #define  LIN0DT1   0x00                // LIN0 Data Byte 1
 380      =1  #define  LIN0DT2   0x01                // LIN0 Data Byte 2
 381      =1  #define  LIN0DT3   0x02                // LIN0 Data Byte 3
 382      =1  #define  LIN0DT4   0x03                // LIN0 Data Byte 4
 383      =1  #define  LIN0DT5   0x04                // LIN0 Data Byte 5
 384      =1  #define  LIN0DT6   0x05                // LIN0 Data Byte 6
 385      =1  #define  LIN0DT7   0x06                // LIN0 Data Byte 7
 386      =1  #define  LIN0DT8   0x07                // LIN0 Data Byte 8
 387      =1  #define  LIN0CTRL  0x08                // LIN0 Control
 388      =1  #define  LIN0ST    0x09                // LIN0 Status
 389      =1  #define  LIN0ERR   0x0A                // LIN0 Error
 390      =1  #define  LIN0SIZE  0x0B                // LIN0 Message Size
 391      =1  #define  LIN0DIV   0x0C                // LIN0 Divider
 392      =1  #define  LIN0MUL   0x0D                // LIN0 Multiplier
 393      =1  #define  LIN0ID    0x0E                // LIN0 Identifier
 394      =1  
 395      =1  //-----------------------------------------------------------------------------
 396      =1  // Address Definitions for Bit-addressable Registers
 397      =1  //-----------------------------------------------------------------------------
 398      =1  
 399      =1  #define SFR_P0       0x80
 400      =1  #define SFR_TCON     0x88
C51 COMPILER V9.51   MGR_ISP                                                               11/17/2023 14:48:45 PAGE 19  

 401      =1  #define SFR_P1       0x90
 402      =1  #define SFR_SCON0    0x98
 403      =1  #define SFR_SCON1    0x98
 404      =1  #define SFR_P2       0xA0
 405      =1  #define SFR_IE       0xA8
 406      =1  #define SFR_P3       0xB0
 407      =1  #define SFR_IP       0xB8
 408      =1  #define SFR_SMB0CN   0xC0
 409      =1  #define SFR_TMR2CN   0xC8
 410      =1  #define SFR_TMR4CN   0xC8
 411      =1  #define SFR_PSW      0xD0
 412      =1  #define SFR_PCA0CN   0xD8
 413      =1  #define SFR_PCA1CN   0xD8
 414      =1  #define SFR_ACC      0xE0
 415      =1  #define SFR_ADC0CN   0xE8
 416      =1  #define SFR_B        0xF0
 417      =1  #define SFR_SPI0CN   0xF8
 418      =1  
 419      =1  //-----------------------------------------------------------------------------
 420      =1  // Bit Definitions
 421      =1  //-----------------------------------------------------------------------------
 422      =1  
 423      =1  // TCON 0x88
 424      =1  SBIT (TF1, SFR_TCON, 7);               // Timer 1 Overflow Flag
 425      =1  SBIT (TR1, SFR_TCON, 6);               // Timer 1 On/Off Control
 426      =1  SBIT (TF0, SFR_TCON, 5);               // Timer 0 Overflow Flag
 427      =1  SBIT (TR0, SFR_TCON, 4);               // Timer 0 On/Off Control
 428      =1  SBIT (IE1, SFR_TCON, 3);               // Ext. Interrupt 1 Edge Flag
 429      =1  SBIT (IT1, SFR_TCON, 2);               // Ext. Interrupt 1 Type
 430      =1  SBIT (IE0, SFR_TCON, 1);               // Ext. Interrupt 0 Edge Flag
 431      =1  SBIT (IT0, SFR_TCON, 0);               // Ext. Interrupt 0 Type
 432      =1  
 433      =1  // SCON0 0x98
 434      =1  SBIT (OVR0, SFR_SCON0, 7);             // UART0 Receive FIFO Overrun Flag
 435      =1  SBIT (PERR0, SFR_SCON0, 6);            // UART0 Parity Error Flag
 436      =1  SBIT (THRE0, SFR_SCON0, 5);            // UART0 Transmit Register Empty Flag
 437      =1  SBIT (REN0, SFR_SCON0, 4);             // UART0 RX Enable
 438      =1  SBIT (TBX0, SFR_SCON0, 3);             // UART0 Extra Transmission Bit
 439      =1  SBIT (RBX0, SFR_SCON0, 2);             // UART0 Extra Receive Bit
 440      =1  SBIT (TI0, SFR_SCON0, 1);              // UART0 TX Interrupt Flag
 441      =1  SBIT (RI0, SFR_SCON0, 0);              // UART0 RX Interrupt Flag
 442      =1  
 443      =1  // SCON1 0x98
 444      =1  SBIT (S1MODE, SFR_SCON1, 7);           // UART1 Mode 0
 445      =1                                         // Bit 6 UNUSED
 446      =1  SBIT (MCE1, SFR_SCON1, 5);             // UART1 Multiprocessor enable
 447      =1  SBIT (REN1, SFR_SCON1, 4);             // UART1 RX Enable
 448      =1  SBIT (TB81, SFR_SCON1, 3);             // UART1 TX Bit 8
 449      =1  SBIT (RB81, SFR_SCON1, 2);             // UART1 RX Bit 8
 450      =1  SBIT (TI1, SFR_SCON1, 1);              // UART1 TX Interrupt Flag
 451      =1  SBIT (RI1, SFR_SCON1, 0);              // UART1 RX Interrupt Flag
 452      =1  
 453      =1  // IE 0xA8
 454      =1  SBIT (EA, SFR_IE, 7);                  // Global Interrupt Enable
 455      =1  SBIT (ESPI0, SFR_IE, 6);               // SPI0 Interrupt Enable
 456      =1  SBIT (ET2, SFR_IE, 5);                 // Timer 2 Interrupt Enable
 457      =1  SBIT (ES0, SFR_IE, 4);                 // UART0 Interrupt Enable
 458      =1  SBIT (ET1, SFR_IE, 3);                 // Timer 1 Interrupt Enable
 459      =1  SBIT (EX1, SFR_IE, 2);                 // External Interrupt 1 Enable
 460      =1  SBIT (ET0, SFR_IE, 1);                 // Timer 0 Interrupt Enable
 461      =1  SBIT (EX0, SFR_IE, 0);                 // External Interrupt 0 Enable
 462      =1  
C51 COMPILER V9.51   MGR_ISP                                                               11/17/2023 14:48:45 PAGE 20  

 463      =1  // IP 0xB8
 464      =1                                         // Bit 7 unused
 465      =1  SBIT (PSPI0, SFR_IP, 6);               // SPI0 Interrupt Priority
 466      =1  SBIT (PT2, SFR_IP, 5);                 // Timer 2 Priority
 467      =1  SBIT (PS0, SFR_IP, 4);                 // UART0 Priority
 468      =1  SBIT (PS, SFR_IP, 4);                  // UART0 Priority
 469      =1  SBIT (PT1, SFR_IP, 3);                 // Timer 1 Priority
 470      =1  SBIT (PX1, SFR_IP, 2);                 // External Interrupt 1 Priority
 471      =1  SBIT (PT0, SFR_IP, 1);                 // Timer 0 Priority
 472      =1  SBIT (PX0, SFR_IP, 0);                 // External Interrupt 0 Priority
 473      =1  
 474      =1  // SMB0CN 0xC0
 475      =1  SBIT (MASTER, SFR_SMB0CN, 7);          // SMBus0 Master/Slave Indicator
 476      =1  SBIT (TXMODE, SFR_SMB0CN, 6);          // SMBus0 Transmit Mode Indicator
 477      =1  SBIT (STA, SFR_SMB0CN, 5);             // SMBus0 Start Flag
 478      =1  SBIT (STO, SFR_SMB0CN, 4);             // SMBus0 Stop Flag
 479      =1  SBIT (ACKRQ, SFR_SMB0CN, 3);           // SMBus0 Acknowledge Request
 480      =1  SBIT (ARBLOST, SFR_SMB0CN, 2);         // SMBus0 Arbitration Lost Indicator
 481      =1  SBIT (ACK, SFR_SMB0CN, 1);             // SMBus0 Acknowledge
 482      =1  SBIT (SI, SFR_SMB0CN, 0);              // SMBus0 Interrupt Flag
 483      =1  
 484      =1  // TMR2CN 0xC8
 485      =1  SBIT (TF2H, SFR_TMR2CN, 7);            // Timer 2 High-Byte Overflow Flag
 486      =1  SBIT (TF2L, SFR_TMR2CN, 6);            // Timer 2 Low-Byte  Overflow Flag
 487      =1  SBIT (TF2LEN, SFR_TMR2CN, 5);          // Timer 2 Low-Byte Flag Enable
 488      =1  SBIT (TF2CEN, SFR_TMR2CN, 4);          // Timer 2 Capture Enable
 489      =1  SBIT (T2SPLIT, SFR_TMR2CN, 3);         // Timer 2 Split-Mode Enable
 490      =1  SBIT (TR2, SFR_TMR2CN, 2);             // Timer 2 Run Enable
 491      =1  SBIT (T2RCLK, SFR_TMR2CN, 1);          // Timer 2 Xclk/Rclk Select
 492      =1  SBIT (T2XCLK, SFR_TMR2CN, 0);          // Timer 2 Clk/8 Clock Source
 493      =1  
 494      =1  // TMR4CN 0xC8
 495      =1  SBIT (TF4, SFR_TMR4CN, 7);             // Timer 4 Overflow/Underflow Flag
 496      =1  SBIT (EXF4, SFR_TMR4CN, 6);            // Timer 4 External Flag
 497      =1                                         // Bit 5 unused
 498      =1                                         // Bit 4 unused
 499      =1  SBIT (EXE4, SFR_TMR4CN, 3);            // Timer 4 External Enable
 500      =1  SBIT (TR4, SFR_TMR4CN, 2);             // Timer 4 Run Enable
 501      =1  SBIT (CT4, SFR_TMR4CN, 1);             // Timer 4 Counter/Timer Select
 502      =1  SBIT (CPRL4, SFR_TMR4CN, 0);           // Timer 4 Capture/Reload Select
 503      =1  
 504      =1  // PSW 0xD0
 505      =1  SBIT (CY, SFR_PSW, 7);                 // Carry Flag
 506      =1  SBIT (AC, SFR_PSW, 6);                 // Auxiliary Carry Flag
 507      =1  SBIT (F0, SFR_PSW, 5);                 // User Flag 0
 508      =1  SBIT (RS1, SFR_PSW, 4);                // Register Bank Select 1
 509      =1  SBIT (RS0, SFR_PSW, 3);                // Register Bank Select 0
 510      =1  SBIT (OV, SFR_PSW, 2);                 // Overflow Flag
 511      =1  SBIT (F1, SFR_PSW, 1);                 // User Flag 1
 512      =1  SBIT (P, SFR_PSW, 0);                  // Accumulator Parity Flag
 513      =1  
 514      =1  // PCA0CN 0xD8
 515      =1  SBIT (CF, SFR_PCA0CN, 7);              // PCA0 Counter Overflow Flag
 516      =1  SBIT (CR, SFR_PCA0CN, 6);              // PCA0 Counter Run Control Bit
 517      =1  SBIT (CCF5, SFR_PCA0CN, 5);            // PCA0 Module 5 Interrupt Flag
 518      =1  SBIT (CCF4, SFR_PCA0CN, 4);            // PCA0 Module 4 Interrupt Flag
 519      =1  SBIT (CCF3, SFR_PCA0CN, 3);            // PCA0 Module 3 Interrupt Flag
 520      =1  SBIT (CCF2, SFR_PCA0CN, 2);            // PCA0 Module 2 Interrupt Flag
 521      =1  SBIT (CCF1, SFR_PCA0CN, 1);            // PCA0 Module 1 Interrupt Flag
 522      =1  SBIT (CCF0, SFR_PCA0CN, 0);            // PCA0 Module 0 Interrupt Flag
 523      =1  
 524      =1  // PCA1CN 0xD8
C51 COMPILER V9.51   MGR_ISP                                                               11/17/2023 14:48:45 PAGE 21  

 525      =1  SBIT (CF1, SFR_PCA1CN, 7);             // PCA1 Counter Overflow Flag
 526      =1  SBIT (CR1, SFR_PCA1CN, 6);             // PCA1 Counter Run Control Bit
 527      =1  SBIT (CCF11, SFR_PCA1CN, 5);           // PCA1 Module 11 Interrupt Flag
 528      =1  SBIT (CCF10, SFR_PCA1CN, 4);           // PCA1 Module 10 Interrupt Flag
 529      =1  SBIT (CCF9, SFR_PCA1CN, 3);            // PCA1 Module 9 Interrupt Flag
 530      =1  SBIT (CCF8, SFR_PCA1CN, 2);            // PCA1 Module 8 Interrupt Flag
 531      =1  SBIT (CCF7, SFR_PCA1CN, 1);            // PCA1 Module 7 Interrupt Flag
 532      =1  SBIT (CCF6, SFR_PCA1CN, 0);            // PCA1 Module 6 Interrupt Flag
 533      =1  
 534      =1  // ADC0CN 0xE8
 535      =1  SBIT (AD0EN, SFR_ADC0CN, 7);           // ADC0 Enable
 536      =1  SBIT (BURSTEN, SFR_ADC0CN, 6);         // ADC0 Burst Enable
 537      =1  SBIT (AD0INT, SFR_ADC0CN, 5);          // ADC0 EOC Interrupt Flag
 538      =1  SBIT (AD0BUSY, SFR_ADC0CN, 4);         // ADC0 Busy Flag
 539      =1  SBIT (AD0WINT, SFR_ADC0CN, 3);         // ADC0 Window Compare Interrupt Flag
 540      =1  SBIT (AD0LJST, SFR_ADC0CN, 2);         // ADC0 Left Justified
 541      =1  SBIT (AD0CM1, SFR_ADC0CN, 1);          // ADC0 Start Of Conversion Mode Bit 1
 542      =1  SBIT (AD0CM0, SFR_ADC0CN, 0);          // ADC0 Start Of Conversion Mode Bit 0
 543      =1  
 544      =1  // SPI0CN 0xF8
 545      =1  SBIT (SPIF, SFR_SPI0CN, 7);            // SPI0 Interrupt Flag
 546      =1  SBIT (WCOL, SFR_SPI0CN, 6);            // SPI0 Write Collision Flag
 547      =1  SBIT (MODF, SFR_SPI0CN, 5);            // SPI0 Mode Fault Flag
 548      =1  SBIT (RXOVRN, SFR_SPI0CN, 4);          // SPI0 RX Overrun Flag
 549      =1  SBIT (NSSMD1, SFR_SPI0CN, 3);          // SPI0 Slave Select Mode 1
 550      =1  SBIT (NSSMD0, SFR_SPI0CN, 2);          // SPI0 Slave Select Mode 0
 551      =1  SBIT (TXBMT, SFR_SPI0CN, 1);           // SPI0 TX Buffer Empty Flag
 552      =1  SBIT (SPIEN, SFR_SPI0CN, 0);           // SPI0 Enable
 553      =1  
 554      =1  //-----------------------------------------------------------------------------
 555      =1  // Interrupt Priorities
 556      =1  //-----------------------------------------------------------------------------
 557      =1  
 558      =1  #define INTERRUPT_INT0             0   // External Interrupt 0
 559      =1  #define INTERRUPT_TIMER0           1   // Timer 0 Overflow
 560      =1  #define INTERRUPT_INT1             2   // External Interrupt 1
 561      =1  #define INTERRUPT_TIMER1           3   // Timer 1 Overflow
 562      =1  #define INTERRUPT_UART0            4   // UART0
 563      =1  #define INTERRUPT_TIMER2           5   // Timer 2 Overflow
 564      =1  #define INTERRUPT_SPI0             6   // SPI0
 565      =1  #define INTERRUPT_SMBUS0           7   // SMBus0 Interface
 566      =1  #define INTERRUPT_ADC0_WINDOW      8   // ADC0 Window Comparison
 567      =1  #define INTERRUPT_ADC0_EOC         9   // ADC0 End Of Conversion
 568      =1  #define INTERRUPT_PCA0            10   // PCA0 Peripheral
 569      =1  #define INTERRUPT_COMPARATOR0     11   // Comparator 0 Comparison
 570      =1  #define INTERRUPT_COMPARATOR1     12   // Comparator 1 Comparison
 571      =1  #define INTERRUPT_TIMER3          13   // Timer 3 Overflow
 572      =1  #define INTERRUPT_LIN0            14   // LIN Bus Interrupt
 573      =1  #define INTERRUPT_VREG            15   // Voltage Regulator
 574      =1  #define INTERRUPT_CAN0            16   // CAN Bus Interrupt
 575      =1  #define INTERRUPT_PORT_MATCH      17   // Port Match
 576      =1  #define INTERRUPT_UART1           18   // UART1
 577      =1  #define INTERRUPT_PCA1            19   // PCA1 Peripheral
 578      =1  #define INTERRUPT_COMPARATOR2     20   // Comparator 2 Comparison
 579      =1  #define INTERRUPT_TIMER4          21   // Timer 4 Overflow
 580      =1  #define INTERRUPT_TIMER5          22   // Timer 5 Overflow
 581      =1  
 582      =1  
 583      =1  //-----------------------------------------------------------------------------
 584      =1  // SFR Page Definitions
 585      =1  //-----------------------------------------------------------------------------
 586      =1  
C51 COMPILER V9.51   MGR_ISP                                                               11/17/2023 14:48:45 PAGE 22  

 587      =1  #define  CONFIG_PAGE       0x0F        // System and Port Configuration Page
 588      =1  #define  ACTIVE_PAGE       0x00        // Active Use Page
 589      =1  #define  ACTIVE2_PAGE      0x10        // Active Use Page 2
 590      =1  #define  CAN0_PAGE         0x0C        // CAN0 Registers
 591      =1  
 592      =1  //-----------------------------------------------------------------------------
 593      =1  // SDCC PDATA External Memory Paging Support
 594      =1  //-----------------------------------------------------------------------------
 595      =1  
 596      =1  #if defined SDCC
           =1 
           =1 SFR(_XPAGE, 0xAA); // Point to the EMI0CN register
           =1 
           =1 #endif
 601      =1  
 602      =1  //-----------------------------------------------------------------------------
 603      =1  // Header File PreProcessor Directive
 604      =1  //-----------------------------------------------------------------------------
 605      =1  
 606      =1  #endif                                 // #define C8051F580_DEFS_H
 607      =1  
 608      =1  //-----------------------------------------------------------------------------
 609      =1  // End Of File
 610      =1  //-----------------------------------------------------------------------------
   4          #include "Global_Define.h"
   1      =1  /*----------TYPE-------------------*/
   2      =1  
   3      =1  #define CAMERA
   4      =1  #define SYSCLK 24000000
   5      =1  /*----------SENSOR-----------------*/
   6      =1  
   7      =1  //      #define APTINA_126
   8      =1  //      #define APTINA_128
   9      =1          #define APTINA_AP0100                   0x03U
  10      =1          #define APTINA_ASX344                   0x04U
  11      =1  //      #define APTINA_ASX350AT
  12      =1  
  13      =1  
  14      =1  /*----------EEPROM-----------------*/
  15      =1  #define MXIC
  16      =1  //#define WINBOND
  17      =1  
  18      =1  /*----------DEVICE-----------------*/
  19      =1  //#define UART
  20      =1  #define SPI
  21      =1  #define I2C                                                     
  22      =1  #define ADC
  23      =1  #define WATCHDOG
  24      =1  #define PCA
  25      =1  #define CAN
  26      =1  
  27      =1  #define EXINTERRUPT
  28      =1  
  29      =1  /*----------I2C---------------*/        // Use Timer1
  30      =1  //#define I2C_SPEED_100KHZ                      
  31      =1  #define I2C_SPEED_400KHZ                
  32      =1  
  33      =1  /*----------WATCHDOG---------------*/
  34      =1  #define WATCHDOG_ENABLE
  35      =1  //#define WATCHDOG_32MS
  36      =1  #define WATCHDOG_400MS
  37      =1  
C51 COMPILER V9.51   MGR_ISP                                                               11/17/2023 14:48:45 PAGE 23  

  38      =1  /*----------VDDMONITOR-------------*/
  39      =1  #define VDDMONITOR_ENABLE
  40      =1  //#define VDDMONITOR_HIGH
  41      =1  #define VDDMONITOR_LOW
  42      =1  
  43      =1  /*----------TIMER-------------*/
  44      =1  //#define TIMER0                                        //Use Wait_ms()
  45      =1  #define TIMER1                                          //Use SMBUS0
  46      =1  #define TIMER2                                          //1ms interrupt1
  47      =1  #define TIMER3                                          //Use SMBUS0 low time out
  48      =1  //#define TIMER4                                        //1ms interrupt2
  49      =1  #define TIMER5                                          //Use PCA0 (Watchdog)
  50      =1  
  51      =1  /*----------ETC..-----------------*/
  52      =1  #define TRUE    (U8)1
  53      =1  #define FALSE   (U8)0
  54      =1  
  55      =1  #define HIGH    (U8)1
  56      =1  #define LOW     (U8)0
  57      =1  
  58      =1  //CAN DATA
  59      =1  //#define MDPS11                                
  60      =1  //#define LANGUAGEINFO          
  61      =1  //#define HUTYPE                                
  62      =1  //#define GATEWAY                               
  63      =1  //#define NAVIONOFF                     
  64      =1  //#define G_SEL_DISP                
  65      =1  //#define CAM_REARCAMERA_REQ    
  66      =1  
  67      =1  //Operate Mode---------------------
  68      =1  #define OPERATE_STANDBY         (U8)1
  69      =1  #define OPERATE_INTERINIT       (U8)2
  70      =1  #define OPERATE_IDLE            (U8)3
  71      =1  #define OPERATE_RUNNING         (U8)4
  72      =1  
  73      =1  #define DTC_RECORD_WRITE
  74      =1  #define DTC_RECORD_CLEAR
  75      =1  
  76      =1  //Define Error
  77      =1  #define NO_ERROR                        (U8)0x00
  78      =1  #define ERROR_RX_COMM           (U8)0x01        //RX Error
  79      =1  #define ERROR_TX_COMM           (U8)0x02        //TX Error
  80      =1  
  81      =1  //#define ERROR_TX_COMM         (U8)0x02        //RX Error
  82      =1  
  83      =1  //BANK SET
  84      =1  #define BANK0                           (U8)0x00
  85      =1  #define BANK1                           (U8)0x10
  86      =1  #define BANK2                           (U8)0x20
  87      =1  #define BANK3                           (U8)0x30
  88      =1  
  89      =1  //DIAGNOSTIC TEST
  90      =1  //#define DIAG_TEST_MCU_WD_ERR
  91      =1  //#define DIAG_TEST_MCU_MC_ERR
  92      =1  //#define DIAG_TEST_ISP_FV_ERR
  93      =1  //#define DIAG_TEST_ISP_FC_ERR
  94      =1  //#define DIAG_TEST_ISP_IS_ERR
  95      =1  //#define DIAG_TEST_ISP_CM_ERR
  96      =1  //#define DIAG_TEST_ISP_IT_ERR
  97      =1  //#define DIAG_TEST_VID_OC_ERR
  98      =1  //#define DIAG_TEST_VID_VO_ERR
  99      =1  
C51 COMPILER V9.51   MGR_ISP                                                               11/17/2023 14:48:45 PAGE 24  

   5          #include "drv_mcu.h"
   1      =1  #ifndef DRV_MCU_H
   2      =1  #define DRV_MCU_H
   3      =1  /* ----- Global Define -------------------------------*/
   4      =1  //#define  SYSCLK                                               (24000000)      // System clock frequency in Hz
   5      =1  
   6      =1  #define FRAME_SYNC_COUNT        ((g_FrameSync)++)
   7      =1  #define FRAME_SYNC_GET          (g_FrameSync)
   8      =1  #define FRAME_SYNC_CLEAR        ((g_FrameSync) = (0))
   9      =1  /*----------------------------------------------------*/
  10      =1  
  11      =1  /* ----- Global Value --------------------------------*/
  12      =1  /* Pin Name Set */
  13      =1  //-----------------------------------------------------------------------------
  14      =1  // Macros and Macrodefinitions
  15      =1  //-----------------------------------------------------------------------------
  16      =1  SBIT (MCU_F_ENABLE,                     SFR_P1, 4);
  17      =1  SBIT (MCU_FRAME_SYNC,           SFR_P1, 6);
  18      =1  SBIT (AMP_V_STB,                        SFR_P2, 2);
  19      =1  SBIT (AMP_VIDEO_SIG,            SFR_P2, 3);
  20      =1  SBIT (MCU_SENSOR_RESET,         SFR_P2, 4);
  21      =1  SBIT (MCU_MCLK_ENABLE,          SFR_P2, 5);
  22      =1  SBIT (MCU_18V_ENABLE,           SFR_P2, 7);
  23      =1  
  24      =1  SBIT (SDA, SFR_P2, 0);
  25      =1  SBIT (SCL, SFR_P2, 1);
  26      =1  /*----------------------------------------------------*/
  27      =1  
  28      =1  /* ----- Function ------------------------------------*/
  29      =1  void Vdd_Monitor_Init(void);
  30      =1  void Osc_Init(void);
  31      =1  void Port_Init(void);
  32      =1  void Rstsrc_Init(void);
  33      =1  void Exinterrupt_Init(void);
  34      =1  void MCU_Reset(void);
  35      =1  void Device_Init(U8 Device);
  36      =1  U8 Frame_Sync_Status(void);
  37      =1  
  38      =1  #ifndef __PST_PolySpace__
  39      =1  #else
           =1 void INT1_ISR(void);
           =1 #endif
  42      =1  /*----------------------------------------------------*/
  43      =1  
  44      =1  /* ----- Extern Function -----------------------------*/
  45      =1  
  46      =1  /*----------------------------------------------------*/
  47      =1  #endif
  48      =1  
  49      =1  
  50      =1  
  51      =1  
  52      =1  
  53      =1  
  54      =1  
  55      =1  
  56      =1  
  57      =1  
   6          #include "drv_timer.h"
   1      =1  #ifndef DRV_TIMER_H
   2      =1  #define DRV_TIMER_H
   3      =1  
C51 COMPILER V9.51   MGR_ISP                                                               11/17/2023 14:48:45 PAGE 25  

   4      =1  /* ----- Global Define -------------------------------*/
   5      =1  
   6      =1  #define TID_FRAME_VALIDE                        0x01U
   7      =1  #define TID_FRAME_COUNT                         0x02U
   8      =1  #define TID_OVERLAY_GUIDELINE           0x03U
   9      =1  #define TID_SENSOR_IDLE_PERIOD          0x04U
  10      =1  #define TID_I2C_COMM_CHECK                      0x05U
  11      =1  #define TID_VCAN                                        0x06U
  12      =1  #define TID_DTC_WRITE                   0x07U
  13      =1  #define TID_DIAG_ECU_RESET                      0x08U
  14      =1  #define TID_FIRME_UPDATE                        0x09U
  15      =1  #define TID_SENSOR_RESET                        0x0AU
  16      =1  #define TID_CHECKSTATUS_LOOP            0x0BU
  17      =1  #define TID_ADC_CHANGE_TIMER            0x0CU
  18      =1  #define TID_I2C_BUSY_CHECK                      0x0DU
  19      =1  #define TID_DOORBELL_CHECK                      0x0EU
  20      =1  #define TID_GEAR_CHATTERING                     0x0FU
  21      =1  #define TID_TEMP_TIMEOUT                        0x10U
  22      =1  #define TID_COUNT                                       0x11U
  23      =1  
  24      =1  /*----------TIMER DELAY-------------*/
  25      =1  #define DT_FRAME_VALIDE                         100U
  26      =1  #define DT_FRAME_COUNT                          100U
  27      =1  #define DT_VCAN                                          10U
  28      =1  #define DT_OVERLAY_GUIDELINE         50U
  29      =1  #define DT_DTC_WRITE                    100U
  30      =1  #define DT_DIAG_ECU_RESET                   100U
  31      =1  #define DT_FIRME_UPDATE                          30U
  32      =1  #define DT_SENSOR_RESET                         500U
  33      =1  #define DT_SENSOR_IDLE_PERIOD           300U
  34      =1  #define DT_CHECKSTATUS_LOOP                      30U
  35      =1  #define DT_ADC_CHANGE_TIMER                  10U
  36      =1  #define DT_I2C_COMM_CHECK                   100U
  37      =1  #define DT_I2C_BUSY_CHECK                        10U
  38      =1  #define DT_DOORBELL_CHECK                        10U
  39      =1  #define DT_GEAR_CHATTERING                       50U
  40      =1  #define DT_TEMP_TIMEOUT                         100U
  41      =1  /*----------------------------------------------------*/
  42      =1  typedef struct {
  43      =1          U8      Set;
  44      =1          U32 Delay_Time;
  45      =1          U32 Cur_Time;
  46      =1          U32 End_Time;
  47      =1  }tMsg_Time_s;
  48      =1  
  49      =1  typedef struct {
  50      =1          U32 Tick_1ms;
  51      =1          U32     Limit;
  52      =1          U8      Over_Set;
  53      =1  }tMsg_Global_Tick;
  54      =1  
  55      =1  /* ----- Function ------------------------------------*/
  56      =1  void Timer0_Init(void);
  57      =1  void Timer1_Init(void);
  58      =1  #if defined(TIMER2)
  59      =1  void Timer2_Init(void);
  60      =1  #endif
  61      =1  void Timer3_Init(void);
  62      =1  void Timer4_Init(void);
  63      =1  void Timer5_Init(void);
  64      =1  void TIMER1__Init (void);
  65      =1  void Wait_ms (U16 ms);
C51 COMPILER V9.51   MGR_ISP                                                               11/17/2023 14:48:45 PAGE 26  

  66      =1  void Global_Timer_Init(void);
  67      =1  void Delay_Time_Set(U8 ID, U16 Delay_Time);
  68      =1  U8   Delay_Time_Get(U8 ID);
  69      =1  void Delay_Time_Expire(U8 ID);
  70      =1  U16 Get_Time(void);
  71      =1  /*----------------------------------------------------*/
  72      =1  
  73      =1  /* ----- Extern Function -----------------------------*/
  74      =1  extern SEG_XDATA tMsg_Global_Tick g_Global_Tick_Msg;
  75      =1  extern SEG_XDATA tMsg_Time_s    ga_tCAN_Time_Msg[TID_COUNT];
  76      =1  /*----------------------------------------------------*/
  77      =1  
  78      =1  /* ----- Global Value --------------------------------*/
  79      =1  /*----------------------------------------------------*/
  80      =1  
  81      =1  #endif
   7          #include "drv_i2c.h"
   1      =1  #ifndef DRV_I2C_H
   2      =1  #define DRV_I2C_H
   3      =1  
   4      =1  
   5      =1  /* ----- Global Define -------------------------------*/
   6      =1  #define  WRITE          0x00           // SMBus WRITE command
   7      =1  #define  READ           0x01U           // SMBus READ command
   8      =1  #define  SMB_MTSTA      0xE0U           // (MT) start transmitted
   9      =1  #define  SMB_MTDB       0xC0U           // (MT) data byte transmitted
  10      =1  #define  SMB_MRDB       0x80U           // (MR) data byte received
  11      =1  
  12      =1  #define  I2C_1BYTE_RW   0x01U           // (MR) data byte received
  13      =1  #define  I2C_2BYTE_RW   0x02U           // (MR) data byte received
  14      =1  
  15      =1  #if defined(APTINA_AP0100)
  16      =1  #define ISP_SLAVE_ADDRESS       0x90U
  17      =1  #endif
  18      =1  
  19      =1  #if defined(APTINA_AP0100)
  20      =1  #define ISP_SLAVE_ADDRESS       0x90U
  21      =1  #endif
  22      =1  /*----------------------------------------------------*/
  23      =1  
  24      =1  
  25      =1  /* ----- Global Value --------------------------------*/
  26      =1  
  27      =1  /*----------------------------------------------------*/
  28      =1  
  29      =1  
  30      =1  /* ----- Function ------------------------------------*/
  31      =1  void SMBUS0_Init (void);
  32      =1  void SMB_Write (void);
  33      =1  void SMB_Read (void);
  34      =1  U16      i2c_master_read(U8 slave_addr, U16 addr, U8 Byte_Length);
  35      =1  void i2c_master_write(U8 slave_addr, U16 addr, U16 dat, U8 Byte_Length);
  36      =1  
  37      =1  /*----------------------------------------------------*/
  38      =1  
  39      =1  
  40      =1  /* ----- INTERRUPT -----------------------------------*/
  41      =1  INTERRUPT_PROTO (TIMER3_ISR, INTERRUPT_TIMER3);
  42      =1  INTERRUPT_PROTO (SMBUS0_ISR, INTERRUPT_SMBUS0);
  43      =1  /*----------------------------------------------------*/
  44      =1  
  45      =1  /* ----- Extern Function -----------------------------*/
C51 COMPILER V9.51   MGR_ISP                                                               11/17/2023 14:48:45 PAGE 27  

  46      =1  extern SEG_XDATA volatile U8 g_I2C_Err_Cnt;
  47      =1  /*----------------------------------------------------*/
  48      =1  
  49      =1  #endif
  50      =1  
  51      =1  
   8          #include "drv_mem.h"
   1      =1  /* ----- Global Define -------------------------------*/
   2      =1  
   3      =1  /*----------------------------------------------------*/
   4      =1  
   5      =1  /* ----- Global Value --------------------------------*/
   6      =1  
   7      =1  /*----------------------------------------------------*/
   8      =1  
   9      =1  /* ----- Function ------------------------------------*/
  10      =1  
  11      =1  /*----------------------------------------------------*/
  12      =1  
  13      =1  /* ----- Extern Function -----------------------------*/
  14      =1  
  15      =1  /*----------------------------------------------------*/
  16      =1  #ifndef DRV_MEM_H_
  17      =1  #define DRV_MEM_H_
  18      =1  
  19      =1  #include "compiler_defs.h"
   1      =2  //-----------------------------------------------------------------------------
   2      =2  // compiler_defs.h
   3      =2  //-----------------------------------------------------------------------------
   4      =2  // Portions of this file are copyright Maarten Brock
   5      =2  // http://sdcc.sourceforge.net
   6      =2  // Portions of this file are copyright 2010, Silicon Laboratories, Inc.
   7      =2  // http://www.silabs.com
   8      =2  //
   9      =2  // GNU LGPL boilerplate:
  10      =2  /** This library is free software; you can redistribute it and/or
  11      =2    * modify it under the terms of the GNU Lesser General Public
  12      =2    * License as published by the Free Software Foundation; either
  13      =2    * version 2.1 of the License, or (at your option) any later version.
  14      =2    *
  15      =2    * This library is distributed in the hope that it will be useful,
  16      =2    * but WITHOUT ANY WARRANTY; without even the implied warranty of
  17      =2    * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
  18      =2    * Lesser General Public License for more details.
  19      =2    *
  20      =2    * You should have received a copy of the GNU Lesser General Public
  21      =2    * License along with this library; if not, write to the Free Software
  22      =2    * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
  23      =2    *
  24      =2    * In other words, you are welcome to use, share and improve this program.
  25      =2    * You are forbidden to forbid anyone else to use, share and improve
  26      =2    * what you give them. Help stamp out software-hoarding!
  27      =2  **/
  28      =2  // Program Description:
  29      =2  //
  30      =2  // **Important Note**: This header file should be included before including
  31      =2  // a device-specific header file such as C8051F300_defs.h.
  32      =2  //
  33      =2  // Macro definitions to accomodate 8051 compiler differences in specifying
  34      =2  // special function registers and other 8051-specific features such as NOP
  35      =2  // generation, and locating variables in memory-specific segments.  The
  36      =2  // compilers are identified by their unique predefined macros. See also:
C51 COMPILER V9.51   MGR_ISP                                                               11/17/2023 14:48:45 PAGE 28  

  37      =2  // http://predef.sourceforge.net/precomp.html
  38      =2  //
  39      =2  // SBIT and SFR define special bit and special function registers at the given
  40      =2  // address. SFR16 and SFR32 define sfr combinations at adjacent addresses in
  41      =2  // little-endian format. SFR16E and SFR32E define sfr combinations without
  42      =2  // prerequisite byte order or adjacency. None of these multi-byte sfr
  43      =2  // combinations will guarantee the order in which they are accessed when read
  44      =2  // or written.
  45      =2  //
  46      =2  // SFR16X and SFR32X for 16 bit and 32 bit xdata registers are not defined
  47      =2  // to avoid portability issues because of compiler endianness.
  48      =2  //
  49      =2  // Example:
  50      =2  // // my_mcu.c: main 'c' file for my mcu
  51      =2  // #include <compiler_defs.h>  // this file
  52      =2  // #include <C8051xxxx_defs.h> // SFR definitions for specific MCU target
  53      =2  //
  54      =2  // SBIT  (P0_1, 0x80, 1);      // Port 0 pin 1
  55      =2  // SFR   (P0, 0x80);           // Port 0
  56      =2  // SFRX  (CPUCS, 0xE600);      // Cypress FX2 Control and Status register in
  57      =2  //                             // xdata memory at 0xE600
  58      =2  // SFR16 (TMR2, 0xCC);         // Timer 2, lsb at 0xCC, msb at 0xCD
  59      =2  // SFR16E(TMR0, 0x8C8A);       // Timer 0, lsb at 0x8A, msb at 0x8C
  60      =2  // SFR32 (MAC0ACC, 0x93);      // SiLabs C8051F120 32 bits MAC0 Accumulator,
  61      =2  //                             // lsb at 0x93, msb at 0x96
  62      =2  // SFR32E(SUMR, 0xE5E4E3E2);   // TI MSC1210 SUMR 32 bits Summation register,
  63      =2  //                             // lsb at 0xE2, msb at 0xE5
  64      =2  //
  65      =2  // Target:         C8051xxxx
  66      =2  // Tool chain:     Generic
  67      =2  // Command Line:   None
  68      =2  // 
  69      =2  // Release 2.6 - 14 DEC 2012 (GO)
  70      =2  //        -Added define for deprecated SDCC keyword 'at'
  71      =2  // Release 2.5 - 12 SEP 2012 (TP)
  72      =2  //    -Added defines for deprecated SDCC keywords bit and code
  73      =2  // Release 2.4 - 27 AUG 2012 (TP)
  74      =2  //    -Added defines for deprecated SDCC keywords interrupt, _asm, and _endasm
  75      =2  // Release 2.3 - 27 MAY 2010 (DM)
  76      =2  //    -Removed 'LOCATED_VARIABLE' pragma from Keil because it is not supported
  77      =2  // Release 2.2 - 06 APR 2010 (ES)
  78      =2  //    -Removed 'PATHINCLUDE' pragma from Raisonance section
  79      =2  // Release 2.1 - 16 JUL 2009 (ES)
  80      =2  //    -Added SEGMENT_POINTER macro definitions for SDCC, Keil, and Raisonance
  81      =2  //    -Added LOCATED_VARIABLE_NO_INIT macro definitions for Raisonance
  82      =2  // Release 2.0 - 19 MAY 2009 (ES)
  83      =2  //    -Added LOCATED_VARIABLE_NO_INIT macro definitions for SDCC and Keil
  84      =2  // Release 1.9 - 23 OCT 2008 (ES)
  85      =2  //    -Updated Hi-Tech INTERRUPT and INTERRUPT_USING macro definitions
  86      =2  //    -Added SFR16 macro defintion for Hi-Tech
  87      =2  // Release 1.8 - 31 JUL 2008 (ES)
  88      =2  //    -Added INTERRUPT_USING and FUNCTION_USING macro's
  89      =2  //    -Added macro's for IAR
  90      =2  //    -Corrected Union definitions for Hi-Tech and added SFR16 macro defintion
  91      =2  // Release 1.7 - 11 SEP 2007 (BW)
  92      =2  //    -Added support for Raisonance EVAL 03.03.42 and Tasking Eval 7.2r1
  93      =2  // Release 1.6 - 27 AUG 2007 (BW)
  94      =2  //    -Updated copyright notice per agreement with Maartin Brock
  95      =2  //    -Added SDCC 2.7.0 "compiler.h" bug fixes
  96      =2  //    -Added memory segment defines (SEG_XDATA, for example)
  97      =2  // Release 1.5 - 24 AUG 2007 (BW)
  98      =2  //    -Added support for NOP () macro
C51 COMPILER V9.51   MGR_ISP                                                               11/17/2023 14:48:45 PAGE 29  

  99      =2  //    -Added support for Hi-Tech ver 9.01
 100      =2  // Release 1.4 - 07 AUG 2007 (PKC)
 101      =2  //    -Removed FID and fixed formatting.
 102      =2  // Release 1.3 - 30 SEP 2007 (TP)
 103      =2  //    -Added INTERRUPT_PROTO_USING to properly support ISR context switching
 104      =2  //     under SDCC.
 105      =2  // Release 1.2 - (BW)
 106      =2  //    -Added support for U8,U16,U32,S8,S16,S32,UU16,UU32 data types
 107      =2  // Release 1.1 - (BW)
 108      =2  //    -Added support for INTERRUPT, INTERRUPT_USING, INTERRUPT_PROTO,
 109      =2  //     SEGMENT_VARIABLE, VARIABLE_SEGMENT_POINTER,
 110      =2  //     SEGMENT_VARIABLE_SEGMENT_POINTER, and LOCATED_VARIABLE
 111      =2  // Release 1.0 - 29 SEP 2006 (PKC)
 112      =2  //    -Initial revision
 113      =2  
 114      =2  //-----------------------------------------------------------------------------
 115      =2  // Header File Preprocessor Directive
 116      =2  //-----------------------------------------------------------------------------
 117      =2  
 118      =2  #ifndef COMPILER_DEFS_H
           =2 #define COMPILER_DEFS_H
           =2 
           =2 //-----------------------------------------------------------------------------
           =2 // Macro definitions
           =2 //-----------------------------------------------------------------------------
           =2 
           =2 // SDCC - Small Device C Compiler
           =2 // http://sdcc.sourceforge.net
           =2 
           =2 #if defined SDCC
           =2 
           =2 #if (SDCC >= 300)
           =2 
           =2 #define interrupt __interrupt
           =2 #define _asm __asm
           =2 #define _endasm __endasm
           =2 #define bit __bit
           =2 #define code __code
           =2 #define at __at
           =2 
           =2 #endif
           =2 
           =2 # define SEG_GENERIC
           =2 # define SEG_FAR   __xdata
           =2 # define SEG_DATA  __data
           =2 # define SEG_NEAR  __data
           =2 # define SEG_IDATA __idata
           =2 # define SEG_XDATA __xdata
           =2 # define SEG_PDATA __pdata
           =2 # define SEG_CODE  __code
           =2 # define SEG_BDATA __bdata
           =2 
           =2 # define SBIT(name, addr, bit)  __sbit  __at(addr+bit)                  name
           =2 # define SFR(name, addr)        __sfr   __at(addr)                      name
           =2 # define SFRX(name, addr)       xdata volatile unsigned char __at(addr) name
           =2 # define SFR16(name, addr)      __sfr16 __at(((addr+1U)<<8) | addr)     name
           =2 # define SFR16E(name, fulladdr) __sfr16 __at(fulladdr)                  name
           =2 # define SFR32(name, addr)      __sfr32 __at(((addr+3UL)<<24) | ((addr+2UL)<<16) | ((addr+1UL)<<8) | addr)
             - name
           =2 # define SFR32E(name, fulladdr) __sfr32 __at(fulladdr)                  name
           =2 
           =2 # define INTERRUPT(name, vector) void name (void) interrupt (vector)
C51 COMPILER V9.51   MGR_ISP                                                               11/17/2023 14:48:45 PAGE 30  

           =2 # define INTERRUPT_USING(name, vector, regnum) void name (void) interrupt (vector) using (regnum)
           =2 # define INTERRUPT_PROTO(name, vector) void name (void) interrupt (vector)
           =2 # define INTERRUPT_PROTO_USING(name, vector, regnum) void name (void) interrupt (vector) using (regnum)
           =2 
           =2 # define FUNCTION_USING(name, return_value, parameter, regnum) return_value name (parameter) using (regnum
             -)
           =2 # define FUNCTION_PROTO_USING(name, return_value, parameter, regnum) return_value name (parameter) using (
             -regnum)
           =2 // Note: Parameter must be either 'void' or include a variable type and name. (Ex: char temp_variable)
           =2 
           =2 # define SEGMENT_VARIABLE(name, vartype, locsegment) locsegment vartype name
           =2 # define VARIABLE_SEGMENT_POINTER(name, vartype, targsegment) targsegment vartype * name
           =2 # define SEGMENT_VARIABLE_SEGMENT_POINTER(name, vartype, targsegment, locsegment) targsegment vartype * lo
             -csegment name
           =2 # define SEGMENT_POINTER(name, vartype, locsegment) vartype * locsegment name
           =2 # define LOCATED_VARIABLE(name, vartype, locsegment, addr, init) locsegment at (addr) vartype name = init
           =2 # define LOCATED_VARIABLE_NO_INIT(name, vartype, locsegment, addr) locsegment at (addr) vartype name
           =2 
           =2 // used with UU16
           =2 # define LSB 0
           =2 # define MSB 1
           =2 
           =2 // used with UU32 (b0 is least-significant byte)
           =2 //# define b0 0
           =2 //# define b1 1
           =2 //# define b2 2
           =2 //# define b3 3
           =2 
           =2 typedef unsigned char U8;
           =2 typedef unsigned int U16;
           =2 typedef unsigned long U32;
           =2 
           =2 typedef signed char S8;
           =2 typedef signed int S16;
           =2 typedef signed long S32;
           =2 
           =2 typedef union UU16
           =2 {
           =2    U16 U16;
           =2    S16 S16;
           =2    U8 U8[2];
           =2    S8 S8[2];
           =2 } UU16;
           =2 
           =2 typedef union UU32
           =2 {
           =2    U32 U32;
           =2    S32 S32;
           =2    UU16 UU16[2];
           =2    U16 U16[2];
           =2    S16 S16[2];
           =2    U8 U8[4];
           =2    S8 S8[4];
           =2 } UU32;
           =2 
           =2 // NOP () macro support
           =2 #define NOP() _asm NOP _endasm
           =2 
           =2 
           =2 //-----------------------------------------------------------------------------
           =2 
           =2 // Raisonance (must be placed before Keil C51)
C51 COMPILER V9.51   MGR_ISP                                                               11/17/2023 14:48:45 PAGE 31  

           =2 // http://www.raisonance.com
           =2 
           =2 #elif defined __RC51__
           =2 
           =2 //#error Raisonance C51 detected.
           =2 
           =2 # define SEG_GENERIC generic     //SEG_GENERIC only applies to pointers in Raisonance, not variables.
           =2 # define SEG_FAR   xdata
           =2 # define SEG_DATA  data
           =2 # define SEG_NEAR  data
           =2 # define SEG_IDATA idata
           =2 # define SEG_XDATA xdata
           =2 # define SEG_PDATA pdata
           =2 # define SEG_CODE  code
           =2 # define SEG_BDATA bdata
           =2 
           =2 # define SBIT(name, addr, bit)  at (addr+bit) sbit         name
           =2 # define SFR(name, addr)        sfr at addr                name
           =2 # define SFR16(name, addr)      sfr16 at addr              name
           =2 # define SFR16E(name, fulladdr) /* not supported */
           =2 # define SFR32(name, fulladdr)  /* not supported */
           =2 # define SFR32E(name, fulladdr) /* not supported */
           =2 
           =2 # define INTERRUPT(name, vector) void name (void) interrupt vector
           =2 # define INTERRUPT_USING(name, vector, regnum) void name (void) interrupt vector using regnum
           =2 # define INTERRUPT_PROTO(name, vector) void name (void)
           =2 # define INTERRUPT_PROTO_USING(name, vector, regnum) void name (void)
           =2 
           =2 # define FUNCTION_USING(name, return_value, parameter, regnum) return_value name (parameter) using regnum
           =2 # define FUNCTION_PROTO_USING(name, return_value, parameter, regnum) return_value name (parameter)
           =2 // Note: Parameter must be either 'void' or include a variable type and name. (Ex: char temp_variable)
           =2 
           =2 # define SEGMENT_VARIABLE(name, vartype, locsegment) vartype locsegment name
           =2 # define VARIABLE_SEGMENT_POINTER(name, vartype, targsegment) vartype targsegment * name
           =2 # define SEGMENT_VARIABLE_SEGMENT_POINTER(name, vartype, targsegment, locsegment) vartype targsegment * lo
             -csegment name
           =2 # define SEGMENT_POINTER(name, vartype, locsegment) vartype * locsegment name
           =2 # define LOCATED_VARIABLE(name, vartype, locsegment, addr, init) at addr locsegment vartype name
           =2 # define LOCATED_VARIABLE_NO_INIT(name, vartype, locsegment, addr) at addr locsegment vartype name
           =2 
           =2 
           =2 // used with UU16
           =2 # define LSB 1
           =2 # define MSB 0
           =2 
           =2 // used with UU32 (b0 is least-significant byte)
           =2 //# define b0 3
           =2 //# define b1 2
           =2 //# define b2 1
           =2 //# define b3 0
           =2 
           =2 typedef unsigned char U8;
           =2 typedef unsigned int U16;
           =2 typedef unsigned long U32;
           =2 
           =2 typedef signed char S8;
           =2 typedef signed int S16;
           =2 typedef signed long S32;
           =2 
           =2 typedef union UU16
           =2 {
           =2    U16 U16;
C51 COMPILER V9.51   MGR_ISP                                                               11/17/2023 14:48:45 PAGE 32  

           =2    S16 S16;
           =2    U8 U8[2];
           =2    S8 S8[2];
           =2 } UU16;
           =2 
           =2 typedef union UU32
           =2 {
           =2    U32 U32;
           =2    S32 S32;
           =2    UU16 UU16[2];
           =2    U16 U16[2];
           =2    S16 S16[2];
           =2    U8 U8[4];
           =2    S8 S8[4];
           =2 } UU32;
           =2 
           =2 // NOP () macro support -- NOP is opcode 0x00
           =2 #define NOP() asm { 0x00 }
           =2 
           =2 
           =2 //-----------------------------------------------------------------------------
           =2 
           =2 
           =2 // Keil C51
           =2 // http://www.keil.com
           =2 
           =2 #elif defined __C51__
           =2 
           =2 //#error Keil C51 detected.
           =2 
           =2 # define SEG_GENERIC
           =2 # define SEG_FAR   xdata
           =2 # define SEG_DATA  data
           =2 # define SEG_NEAR  data
           =2 # define SEG_IDATA idata
           =2 # define SEG_XDATA xdata
           =2 # define SEG_PDATA pdata
           =2 # define SEG_CODE  code
           =2 # define SEG_BDATA bdata
           =2 
           =2 # define SBIT(name, addr, bit)  sbit  name = addr^bit
           =2 # define SFR(name, addr)        sfr   name = addr
           =2 # define SFR16(name, addr)      sfr16 name = addr
           =2 # define SFR16E(name, fulladdr) /* not supported */
           =2 # define SFR32(name, fulladdr)  /* not supported */
           =2 # define SFR32E(name, fulladdr) /* not supported */
           =2 
           =2 # define INTERRUPT(name, vector) void name (void) interrupt vector
           =2 # define INTERRUPT_USING(name, vector, regnum) void name (void) interrupt vector using regnum
           =2 # define INTERRUPT_PROTO(name, vector) void name (void)
           =2 # define INTERRUPT_PROTO_USING(name, vector, regnum) void name (void)
           =2 
           =2 # define FUNCTION_USING(name, return_value, parameter, regnum) return_value name (parameter) using regnum
           =2 # define FUNCTION_PROTO_USING(name, return_value, parameter, regnum) return_value name (parameter)
           =2 // Note: Parameter must be either 'void' or include a variable type and name. (Ex: char temp_variable)
           =2 
           =2 # define SEGMENT_VARIABLE(name, vartype, locsegment) vartype locsegment name
           =2 # define VARIABLE_SEGMENT_POINTER(name, vartype, targsegment) vartype targsegment * name
           =2 # define SEGMENT_VARIABLE_SEGMENT_POINTER(name, vartype, targsegment, locsegment) vartype targsegment * lo
             -csegment name
           =2 # define SEGMENT_POINTER(name, vartype, locsegment) vartype * locsegment name
           =2 # define LOCATED_VARIABLE_NO_INIT(name, vartype, locsegment, addr) vartype locsegment name _at_ addr
C51 COMPILER V9.51   MGR_ISP                                                               11/17/2023 14:48:45 PAGE 33  

           =2 
           =2 // used with UU16
           =2 # define LSB 1
           =2 # define MSB 0
           =2 
           =2 // used with UU32 (b0 is least-significant byte)
           =2 //# define b0 3
           =2 // define b1 2
           =2 //# define b2 1
           =2 //# define b3 0
           =2 
           =2 typedef unsigned char U8;
           =2 typedef unsigned int U16;
           =2 typedef unsigned long U32;
           =2 
           =2 typedef signed char S8;
           =2 typedef signed int S16;
           =2 typedef signed long S32;
           =2 
           =2 typedef union UU16
           =2 {
           =2    U16 U16;
           =2    S16 S16;
           =2    U8 U8[2];
           =2    S8 S8[2];
           =2 } UU16;
           =2 
           =2 typedef union UU32
           =2 {
           =2    U32 U32;
           =2    S32 S32;
           =2    UU16 UU16[2];
           =2    U16 U16[2];
           =2    S16 S16[2];
           =2    U8 U8[4];
           =2    S8 S8[4];
           =2 } UU32;
           =2 
           =2 // NOP () macro support
           =2 extern void _nop_ (void);
           =2 #define NOP() _nop_()
           =2 
           =2 //-----------------------------------------------------------------------------
           =2 
           =2 // Hi-Tech 8051
           =2 // http://www.htsoft.com
           =2 
           =2 #elif defined HI_TECH_C
           =2 
           =2 # define SEG_GENERIC
           =2 # define SEG_FAR   far
           =2 # define SEG_DATA  data
           =2 # define SEG_NEAR  near
           =2 # define SEG_IDATA idata
           =2 # define SEG_XDATA xdata
           =2 # define SEG_PDATA pdata
           =2 # define SEG_CODE  code
           =2 # define SEG_BDATA bdata
           =2 
           =2 
           =2 # define SBIT(name, addr, thebit) static volatile bit name @ (addr + thebit)
           =2 # define SFR(name, addr)          static volatile unsigned char name @ addr
C51 COMPILER V9.51   MGR_ISP                                                               11/17/2023 14:48:45 PAGE 34  

           =2 # define SFR16(name, addr)        static volatile unsigned int name @ addr
           =2 # define SFR16E(name, fulladdr) /* not supported */
           =2 # define SFR32(name, fulladdr)  /* not supported */
           =2 # define SFR32E(name, fulladdr) /* not supported */
           =2 
           =2 # define INTERRUPT(name, vector)       void name (void) interrupt vector
           =2 # define INTERRUPT_PROTO(name, vector)
           =2 # define INTERRUPT_USING(name, vector, regnum) void name (void) interrupt vector using regnum
           =2 # define INTERRUPT_PROTO_USING(name, vector, regnum)
           =2 
           =2 # define FUNCTION_USING(name, return_value, parameter, regnum) /* not supported */
           =2 # define FUNCTION_PROTO_USING(name, return_value, parameter, regnum) /* not supported */
           =2 // Note: Hi-Tech does not support functions using different register banks. Register
           =2 //       banks can only be specified in interrupts. If a function is called from
           =2 //       inside an interrupt, it will use the same register bank as the interrupt.
           =2 
           =2 # define SEGMENT_VARIABLE(name, vartype, locsegment) locsegment vartype name
           =2 # define VARIABLE_SEGMENT_POINTER(name, vartype, targsegment) targsegment vartype * name
           =2 # define SEGMENT_VARIABLE_SEGMENT_POINTER(name, vartype, targsegment, locsegment) targsegment vartype * lo
             -csegment name
           =2 # define LOCATED_VARIABLE(name, vartype, locsegment, addr, init) locsegment vartype name @ addr
           =2 
           =2 // used with UU16
           =2 # define LSB 0
           =2 # define MSB 1
           =2 
           =2 // used with UU32 (b0 is least-significant byte)
           =2 # define b0 0
           =2 # define b1 1
           =2 # define b2 2
           =2 # define b3 3
           =2 
           =2 typedef unsigned char U8;
           =2 typedef unsigned int U16;
           =2 typedef unsigned long U32;
           =2 
           =2 typedef signed char S8;
           =2 typedef signed int S16;
           =2 typedef signed long S32;
           =2 
           =2 typedef union UU16
           =2 {
           =2    U16 U16;
           =2    S16 S16;
           =2    U8 U8[2];
           =2    S8 S8[2];
           =2 } UU16;
           =2 
           =2 typedef union UU32
           =2 {
           =2    U32 U32;
           =2    S32 S32;
           =2    UU16 UU16[2];
           =2    U16 U16[2];
           =2    S16 S16[2];
           =2    U8 U8[4];
           =2    S8 S8[4];
           =2 } UU32;
           =2 
           =2 // NOP () macro support
           =2 #define NOP() asm(" nop ")
           =2 
C51 COMPILER V9.51   MGR_ISP                                                               11/17/2023 14:48:45 PAGE 35  

           =2 //-----------------------------------------------------------------------------
           =2 
           =2 // Tasking / Altium
           =2 // http://www.altium.com/tasking
           =2 
           =2 
           =2 #elif defined _CC51
           =2 
           =2 # define SEG_GENERIC
           =2 # define SEG_FAR   _xdat
           =2 # define SEG_DATA  _data
           =2 # define SEG_NEAR  _data
           =2 # define SEG_IDATA _idat
           =2 # define SEG_XDATA _xdat
           =2 # define SEG_PDATA _pdat
           =2 # define SEG_CODE  _rom
           =2 # define SEG_BDATA _bdat
           =2 
           =2 # define SBIT(name, addr, bit)  _sfrbit  name _at(addr+bit)
           =2 # define SFR(name, addr)        _sfrbyte name _at(addr)
           =2 # define SFRX(name, addr)       _xdat volatile unsigned char name _at(addr)
           =2 #if _CC51 > 71
           =2 # define SFR16(name, addr)      _sfrword _little name _at(addr)
           =2 #else
           =2 # define SFR16(name, addr)      /* not supported */
           =2 #endif
           =2 # define SFR16E(name, fulladdr) /* not supported */
           =2 # define SFR32(name, fulladdr)  /* not supported */
           =2 # define SFR32E(name, fulladdr) /* not supported */
           =2 
           =2 # define INTERRUPT(name, vector) _interrupt (vector) void name (void)
           =2 # define INTERRUPT_USING(name, vector, regnum) _interrupt (vector) _using(regnum) void name (void)
           =2 # define INTERRUPT_PROTO(name, vector) _interrupt (vector) void name (void)
           =2 # define INTERRUPT_PROTO_USING(name, vector, regnum) _interrupt (vector) _using(regnum) void name (void)
           =2 
           =2 // When calling FUNCTION_USING in Tasking, the function must be called from an interrupt or Main which
           =2 // is also using the same register bank. If not, the compiler will generate an error.
           =2 # define FUNCTION_USING(name, return_value, parameter, regnum) _using(regnum) return_value name (parameter
             -)
           =2 # define FUNCTION_PROTO_USING(name, return_value, parameter, regnum) _using(regnum) return_value name (par
             -ameter)
           =2 // Note: Parameter must be either 'void' or include a variable type and name. (Ex: char temp_variable)
           =2 
           =2 # define SEGMENT_VARIABLE(name, vartype, locsegment) vartype locsegment name
           =2 # define VARIABLE_SEGMENT_POINTER(name, vartype, targsegment) vartype targsegment * name
           =2 # define SEGMENT_VARIABLE_SEGMENT_POINTER(name, vartype, targsegment, locsegment) vartype targsegment * lo
             -csegment name
           =2 # define LOCATED_VARIABLE(name, vartype, locsegment, addr, init) vartype locsegment name _at( addr )
           =2 
           =2 // used with UU16
           =2 # define LSB 1
           =2 # define MSB 0
           =2 
           =2 // used with UU32 (b0 is least-significant byte)
           =2 //# define b0 3
           =2 //# define b1 2
           =2 //# define b2 1
           =2 //# define b3 0
           =2 
           =2 typedef unsigned char U8;
           =2 typedef unsigned int U16;
           =2 typedef unsigned long U32;
C51 COMPILER V9.51   MGR_ISP                                                               11/17/2023 14:48:45 PAGE 36  

           =2 
           =2 typedef signed char S8;
           =2 typedef signed int S16;
           =2 typedef signed long S32;
           =2 
           =2 typedef union UU16
           =2 {
           =2    U16 U16;
           =2    S16 S16;
           =2    U8 U8[2];
           =2    S8 S8[2];
           =2 } UU16;
           =2 
           =2 typedef union UU32
           =2 {
           =2    U32 U32;
           =2    S32 S32;
           =2    UU16 UU16[2];
           =2    U16 U16[2];
           =2    S16 S16[2];
           =2    U8 U8[4];
           =2    S8 S8[4];
           =2 } UU32;
           =2 
           =2 // NOP () macro support
           =2 extern void _nop (void);
           =2 #define NOP() _nop()
           =2 
           =2 //-----------------------------------------------------------------------------
           =2 
           =2 
           =2 // IAR 8051
           =2 // http://www.iar.com
           =2 
           =2 #elif defined __ICC8051__
           =2 
           =2 #include <stdbool.h>
           =2 #include <intrinsics.h>
           =2 
           =2 # define SBIT(name, addr, bit)  __bit __no_init volatile bool name @ (addr+bit)
           =2 # define SFR(name, addr)        __sfr __no_init volatile unsigned char name @ addr
           =2 # define SFRX(name, addr)       __xdata __no_init volatile unsigned char name @ addr
           =2 # define SFR16(name, addr)      __sfr __no_init volatile unsigned int  name @ addr
           =2 # define SFR16E(name, fulladdr) /* not supported */
           =2 # define SFR32(name, fulladdr) /* not supported */
           =2 # define SFR32E(name, fulladdr) /* not supported */
           =2 
           =2 # define SEG_GENERIC __generic
           =2 # define SEG_FAR  __xdata
           =2 # define SEG_DATA __data
           =2 # define SEG_NEAR __data
           =2 # define SEG_IDATA __idata
           =2 # define SEG_XDATA __xdata
           =2 # define SEG_PDATA __pdata
           =2 # define SEG_CODE  __code
           =2 # define SEG_BDATA __bdata
           =2 
           =2 #define bit bool
           =2 
           =2 # define _PPTOSTR_(x) #x
           =2 # define _PPARAM_(address) _PPTOSTR_(vector=address * 8 + 3)
           =2 # define _PPARAM2_(regbank) _PPTOSTR_(register_bank=regbank)
C51 COMPILER V9.51   MGR_ISP                                                               11/17/2023 14:48:45 PAGE 37  

           =2 # define INTERRUPT(name, vector) _Pragma(_PPARAM_(vector)) __interrupt void name(void)
           =2 # define INTERRUPT_PROTO(name, vector)  __interrupt void name(void)
           =2 # define INTERRUPT_USING(name, vector, regnum) _Pragma(_PPARAM2_(regnum)) _Pragma(_PPARAM_(vector)) __inte
             -rrupt void name(void)
           =2 # define INTERRUPT_PROTO_USING(name, vector, regnum) __interrupt void name(void)
           =2 
           =2 # define FUNCTION_USING(name, return_value, parameter, regnum) /* not supported */
           =2 # define FUNCTION_PROTO_USING(name, return_value, parameter, regnum) /* not supported */
           =2 // Note: IAR does not support functions using different register banks. Register
           =2 //       banks can only be specified in interrupts. If a function is called from
           =2 //       inside an interrupt, it will use the same register bank as the interrupt.
           =2 
           =2 # define SEGMENT_VARIABLE(name, vartype, locsegment)  locsegment vartype name
           =2 # define VARIABLE_SEGMENT_POINTER(name, vartype, targsegment) vartype targsegment  * name
           =2 # define SEGMENT_VARIABLE_SEGMENT_POINTER(name, vartype, targsegment, locsegment) vartype targsegment * lo
             -csegment name
           =2 
           =2 # define LOCATED_VARIABLE(name, vartype, locsegment, addr, init) locsegment __no_init vartype name @ addr
           =2 
           =2 // used with UU16
           =2 # define LSB 0
           =2 # define MSB 1
           =2 
           =2 // used with UU32 (b0 is least-significant byte)
           =2 //# define b0 0
           =2 //# define b1 1
           =2 //# define b2 2
           =2 //# define b3 3
           =2 
           =2 typedef unsigned char U8;
           =2 typedef unsigned int U16;
           =2 typedef unsigned long U32;
           =2 
           =2 typedef signed char S8;
           =2 typedef signed int S16;
           =2 typedef signed long S32;
           =2 
           =2 typedef union UU16
           =2 {
           =2    U16 U16;
           =2    S16 S16;
           =2    U8 U8[2];
           =2    S8 S8[2];
           =2 } UU16;
           =2 
           =2 typedef union UU32
           =2 {
           =2    U32 U32;
           =2    S32 S32;
           =2    UU16 UU16[2];
           =2    U16 U16[2];
           =2    S16 S16[2];
           =2    U8 U8[4];
           =2    S8 S8[4];
           =2 } UU32;
           =2 
           =2 
           =2 #define NOP() __no_operation();
           =2 //-----------------------------------------------------------------------------
           =2 
           =2 // Crossware
           =2 // http://www.crossware.com
C51 COMPILER V9.51   MGR_ISP                                                               11/17/2023 14:48:45 PAGE 38  

           =2 
           =2 #elif defined _XC51_VER
           =2 # define SBIT(name, addr, bit)  _sfrbit  name = (addr+bit)
           =2 # define SFR(name, addr)        _sfr     name = addr
           =2 # define SFR16(name, addr)      _sfrword name = addr
           =2 # define SFR16E(name, fulladdr) /* not supported */
           =2 # define SFR32(name, fulladdr)  /* not supported */
           =2 # define SFR32E(name, fulladdr) /* not supported */
           =2 
           =2 //-----------------------------------------------------------------------------
           =2 
           =2 // Wickenhäuser
           =2 // http://www.wickenhaeuser.de
           =2 
           =2 #elif defined __UC__
           =2 # define SBIT(name, addr, bit)  unsigned char bit  name @ (addr+bit)
           =2 # define SFR(name, addr)        near unsigned char name @ addr
           =2 # define SFR16(name, addr)      /* not supported */
           =2 # define SFR16E(name, fulladdr) /* not supported */
           =2 # define SFR32(name, fulladdr)  /* not supported */
           =2 # define SFR32E(name, fulladdr) /* not supported */
           =2 
           =2 //-----------------------------------------------------------------------------
           =2 
           =2 // Default
           =2 // Unknown compiler
           =2 
           =2 #else
           =2 # warning unrecognized compiler
           =2 # define SBIT(name, addr, bit)  volatile bool           name
           =2 # define SFR(name, addr)        volatile unsigned char  name
           =2 # define SFRX(name, addr)       volatile unsigned char  name
           =2 # define SFR16(name, addr)      volatile unsigned short name
           =2 # define SFR16E(name, fulladdr) volatile unsigned short name
           =2 # define SFR32(name, fulladdr)  volatile unsigned long  name
           =2 # define SFR32E(name, fulladdr) volatile unsigned long  name
           =2 
           =2 #endif
           =2 
           =2 //-----------------------------------------------------------------------------
           =2 // Header File PreProcessor Directive
           =2 //-----------------------------------------------------------------------------
           =2 
           =2 #endif                                 // #define COMPILER_DEFS_H
 689      =2  
 690      =2  //-----------------------------------------------------------------------------
 691      =2  // End Of File
 692      =2  //-----------------------------------------------------------------------------
  20      =1  #include "mgr_diag.h"
   1      =2  //#include "drv_i2c.h"
   2      =2  
   3      =2  #ifndef MGR_DIAG_H
   4      =2  #define MGR_DIAG_H
   5      =2  
   6      =2  #include "mgr_comm.h"
   1      =3  #ifndef MGR_COMM_H
   2      =3  #define MGR_COMM_H
   3      =3  
   4      =3  #include "compiler_defs.h"
   1      =4  //-----------------------------------------------------------------------------
   2      =4  // compiler_defs.h
   3      =4  //-----------------------------------------------------------------------------
C51 COMPILER V9.51   MGR_ISP                                                               11/17/2023 14:48:45 PAGE 39  

   4      =4  // Portions of this file are copyright Maarten Brock
   5      =4  // http://sdcc.sourceforge.net
   6      =4  // Portions of this file are copyright 2010, Silicon Laboratories, Inc.
   7      =4  // http://www.silabs.com
   8      =4  //
   9      =4  // GNU LGPL boilerplate:
  10      =4  /** This library is free software; you can redistribute it and/or
  11      =4    * modify it under the terms of the GNU Lesser General Public
  12      =4    * License as published by the Free Software Foundation; either
  13      =4    * version 2.1 of the License, or (at your option) any later version.
  14      =4    *
  15      =4    * This library is distributed in the hope that it will be useful,
  16      =4    * but WITHOUT ANY WARRANTY; without even the implied warranty of
  17      =4    * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
  18      =4    * Lesser General Public License for more details.
  19      =4    *
  20      =4    * You should have received a copy of the GNU Lesser General Public
  21      =4    * License along with this library; if not, write to the Free Software
  22      =4    * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
  23      =4    *
  24      =4    * In other words, you are welcome to use, share and improve this program.
  25      =4    * You are forbidden to forbid anyone else to use, share and improve
  26      =4    * what you give them. Help stamp out software-hoarding!
  27      =4  **/
  28      =4  // Program Description:
  29      =4  //
  30      =4  // **Important Note**: This header file should be included before including
  31      =4  // a device-specific header file such as C8051F300_defs.h.
  32      =4  //
  33      =4  // Macro definitions to accomodate 8051 compiler differences in specifying
  34      =4  // special function registers and other 8051-specific features such as NOP
  35      =4  // generation, and locating variables in memory-specific segments.  The
  36      =4  // compilers are identified by their unique predefined macros. See also:
  37      =4  // http://predef.sourceforge.net/precomp.html
  38      =4  //
  39      =4  // SBIT and SFR define special bit and special function registers at the given
  40      =4  // address. SFR16 and SFR32 define sfr combinations at adjacent addresses in
  41      =4  // little-endian format. SFR16E and SFR32E define sfr combinations without
  42      =4  // prerequisite byte order or adjacency. None of these multi-byte sfr
  43      =4  // combinations will guarantee the order in which they are accessed when read
  44      =4  // or written.
  45      =4  //
  46      =4  // SFR16X and SFR32X for 16 bit and 32 bit xdata registers are not defined
  47      =4  // to avoid portability issues because of compiler endianness.
  48      =4  //
  49      =4  // Example:
  50      =4  // // my_mcu.c: main 'c' file for my mcu
  51      =4  // #include <compiler_defs.h>  // this file
  52      =4  // #include <C8051xxxx_defs.h> // SFR definitions for specific MCU target
  53      =4  //
  54      =4  // SBIT  (P0_1, 0x80, 1);      // Port 0 pin 1
  55      =4  // SFR   (P0, 0x80);           // Port 0
  56      =4  // SFRX  (CPUCS, 0xE600);      // Cypress FX2 Control and Status register in
  57      =4  //                             // xdata memory at 0xE600
  58      =4  // SFR16 (TMR2, 0xCC);         // Timer 2, lsb at 0xCC, msb at 0xCD
  59      =4  // SFR16E(TMR0, 0x8C8A);       // Timer 0, lsb at 0x8A, msb at 0x8C
  60      =4  // SFR32 (MAC0ACC, 0x93);      // SiLabs C8051F120 32 bits MAC0 Accumulator,
  61      =4  //                             // lsb at 0x93, msb at 0x96
  62      =4  // SFR32E(SUMR, 0xE5E4E3E2);   // TI MSC1210 SUMR 32 bits Summation register,
  63      =4  //                             // lsb at 0xE2, msb at 0xE5
  64      =4  //
  65      =4  // Target:         C8051xxxx
C51 COMPILER V9.51   MGR_ISP                                                               11/17/2023 14:48:45 PAGE 40  

  66      =4  // Tool chain:     Generic
  67      =4  // Command Line:   None
  68      =4  // 
  69      =4  // Release 2.6 - 14 DEC 2012 (GO)
  70      =4  //        -Added define for deprecated SDCC keyword 'at'
  71      =4  // Release 2.5 - 12 SEP 2012 (TP)
  72      =4  //    -Added defines for deprecated SDCC keywords bit and code
  73      =4  // Release 2.4 - 27 AUG 2012 (TP)
  74      =4  //    -Added defines for deprecated SDCC keywords interrupt, _asm, and _endasm
  75      =4  // Release 2.3 - 27 MAY 2010 (DM)
  76      =4  //    -Removed 'LOCATED_VARIABLE' pragma from Keil because it is not supported
  77      =4  // Release 2.2 - 06 APR 2010 (ES)
  78      =4  //    -Removed 'PATHINCLUDE' pragma from Raisonance section
  79      =4  // Release 2.1 - 16 JUL 2009 (ES)
  80      =4  //    -Added SEGMENT_POINTER macro definitions for SDCC, Keil, and Raisonance
  81      =4  //    -Added LOCATED_VARIABLE_NO_INIT macro definitions for Raisonance
  82      =4  // Release 2.0 - 19 MAY 2009 (ES)
  83      =4  //    -Added LOCATED_VARIABLE_NO_INIT macro definitions for SDCC and Keil
  84      =4  // Release 1.9 - 23 OCT 2008 (ES)
  85      =4  //    -Updated Hi-Tech INTERRUPT and INTERRUPT_USING macro definitions
  86      =4  //    -Added SFR16 macro defintion for Hi-Tech
  87      =4  // Release 1.8 - 31 JUL 2008 (ES)
  88      =4  //    -Added INTERRUPT_USING and FUNCTION_USING macro's
  89      =4  //    -Added macro's for IAR
  90      =4  //    -Corrected Union definitions for Hi-Tech and added SFR16 macro defintion
  91      =4  // Release 1.7 - 11 SEP 2007 (BW)
  92      =4  //    -Added support for Raisonance EVAL 03.03.42 and Tasking Eval 7.2r1
  93      =4  // Release 1.6 - 27 AUG 2007 (BW)
  94      =4  //    -Updated copyright notice per agreement with Maartin Brock
  95      =4  //    -Added SDCC 2.7.0 "compiler.h" bug fixes
  96      =4  //    -Added memory segment defines (SEG_XDATA, for example)
  97      =4  // Release 1.5 - 24 AUG 2007 (BW)
  98      =4  //    -Added support for NOP () macro
  99      =4  //    -Added support for Hi-Tech ver 9.01
 100      =4  // Release 1.4 - 07 AUG 2007 (PKC)
 101      =4  //    -Removed FID and fixed formatting.
 102      =4  // Release 1.3 - 30 SEP 2007 (TP)
 103      =4  //    -Added INTERRUPT_PROTO_USING to properly support ISR context switching
 104      =4  //     under SDCC.
 105      =4  // Release 1.2 - (BW)
 106      =4  //    -Added support for U8,U16,U32,S8,S16,S32,UU16,UU32 data types
 107      =4  // Release 1.1 - (BW)
 108      =4  //    -Added support for INTERRUPT, INTERRUPT_USING, INTERRUPT_PROTO,
 109      =4  //     SEGMENT_VARIABLE, VARIABLE_SEGMENT_POINTER,
 110      =4  //     SEGMENT_VARIABLE_SEGMENT_POINTER, and LOCATED_VARIABLE
 111      =4  // Release 1.0 - 29 SEP 2006 (PKC)
 112      =4  //    -Initial revision
 113      =4  
 114      =4  //-----------------------------------------------------------------------------
 115      =4  // Header File Preprocessor Directive
 116      =4  //-----------------------------------------------------------------------------
 117      =4  
 118      =4  #ifndef COMPILER_DEFS_H
           =4 #define COMPILER_DEFS_H
           =4 
           =4 //-----------------------------------------------------------------------------
           =4 // Macro definitions
           =4 //-----------------------------------------------------------------------------
           =4 
           =4 // SDCC - Small Device C Compiler
           =4 // http://sdcc.sourceforge.net
           =4 
C51 COMPILER V9.51   MGR_ISP                                                               11/17/2023 14:48:45 PAGE 41  

           =4 #if defined SDCC
           =4 
           =4 #if (SDCC >= 300)
           =4 
           =4 #define interrupt __interrupt
           =4 #define _asm __asm
           =4 #define _endasm __endasm
           =4 #define bit __bit
           =4 #define code __code
           =4 #define at __at
           =4 
           =4 #endif
           =4 
           =4 # define SEG_GENERIC
           =4 # define SEG_FAR   __xdata
           =4 # define SEG_DATA  __data
           =4 # define SEG_NEAR  __data
           =4 # define SEG_IDATA __idata
           =4 # define SEG_XDATA __xdata
           =4 # define SEG_PDATA __pdata
           =4 # define SEG_CODE  __code
           =4 # define SEG_BDATA __bdata
           =4 
           =4 # define SBIT(name, addr, bit)  __sbit  __at(addr+bit)                  name
           =4 # define SFR(name, addr)        __sfr   __at(addr)                      name
           =4 # define SFRX(name, addr)       xdata volatile unsigned char __at(addr) name
           =4 # define SFR16(name, addr)      __sfr16 __at(((addr+1U)<<8) | addr)     name
           =4 # define SFR16E(name, fulladdr) __sfr16 __at(fulladdr)                  name
           =4 # define SFR32(name, addr)      __sfr32 __at(((addr+3UL)<<24) | ((addr+2UL)<<16) | ((addr+1UL)<<8) | addr)
             - name
           =4 # define SFR32E(name, fulladdr) __sfr32 __at(fulladdr)                  name
           =4 
           =4 # define INTERRUPT(name, vector) void name (void) interrupt (vector)
           =4 # define INTERRUPT_USING(name, vector, regnum) void name (void) interrupt (vector) using (regnum)
           =4 # define INTERRUPT_PROTO(name, vector) void name (void) interrupt (vector)
           =4 # define INTERRUPT_PROTO_USING(name, vector, regnum) void name (void) interrupt (vector) using (regnum)
           =4 
           =4 # define FUNCTION_USING(name, return_value, parameter, regnum) return_value name (parameter) using (regnum
             -)
           =4 # define FUNCTION_PROTO_USING(name, return_value, parameter, regnum) return_value name (parameter) using (
             -regnum)
           =4 // Note: Parameter must be either 'void' or include a variable type and name. (Ex: char temp_variable)
           =4 
           =4 # define SEGMENT_VARIABLE(name, vartype, locsegment) locsegment vartype name
           =4 # define VARIABLE_SEGMENT_POINTER(name, vartype, targsegment) targsegment vartype * name
           =4 # define SEGMENT_VARIABLE_SEGMENT_POINTER(name, vartype, targsegment, locsegment) targsegment vartype * lo
             -csegment name
           =4 # define SEGMENT_POINTER(name, vartype, locsegment) vartype * locsegment name
           =4 # define LOCATED_VARIABLE(name, vartype, locsegment, addr, init) locsegment at (addr) vartype name = init
           =4 # define LOCATED_VARIABLE_NO_INIT(name, vartype, locsegment, addr) locsegment at (addr) vartype name
           =4 
           =4 // used with UU16
           =4 # define LSB 0
           =4 # define MSB 1
           =4 
           =4 // used with UU32 (b0 is least-significant byte)
           =4 //# define b0 0
           =4 //# define b1 1
           =4 //# define b2 2
           =4 //# define b3 3
           =4 
           =4 typedef unsigned char U8;
C51 COMPILER V9.51   MGR_ISP                                                               11/17/2023 14:48:45 PAGE 42  

           =4 typedef unsigned int U16;
           =4 typedef unsigned long U32;
           =4 
           =4 typedef signed char S8;
           =4 typedef signed int S16;
           =4 typedef signed long S32;
           =4 
           =4 typedef union UU16
           =4 {
           =4    U16 U16;
           =4    S16 S16;
           =4    U8 U8[2];
           =4    S8 S8[2];
           =4 } UU16;
           =4 
           =4 typedef union UU32
           =4 {
           =4    U32 U32;
           =4    S32 S32;
           =4    UU16 UU16[2];
           =4    U16 U16[2];
           =4    S16 S16[2];
           =4    U8 U8[4];
           =4    S8 S8[4];
           =4 } UU32;
           =4 
           =4 // NOP () macro support
           =4 #define NOP() _asm NOP _endasm
           =4 
           =4 
           =4 //-----------------------------------------------------------------------------
           =4 
           =4 // Raisonance (must be placed before Keil C51)
           =4 // http://www.raisonance.com
           =4 
           =4 #elif defined __RC51__
           =4 
           =4 //#error Raisonance C51 detected.
           =4 
           =4 # define SEG_GENERIC generic     //SEG_GENERIC only applies to pointers in Raisonance, not variables.
           =4 # define SEG_FAR   xdata
           =4 # define SEG_DATA  data
           =4 # define SEG_NEAR  data
           =4 # define SEG_IDATA idata
           =4 # define SEG_XDATA xdata
           =4 # define SEG_PDATA pdata
           =4 # define SEG_CODE  code
           =4 # define SEG_BDATA bdata
           =4 
           =4 # define SBIT(name, addr, bit)  at (addr+bit) sbit         name
           =4 # define SFR(name, addr)        sfr at addr                name
           =4 # define SFR16(name, addr)      sfr16 at addr              name
           =4 # define SFR16E(name, fulladdr) /* not supported */
           =4 # define SFR32(name, fulladdr)  /* not supported */
           =4 # define SFR32E(name, fulladdr) /* not supported */
           =4 
           =4 # define INTERRUPT(name, vector) void name (void) interrupt vector
           =4 # define INTERRUPT_USING(name, vector, regnum) void name (void) interrupt vector using regnum
           =4 # define INTERRUPT_PROTO(name, vector) void name (void)
           =4 # define INTERRUPT_PROTO_USING(name, vector, regnum) void name (void)
           =4 
           =4 # define FUNCTION_USING(name, return_value, parameter, regnum) return_value name (parameter) using regnum
C51 COMPILER V9.51   MGR_ISP                                                               11/17/2023 14:48:45 PAGE 43  

           =4 # define FUNCTION_PROTO_USING(name, return_value, parameter, regnum) return_value name (parameter)
           =4 // Note: Parameter must be either 'void' or include a variable type and name. (Ex: char temp_variable)
           =4 
           =4 # define SEGMENT_VARIABLE(name, vartype, locsegment) vartype locsegment name
           =4 # define VARIABLE_SEGMENT_POINTER(name, vartype, targsegment) vartype targsegment * name
           =4 # define SEGMENT_VARIABLE_SEGMENT_POINTER(name, vartype, targsegment, locsegment) vartype targsegment * lo
             -csegment name
           =4 # define SEGMENT_POINTER(name, vartype, locsegment) vartype * locsegment name
           =4 # define LOCATED_VARIABLE(name, vartype, locsegment, addr, init) at addr locsegment vartype name
           =4 # define LOCATED_VARIABLE_NO_INIT(name, vartype, locsegment, addr) at addr locsegment vartype name
           =4 
           =4 
           =4 // used with UU16
           =4 # define LSB 1
           =4 # define MSB 0
           =4 
           =4 // used with UU32 (b0 is least-significant byte)
           =4 //# define b0 3
           =4 //# define b1 2
           =4 //# define b2 1
           =4 //# define b3 0
           =4 
           =4 typedef unsigned char U8;
           =4 typedef unsigned int U16;
           =4 typedef unsigned long U32;
           =4 
           =4 typedef signed char S8;
           =4 typedef signed int S16;
           =4 typedef signed long S32;
           =4 
           =4 typedef union UU16
           =4 {
           =4    U16 U16;
           =4    S16 S16;
           =4    U8 U8[2];
           =4    S8 S8[2];
           =4 } UU16;
           =4 
           =4 typedef union UU32
           =4 {
           =4    U32 U32;
           =4    S32 S32;
           =4    UU16 UU16[2];
           =4    U16 U16[2];
           =4    S16 S16[2];
           =4    U8 U8[4];
           =4    S8 S8[4];
           =4 } UU32;
           =4 
           =4 // NOP () macro support -- NOP is opcode 0x00
           =4 #define NOP() asm { 0x00 }
           =4 
           =4 
           =4 //-----------------------------------------------------------------------------
           =4 
           =4 
           =4 // Keil C51
           =4 // http://www.keil.com
           =4 
           =4 #elif defined __C51__
           =4 
           =4 //#error Keil C51 detected.
C51 COMPILER V9.51   MGR_ISP                                                               11/17/2023 14:48:45 PAGE 44  

           =4 
           =4 # define SEG_GENERIC
           =4 # define SEG_FAR   xdata
           =4 # define SEG_DATA  data
           =4 # define SEG_NEAR  data
           =4 # define SEG_IDATA idata
           =4 # define SEG_XDATA xdata
           =4 # define SEG_PDATA pdata
           =4 # define SEG_CODE  code
           =4 # define SEG_BDATA bdata
           =4 
           =4 # define SBIT(name, addr, bit)  sbit  name = addr^bit
           =4 # define SFR(name, addr)        sfr   name = addr
           =4 # define SFR16(name, addr)      sfr16 name = addr
           =4 # define SFR16E(name, fulladdr) /* not supported */
           =4 # define SFR32(name, fulladdr)  /* not supported */
           =4 # define SFR32E(name, fulladdr) /* not supported */
           =4 
           =4 # define INTERRUPT(name, vector) void name (void) interrupt vector
           =4 # define INTERRUPT_USING(name, vector, regnum) void name (void) interrupt vector using regnum
           =4 # define INTERRUPT_PROTO(name, vector) void name (void)
           =4 # define INTERRUPT_PROTO_USING(name, vector, regnum) void name (void)
           =4 
           =4 # define FUNCTION_USING(name, return_value, parameter, regnum) return_value name (parameter) using regnum
           =4 # define FUNCTION_PROTO_USING(name, return_value, parameter, regnum) return_value name (parameter)
           =4 // Note: Parameter must be either 'void' or include a variable type and name. (Ex: char temp_variable)
           =4 
           =4 # define SEGMENT_VARIABLE(name, vartype, locsegment) vartype locsegment name
           =4 # define VARIABLE_SEGMENT_POINTER(name, vartype, targsegment) vartype targsegment * name
           =4 # define SEGMENT_VARIABLE_SEGMENT_POINTER(name, vartype, targsegment, locsegment) vartype targsegment * lo
             -csegment name
           =4 # define SEGMENT_POINTER(name, vartype, locsegment) vartype * locsegment name
           =4 # define LOCATED_VARIABLE_NO_INIT(name, vartype, locsegment, addr) vartype locsegment name _at_ addr
           =4 
           =4 // used with UU16
           =4 # define LSB 1
           =4 # define MSB 0
           =4 
           =4 // used with UU32 (b0 is least-significant byte)
           =4 //# define b0 3
           =4 // define b1 2
           =4 //# define b2 1
           =4 //# define b3 0
           =4 
           =4 typedef unsigned char U8;
           =4 typedef unsigned int U16;
           =4 typedef unsigned long U32;
           =4 
           =4 typedef signed char S8;
           =4 typedef signed int S16;
           =4 typedef signed long S32;
           =4 
           =4 typedef union UU16
           =4 {
           =4    U16 U16;
           =4    S16 S16;
           =4    U8 U8[2];
           =4    S8 S8[2];
           =4 } UU16;
           =4 
           =4 typedef union UU32
           =4 {
C51 COMPILER V9.51   MGR_ISP                                                               11/17/2023 14:48:45 PAGE 45  

           =4    U32 U32;
           =4    S32 S32;
           =4    UU16 UU16[2];
           =4    U16 U16[2];
           =4    S16 S16[2];
           =4    U8 U8[4];
           =4    S8 S8[4];
           =4 } UU32;
           =4 
           =4 // NOP () macro support
           =4 extern void _nop_ (void);
           =4 #define NOP() _nop_()
           =4 
           =4 //-----------------------------------------------------------------------------
           =4 
           =4 // Hi-Tech 8051
           =4 // http://www.htsoft.com
           =4 
           =4 #elif defined HI_TECH_C
           =4 
           =4 # define SEG_GENERIC
           =4 # define SEG_FAR   far
           =4 # define SEG_DATA  data
           =4 # define SEG_NEAR  near
           =4 # define SEG_IDATA idata
           =4 # define SEG_XDATA xdata
           =4 # define SEG_PDATA pdata
           =4 # define SEG_CODE  code
           =4 # define SEG_BDATA bdata
           =4 
           =4 
           =4 # define SBIT(name, addr, thebit) static volatile bit name @ (addr + thebit)
           =4 # define SFR(name, addr)          static volatile unsigned char name @ addr
           =4 # define SFR16(name, addr)        static volatile unsigned int name @ addr
           =4 # define SFR16E(name, fulladdr) /* not supported */
           =4 # define SFR32(name, fulladdr)  /* not supported */
           =4 # define SFR32E(name, fulladdr) /* not supported */
           =4 
           =4 # define INTERRUPT(name, vector)       void name (void) interrupt vector
           =4 # define INTERRUPT_PROTO(name, vector)
           =4 # define INTERRUPT_USING(name, vector, regnum) void name (void) interrupt vector using regnum
           =4 # define INTERRUPT_PROTO_USING(name, vector, regnum)
           =4 
           =4 # define FUNCTION_USING(name, return_value, parameter, regnum) /* not supported */
           =4 # define FUNCTION_PROTO_USING(name, return_value, parameter, regnum) /* not supported */
           =4 // Note: Hi-Tech does not support functions using different register banks. Register
           =4 //       banks can only be specified in interrupts. If a function is called from
           =4 //       inside an interrupt, it will use the same register bank as the interrupt.
           =4 
           =4 # define SEGMENT_VARIABLE(name, vartype, locsegment) locsegment vartype name
           =4 # define VARIABLE_SEGMENT_POINTER(name, vartype, targsegment) targsegment vartype * name
           =4 # define SEGMENT_VARIABLE_SEGMENT_POINTER(name, vartype, targsegment, locsegment) targsegment vartype * lo
             -csegment name
           =4 # define LOCATED_VARIABLE(name, vartype, locsegment, addr, init) locsegment vartype name @ addr
           =4 
           =4 // used with UU16
           =4 # define LSB 0
           =4 # define MSB 1
           =4 
           =4 // used with UU32 (b0 is least-significant byte)
           =4 # define b0 0
           =4 # define b1 1
C51 COMPILER V9.51   MGR_ISP                                                               11/17/2023 14:48:45 PAGE 46  

           =4 # define b2 2
           =4 # define b3 3
           =4 
           =4 typedef unsigned char U8;
           =4 typedef unsigned int U16;
           =4 typedef unsigned long U32;
           =4 
           =4 typedef signed char S8;
           =4 typedef signed int S16;
           =4 typedef signed long S32;
           =4 
           =4 typedef union UU16
           =4 {
           =4    U16 U16;
           =4    S16 S16;
           =4    U8 U8[2];
           =4    S8 S8[2];
           =4 } UU16;
           =4 
           =4 typedef union UU32
           =4 {
           =4    U32 U32;
           =4    S32 S32;
           =4    UU16 UU16[2];
           =4    U16 U16[2];
           =4    S16 S16[2];
           =4    U8 U8[4];
           =4    S8 S8[4];
           =4 } UU32;
           =4 
           =4 // NOP () macro support
           =4 #define NOP() asm(" nop ")
           =4 
           =4 //-----------------------------------------------------------------------------
           =4 
           =4 // Tasking / Altium
           =4 // http://www.altium.com/tasking
           =4 
           =4 
           =4 #elif defined _CC51
           =4 
           =4 # define SEG_GENERIC
           =4 # define SEG_FAR   _xdat
           =4 # define SEG_DATA  _data
           =4 # define SEG_NEAR  _data
           =4 # define SEG_IDATA _idat
           =4 # define SEG_XDATA _xdat
           =4 # define SEG_PDATA _pdat
           =4 # define SEG_CODE  _rom
           =4 # define SEG_BDATA _bdat
           =4 
           =4 # define SBIT(name, addr, bit)  _sfrbit  name _at(addr+bit)
           =4 # define SFR(name, addr)        _sfrbyte name _at(addr)
           =4 # define SFRX(name, addr)       _xdat volatile unsigned char name _at(addr)
           =4 #if _CC51 > 71
           =4 # define SFR16(name, addr)      _sfrword _little name _at(addr)
           =4 #else
           =4 # define SFR16(name, addr)      /* not supported */
           =4 #endif
           =4 # define SFR16E(name, fulladdr) /* not supported */
           =4 # define SFR32(name, fulladdr)  /* not supported */
           =4 # define SFR32E(name, fulladdr) /* not supported */
C51 COMPILER V9.51   MGR_ISP                                                               11/17/2023 14:48:45 PAGE 47  

           =4 
           =4 # define INTERRUPT(name, vector) _interrupt (vector) void name (void)
           =4 # define INTERRUPT_USING(name, vector, regnum) _interrupt (vector) _using(regnum) void name (void)
           =4 # define INTERRUPT_PROTO(name, vector) _interrupt (vector) void name (void)
           =4 # define INTERRUPT_PROTO_USING(name, vector, regnum) _interrupt (vector) _using(regnum) void name (void)
           =4 
           =4 // When calling FUNCTION_USING in Tasking, the function must be called from an interrupt or Main which
           =4 // is also using the same register bank. If not, the compiler will generate an error.
           =4 # define FUNCTION_USING(name, return_value, parameter, regnum) _using(regnum) return_value name (parameter
             -)
           =4 # define FUNCTION_PROTO_USING(name, return_value, parameter, regnum) _using(regnum) return_value name (par
             -ameter)
           =4 // Note: Parameter must be either 'void' or include a variable type and name. (Ex: char temp_variable)
           =4 
           =4 # define SEGMENT_VARIABLE(name, vartype, locsegment) vartype locsegment name
           =4 # define VARIABLE_SEGMENT_POINTER(name, vartype, targsegment) vartype targsegment * name
           =4 # define SEGMENT_VARIABLE_SEGMENT_POINTER(name, vartype, targsegment, locsegment) vartype targsegment * lo
             -csegment name
           =4 # define LOCATED_VARIABLE(name, vartype, locsegment, addr, init) vartype locsegment name _at( addr )
           =4 
           =4 // used with UU16
           =4 # define LSB 1
           =4 # define MSB 0
           =4 
           =4 // used with UU32 (b0 is least-significant byte)
           =4 //# define b0 3
           =4 //# define b1 2
           =4 //# define b2 1
           =4 //# define b3 0
           =4 
           =4 typedef unsigned char U8;
           =4 typedef unsigned int U16;
           =4 typedef unsigned long U32;
           =4 
           =4 typedef signed char S8;
           =4 typedef signed int S16;
           =4 typedef signed long S32;
           =4 
           =4 typedef union UU16
           =4 {
           =4    U16 U16;
           =4    S16 S16;
           =4    U8 U8[2];
           =4    S8 S8[2];
           =4 } UU16;
           =4 
           =4 typedef union UU32
           =4 {
           =4    U32 U32;
           =4    S32 S32;
           =4    UU16 UU16[2];
           =4    U16 U16[2];
           =4    S16 S16[2];
           =4    U8 U8[4];
           =4    S8 S8[4];
           =4 } UU32;
           =4 
           =4 // NOP () macro support
           =4 extern void _nop (void);
           =4 #define NOP() _nop()
           =4 
           =4 //-----------------------------------------------------------------------------
C51 COMPILER V9.51   MGR_ISP                                                               11/17/2023 14:48:45 PAGE 48  

           =4 
           =4 
           =4 // IAR 8051
           =4 // http://www.iar.com
           =4 
           =4 #elif defined __ICC8051__
           =4 
           =4 #include <stdbool.h>
           =4 #include <intrinsics.h>
           =4 
           =4 # define SBIT(name, addr, bit)  __bit __no_init volatile bool name @ (addr+bit)
           =4 # define SFR(name, addr)        __sfr __no_init volatile unsigned char name @ addr
           =4 # define SFRX(name, addr)       __xdata __no_init volatile unsigned char name @ addr
           =4 # define SFR16(name, addr)      __sfr __no_init volatile unsigned int  name @ addr
           =4 # define SFR16E(name, fulladdr) /* not supported */
           =4 # define SFR32(name, fulladdr) /* not supported */
           =4 # define SFR32E(name, fulladdr) /* not supported */
           =4 
           =4 # define SEG_GENERIC __generic
           =4 # define SEG_FAR  __xdata
           =4 # define SEG_DATA __data
           =4 # define SEG_NEAR __data
           =4 # define SEG_IDATA __idata
           =4 # define SEG_XDATA __xdata
           =4 # define SEG_PDATA __pdata
           =4 # define SEG_CODE  __code
           =4 # define SEG_BDATA __bdata
           =4 
           =4 #define bit bool
           =4 
           =4 # define _PPTOSTR_(x) #x
           =4 # define _PPARAM_(address) _PPTOSTR_(vector=address * 8 + 3)
           =4 # define _PPARAM2_(regbank) _PPTOSTR_(register_bank=regbank)
           =4 # define INTERRUPT(name, vector) _Pragma(_PPARAM_(vector)) __interrupt void name(void)
           =4 # define INTERRUPT_PROTO(name, vector)  __interrupt void name(void)
           =4 # define INTERRUPT_USING(name, vector, regnum) _Pragma(_PPARAM2_(regnum)) _Pragma(_PPARAM_(vector)) __inte
             -rrupt void name(void)
           =4 # define INTERRUPT_PROTO_USING(name, vector, regnum) __interrupt void name(void)
           =4 
           =4 # define FUNCTION_USING(name, return_value, parameter, regnum) /* not supported */
           =4 # define FUNCTION_PROTO_USING(name, return_value, parameter, regnum) /* not supported */
           =4 // Note: IAR does not support functions using different register banks. Register
           =4 //       banks can only be specified in interrupts. If a function is called from
           =4 //       inside an interrupt, it will use the same register bank as the interrupt.
           =4 
           =4 # define SEGMENT_VARIABLE(name, vartype, locsegment)  locsegment vartype name
           =4 # define VARIABLE_SEGMENT_POINTER(name, vartype, targsegment) vartype targsegment  * name
           =4 # define SEGMENT_VARIABLE_SEGMENT_POINTER(name, vartype, targsegment, locsegment) vartype targsegment * lo
             -csegment name
           =4 
           =4 # define LOCATED_VARIABLE(name, vartype, locsegment, addr, init) locsegment __no_init vartype name @ addr
           =4 
           =4 // used with UU16
           =4 # define LSB 0
           =4 # define MSB 1
           =4 
           =4 // used with UU32 (b0 is least-significant byte)
           =4 //# define b0 0
           =4 //# define b1 1
           =4 //# define b2 2
           =4 //# define b3 3
           =4 
C51 COMPILER V9.51   MGR_ISP                                                               11/17/2023 14:48:45 PAGE 49  

           =4 typedef unsigned char U8;
           =4 typedef unsigned int U16;
           =4 typedef unsigned long U32;
           =4 
           =4 typedef signed char S8;
           =4 typedef signed int S16;
           =4 typedef signed long S32;
           =4 
           =4 typedef union UU16
           =4 {
           =4    U16 U16;
           =4    S16 S16;
           =4    U8 U8[2];
           =4    S8 S8[2];
           =4 } UU16;
           =4 
           =4 typedef union UU32
           =4 {
           =4    U32 U32;
           =4    S32 S32;
           =4    UU16 UU16[2];
           =4    U16 U16[2];
           =4    S16 S16[2];
           =4    U8 U8[4];
           =4    S8 S8[4];
           =4 } UU32;
           =4 
           =4 
           =4 #define NOP() __no_operation();
           =4 //-----------------------------------------------------------------------------
           =4 
           =4 // Crossware
           =4 // http://www.crossware.com
           =4 
           =4 #elif defined _XC51_VER
           =4 # define SBIT(name, addr, bit)  _sfrbit  name = (addr+bit)
           =4 # define SFR(name, addr)        _sfr     name = addr
           =4 # define SFR16(name, addr)      _sfrword name = addr
           =4 # define SFR16E(name, fulladdr) /* not supported */
           =4 # define SFR32(name, fulladdr)  /* not supported */
           =4 # define SFR32E(name, fulladdr) /* not supported */
           =4 
           =4 //-----------------------------------------------------------------------------
           =4 
           =4 // Wickenhäuser
           =4 // http://www.wickenhaeuser.de
           =4 
           =4 #elif defined __UC__
           =4 # define SBIT(name, addr, bit)  unsigned char bit  name @ (addr+bit)
           =4 # define SFR(name, addr)        near unsigned char name @ addr
           =4 # define SFR16(name, addr)      /* not supported */
           =4 # define SFR16E(name, fulladdr) /* not supported */
           =4 # define SFR32(name, fulladdr)  /* not supported */
           =4 # define SFR32E(name, fulladdr) /* not supported */
           =4 
           =4 //-----------------------------------------------------------------------------
           =4 
           =4 // Default
           =4 // Unknown compiler
           =4 
           =4 #else
           =4 # warning unrecognized compiler
C51 COMPILER V9.51   MGR_ISP                                                               11/17/2023 14:48:45 PAGE 50  

           =4 # define SBIT(name, addr, bit)  volatile bool           name
           =4 # define SFR(name, addr)        volatile unsigned char  name
           =4 # define SFRX(name, addr)       volatile unsigned char  name
           =4 # define SFR16(name, addr)      volatile unsigned short name
           =4 # define SFR16E(name, fulladdr) volatile unsigned short name
           =4 # define SFR32(name, fulladdr)  volatile unsigned long  name
           =4 # define SFR32E(name, fulladdr) volatile unsigned long  name
           =4 
           =4 #endif
           =4 
           =4 //-----------------------------------------------------------------------------
           =4 // Header File PreProcessor Directive
           =4 //-----------------------------------------------------------------------------
           =4 
           =4 #endif                                 // #define COMPILER_DEFS_H
 689      =4  
 690      =4  //-----------------------------------------------------------------------------
 691      =4  // End Of File
 692      =4  //-----------------------------------------------------------------------------
   5      =3  #include "C8051F580_defs.h"
   1      =4  //-----------------------------------------------------------------------------
   2      =4  // C8051F580_defs.h
   3      =4  //-----------------------------------------------------------------------------
   4      =4  // Copyright 2008, Silicon Laboratories, Inc.
   5      =4  // http://www.silabs.com
   6      =4  //
   7      =4  // Program Description:
   8      =4  //
   9      =4  // Register/bit definitions for the C8051F58x family.
  10      =4  // **Important Note**: The compiler_defs.h header file should be included
  11      =4  // before including this header file.
  12      =4  //
  13      =4  // Target:         C8051F580/1/2/3/4/5/6/7,8/9-F590/1
  14      =4  // Tool chain:     Generic
  15      =4  // Command Line:   None
  16      =4  //
  17      =4  // Release 0.6 - 20 AUG 2012 (TP)
  18      =4  //    -Added #define for _XPAGE to provide support for SDCC memory paging
  19      =4  //     (pdata)
  20      =4  //
  21      =4  // Release 0.5 - 10 SEP 2011 (GP)
  22      =4  //    - Fixed SFR16 definition for CAN0IF2MC
  23      =4  //
  24      =4  // Release 0.4 - 08 OCT 2010 (TP)
  25      =4  //    - Fixed bit definitions for SCON0
  26      =4  //
  27      =4  // Release 0.3 - 01 APR 2009 (GP)
  28      =4  //    - Added SN0-SN3
  29      =4  //
  30      =4  // Release 0.2 - 29 JUL 2008 (ADT)
  31      =4  //    - Added Timer 4 bit definitions
  32      =4  //
  33      =4  // Release 0.1 - 09 JUL 2008 (GP)
  34      =4  //    - Initial Revision
  35      =4  //
  36      =4  //-----------------------------------------------------------------------------
  37      =4  // Header File Preprocessor Directive
  38      =4  //-----------------------------------------------------------------------------
  39      =4  
  40      =4  #ifndef C8051F580_DEFS_H
           =4 #define C8051F580_DEFS_H
           =4 
C51 COMPILER V9.51   MGR_ISP                                                               11/17/2023 14:48:45 PAGE 51  

           =4 //-----------------------------------------------------------------------------
           =4 // Page 0, Page 1 and Page F Registers
           =4 //-----------------------------------------------------------------------------
           =4 
           =4 SFR (P0, 0x80);                        // Port 0 Latch
           =4 SFR (SP, 0x81);                        // Stack Pointer
           =4 SFR (DPL, 0x82);                       // Data Pointer Low
           =4 SFR (DPH, 0x83);                       // Data Pointer High
           =4 SFR (SFR0CN, 0x84);                    // SFR Page Control
           =4 SFR (SFRNEXT, 0x85);                   // SFR stack next page
           =4 SFR (SFRLAST, 0x86);                   // SFR stack last page
           =4 SFR (PCON, 0x87);                      // Power Control
           =4 SFR (TCON, 0x88);                      // Timer/Counter Control
           =4 SFR (TMOD, 0x89);                      // Timer/Counter Mode
           =4 SFR (TL0, 0x8A);                       // Timer/Counter 0 Low
           =4 SFR (TL1, 0x8B);                       // Timer/Counter 1 Low
           =4 SFR (TH0, 0x8C);                       // Timer/Counter 0 High
           =4 SFR (TH1, 0x8D);                       // Timer/Counter 1 High
           =4 SFR (CKCON, 0x8E);                     // Clock Control
           =4 SFR (PSCTL, 0x8F);                     // Program Store R/W Control
           =4 SFR (CLKSEL, 0x8F);                    // System clock select
           =4 SFR (P1, 0x90);                        // Port 1 Latch
           =4 SFR (TMR3CN, 0x91);                    // Timer/Counter 3 Control
           =4 SFR (TMR5CN, 0x91);                    // Timer/Counter 5 Control
           =4 SFR (TMR3RLL, 0x92);                   // Timer/Counter 3 Reload Low
           =4 SFR (TMR5CAPL, 0x92);                  // Timer/Counter 5 Capture Low
           =4 SFR (TMR3RLH, 0x93);                   // Timer/Counter 3 Reload High
           =4 SFR (TMR5CAPH, 0x93);                  // Timer/Counter 5 Capture High
           =4 SFR (TMR3L, 0x94);                     // Timer/Counter 3 Low
           =4 SFR (TMR5L, 0x94);                     // Timer/Counter 5 Low
           =4 SFR (TMR3H, 0x95);                     // Timer/Counter 3 High
           =4 SFR (TMR5H, 0x95);                     // Timer/Counter 5 High
           =4 SFR (TMR5CF, 0x96);                    // Timer/Counter 5 Configuration
           =4 SFR (CLKMUL, 0x97);                    // Clock Multiplier
           =4 SFR (SCON0, 0x98);                     // UART0 Control
           =4 SFR (SCON1, 0x98);                     // UART1 Control
           =4 SFR (SBUF0, 0x99);                     // UART0 Data Buffer
           =4 SFR (SBUF1, 0x99);                     // UART1 Data Buffer
           =4 SFR (CPT0CN, 0x9A);                    // Comparator 0 Control
           =4 SFR (CPT2CN, 0x9A);                    // Comparator 2 Control
           =4 SFR (CPT0MD, 0x9B);                    // Comparator 0 Mode
           =4 SFR (CPT2MD, 0x9B);                    // Comparator 2 Mode
           =4 SFR (CPT0MX, 0x9C);                    // Comparator 0 Mux
           =4 SFR (CPT2MX, 0x9C);                    // Comparator 2 Mux
           =4 SFR (CPT1CN, 0x9D);                    // Comparator 1 Control
           =4 SFR (CPT1MD, 0x9E);                    // Comparator 0 Mode
           =4 SFR (OSCIFIN, 0x9E);                   // Internal Oscillator Fine Control
           =4 SFR (CPT1MX, 0x9F);                    // Comparator 1 Mux
           =4 SFR (OSCXCN, 0x9F);                    // External Oscillator Control
           =4 SFR (P2, 0xA0);                        // Port 2 Latch
           =4 SFR (SPI0CFG, 0xA1);                   // SPI0 Configuration
           =4 SFR (OSCICN, 0xA1);                    // Internal Oscillator Control
           =4 SFR (SPI0CKR, 0xA2);                   // SPI0 Clock rate control
           =4 SFR (OSCICRS, 0xA2);                   // Internal Oscillator Coarse Control
           =4 SFR (SPI0DAT, 0xA3);                   // SPI0 Data Buffer
           =4 SFR (P0MDOUT, 0xA4);                   // Port 0 Output Mode
           =4 SFR (P1MDOUT, 0xA5);                   // Port 1 Output Mode
           =4 SFR (P2MDOUT, 0xA6);                   // Port 2 Output Mode
           =4 SFR (SFRPAGE, 0xA7);                   // SFR Page Select
           =4 SFR (IE, 0xA8);                        // Interrupt Enable
           =4 SFR (SMOD0, 0xA9);                     // Serial Port 0 Control
           =4 SFR (EMI0CN, 0xAA);                    // EMIF Control
C51 COMPILER V9.51   MGR_ISP                                                               11/17/2023 14:48:45 PAGE 52  

           =4 SFR (EMI0TC, 0xAA);                    // EMIF Timing control
           =4 SFR (SBCON0, 0xAB);                    // UART0 Baud Rate Generator Control
           =4 SFR (SBRLL0, 0xAC);                    // UART0 Baud Rate Generator Low
           =4 SFR (SBRLH0, 0xAD);                    // UART0 Baud Rate Generator High
           =4 SFR (P3MAT, 0xAE);                     // Port 3 Match
           =4 SFR (P3MDOUT, 0xAE);                   // Port 3 Mode
           =4 SFR (P3MASK, 0xAF);                    // Port 3 Mask
           =4 SFR (P4MDOUT, 0xAF);                   // Port 4 Mode
           =4 SFR (P3, 0xB0);                        // Port 3 Latch
           =4 SFR (P2MAT, 0xB1);                     // Port 2 Match
           =4 SFR (P2MASK, 0xB2);                    // Port 2 Mask
           =4 SFR (EMI0CF, 0xB2);                    // EMIF Configuration
           =4 SFR (P4, 0xB5);                        // Port 4 Latch
           =4 SFR (FLSCL, 0xB6);                     // Flash Scale
           =4 SFR (FLKEY, 0xB7);                     // Flash access limit
           =4 SFR (IP, 0xB8);                        // Interrupt Priority
           =4 SFR (SMB0ADR, 0xB9);                   // SMBus0 Slave address
           =4 SFR (ADC0TK, 0xBA);                    // ADC0 Tracking Mode Select
           =4 SFR (SMB0ADM, 0xBA);                   // SMBus0 Address Mask
           =4 SFR (ADC0MX, 0xBB);                    // AMUX0 Channel select
           =4 SFR (ADC0CF, 0xBC);                    // AMUX0 Channel configuration
           =4 SFR (ADC0L, 0xBD);                     // ADC0 Data Low
           =4 SFR (ADC0H, 0xBE);                     // ADC0 Data High
           =4 SFR (SMB0CN, 0xC0);                    // SMBus0 Control
           =4 SFR (SMB0CF, 0xC1);                    // SMBus0 Configuration
           =4 SFR (SMB0DAT, 0xC2);                   // SMBus0 Data
           =4 SFR (ADC0GTL, 0xC3);                   // ADC0 Greater-Than Compare Low
           =4 SFR (ADC0GTH, 0xC4);                   // ADC0 Greater-Than Compare High
           =4 SFR (ADC0LTL, 0xC5);                   // ADC0 Less-Than Compare Word Low
           =4 SFR (ADC0LTH, 0xC6);                   // ADC0 Less-Than Compare Word High
           =4 SFR (XBR3, 0xC6);                      // Port I/O Crossbar Control 3
           =4 SFR (XBR2, 0xC7);                      // Port I/O Crossbar Control 2
           =4 SFR (TMR2CN, 0xC8);                    // Timer/Counter 2 Control
           =4 SFR (TMR4CN, 0xC8);                    // Timer/Counter 4 Control
           =4 SFR (REG0CN, 0xC9);                    // Regulator Control
           =4 SFR (LIN0CF, 0xC9);                    // LIN 0 Configuration
           =4 SFR (TMR4CF, 0xC9);                    // Timer/Counter 4 Configuration
           =4 SFR (TMR2RLL, 0xCA);                   // Timer/Counter 2 Reload Low
           =4 SFR (TMR4CAPL, 0xCA);                  // Timer/Counter 4 Capture Low
           =4 SFR (TMR2RLH, 0xCB);                   // Timer/Counter 2 Reload High
           =4 SFR (TMR4CAPH, 0xCB);                  // Timer/Counter 4 Capture High
           =4 SFR (TMR2L, 0xCC);                     // Timer/Counter 2 Low
           =4 SFR (TMR4L, 0xCC);                     // Timer/Counter 4 Low
           =4 SFR (TMR2H, 0xCD);                     // Timer/Counter 2 High
           =4 SFR (TMR4H, 0xCD);                     // Timer/Counter 4 High
           =4 SFR (PCA0CPL5, 0xCE);                  // PCA0 Capture 5 Low
           =4 SFR (PCA1CPL11, 0xCE);                 // PCA1 Capture 11 Low
           =4 SFR (PCA0CPH5, 0xCF);                  // PCA0 Capture 5 High
           =4 SFR (PCA1CPH11, 0xCF);                 // PCA1 Capture 11 High
           =4 SFR (PSW, 0xD0);                       // Program Status Word
           =4 SFR (REF0CN, 0xD1);                    // Voltage Reference Control
           =4 SFR (LIN0DAT, 0xD2);                   // LIN0 Data
           =4 SFR (LIN0ADR, 0xD3);                   // LIN0 Address
           =4 SFR (P0SKIP, 0xD4);                    // Port 0 Skip
           =4 SFR (P1SKIP, 0xD5);                    // Port 1 Skip
           =4 SFR (P2SKIP, 0xD6);                    // Port 2 Skip
           =4 SFR (P3SKIP, 0xD7);                    // Port 3 Skip
           =4 SFR (PCA0CN, 0xD8);                    // PCA0 Control
           =4 SFR (PCA1CN, 0xD8);                    // PCA1 Control
           =4 SFR (PCA0MD, 0xD9);                    // PCA0 Mode
           =4 SFR (PCA1MD, 0xD9);                    // PCA1 Mode
           =4 SFR (PCA0PWM, 0xD9);                   // PCA0 PWM Control
C51 COMPILER V9.51   MGR_ISP                                                               11/17/2023 14:48:45 PAGE 53  

           =4 SFR (PCA0CPM0, 0xDA);                  // PCA0 Module 0 Mode
           =4 SFR (PCA1CPM6, 0xDA);                  // PCA1 Module 6 Mode
           =4 SFR (PCA1PWM, 0xDA);                   // PCA1 PWM Control
           =4 SFR (PCA0CPM1, 0xDB);                  // PCA0 Module 1  Mode
           =4 SFR (PCA1CPM7, 0xDB);                  // PCA1 Module 7  Mode
           =4 SFR (PCA0CPM2, 0xDC);                  // PCA0 Module 2  Mode
           =4 SFR (PCA1CPM8, 0xDC);                  // PCA1 Module 8  Mode
           =4 SFR (PCA0CPM3, 0xDD);                  // PCA0 Module 3  Mode
           =4 SFR (PCA1CPM9, 0xDD);                  // PCA1 Module 9  Mode
           =4 SFR (PCA0CPM4, 0xDE);                  // PCA0 Module 4  Mode
           =4 SFR (PCA1CPM10, 0xDE);                  // PCA1 Module 10 Mode
           =4 SFR (PCA0CPM5, 0xDF);                  // PCA0 Module 5  Mode
           =4 SFR (PCA1CPM11, 0xDF);                  // PCA1 Module 11 Mode
           =4 SFR (ACC, 0xE0);                       // Accumulator
           =4 SFR (XBR0, 0xE1);                      // Port I/O Crossbar Control 0
           =4 SFR (XBR1, 0xE2);                      // Port I/O Crossbar Control 1
           =4 SFR (CCH0CN, 0xE3);                    // Cache control
           =4 SFR (IT01CF, 0xE4);                    // INT0/INT1 Configuration
           =4 SFR (EIE1, 0xE6);                      // Extended Interrupt Enable 2
           =4 SFR (EIE2, 0xE7);                      // Extended Interrupt Enable 2
           =4 SFR (ADC0CN, 0xE8);                    // ADC0 Control
           =4 SFR (PCA0CPL1, 0xE9);                  // PCA0 Capture 1 Low
           =4 SFR (PCA1CPL1, 0xE9);                  // PCA1 Capture 7 Low
           =4 SFR (PCA0CPH1, 0xEA);                  // PCA0 Capture 1 High
           =4 SFR (PCA1CPH1, 0xEA);                  // PCA1 Capture 7 High
           =4 SFR (PCA0CPL2, 0xEB);                  // PCA0 Capture 2 Low
           =4 SFR (PCA1CPL2, 0xEB);                  // PCA1 Capture 8 Low
           =4 SFR (PCA0CPH2, 0xEC);                  // PCA0 Capture 2 High
           =4 SFR (PCA1CPH2, 0xEC);                  // PCA1 Capture 8 High
           =4 SFR (PCA0CPL3, 0xED);                  // PCA0 Capture 3 Low
           =4 SFR (PCA1CPL3, 0xED);                  // PCA1 Capture 9 Low
           =4 SFR (PCA0CPH3, 0xEE);                  // PCA0 Capture 3 High
           =4 SFR (PCA1CPH3, 0xEE);                  // PCA1 Capture 9 High
           =4 SFR (RSTSRC, 0xEF);                    // Reset Source Configuration/Status
           =4 SFR (B, 0xF0);                         // B Register
           =4 SFR (P0MAT, 0xF1);                     // Port 0 Match
           =4 SFR (P0MDIN, 0xF1);                    // Port 0 Input Mode
           =4 SFR (P0MASK, 0xF2);                    // Port 0 Mask
           =4 SFR (P1MDIN, 0xF2);                    // Port 1 Input Mode
           =4 SFR (P1MAT, 0xF3);                     // Port 1 Match
           =4 SFR (P2MDIN, 0xF3);                    // Port 2 Input Mode
           =4 SFR (P1MASK, 0xF4);                    // Port 1 Mask
           =4 SFR (P3MDIN, 0xF4);                    // Port 3 Input Mode
           =4 SFR (PSBANK, 0xF5);                    // Program Space Bank Select
           =4 SFR (EIP1, 0xF6);                      // External Interrupt Priority 1
           =4 SFR (EIP2, 0xF7);                      // External Interrupt Priority 2
           =4 SFR (SPI0CN, 0xF8);                    // SPI0 Control
           =4 SFR (PCA0L, 0xF9);                     // PCA0 Counter Low
           =4 SFR (PCA1L, 0xF9);                     // PCA1 Counter Low
           =4 SFR (SN0, 0xF9);                       // Serial Number 0
           =4 SFR (PCA0H, 0xFA);                     // PCA0 Counter High
           =4 SFR (PCA1H, 0xFA);                     // PCA1 Counter High
           =4 SFR (SN1, 0xFA);                       // Serial Number 1
           =4 SFR (PCA0CPL0, 0xFB);                  // PCA0 Capture 0 Low
           =4 SFR (PCA1CPL6, 0xFB);                  // PCA1 Capture 6 Low
           =4 SFR (SN2, 0xFB);                       // Serial Number 2
           =4 SFR (PCA0CPH0, 0xFC);                  // PCA0 Capture 0 High
           =4 SFR (PCA1CPH6, 0xFC);                  // PCA1 Capture 6 High
           =4 SFR (SN3, 0xFC);                       // Serial Number 3
           =4 SFR (PCA0CPL4, 0xFD);                  // PCA0 Capture 4 Low
           =4 SFR (PCA1CPL10, 0xFD);                 // PCA1 Capture 10 Low
           =4 SFR (PCA0CPH4, 0xFE);                  // PCA0 Capture 4 High
C51 COMPILER V9.51   MGR_ISP                                                               11/17/2023 14:48:45 PAGE 54  

           =4 SFR (PCA1CPH10, 0xFE);                 // PCA1 Capture 10 High
           =4 SFR (VDM0CN, 0xFF);                    // VDD Monitor Control
           =4 
           =4 //-----------------------------------------------------------------------------
           =4 // Page C (CAN0) Registers
           =4 //-----------------------------------------------------------------------------
           =4 
           =4 SFR (CAN0CFG, 0x92);                   // CAN0 Clock Configuration
           =4 SFR (CAN0STAT, 0x94);                  // Status Register Low Byte
           =4 SFR (CAN0ERRL, 0x96);                  // Error Counter Low Byte
           =4 SFR (CAN0ERRH, 0x97);                  // Error Counter High Byte
           =4 SFR (CAN0BTL, 0x9A);                   // Bit Timing Register Low Byte
           =4 SFR (CAN0BTH, 0x9B);                   // Bit Timing Register High Byte
           =4 SFR (CAN0IIDL, 0x9C);                  // Interrupt Register Low Byte
           =4 SFR (CAN0IIDH, 0x9D);                  // Interrupt Register High Byte
           =4 SFR (CAN0TST, 0x9E);                   // Test Register Low Byte
           =4 SFR (CAN0BRPE, 0xA1);                  // BRP Extension Register Low Byte
           =4 SFR (CAN0TR1L, 0xA2);                  // Transmission Request 1 Low Byte
           =4 SFR (CAN0TR1H, 0xA3);                  // Transmission Request 1 High Byte
           =4 SFR (CAN0TR2L, 0xA4);                  // Transmission Request 2 Low Byte
           =4 SFR (CAN0TR2H, 0xA5);                  // Transmission Request 2 High Byte
           =4 SFR (CAN0ND1L, 0xAA);                  // New Data 1 Low Byte
           =4 SFR (CAN0ND1H, 0xAB);                  // New Data 1 High Byte
           =4 SFR (CAN0ND2L, 0xAC);                  // New Data 2 Low Byte
           =4 SFR (CAN0ND2H, 0xAD);                  // New Data 2 High Byte
           =4 SFR (CAN0IP1L, 0xAE);                  // Interrupt Pending 1 Low Byte
           =4 SFR (CAN0IP1H, 0xAF);                  // Interrupt Pending 1 High Byte
           =4 SFR (CAN0IP2L, 0xB2);                  // Interrupt Pending 2 Low Byte
           =4 SFR (CAN0IP2H, 0xB3);                  // Interrupt Pending 2 High Byte
           =4 SFR (CAN0MV1L, 0xBA);                  // Message Valid 1 Low Byte
           =4 SFR (CAN0MV1H, 0xBB);                  // Message Valid 1 High Byte
           =4 SFR (CAN0MV2L, 0xBC);                  // Message Valid 2 Low Byte
           =4 SFR (CAN0MV2H, 0xBD);                  // Message Valid 2 High Byte
           =4 SFR (CAN0IF1CRL, 0xBE);                // IF1 Command Request Low Byte
           =4 SFR (CAN0IF1CRH, 0xBF);                // IF1 Command Request High Byte
           =4 SFR (CAN0CN, 0xC0);                    // CAN Control Register Low Byte
           =4 SFR (CAN0IF1CML, 0xC2);                // IF1 Command Mask Low Byte
           =4 SFR (CAN0IF1CMH, 0xC3);                // IF1 Command Mask High Byte
           =4 SFR (CAN0IF1M1L, 0xC4);                // IF1 Mask 1 Low Byte
           =4 SFR (CAN0IF1M1H, 0xC5);                // IF1 Mask 1 High Byte
           =4 SFR (CAN0IF1M2L, 0xC6);                // IF1 Mask 2 Low Byte
           =4 SFR (CAN0IF1M2H, 0xC7);                // IF1 Mask 2 High Byte
           =4 SFR (CAN0IF1A1L, 0xCA);                // IF1 Arbitration 1 Low Byte
           =4 SFR (CAN0IF1A1H, 0xCB);                // IF1 Arbitration 1 High Byte
           =4 SFR (CAN0IF1A2L, 0xCC);                // IF1 Arbitration 2 Low Byte
           =4 SFR (CAN0IF1A2H, 0xCD);                // IF1 Arbitration 2 High Byte
           =4 SFR (CAN0IF2MCL, 0xCE);                // IF2 Message Control Low Byte
           =4 SFR (CAN0IF2MCH, 0xCF);                // IF2 Message Control High Byte
           =4 SFR (CAN0IF1MCL, 0xD2);                // IF1 Message Control Low Byte
           =4 SFR (CAN0IF1MCH, 0xD3);                // IF1 Message Control High Byte
           =4 SFR (CAN0IF1DA1L, 0xD4);               // IF1 Data A 1 Low Byte
           =4 SFR (CAN0IF1DA1H, 0xD5);               // IF1 Data A 1 High Byte
           =4 SFR (CAN0IF1DA2L, 0xD6);               // IF1 Data A 2 Low Byte
           =4 SFR (CAN0IF1DA2H, 0xD7);               // IF1 Data A 2 High Byte
           =4 SFR (CAN0IF1DB1L, 0xDA);               // IF1 Data B 1 Low Byte
           =4 SFR (CAN0IF1DB1H, 0xDB);               // IF1 Data B 1 High Byte
           =4 SFR (CAN0IF1DB2L, 0xDC);               // IF1 Data B 2 Low Byte
           =4 SFR (CAN0IF1DB2H, 0xDD);               // IF1 Data B 2 High Byte
           =4 SFR (CAN0IF2CRL, 0xDE);                // IF2 Command Request Low Byte
           =4 SFR (CAN0IF2CRH, 0xDF);                // IF2 Command Request High Byte
           =4 SFR (CAN0IF2CML, 0xE2);                // IF2 Command Mask Low Byte
           =4 SFR (CAN0IF2CMH, 0xE3);                // IF2 Command Mask High Byte
C51 COMPILER V9.51   MGR_ISP                                                               11/17/2023 14:48:45 PAGE 55  

           =4 SFR (CAN0IF2M1L, 0xEA);                // IF2 Mask 1 Low Byte
           =4 SFR (CAN0IF2M1H, 0xEB);                // IF2 Mask 1 High Byte
           =4 SFR (CAN0IF2M2L, 0xEC);                // IF2 Mask 2 Low Byte
           =4 SFR (CAN0IF2M2H, 0xED);                // IF2 Mask 2 High Byte
           =4 SFR (CAN0IF2A1L, 0xEE);                // IF2 Arbitration 1 Low Byte
           =4 SFR (CAN0IF2A1H, 0xEF);                // IF2 Arbitration 1 High Byte
           =4 SFR (CAN0IF2A2L, 0xF2);                // IF2 Arbitration 2 Low Byte
           =4 SFR (CAN0IF2A2H, 0xF3);                // IF2 Arbitration 2 High Byte
           =4 SFR (CAN0IF2DA1L, 0xF6);               // IF2 Data A 1 Low Byte
           =4 SFR (CAN0IF2DA1H, 0xF7);               // IF2 Data A 1 High Byte
           =4 SFR (CAN0IF2DA2L, 0xFA);               // IF2 Data A 2 Low Byte
           =4 SFR (CAN0IF2DA2H, 0xFB);               // IF2 Data A 2 High Byte
           =4 SFR (CAN0IF2DB1L, 0xFC);               // IF2 Data B 1 Low Byte
           =4 SFR (CAN0IF2DB1H, 0xFD);               // IF2 Data B 1 High Byte
           =4 SFR (CAN0IF2DB2L, 0xFE);               // IF2 Data B 2 Low Byte
           =4 SFR (CAN0IF2DB2H, 0xFF);               // IF2 Data B 2 High Byte
           =4 
           =4 
           =4 //-----------------------------------------------------------------------------
           =4 // 16-bit Register Definitions (might not be supported by all compilers)
           =4 //-----------------------------------------------------------------------------
           =4 
           =4 SFR16 (DP, 0x82);                      // Data Pointer
           =4 SFR16 (TMR3RL, 0x92);                  // Timer 3 Reload
           =4 SFR16 (TMR5CAP, 0x92);                 // Timer 5 Capture
           =4 SFR16 (TMR3, 0x94);                    // Timer 3 Capture / Reload
           =4 SFR16 (TMR5, 0x94);                    // Timer 5
           =4 SFR16 (SBRL0, 0xAC);                   // UART0 Reload
           =4 SFR16 (ADC0, 0xBD);                    // ADC0 data
           =4 SFR16 (ADC0GT, 0xC3);                  // ADC0 Greater Than Window
           =4 SFR16 (ADC0LT, 0xC5);                  // ADC0 Less Than Window
           =4 SFR16 (TMR2RL, 0xCA);                  // Timer 2 Reload
           =4 SFR16 (TMR4CAP, 0xCA);                 // Timer 4 Capture
           =4 SFR16 (TMR2, 0xCC);                    // Timer 2 Capture / Reload
           =4 SFR16 (TMR4, 0xCC);                    // Timer 4
           =4 SFR16 (PCA0CP5, 0xCE);                 // PCA0 Module 5 Capture
           =4 SFR16 (PCA1CP11, 0xCE);                // PCA1 Module 11 Capture
           =4 SFR16 (PCA0CP1, 0xE9);                 // PCA0 Module 1 Capture
           =4 SFR16 (PCA1CP7, 0xE9);                 // PCA1 Module 7 Capture
           =4 SFR16 (PCA0CP2, 0xEB);                 // PCA0 Module 2 Capture
           =4 SFR16 (PCA1CP8, 0xEB);                 // PCA1 Module 8 Capture
           =4 SFR16 (PCA0CP3, 0xED);                 // PCA0 Module 3 Capture
           =4 SFR16 (PCA1CP9, 0xED);                 // PCA1 Module 9 Capture
           =4 SFR16 (PCA0, 0xF9);                    // PCA0 Counter
           =4 SFR16 (PCA1, 0xF9);                    // PCA1 Counter
           =4 SFR16 (PCA0CP0, 0xFB);                 // PCA0 Module 0 Capture
           =4 SFR16 (PCA1CP6, 0xFB);                 // PCA1 Module 6 Capture
           =4 SFR16 (PCA0CP4, 0xFD);                 // PCA0 Module 4 Capture
           =4 SFR16 (PCA1CP10, 0xFD);                 // PCA1 Module 10 Capture
           =4 
           =4 SFR16 (CAN0ERR, 0x96);                 // Error Counter
           =4 SFR16 (CAN0BT, 0x9A);                  // Bit Timing Register
           =4 SFR16 (CAN0IID, 0x9C);                 // Interrupt Register
           =4 SFR16 (CAN0TR1, 0xA2);                 // Transmission Request 1
           =4 SFR16 (CAN0TR2, 0xA4);                 // Transmission Request 2
           =4 SFR16 (CAN0ND1, 0xAA);                 // New Data 1
           =4 SFR16 (CAN0ND2, 0xAC);                 // New Data 2
           =4 SFR16 (CAN0IP1, 0xAE);                 // Interrupt Pending 1
           =4 SFR16 (CAN0IP2, 0xB2);                 // Interrupt Pending 2
           =4 SFR16 (CAN0MV1, 0xBA);                 // Message Valid 1
           =4 SFR16 (CAN0MV2, 0xBC);                 // Message Valid 2
           =4 SFR16 (CAN0IF1CR, 0xBE);               // IF1 Command Request
C51 COMPILER V9.51   MGR_ISP                                                               11/17/2023 14:48:45 PAGE 56  

           =4 SFR16 (CAN0IF1CM, 0xC2);               // IF1 Command Mask
           =4 SFR16 (CAN0IF1M1, 0xC4);               // IF1 Mask 1
           =4 SFR16 (CAN0IF1M2, 0xC6);               // IF1 Mask 2
           =4 SFR16 (CAN0IF1A1, 0xCA);               // IF1 Arbitration 1
           =4 SFR16 (CAN0IF1A2, 0xCC);               // IF1 Arbitration 2
           =4 SFR16 (CAN0IF1MC, 0xD2);               // IF1 Message Control
           =4 SFR16 (CAN0IF1DA1, 0xD4);              // IF1 Data A 1
           =4 SFR16 (CAN0IF1DA2, 0xD6);              // IF1 Data A 2
           =4 SFR16 (CAN0IF1DB1, 0xDA);              // IF1 Data B 1
           =4 SFR16 (CAN0IF1DB2, 0xDC);              // IF1 Data B 2
           =4 SFR16 (CAN0IF2CR, 0xDE);               // IF2 Command Request
           =4 SFR16 (CAN0IF2CM, 0xE2);               // IF2 Command Mask
           =4 SFR16 (CAN0IF2M1, 0xEA);               // IF2 Mask 1
           =4 SFR16 (CAN0IF2M2, 0xEC);               // IF2 Mask 2
           =4 SFR16 (CAN0IF2A1, 0xEE);               // IF2 Arbitration 1
           =4 SFR16 (CAN0IF2A2, 0xF2);               // IF2 Arbitration 2
           =4 SFR16 (CAN0IF2MC, 0xCE);               // IF2 Message Control
           =4 SFR16 (CAN0IF2DA1, 0xF6);              // IF2 Data A 1
           =4 SFR16 (CAN0IF2DA2, 0xFA);              // IF2 Data A 2
           =4 SFR16 (CAN0IF2DB1, 0xFC);              // IF2 Data B 1
           =4 SFR16 (CAN0IF2DB2, 0xFE);              // IF2 Data B 2
           =4 
           =4 //-----------------------------------------------------------------------------
           =4 // LIN0 Indirect Registers
           =4 //-----------------------------------------------------------------------------
           =4 
           =4 #define  LIN0DT1   0x00                // LIN0 Data Byte 1
           =4 #define  LIN0DT2   0x01                // LIN0 Data Byte 2
           =4 #define  LIN0DT3   0x02                // LIN0 Data Byte 3
           =4 #define  LIN0DT4   0x03                // LIN0 Data Byte 4
           =4 #define  LIN0DT5   0x04                // LIN0 Data Byte 5
           =4 #define  LIN0DT6   0x05                // LIN0 Data Byte 6
           =4 #define  LIN0DT7   0x06                // LIN0 Data Byte 7
           =4 #define  LIN0DT8   0x07                // LIN0 Data Byte 8
           =4 #define  LIN0CTRL  0x08                // LIN0 Control
           =4 #define  LIN0ST    0x09                // LIN0 Status
           =4 #define  LIN0ERR   0x0A                // LIN0 Error
           =4 #define  LIN0SIZE  0x0B                // LIN0 Message Size
           =4 #define  LIN0DIV   0x0C                // LIN0 Divider
           =4 #define  LIN0MUL   0x0D                // LIN0 Multiplier
           =4 #define  LIN0ID    0x0E                // LIN0 Identifier
           =4 
           =4 //-----------------------------------------------------------------------------
           =4 // Address Definitions for Bit-addressable Registers
           =4 //-----------------------------------------------------------------------------
           =4 
           =4 #define SFR_P0       0x80
           =4 #define SFR_TCON     0x88
           =4 #define SFR_P1       0x90
           =4 #define SFR_SCON0    0x98
           =4 #define SFR_SCON1    0x98
           =4 #define SFR_P2       0xA0
           =4 #define SFR_IE       0xA8
           =4 #define SFR_P3       0xB0
           =4 #define SFR_IP       0xB8
           =4 #define SFR_SMB0CN   0xC0
           =4 #define SFR_TMR2CN   0xC8
           =4 #define SFR_TMR4CN   0xC8
           =4 #define SFR_PSW      0xD0
           =4 #define SFR_PCA0CN   0xD8
           =4 #define SFR_PCA1CN   0xD8
           =4 #define SFR_ACC      0xE0
C51 COMPILER V9.51   MGR_ISP                                                               11/17/2023 14:48:45 PAGE 57  

           =4 #define SFR_ADC0CN   0xE8
           =4 #define SFR_B        0xF0
           =4 #define SFR_SPI0CN   0xF8
           =4 
           =4 //-----------------------------------------------------------------------------
           =4 // Bit Definitions
           =4 //-----------------------------------------------------------------------------
           =4 
           =4 // TCON 0x88
           =4 SBIT (TF1, SFR_TCON, 7);               // Timer 1 Overflow Flag
           =4 SBIT (TR1, SFR_TCON, 6);               // Timer 1 On/Off Control
           =4 SBIT (TF0, SFR_TCON, 5);               // Timer 0 Overflow Flag
           =4 SBIT (TR0, SFR_TCON, 4);               // Timer 0 On/Off Control
           =4 SBIT (IE1, SFR_TCON, 3);               // Ext. Interrupt 1 Edge Flag
           =4 SBIT (IT1, SFR_TCON, 2);               // Ext. Interrupt 1 Type
           =4 SBIT (IE0, SFR_TCON, 1);               // Ext. Interrupt 0 Edge Flag
           =4 SBIT (IT0, SFR_TCON, 0);               // Ext. Interrupt 0 Type
           =4 
           =4 // SCON0 0x98
           =4 SBIT (OVR0, SFR_SCON0, 7);             // UART0 Receive FIFO Overrun Flag
           =4 SBIT (PERR0, SFR_SCON0, 6);            // UART0 Parity Error Flag
           =4 SBIT (THRE0, SFR_SCON0, 5);            // UART0 Transmit Register Empty Flag
           =4 SBIT (REN0, SFR_SCON0, 4);             // UART0 RX Enable
           =4 SBIT (TBX0, SFR_SCON0, 3);             // UART0 Extra Transmission Bit
           =4 SBIT (RBX0, SFR_SCON0, 2);             // UART0 Extra Receive Bit
           =4 SBIT (TI0, SFR_SCON0, 1);              // UART0 TX Interrupt Flag
           =4 SBIT (RI0, SFR_SCON0, 0);              // UART0 RX Interrupt Flag
           =4 
           =4 // SCON1 0x98
           =4 SBIT (S1MODE, SFR_SCON1, 7);           // UART1 Mode 0
           =4                                        // Bit 6 UNUSED
           =4 SBIT (MCE1, SFR_SCON1, 5);             // UART1 Multiprocessor enable
           =4 SBIT (REN1, SFR_SCON1, 4);             // UART1 RX Enable
           =4 SBIT (TB81, SFR_SCON1, 3);             // UART1 TX Bit 8
           =4 SBIT (RB81, SFR_SCON1, 2);             // UART1 RX Bit 8
           =4 SBIT (TI1, SFR_SCON1, 1);              // UART1 TX Interrupt Flag
           =4 SBIT (RI1, SFR_SCON1, 0);              // UART1 RX Interrupt Flag
           =4 
           =4 // IE 0xA8
           =4 SBIT (EA, SFR_IE, 7);                  // Global Interrupt Enable
           =4 SBIT (ESPI0, SFR_IE, 6);               // SPI0 Interrupt Enable
           =4 SBIT (ET2, SFR_IE, 5);                 // Timer 2 Interrupt Enable
           =4 SBIT (ES0, SFR_IE, 4);                 // UART0 Interrupt Enable
           =4 SBIT (ET1, SFR_IE, 3);                 // Timer 1 Interrupt Enable
           =4 SBIT (EX1, SFR_IE, 2);                 // External Interrupt 1 Enable
           =4 SBIT (ET0, SFR_IE, 1);                 // Timer 0 Interrupt Enable
           =4 SBIT (EX0, SFR_IE, 0);                 // External Interrupt 0 Enable
           =4 
           =4 // IP 0xB8
           =4                                        // Bit 7 unused
           =4 SBIT (PSPI0, SFR_IP, 6);               // SPI0 Interrupt Priority
           =4 SBIT (PT2, SFR_IP, 5);                 // Timer 2 Priority
           =4 SBIT (PS0, SFR_IP, 4);                 // UART0 Priority
           =4 SBIT (PS, SFR_IP, 4);                  // UART0 Priority
           =4 SBIT (PT1, SFR_IP, 3);                 // Timer 1 Priority
           =4 SBIT (PX1, SFR_IP, 2);                 // External Interrupt 1 Priority
           =4 SBIT (PT0, SFR_IP, 1);                 // Timer 0 Priority
           =4 SBIT (PX0, SFR_IP, 0);                 // External Interrupt 0 Priority
           =4 
           =4 // SMB0CN 0xC0
           =4 SBIT (MASTER, SFR_SMB0CN, 7);          // SMBus0 Master/Slave Indicator
           =4 SBIT (TXMODE, SFR_SMB0CN, 6);          // SMBus0 Transmit Mode Indicator
C51 COMPILER V9.51   MGR_ISP                                                               11/17/2023 14:48:45 PAGE 58  

           =4 SBIT (STA, SFR_SMB0CN, 5);             // SMBus0 Start Flag
           =4 SBIT (STO, SFR_SMB0CN, 4);             // SMBus0 Stop Flag
           =4 SBIT (ACKRQ, SFR_SMB0CN, 3);           // SMBus0 Acknowledge Request
           =4 SBIT (ARBLOST, SFR_SMB0CN, 2);         // SMBus0 Arbitration Lost Indicator
           =4 SBIT (ACK, SFR_SMB0CN, 1);             // SMBus0 Acknowledge
           =4 SBIT (SI, SFR_SMB0CN, 0);              // SMBus0 Interrupt Flag
           =4 
           =4 // TMR2CN 0xC8
           =4 SBIT (TF2H, SFR_TMR2CN, 7);            // Timer 2 High-Byte Overflow Flag
           =4 SBIT (TF2L, SFR_TMR2CN, 6);            // Timer 2 Low-Byte  Overflow Flag
           =4 SBIT (TF2LEN, SFR_TMR2CN, 5);          // Timer 2 Low-Byte Flag Enable
           =4 SBIT (TF2CEN, SFR_TMR2CN, 4);          // Timer 2 Capture Enable
           =4 SBIT (T2SPLIT, SFR_TMR2CN, 3);         // Timer 2 Split-Mode Enable
           =4 SBIT (TR2, SFR_TMR2CN, 2);             // Timer 2 Run Enable
           =4 SBIT (T2RCLK, SFR_TMR2CN, 1);          // Timer 2 Xclk/Rclk Select
           =4 SBIT (T2XCLK, SFR_TMR2CN, 0);          // Timer 2 Clk/8 Clock Source
           =4 
           =4 // TMR4CN 0xC8
           =4 SBIT (TF4, SFR_TMR4CN, 7);             // Timer 4 Overflow/Underflow Flag
           =4 SBIT (EXF4, SFR_TMR4CN, 6);            // Timer 4 External Flag
           =4                                        // Bit 5 unused
           =4                                        // Bit 4 unused
           =4 SBIT (EXE4, SFR_TMR4CN, 3);            // Timer 4 External Enable
           =4 SBIT (TR4, SFR_TMR4CN, 2);             // Timer 4 Run Enable
           =4 SBIT (CT4, SFR_TMR4CN, 1);             // Timer 4 Counter/Timer Select
           =4 SBIT (CPRL4, SFR_TMR4CN, 0);           // Timer 4 Capture/Reload Select
           =4 
           =4 // PSW 0xD0
           =4 SBIT (CY, SFR_PSW, 7);                 // Carry Flag
           =4 SBIT (AC, SFR_PSW, 6);                 // Auxiliary Carry Flag
           =4 SBIT (F0, SFR_PSW, 5);                 // User Flag 0
           =4 SBIT (RS1, SFR_PSW, 4);                // Register Bank Select 1
           =4 SBIT (RS0, SFR_PSW, 3);                // Register Bank Select 0
           =4 SBIT (OV, SFR_PSW, 2);                 // Overflow Flag
           =4 SBIT (F1, SFR_PSW, 1);                 // User Flag 1
           =4 SBIT (P, SFR_PSW, 0);                  // Accumulator Parity Flag
           =4 
           =4 // PCA0CN 0xD8
           =4 SBIT (CF, SFR_PCA0CN, 7);              // PCA0 Counter Overflow Flag
           =4 SBIT (CR, SFR_PCA0CN, 6);              // PCA0 Counter Run Control Bit
           =4 SBIT (CCF5, SFR_PCA0CN, 5);            // PCA0 Module 5 Interrupt Flag
           =4 SBIT (CCF4, SFR_PCA0CN, 4);            // PCA0 Module 4 Interrupt Flag
           =4 SBIT (CCF3, SFR_PCA0CN, 3);            // PCA0 Module 3 Interrupt Flag
           =4 SBIT (CCF2, SFR_PCA0CN, 2);            // PCA0 Module 2 Interrupt Flag
           =4 SBIT (CCF1, SFR_PCA0CN, 1);            // PCA0 Module 1 Interrupt Flag
           =4 SBIT (CCF0, SFR_PCA0CN, 0);            // PCA0 Module 0 Interrupt Flag
           =4 
           =4 // PCA1CN 0xD8
           =4 SBIT (CF1, SFR_PCA1CN, 7);             // PCA1 Counter Overflow Flag
           =4 SBIT (CR1, SFR_PCA1CN, 6);             // PCA1 Counter Run Control Bit
           =4 SBIT (CCF11, SFR_PCA1CN, 5);           // PCA1 Module 11 Interrupt Flag
           =4 SBIT (CCF10, SFR_PCA1CN, 4);           // PCA1 Module 10 Interrupt Flag
           =4 SBIT (CCF9, SFR_PCA1CN, 3);            // PCA1 Module 9 Interrupt Flag
           =4 SBIT (CCF8, SFR_PCA1CN, 2);            // PCA1 Module 8 Interrupt Flag
           =4 SBIT (CCF7, SFR_PCA1CN, 1);            // PCA1 Module 7 Interrupt Flag
           =4 SBIT (CCF6, SFR_PCA1CN, 0);            // PCA1 Module 6 Interrupt Flag
           =4 
           =4 // ADC0CN 0xE8
           =4 SBIT (AD0EN, SFR_ADC0CN, 7);           // ADC0 Enable
           =4 SBIT (BURSTEN, SFR_ADC0CN, 6);         // ADC0 Burst Enable
           =4 SBIT (AD0INT, SFR_ADC0CN, 5);          // ADC0 EOC Interrupt Flag
           =4 SBIT (AD0BUSY, SFR_ADC0CN, 4);         // ADC0 Busy Flag
C51 COMPILER V9.51   MGR_ISP                                                               11/17/2023 14:48:45 PAGE 59  

           =4 SBIT (AD0WINT, SFR_ADC0CN, 3);         // ADC0 Window Compare Interrupt Flag
           =4 SBIT (AD0LJST, SFR_ADC0CN, 2);         // ADC0 Left Justified
           =4 SBIT (AD0CM1, SFR_ADC0CN, 1);          // ADC0 Start Of Conversion Mode Bit 1
           =4 SBIT (AD0CM0, SFR_ADC0CN, 0);          // ADC0 Start Of Conversion Mode Bit 0
           =4 
           =4 // SPI0CN 0xF8
           =4 SBIT (SPIF, SFR_SPI0CN, 7);            // SPI0 Interrupt Flag
           =4 SBIT (WCOL, SFR_SPI0CN, 6);            // SPI0 Write Collision Flag
           =4 SBIT (MODF, SFR_SPI0CN, 5);            // SPI0 Mode Fault Flag
           =4 SBIT (RXOVRN, SFR_SPI0CN, 4);          // SPI0 RX Overrun Flag
           =4 SBIT (NSSMD1, SFR_SPI0CN, 3);          // SPI0 Slave Select Mode 1
           =4 SBIT (NSSMD0, SFR_SPI0CN, 2);          // SPI0 Slave Select Mode 0
           =4 SBIT (TXBMT, SFR_SPI0CN, 1);           // SPI0 TX Buffer Empty Flag
           =4 SBIT (SPIEN, SFR_SPI0CN, 0);           // SPI0 Enable
           =4 
           =4 //-----------------------------------------------------------------------------
           =4 // Interrupt Priorities
           =4 //-----------------------------------------------------------------------------
           =4 
           =4 #define INTERRUPT_INT0             0   // External Interrupt 0
           =4 #define INTERRUPT_TIMER0           1   // Timer 0 Overflow
           =4 #define INTERRUPT_INT1             2   // External Interrupt 1
           =4 #define INTERRUPT_TIMER1           3   // Timer 1 Overflow
           =4 #define INTERRUPT_UART0            4   // UART0
           =4 #define INTERRUPT_TIMER2           5   // Timer 2 Overflow
           =4 #define INTERRUPT_SPI0             6   // SPI0
           =4 #define INTERRUPT_SMBUS0           7   // SMBus0 Interface
           =4 #define INTERRUPT_ADC0_WINDOW      8   // ADC0 Window Comparison
           =4 #define INTERRUPT_ADC0_EOC         9   // ADC0 End Of Conversion
           =4 #define INTERRUPT_PCA0            10   // PCA0 Peripheral
           =4 #define INTERRUPT_COMPARATOR0     11   // Comparator 0 Comparison
           =4 #define INTERRUPT_COMPARATOR1     12   // Comparator 1 Comparison
           =4 #define INTERRUPT_TIMER3          13   // Timer 3 Overflow
           =4 #define INTERRUPT_LIN0            14   // LIN Bus Interrupt
           =4 #define INTERRUPT_VREG            15   // Voltage Regulator
           =4 #define INTERRUPT_CAN0            16   // CAN Bus Interrupt
           =4 #define INTERRUPT_PORT_MATCH      17   // Port Match
           =4 #define INTERRUPT_UART1           18   // UART1
           =4 #define INTERRUPT_PCA1            19   // PCA1 Peripheral
           =4 #define INTERRUPT_COMPARATOR2     20   // Comparator 2 Comparison
           =4 #define INTERRUPT_TIMER4          21   // Timer 4 Overflow
           =4 #define INTERRUPT_TIMER5          22   // Timer 5 Overflow
           =4 
           =4 
           =4 //-----------------------------------------------------------------------------
           =4 // SFR Page Definitions
           =4 //-----------------------------------------------------------------------------
           =4 
           =4 #define  CONFIG_PAGE       0x0F        // System and Port Configuration Page
           =4 #define  ACTIVE_PAGE       0x00        // Active Use Page
           =4 #define  ACTIVE2_PAGE      0x10        // Active Use Page 2
           =4 #define  CAN0_PAGE         0x0C        // CAN0 Registers
           =4 
           =4 //-----------------------------------------------------------------------------
           =4 // SDCC PDATA External Memory Paging Support
           =4 //-----------------------------------------------------------------------------
           =4 
           =4 #if defined SDCC
           =4 
           =4 SFR(_XPAGE, 0xAA); // Point to the EMI0CN register
           =4 
           =4 #endif
C51 COMPILER V9.51   MGR_ISP                                                               11/17/2023 14:48:45 PAGE 60  

           =4 
           =4 //-----------------------------------------------------------------------------
           =4 // Header File PreProcessor Directive
           =4 //-----------------------------------------------------------------------------
           =4 
           =4 #endif                                 // #define C8051F580_DEFS_H
 607      =4  
 608      =4  //-----------------------------------------------------------------------------
 609      =4  // End Of File
 610      =4  //-----------------------------------------------------------------------------
   6      =3  
   7      =3  /* ----- Global Define -------------------------------*/
   8      =3  /*
   9      =3  #define TW8836          0x00U
  10      =3  #define DESERIALIZE     0x01U
  11      =3  #define SERIALIZE       0x02U
  12      =3  */
  13      =3  #define  TW8836_SLAVE_ADDRESS   (U8)0x8A
  14      =3  #define  TW8836_ID_ADRESS           (U8)0x00
  15      =3  #define  TW8836_ID                              (U16)0x0036
  16      =3  
  17      =3  #define  INIT                           0x00U           // (MR) data byte received
  18      =3  #define  RX                                     0x01U           // (MR) data byte received
  19      =3  #define  TX                                     0x02U           // (MR) data byte received
  20      =3  
  21      =3  #define USE_MDPS11                              0x00U
  22      =3  #define USE_LANGUAGEINFO                0x01U
  23      =3  #define USE_HUTYPE                              0x02U
  24      =3  #define USE_GATEWAY                             0x03U
  25      =3  #define USE_NAVIONOFF                   0x04U
  26      =3  #define USE_G_SEL_DISP                  0x05U
  27      =3  #define USE_IGN_SW                              0x06U
  28      =3  #define USE_RVM_CAMERAOFF               0x07U
  29      =3  #define FCZC_RVM_SW                             0x08U
  30      =3  #define USE_4WDERR                              0x09U
  31      =3  #define USE_ENGVOL                              0x0AU
  32      =3  #define USE_CAN_COUNT                   0x0BU           
  33      =3  
  34      =3  #define TYPE_2WD                                0x00U
  35      =3  #define TYPE_4WD                                0x01U
  36      =3  
  37      =3  #define TYPE_ENGVOL20                   0x14U
  38      =3  #define TYPE_ENGVOL22                   0x16U
  39      =3  #define TYPE_ENGVOL33                   0x21U
  40      =3  /*----------------------------------------------------*/
  41      =3  
  42      =3  /* ----- Function ------------------------------------*/
  43      =3  void Init_CommTask(void);
  44      =3  void Operate_CommTask(void);
  45      =3  void Rx_Data_Process(void);
  46      =3  //void Comm_I2C_Tx_Data(void);
  47      =3  void Comm_I2C_Tx(U8 Slave_Addr,U8 Length,U16 Addr, U16 TData,U16 RData );
  48      =3  U16   Comm_I2C_Rx(U8 Slave_Addr,U8 Length,U16 Addr, U16 TData,U16 RData );
  49      =3  void Clear_I2C_Tx_Data(void);
  50      =3  void Clear_CAN_Tx_Data(void);
  51      =3  void Clear_Can_Data(void);
  52      =3  void Clear_Sas_Data(void);
  53      =3  
  54      =3  void Comm_RearView_Data(void);
  55      =3  void Comm_Tuning_Value_Type(U8 Type4WdErr, U8 TypeEngVol);
  56      =3  U8 Comm_Sas_Data(U8 *pa_Data);
  57      =3  U8 Comm_Hutype_Data(U8 *pa_Data);
C51 COMPILER V9.51   MGR_ISP                                                               11/17/2023 14:48:45 PAGE 61  

  58      =3  U8 Comm_Language_Data(U8 *pa_Data);
  59      =3  U8 Comm_G_Sel_Disp_Data(U8 *Data);
  60      =3  U8 Comm_IGN_Sw_Data(U8 *Data);
  61      =3  U8 Comm_RVM_CameraOff_Data(U8 *Data);
  62      =3  U8 Comm_RVM_SW_Data(U8 *Data);
  63      =3  U8 Comm_ENG_Vol_Data(U8 *pa_Data);
  64      =3  U8 Comm_4WD_Err_Data(U8 *pa_Data);
  65      =3  void Comm_Tx_RVM_View(U8 sigData);
  66      =3  void Comm_Tx_RVM_SW_IND(U8 sigData);
  67      =3  
  68      =3  void Flash_OneSpec_Write(void);
  69      =3  void Flash_OneSpec_Read(void);
  70      =3  void Comm_Error_Check(void);
  71      =3  /*----------------------------------------------------*/
  72      =3  
  73      =3  /* ----- Extern Function -----------------------------*/
  74      =3  /*----------------------------------------------------*/
  75      =3  
  76      =3  /* ----- Global Value --------------------------------*/
  77      =3  
  78      =3  typedef struct {
  79      =3          U8  Slave;
  80      =3          U8  Length;
  81      =3          U8  TRX_Flag;
  82      =3          U16 Addr;
  83      =3          U16 TxData;
  84      =3          U16 RxData;
  85      =3  }tMsg_I2C_Tx_Data_s;
  86      =3  
  87      =3  typedef struct {
  88      =3          U8  Slave;
  89      =3          U8  Length;
  90      =3          U8  TRX_Flag;
  91      =3          U16 Addr;
  92      =3          U16 TxData;
  93      =3          U16 RxData;
  94      =3  }tMsg_CAN_Tx_Data_s;
  95      =3  
  96      =3  typedef struct {
  97      =3          U8 Is_Change;
  98      =3          U8 Change_Count;
  99      =3          U8 Time_Out;
 100      =3          U8 Cur_Data;
 101      =3          U8 Mid_Data;
 102      =3          U8 Pre_Data;
 103      =3          U16 Chatter_Time;
 104      =3  }tMsg_CAN_Rx_Data_s;
 105      =3  
 106      =3  typedef struct {
 107      =3          U8  Is_Change;
 108      =3          U8  Pre_Sign;
 109      =3          U8  Angle;
 110      =3          U8  Angle_Pre_Sign;
 111      =3          U8  Time_Out;
 112      =3          U16 Pre_Data;
 113      =3          U8      Tuning_Type;
 114      =3  }tMsg_CAN_SAS_Data_s;
 115      =3  
 116      =3  typedef struct {
 117      =3          U8  Is_Change;
 118      =3          U8  Pre_Sign;
 119      =3          U8  Angle;
C51 COMPILER V9.51   MGR_ISP                                                               11/17/2023 14:48:45 PAGE 62  

 120      =3          U16 Pre_Data;
 121      =3  }tMsg_CAN_State_s;
 122      =3  
 123      =3  
 124      =3  /*
 125      =3  struct tCAN_Tx_Data_s {
 126      =3          U8 Flag;
 127      =3          U8 Dest;
 128      =3          U8 Length;
 129      =3          U8 *TxData;
 130      =3  }
 131      =3  
 132      =3  struct tCAN_Rx_Data_s {
 133      =3          U8 Flag;
 134      =3          U8 Src;
 135      =3          U8 Length;
 136      =3          U8 RxData;
 137      =3  }
 138      =3  */
 139      =3  /*----------------------------------------------------*/
 140      =3  
 141      =3  extern SEG_XDATA volatile tMsg_CAN_SAS_Data_s tCAN_Rx_SAS_Msg;
 142      =3  #endif
 143      =3  
   7      =2  #include "compiler_defs.h"
   1      =3  //-----------------------------------------------------------------------------
   2      =3  // compiler_defs.h
   3      =3  //-----------------------------------------------------------------------------
   4      =3  // Portions of this file are copyright Maarten Brock
   5      =3  // http://sdcc.sourceforge.net
   6      =3  // Portions of this file are copyright 2010, Silicon Laboratories, Inc.
   7      =3  // http://www.silabs.com
   8      =3  //
   9      =3  // GNU LGPL boilerplate:
  10      =3  /** This library is free software; you can redistribute it and/or
  11      =3    * modify it under the terms of the GNU Lesser General Public
  12      =3    * License as published by the Free Software Foundation; either
  13      =3    * version 2.1 of the License, or (at your option) any later version.
  14      =3    *
  15      =3    * This library is distributed in the hope that it will be useful,
  16      =3    * but WITHOUT ANY WARRANTY; without even the implied warranty of
  17      =3    * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
  18      =3    * Lesser General Public License for more details.
  19      =3    *
  20      =3    * You should have received a copy of the GNU Lesser General Public
  21      =3    * License along with this library; if not, write to the Free Software
  22      =3    * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
  23      =3    *
  24      =3    * In other words, you are welcome to use, share and improve this program.
  25      =3    * You are forbidden to forbid anyone else to use, share and improve
  26      =3    * what you give them. Help stamp out software-hoarding!
  27      =3  **/
  28      =3  // Program Description:
  29      =3  //
  30      =3  // **Important Note**: This header file should be included before including
  31      =3  // a device-specific header file such as C8051F300_defs.h.
  32      =3  //
  33      =3  // Macro definitions to accomodate 8051 compiler differences in specifying
  34      =3  // special function registers and other 8051-specific features such as NOP
  35      =3  // generation, and locating variables in memory-specific segments.  The
  36      =3  // compilers are identified by their unique predefined macros. See also:
  37      =3  // http://predef.sourceforge.net/precomp.html
C51 COMPILER V9.51   MGR_ISP                                                               11/17/2023 14:48:45 PAGE 63  

  38      =3  //
  39      =3  // SBIT and SFR define special bit and special function registers at the given
  40      =3  // address. SFR16 and SFR32 define sfr combinations at adjacent addresses in
  41      =3  // little-endian format. SFR16E and SFR32E define sfr combinations without
  42      =3  // prerequisite byte order or adjacency. None of these multi-byte sfr
  43      =3  // combinations will guarantee the order in which they are accessed when read
  44      =3  // or written.
  45      =3  //
  46      =3  // SFR16X and SFR32X for 16 bit and 32 bit xdata registers are not defined
  47      =3  // to avoid portability issues because of compiler endianness.
  48      =3  //
  49      =3  // Example:
  50      =3  // // my_mcu.c: main 'c' file for my mcu
  51      =3  // #include <compiler_defs.h>  // this file
  52      =3  // #include <C8051xxxx_defs.h> // SFR definitions for specific MCU target
  53      =3  //
  54      =3  // SBIT  (P0_1, 0x80, 1);      // Port 0 pin 1
  55      =3  // SFR   (P0, 0x80);           // Port 0
  56      =3  // SFRX  (CPUCS, 0xE600);      // Cypress FX2 Control and Status register in
  57      =3  //                             // xdata memory at 0xE600
  58      =3  // SFR16 (TMR2, 0xCC);         // Timer 2, lsb at 0xCC, msb at 0xCD
  59      =3  // SFR16E(TMR0, 0x8C8A);       // Timer 0, lsb at 0x8A, msb at 0x8C
  60      =3  // SFR32 (MAC0ACC, 0x93);      // SiLabs C8051F120 32 bits MAC0 Accumulator,
  61      =3  //                             // lsb at 0x93, msb at 0x96
  62      =3  // SFR32E(SUMR, 0xE5E4E3E2);   // TI MSC1210 SUMR 32 bits Summation register,
  63      =3  //                             // lsb at 0xE2, msb at 0xE5
  64      =3  //
  65      =3  // Target:         C8051xxxx
  66      =3  // Tool chain:     Generic
  67      =3  // Command Line:   None
  68      =3  // 
  69      =3  // Release 2.6 - 14 DEC 2012 (GO)
  70      =3  //        -Added define for deprecated SDCC keyword 'at'
  71      =3  // Release 2.5 - 12 SEP 2012 (TP)
  72      =3  //    -Added defines for deprecated SDCC keywords bit and code
  73      =3  // Release 2.4 - 27 AUG 2012 (TP)
  74      =3  //    -Added defines for deprecated SDCC keywords interrupt, _asm, and _endasm
  75      =3  // Release 2.3 - 27 MAY 2010 (DM)
  76      =3  //    -Removed 'LOCATED_VARIABLE' pragma from Keil because it is not supported
  77      =3  // Release 2.2 - 06 APR 2010 (ES)
  78      =3  //    -Removed 'PATHINCLUDE' pragma from Raisonance section
  79      =3  // Release 2.1 - 16 JUL 2009 (ES)
  80      =3  //    -Added SEGMENT_POINTER macro definitions for SDCC, Keil, and Raisonance
  81      =3  //    -Added LOCATED_VARIABLE_NO_INIT macro definitions for Raisonance
  82      =3  // Release 2.0 - 19 MAY 2009 (ES)
  83      =3  //    -Added LOCATED_VARIABLE_NO_INIT macro definitions for SDCC and Keil
  84      =3  // Release 1.9 - 23 OCT 2008 (ES)
  85      =3  //    -Updated Hi-Tech INTERRUPT and INTERRUPT_USING macro definitions
  86      =3  //    -Added SFR16 macro defintion for Hi-Tech
  87      =3  // Release 1.8 - 31 JUL 2008 (ES)
  88      =3  //    -Added INTERRUPT_USING and FUNCTION_USING macro's
  89      =3  //    -Added macro's for IAR
  90      =3  //    -Corrected Union definitions for Hi-Tech and added SFR16 macro defintion
  91      =3  // Release 1.7 - 11 SEP 2007 (BW)
  92      =3  //    -Added support for Raisonance EVAL 03.03.42 and Tasking Eval 7.2r1
  93      =3  // Release 1.6 - 27 AUG 2007 (BW)
  94      =3  //    -Updated copyright notice per agreement with Maartin Brock
  95      =3  //    -Added SDCC 2.7.0 "compiler.h" bug fixes
  96      =3  //    -Added memory segment defines (SEG_XDATA, for example)
  97      =3  // Release 1.5 - 24 AUG 2007 (BW)
  98      =3  //    -Added support for NOP () macro
  99      =3  //    -Added support for Hi-Tech ver 9.01
C51 COMPILER V9.51   MGR_ISP                                                               11/17/2023 14:48:45 PAGE 64  

 100      =3  // Release 1.4 - 07 AUG 2007 (PKC)
 101      =3  //    -Removed FID and fixed formatting.
 102      =3  // Release 1.3 - 30 SEP 2007 (TP)
 103      =3  //    -Added INTERRUPT_PROTO_USING to properly support ISR context switching
 104      =3  //     under SDCC.
 105      =3  // Release 1.2 - (BW)
 106      =3  //    -Added support for U8,U16,U32,S8,S16,S32,UU16,UU32 data types
 107      =3  // Release 1.1 - (BW)
 108      =3  //    -Added support for INTERRUPT, INTERRUPT_USING, INTERRUPT_PROTO,
 109      =3  //     SEGMENT_VARIABLE, VARIABLE_SEGMENT_POINTER,
 110      =3  //     SEGMENT_VARIABLE_SEGMENT_POINTER, and LOCATED_VARIABLE
 111      =3  // Release 1.0 - 29 SEP 2006 (PKC)
 112      =3  //    -Initial revision
 113      =3  
 114      =3  //-----------------------------------------------------------------------------
 115      =3  // Header File Preprocessor Directive
 116      =3  //-----------------------------------------------------------------------------
 117      =3  
 118      =3  #ifndef COMPILER_DEFS_H
           =3 #define COMPILER_DEFS_H
           =3 
           =3 //-----------------------------------------------------------------------------
           =3 // Macro definitions
           =3 //-----------------------------------------------------------------------------
           =3 
           =3 // SDCC - Small Device C Compiler
           =3 // http://sdcc.sourceforge.net
           =3 
           =3 #if defined SDCC
           =3 
           =3 #if (SDCC >= 300)
           =3 
           =3 #define interrupt __interrupt
           =3 #define _asm __asm
           =3 #define _endasm __endasm
           =3 #define bit __bit
           =3 #define code __code
           =3 #define at __at
           =3 
           =3 #endif
           =3 
           =3 # define SEG_GENERIC
           =3 # define SEG_FAR   __xdata
           =3 # define SEG_DATA  __data
           =3 # define SEG_NEAR  __data
           =3 # define SEG_IDATA __idata
           =3 # define SEG_XDATA __xdata
           =3 # define SEG_PDATA __pdata
           =3 # define SEG_CODE  __code
           =3 # define SEG_BDATA __bdata
           =3 
           =3 # define SBIT(name, addr, bit)  __sbit  __at(addr+bit)                  name
           =3 # define SFR(name, addr)        __sfr   __at(addr)                      name
           =3 # define SFRX(name, addr)       xdata volatile unsigned char __at(addr) name
           =3 # define SFR16(name, addr)      __sfr16 __at(((addr+1U)<<8) | addr)     name
           =3 # define SFR16E(name, fulladdr) __sfr16 __at(fulladdr)                  name
           =3 # define SFR32(name, addr)      __sfr32 __at(((addr+3UL)<<24) | ((addr+2UL)<<16) | ((addr+1UL)<<8) | addr)
             - name
           =3 # define SFR32E(name, fulladdr) __sfr32 __at(fulladdr)                  name
           =3 
           =3 # define INTERRUPT(name, vector) void name (void) interrupt (vector)
           =3 # define INTERRUPT_USING(name, vector, regnum) void name (void) interrupt (vector) using (regnum)
C51 COMPILER V9.51   MGR_ISP                                                               11/17/2023 14:48:45 PAGE 65  

           =3 # define INTERRUPT_PROTO(name, vector) void name (void) interrupt (vector)
           =3 # define INTERRUPT_PROTO_USING(name, vector, regnum) void name (void) interrupt (vector) using (regnum)
           =3 
           =3 # define FUNCTION_USING(name, return_value, parameter, regnum) return_value name (parameter) using (regnum
             -)
           =3 # define FUNCTION_PROTO_USING(name, return_value, parameter, regnum) return_value name (parameter) using (
             -regnum)
           =3 // Note: Parameter must be either 'void' or include a variable type and name. (Ex: char temp_variable)
           =3 
           =3 # define SEGMENT_VARIABLE(name, vartype, locsegment) locsegment vartype name
           =3 # define VARIABLE_SEGMENT_POINTER(name, vartype, targsegment) targsegment vartype * name
           =3 # define SEGMENT_VARIABLE_SEGMENT_POINTER(name, vartype, targsegment, locsegment) targsegment vartype * lo
             -csegment name
           =3 # define SEGMENT_POINTER(name, vartype, locsegment) vartype * locsegment name
           =3 # define LOCATED_VARIABLE(name, vartype, locsegment, addr, init) locsegment at (addr) vartype name = init
           =3 # define LOCATED_VARIABLE_NO_INIT(name, vartype, locsegment, addr) locsegment at (addr) vartype name
           =3 
           =3 // used with UU16
           =3 # define LSB 0
           =3 # define MSB 1
           =3 
           =3 // used with UU32 (b0 is least-significant byte)
           =3 //# define b0 0
           =3 //# define b1 1
           =3 //# define b2 2
           =3 //# define b3 3
           =3 
           =3 typedef unsigned char U8;
           =3 typedef unsigned int U16;
           =3 typedef unsigned long U32;
           =3 
           =3 typedef signed char S8;
           =3 typedef signed int S16;
           =3 typedef signed long S32;
           =3 
           =3 typedef union UU16
           =3 {
           =3    U16 U16;
           =3    S16 S16;
           =3    U8 U8[2];
           =3    S8 S8[2];
           =3 } UU16;
           =3 
           =3 typedef union UU32
           =3 {
           =3    U32 U32;
           =3    S32 S32;
           =3    UU16 UU16[2];
           =3    U16 U16[2];
           =3    S16 S16[2];
           =3    U8 U8[4];
           =3    S8 S8[4];
           =3 } UU32;
           =3 
           =3 // NOP () macro support
           =3 #define NOP() _asm NOP _endasm
           =3 
           =3 
           =3 //-----------------------------------------------------------------------------
           =3 
           =3 // Raisonance (must be placed before Keil C51)
           =3 // http://www.raisonance.com
C51 COMPILER V9.51   MGR_ISP                                                               11/17/2023 14:48:45 PAGE 66  

           =3 
           =3 #elif defined __RC51__
           =3 
           =3 //#error Raisonance C51 detected.
           =3 
           =3 # define SEG_GENERIC generic     //SEG_GENERIC only applies to pointers in Raisonance, not variables.
           =3 # define SEG_FAR   xdata
           =3 # define SEG_DATA  data
           =3 # define SEG_NEAR  data
           =3 # define SEG_IDATA idata
           =3 # define SEG_XDATA xdata
           =3 # define SEG_PDATA pdata
           =3 # define SEG_CODE  code
           =3 # define SEG_BDATA bdata
           =3 
           =3 # define SBIT(name, addr, bit)  at (addr+bit) sbit         name
           =3 # define SFR(name, addr)        sfr at addr                name
           =3 # define SFR16(name, addr)      sfr16 at addr              name
           =3 # define SFR16E(name, fulladdr) /* not supported */
           =3 # define SFR32(name, fulladdr)  /* not supported */
           =3 # define SFR32E(name, fulladdr) /* not supported */
           =3 
           =3 # define INTERRUPT(name, vector) void name (void) interrupt vector
           =3 # define INTERRUPT_USING(name, vector, regnum) void name (void) interrupt vector using regnum
           =3 # define INTERRUPT_PROTO(name, vector) void name (void)
           =3 # define INTERRUPT_PROTO_USING(name, vector, regnum) void name (void)
           =3 
           =3 # define FUNCTION_USING(name, return_value, parameter, regnum) return_value name (parameter) using regnum
           =3 # define FUNCTION_PROTO_USING(name, return_value, parameter, regnum) return_value name (parameter)
           =3 // Note: Parameter must be either 'void' or include a variable type and name. (Ex: char temp_variable)
           =3 
           =3 # define SEGMENT_VARIABLE(name, vartype, locsegment) vartype locsegment name
           =3 # define VARIABLE_SEGMENT_POINTER(name, vartype, targsegment) vartype targsegment * name
           =3 # define SEGMENT_VARIABLE_SEGMENT_POINTER(name, vartype, targsegment, locsegment) vartype targsegment * lo
             -csegment name
           =3 # define SEGMENT_POINTER(name, vartype, locsegment) vartype * locsegment name
           =3 # define LOCATED_VARIABLE(name, vartype, locsegment, addr, init) at addr locsegment vartype name
           =3 # define LOCATED_VARIABLE_NO_INIT(name, vartype, locsegment, addr) at addr locsegment vartype name
           =3 
           =3 
           =3 // used with UU16
           =3 # define LSB 1
           =3 # define MSB 0
           =3 
           =3 // used with UU32 (b0 is least-significant byte)
           =3 //# define b0 3
           =3 //# define b1 2
           =3 //# define b2 1
           =3 //# define b3 0
           =3 
           =3 typedef unsigned char U8;
           =3 typedef unsigned int U16;
           =3 typedef unsigned long U32;
           =3 
           =3 typedef signed char S8;
           =3 typedef signed int S16;
           =3 typedef signed long S32;
           =3 
           =3 typedef union UU16
           =3 {
           =3    U16 U16;
           =3    S16 S16;
C51 COMPILER V9.51   MGR_ISP                                                               11/17/2023 14:48:45 PAGE 67  

           =3    U8 U8[2];
           =3    S8 S8[2];
           =3 } UU16;
           =3 
           =3 typedef union UU32
           =3 {
           =3    U32 U32;
           =3    S32 S32;
           =3    UU16 UU16[2];
           =3    U16 U16[2];
           =3    S16 S16[2];
           =3    U8 U8[4];
           =3    S8 S8[4];
           =3 } UU32;
           =3 
           =3 // NOP () macro support -- NOP is opcode 0x00
           =3 #define NOP() asm { 0x00 }
           =3 
           =3 
           =3 //-----------------------------------------------------------------------------
           =3 
           =3 
           =3 // Keil C51
           =3 // http://www.keil.com
           =3 
           =3 #elif defined __C51__
           =3 
           =3 //#error Keil C51 detected.
           =3 
           =3 # define SEG_GENERIC
           =3 # define SEG_FAR   xdata
           =3 # define SEG_DATA  data
           =3 # define SEG_NEAR  data
           =3 # define SEG_IDATA idata
           =3 # define SEG_XDATA xdata
           =3 # define SEG_PDATA pdata
           =3 # define SEG_CODE  code
           =3 # define SEG_BDATA bdata
           =3 
           =3 # define SBIT(name, addr, bit)  sbit  name = addr^bit
           =3 # define SFR(name, addr)        sfr   name = addr
           =3 # define SFR16(name, addr)      sfr16 name = addr
           =3 # define SFR16E(name, fulladdr) /* not supported */
           =3 # define SFR32(name, fulladdr)  /* not supported */
           =3 # define SFR32E(name, fulladdr) /* not supported */
           =3 
           =3 # define INTERRUPT(name, vector) void name (void) interrupt vector
           =3 # define INTERRUPT_USING(name, vector, regnum) void name (void) interrupt vector using regnum
           =3 # define INTERRUPT_PROTO(name, vector) void name (void)
           =3 # define INTERRUPT_PROTO_USING(name, vector, regnum) void name (void)
           =3 
           =3 # define FUNCTION_USING(name, return_value, parameter, regnum) return_value name (parameter) using regnum
           =3 # define FUNCTION_PROTO_USING(name, return_value, parameter, regnum) return_value name (parameter)
           =3 // Note: Parameter must be either 'void' or include a variable type and name. (Ex: char temp_variable)
           =3 
           =3 # define SEGMENT_VARIABLE(name, vartype, locsegment) vartype locsegment name
           =3 # define VARIABLE_SEGMENT_POINTER(name, vartype, targsegment) vartype targsegment * name
           =3 # define SEGMENT_VARIABLE_SEGMENT_POINTER(name, vartype, targsegment, locsegment) vartype targsegment * lo
             -csegment name
           =3 # define SEGMENT_POINTER(name, vartype, locsegment) vartype * locsegment name
           =3 # define LOCATED_VARIABLE_NO_INIT(name, vartype, locsegment, addr) vartype locsegment name _at_ addr
           =3 
C51 COMPILER V9.51   MGR_ISP                                                               11/17/2023 14:48:45 PAGE 68  

           =3 // used with UU16
           =3 # define LSB 1
           =3 # define MSB 0
           =3 
           =3 // used with UU32 (b0 is least-significant byte)
           =3 //# define b0 3
           =3 // define b1 2
           =3 //# define b2 1
           =3 //# define b3 0
           =3 
           =3 typedef unsigned char U8;
           =3 typedef unsigned int U16;
           =3 typedef unsigned long U32;
           =3 
           =3 typedef signed char S8;
           =3 typedef signed int S16;
           =3 typedef signed long S32;
           =3 
           =3 typedef union UU16
           =3 {
           =3    U16 U16;
           =3    S16 S16;
           =3    U8 U8[2];
           =3    S8 S8[2];
           =3 } UU16;
           =3 
           =3 typedef union UU32
           =3 {
           =3    U32 U32;
           =3    S32 S32;
           =3    UU16 UU16[2];
           =3    U16 U16[2];
           =3    S16 S16[2];
           =3    U8 U8[4];
           =3    S8 S8[4];
           =3 } UU32;
           =3 
           =3 // NOP () macro support
           =3 extern void _nop_ (void);
           =3 #define NOP() _nop_()
           =3 
           =3 //-----------------------------------------------------------------------------
           =3 
           =3 // Hi-Tech 8051
           =3 // http://www.htsoft.com
           =3 
           =3 #elif defined HI_TECH_C
           =3 
           =3 # define SEG_GENERIC
           =3 # define SEG_FAR   far
           =3 # define SEG_DATA  data
           =3 # define SEG_NEAR  near
           =3 # define SEG_IDATA idata
           =3 # define SEG_XDATA xdata
           =3 # define SEG_PDATA pdata
           =3 # define SEG_CODE  code
           =3 # define SEG_BDATA bdata
           =3 
           =3 
           =3 # define SBIT(name, addr, thebit) static volatile bit name @ (addr + thebit)
           =3 # define SFR(name, addr)          static volatile unsigned char name @ addr
           =3 # define SFR16(name, addr)        static volatile unsigned int name @ addr
C51 COMPILER V9.51   MGR_ISP                                                               11/17/2023 14:48:45 PAGE 69  

           =3 # define SFR16E(name, fulladdr) /* not supported */
           =3 # define SFR32(name, fulladdr)  /* not supported */
           =3 # define SFR32E(name, fulladdr) /* not supported */
           =3 
           =3 # define INTERRUPT(name, vector)       void name (void) interrupt vector
           =3 # define INTERRUPT_PROTO(name, vector)
           =3 # define INTERRUPT_USING(name, vector, regnum) void name (void) interrupt vector using regnum
           =3 # define INTERRUPT_PROTO_USING(name, vector, regnum)
           =3 
           =3 # define FUNCTION_USING(name, return_value, parameter, regnum) /* not supported */
           =3 # define FUNCTION_PROTO_USING(name, return_value, parameter, regnum) /* not supported */
           =3 // Note: Hi-Tech does not support functions using different register banks. Register
           =3 //       banks can only be specified in interrupts. If a function is called from
           =3 //       inside an interrupt, it will use the same register bank as the interrupt.
           =3 
           =3 # define SEGMENT_VARIABLE(name, vartype, locsegment) locsegment vartype name
           =3 # define VARIABLE_SEGMENT_POINTER(name, vartype, targsegment) targsegment vartype * name
           =3 # define SEGMENT_VARIABLE_SEGMENT_POINTER(name, vartype, targsegment, locsegment) targsegment vartype * lo
             -csegment name
           =3 # define LOCATED_VARIABLE(name, vartype, locsegment, addr, init) locsegment vartype name @ addr
           =3 
           =3 // used with UU16
           =3 # define LSB 0
           =3 # define MSB 1
           =3 
           =3 // used with UU32 (b0 is least-significant byte)
           =3 # define b0 0
           =3 # define b1 1
           =3 # define b2 2
           =3 # define b3 3
           =3 
           =3 typedef unsigned char U8;
           =3 typedef unsigned int U16;
           =3 typedef unsigned long U32;
           =3 
           =3 typedef signed char S8;
           =3 typedef signed int S16;
           =3 typedef signed long S32;
           =3 
           =3 typedef union UU16
           =3 {
           =3    U16 U16;
           =3    S16 S16;
           =3    U8 U8[2];
           =3    S8 S8[2];
           =3 } UU16;
           =3 
           =3 typedef union UU32
           =3 {
           =3    U32 U32;
           =3    S32 S32;
           =3    UU16 UU16[2];
           =3    U16 U16[2];
           =3    S16 S16[2];
           =3    U8 U8[4];
           =3    S8 S8[4];
           =3 } UU32;
           =3 
           =3 // NOP () macro support
           =3 #define NOP() asm(" nop ")
           =3 
           =3 //-----------------------------------------------------------------------------
C51 COMPILER V9.51   MGR_ISP                                                               11/17/2023 14:48:45 PAGE 70  

           =3 
           =3 // Tasking / Altium
           =3 // http://www.altium.com/tasking
           =3 
           =3 
           =3 #elif defined _CC51
           =3 
           =3 # define SEG_GENERIC
           =3 # define SEG_FAR   _xdat
           =3 # define SEG_DATA  _data
           =3 # define SEG_NEAR  _data
           =3 # define SEG_IDATA _idat
           =3 # define SEG_XDATA _xdat
           =3 # define SEG_PDATA _pdat
           =3 # define SEG_CODE  _rom
           =3 # define SEG_BDATA _bdat
           =3 
           =3 # define SBIT(name, addr, bit)  _sfrbit  name _at(addr+bit)
           =3 # define SFR(name, addr)        _sfrbyte name _at(addr)
           =3 # define SFRX(name, addr)       _xdat volatile unsigned char name _at(addr)
           =3 #if _CC51 > 71
           =3 # define SFR16(name, addr)      _sfrword _little name _at(addr)
           =3 #else
           =3 # define SFR16(name, addr)      /* not supported */
           =3 #endif
           =3 # define SFR16E(name, fulladdr) /* not supported */
           =3 # define SFR32(name, fulladdr)  /* not supported */
           =3 # define SFR32E(name, fulladdr) /* not supported */
           =3 
           =3 # define INTERRUPT(name, vector) _interrupt (vector) void name (void)
           =3 # define INTERRUPT_USING(name, vector, regnum) _interrupt (vector) _using(regnum) void name (void)
           =3 # define INTERRUPT_PROTO(name, vector) _interrupt (vector) void name (void)
           =3 # define INTERRUPT_PROTO_USING(name, vector, regnum) _interrupt (vector) _using(regnum) void name (void)
           =3 
           =3 // When calling FUNCTION_USING in Tasking, the function must be called from an interrupt or Main which
           =3 // is also using the same register bank. If not, the compiler will generate an error.
           =3 # define FUNCTION_USING(name, return_value, parameter, regnum) _using(regnum) return_value name (parameter
             -)
           =3 # define FUNCTION_PROTO_USING(name, return_value, parameter, regnum) _using(regnum) return_value name (par
             -ameter)
           =3 // Note: Parameter must be either 'void' or include a variable type and name. (Ex: char temp_variable)
           =3 
           =3 # define SEGMENT_VARIABLE(name, vartype, locsegment) vartype locsegment name
           =3 # define VARIABLE_SEGMENT_POINTER(name, vartype, targsegment) vartype targsegment * name
           =3 # define SEGMENT_VARIABLE_SEGMENT_POINTER(name, vartype, targsegment, locsegment) vartype targsegment * lo
             -csegment name
           =3 # define LOCATED_VARIABLE(name, vartype, locsegment, addr, init) vartype locsegment name _at( addr )
           =3 
           =3 // used with UU16
           =3 # define LSB 1
           =3 # define MSB 0
           =3 
           =3 // used with UU32 (b0 is least-significant byte)
           =3 //# define b0 3
           =3 //# define b1 2
           =3 //# define b2 1
           =3 //# define b3 0
           =3 
           =3 typedef unsigned char U8;
           =3 typedef unsigned int U16;
           =3 typedef unsigned long U32;
           =3 
C51 COMPILER V9.51   MGR_ISP                                                               11/17/2023 14:48:45 PAGE 71  

           =3 typedef signed char S8;
           =3 typedef signed int S16;
           =3 typedef signed long S32;
           =3 
           =3 typedef union UU16
           =3 {
           =3    U16 U16;
           =3    S16 S16;
           =3    U8 U8[2];
           =3    S8 S8[2];
           =3 } UU16;
           =3 
           =3 typedef union UU32
           =3 {
           =3    U32 U32;
           =3    S32 S32;
           =3    UU16 UU16[2];
           =3    U16 U16[2];
           =3    S16 S16[2];
           =3    U8 U8[4];
           =3    S8 S8[4];
           =3 } UU32;
           =3 
           =3 // NOP () macro support
           =3 extern void _nop (void);
           =3 #define NOP() _nop()
           =3 
           =3 //-----------------------------------------------------------------------------
           =3 
           =3 
           =3 // IAR 8051
           =3 // http://www.iar.com
           =3 
           =3 #elif defined __ICC8051__
           =3 
           =3 #include <stdbool.h>
           =3 #include <intrinsics.h>
           =3 
           =3 # define SBIT(name, addr, bit)  __bit __no_init volatile bool name @ (addr+bit)
           =3 # define SFR(name, addr)        __sfr __no_init volatile unsigned char name @ addr
           =3 # define SFRX(name, addr)       __xdata __no_init volatile unsigned char name @ addr
           =3 # define SFR16(name, addr)      __sfr __no_init volatile unsigned int  name @ addr
           =3 # define SFR16E(name, fulladdr) /* not supported */
           =3 # define SFR32(name, fulladdr) /* not supported */
           =3 # define SFR32E(name, fulladdr) /* not supported */
           =3 
           =3 # define SEG_GENERIC __generic
           =3 # define SEG_FAR  __xdata
           =3 # define SEG_DATA __data
           =3 # define SEG_NEAR __data
           =3 # define SEG_IDATA __idata
           =3 # define SEG_XDATA __xdata
           =3 # define SEG_PDATA __pdata
           =3 # define SEG_CODE  __code
           =3 # define SEG_BDATA __bdata
           =3 
           =3 #define bit bool
           =3 
           =3 # define _PPTOSTR_(x) #x
           =3 # define _PPARAM_(address) _PPTOSTR_(vector=address * 8 + 3)
           =3 # define _PPARAM2_(regbank) _PPTOSTR_(register_bank=regbank)
           =3 # define INTERRUPT(name, vector) _Pragma(_PPARAM_(vector)) __interrupt void name(void)
C51 COMPILER V9.51   MGR_ISP                                                               11/17/2023 14:48:45 PAGE 72  

           =3 # define INTERRUPT_PROTO(name, vector)  __interrupt void name(void)
           =3 # define INTERRUPT_USING(name, vector, regnum) _Pragma(_PPARAM2_(regnum)) _Pragma(_PPARAM_(vector)) __inte
             -rrupt void name(void)
           =3 # define INTERRUPT_PROTO_USING(name, vector, regnum) __interrupt void name(void)
           =3 
           =3 # define FUNCTION_USING(name, return_value, parameter, regnum) /* not supported */
           =3 # define FUNCTION_PROTO_USING(name, return_value, parameter, regnum) /* not supported */
           =3 // Note: IAR does not support functions using different register banks. Register
           =3 //       banks can only be specified in interrupts. If a function is called from
           =3 //       inside an interrupt, it will use the same register bank as the interrupt.
           =3 
           =3 # define SEGMENT_VARIABLE(name, vartype, locsegment)  locsegment vartype name
           =3 # define VARIABLE_SEGMENT_POINTER(name, vartype, targsegment) vartype targsegment  * name
           =3 # define SEGMENT_VARIABLE_SEGMENT_POINTER(name, vartype, targsegment, locsegment) vartype targsegment * lo
             -csegment name
           =3 
           =3 # define LOCATED_VARIABLE(name, vartype, locsegment, addr, init) locsegment __no_init vartype name @ addr
           =3 
           =3 // used with UU16
           =3 # define LSB 0
           =3 # define MSB 1
           =3 
           =3 // used with UU32 (b0 is least-significant byte)
           =3 //# define b0 0
           =3 //# define b1 1
           =3 //# define b2 2
           =3 //# define b3 3
           =3 
           =3 typedef unsigned char U8;
           =3 typedef unsigned int U16;
           =3 typedef unsigned long U32;
           =3 
           =3 typedef signed char S8;
           =3 typedef signed int S16;
           =3 typedef signed long S32;
           =3 
           =3 typedef union UU16
           =3 {
           =3    U16 U16;
           =3    S16 S16;
           =3    U8 U8[2];
           =3    S8 S8[2];
           =3 } UU16;
           =3 
           =3 typedef union UU32
           =3 {
           =3    U32 U32;
           =3    S32 S32;
           =3    UU16 UU16[2];
           =3    U16 U16[2];
           =3    S16 S16[2];
           =3    U8 U8[4];
           =3    S8 S8[4];
           =3 } UU32;
           =3 
           =3 
           =3 #define NOP() __no_operation();
           =3 //-----------------------------------------------------------------------------
           =3 
           =3 // Crossware
           =3 // http://www.crossware.com
           =3 
C51 COMPILER V9.51   MGR_ISP                                                               11/17/2023 14:48:45 PAGE 73  

           =3 #elif defined _XC51_VER
           =3 # define SBIT(name, addr, bit)  _sfrbit  name = (addr+bit)
           =3 # define SFR(name, addr)        _sfr     name = addr
           =3 # define SFR16(name, addr)      _sfrword name = addr
           =3 # define SFR16E(name, fulladdr) /* not supported */
           =3 # define SFR32(name, fulladdr)  /* not supported */
           =3 # define SFR32E(name, fulladdr) /* not supported */
           =3 
           =3 //-----------------------------------------------------------------------------
           =3 
           =3 // Wickenhäuser
           =3 // http://www.wickenhaeuser.de
           =3 
           =3 #elif defined __UC__
           =3 # define SBIT(name, addr, bit)  unsigned char bit  name @ (addr+bit)
           =3 # define SFR(name, addr)        near unsigned char name @ addr
           =3 # define SFR16(name, addr)      /* not supported */
           =3 # define SFR16E(name, fulladdr) /* not supported */
           =3 # define SFR32(name, fulladdr)  /* not supported */
           =3 # define SFR32E(name, fulladdr) /* not supported */
           =3 
           =3 //-----------------------------------------------------------------------------
           =3 
           =3 // Default
           =3 // Unknown compiler
           =3 
           =3 #else
           =3 # warning unrecognized compiler
           =3 # define SBIT(name, addr, bit)  volatile bool           name
           =3 # define SFR(name, addr)        volatile unsigned char  name
           =3 # define SFRX(name, addr)       volatile unsigned char  name
           =3 # define SFR16(name, addr)      volatile unsigned short name
           =3 # define SFR16E(name, fulladdr) volatile unsigned short name
           =3 # define SFR32(name, fulladdr)  volatile unsigned long  name
           =3 # define SFR32E(name, fulladdr) volatile unsigned long  name
           =3 
           =3 #endif
           =3 
           =3 //-----------------------------------------------------------------------------
           =3 // Header File PreProcessor Directive
           =3 //-----------------------------------------------------------------------------
           =3 
           =3 #endif                                 // #define COMPILER_DEFS_H
 689      =3  
 690      =3  //-----------------------------------------------------------------------------
 691      =3  // End Of File
 692      =3  //-----------------------------------------------------------------------------
   8      =2  #include "C8051F580_defs.h"
   1      =3  //-----------------------------------------------------------------------------
   2      =3  // C8051F580_defs.h
   3      =3  //-----------------------------------------------------------------------------
   4      =3  // Copyright 2008, Silicon Laboratories, Inc.
   5      =3  // http://www.silabs.com
   6      =3  //
   7      =3  // Program Description:
   8      =3  //
   9      =3  // Register/bit definitions for the C8051F58x family.
  10      =3  // **Important Note**: The compiler_defs.h header file should be included
  11      =3  // before including this header file.
  12      =3  //
  13      =3  // Target:         C8051F580/1/2/3/4/5/6/7,8/9-F590/1
  14      =3  // Tool chain:     Generic
C51 COMPILER V9.51   MGR_ISP                                                               11/17/2023 14:48:45 PAGE 74  

  15      =3  // Command Line:   None
  16      =3  //
  17      =3  // Release 0.6 - 20 AUG 2012 (TP)
  18      =3  //    -Added #define for _XPAGE to provide support for SDCC memory paging
  19      =3  //     (pdata)
  20      =3  //
  21      =3  // Release 0.5 - 10 SEP 2011 (GP)
  22      =3  //    - Fixed SFR16 definition for CAN0IF2MC
  23      =3  //
  24      =3  // Release 0.4 - 08 OCT 2010 (TP)
  25      =3  //    - Fixed bit definitions for SCON0
  26      =3  //
  27      =3  // Release 0.3 - 01 APR 2009 (GP)
  28      =3  //    - Added SN0-SN3
  29      =3  //
  30      =3  // Release 0.2 - 29 JUL 2008 (ADT)
  31      =3  //    - Added Timer 4 bit definitions
  32      =3  //
  33      =3  // Release 0.1 - 09 JUL 2008 (GP)
  34      =3  //    - Initial Revision
  35      =3  //
  36      =3  //-----------------------------------------------------------------------------
  37      =3  // Header File Preprocessor Directive
  38      =3  //-----------------------------------------------------------------------------
  39      =3  
  40      =3  #ifndef C8051F580_DEFS_H
           =3 #define C8051F580_DEFS_H
           =3 
           =3 //-----------------------------------------------------------------------------
           =3 // Page 0, Page 1 and Page F Registers
           =3 //-----------------------------------------------------------------------------
           =3 
           =3 SFR (P0, 0x80);                        // Port 0 Latch
           =3 SFR (SP, 0x81);                        // Stack Pointer
           =3 SFR (DPL, 0x82);                       // Data Pointer Low
           =3 SFR (DPH, 0x83);                       // Data Pointer High
           =3 SFR (SFR0CN, 0x84);                    // SFR Page Control
           =3 SFR (SFRNEXT, 0x85);                   // SFR stack next page
           =3 SFR (SFRLAST, 0x86);                   // SFR stack last page
           =3 SFR (PCON, 0x87);                      // Power Control
           =3 SFR (TCON, 0x88);                      // Timer/Counter Control
           =3 SFR (TMOD, 0x89);                      // Timer/Counter Mode
           =3 SFR (TL0, 0x8A);                       // Timer/Counter 0 Low
           =3 SFR (TL1, 0x8B);                       // Timer/Counter 1 Low
           =3 SFR (TH0, 0x8C);                       // Timer/Counter 0 High
           =3 SFR (TH1, 0x8D);                       // Timer/Counter 1 High
           =3 SFR (CKCON, 0x8E);                     // Clock Control
           =3 SFR (PSCTL, 0x8F);                     // Program Store R/W Control
           =3 SFR (CLKSEL, 0x8F);                    // System clock select
           =3 SFR (P1, 0x90);                        // Port 1 Latch
           =3 SFR (TMR3CN, 0x91);                    // Timer/Counter 3 Control
           =3 SFR (TMR5CN, 0x91);                    // Timer/Counter 5 Control
           =3 SFR (TMR3RLL, 0x92);                   // Timer/Counter 3 Reload Low
           =3 SFR (TMR5CAPL, 0x92);                  // Timer/Counter 5 Capture Low
           =3 SFR (TMR3RLH, 0x93);                   // Timer/Counter 3 Reload High
           =3 SFR (TMR5CAPH, 0x93);                  // Timer/Counter 5 Capture High
           =3 SFR (TMR3L, 0x94);                     // Timer/Counter 3 Low
           =3 SFR (TMR5L, 0x94);                     // Timer/Counter 5 Low
           =3 SFR (TMR3H, 0x95);                     // Timer/Counter 3 High
           =3 SFR (TMR5H, 0x95);                     // Timer/Counter 5 High
           =3 SFR (TMR5CF, 0x96);                    // Timer/Counter 5 Configuration
           =3 SFR (CLKMUL, 0x97);                    // Clock Multiplier
C51 COMPILER V9.51   MGR_ISP                                                               11/17/2023 14:48:45 PAGE 75  

           =3 SFR (SCON0, 0x98);                     // UART0 Control
           =3 SFR (SCON1, 0x98);                     // UART1 Control
           =3 SFR (SBUF0, 0x99);                     // UART0 Data Buffer
           =3 SFR (SBUF1, 0x99);                     // UART1 Data Buffer
           =3 SFR (CPT0CN, 0x9A);                    // Comparator 0 Control
           =3 SFR (CPT2CN, 0x9A);                    // Comparator 2 Control
           =3 SFR (CPT0MD, 0x9B);                    // Comparator 0 Mode
           =3 SFR (CPT2MD, 0x9B);                    // Comparator 2 Mode
           =3 SFR (CPT0MX, 0x9C);                    // Comparator 0 Mux
           =3 SFR (CPT2MX, 0x9C);                    // Comparator 2 Mux
           =3 SFR (CPT1CN, 0x9D);                    // Comparator 1 Control
           =3 SFR (CPT1MD, 0x9E);                    // Comparator 0 Mode
           =3 SFR (OSCIFIN, 0x9E);                   // Internal Oscillator Fine Control
           =3 SFR (CPT1MX, 0x9F);                    // Comparator 1 Mux
           =3 SFR (OSCXCN, 0x9F);                    // External Oscillator Control
           =3 SFR (P2, 0xA0);                        // Port 2 Latch
           =3 SFR (SPI0CFG, 0xA1);                   // SPI0 Configuration
           =3 SFR (OSCICN, 0xA1);                    // Internal Oscillator Control
           =3 SFR (SPI0CKR, 0xA2);                   // SPI0 Clock rate control
           =3 SFR (OSCICRS, 0xA2);                   // Internal Oscillator Coarse Control
           =3 SFR (SPI0DAT, 0xA3);                   // SPI0 Data Buffer
           =3 SFR (P0MDOUT, 0xA4);                   // Port 0 Output Mode
           =3 SFR (P1MDOUT, 0xA5);                   // Port 1 Output Mode
           =3 SFR (P2MDOUT, 0xA6);                   // Port 2 Output Mode
           =3 SFR (SFRPAGE, 0xA7);                   // SFR Page Select
           =3 SFR (IE, 0xA8);                        // Interrupt Enable
           =3 SFR (SMOD0, 0xA9);                     // Serial Port 0 Control
           =3 SFR (EMI0CN, 0xAA);                    // EMIF Control
           =3 SFR (EMI0TC, 0xAA);                    // EMIF Timing control
           =3 SFR (SBCON0, 0xAB);                    // UART0 Baud Rate Generator Control
           =3 SFR (SBRLL0, 0xAC);                    // UART0 Baud Rate Generator Low
           =3 SFR (SBRLH0, 0xAD);                    // UART0 Baud Rate Generator High
           =3 SFR (P3MAT, 0xAE);                     // Port 3 Match
           =3 SFR (P3MDOUT, 0xAE);                   // Port 3 Mode
           =3 SFR (P3MASK, 0xAF);                    // Port 3 Mask
           =3 SFR (P4MDOUT, 0xAF);                   // Port 4 Mode
           =3 SFR (P3, 0xB0);                        // Port 3 Latch
           =3 SFR (P2MAT, 0xB1);                     // Port 2 Match
           =3 SFR (P2MASK, 0xB2);                    // Port 2 Mask
           =3 SFR (EMI0CF, 0xB2);                    // EMIF Configuration
           =3 SFR (P4, 0xB5);                        // Port 4 Latch
           =3 SFR (FLSCL, 0xB6);                     // Flash Scale
           =3 SFR (FLKEY, 0xB7);                     // Flash access limit
           =3 SFR (IP, 0xB8);                        // Interrupt Priority
           =3 SFR (SMB0ADR, 0xB9);                   // SMBus0 Slave address
           =3 SFR (ADC0TK, 0xBA);                    // ADC0 Tracking Mode Select
           =3 SFR (SMB0ADM, 0xBA);                   // SMBus0 Address Mask
           =3 SFR (ADC0MX, 0xBB);                    // AMUX0 Channel select
           =3 SFR (ADC0CF, 0xBC);                    // AMUX0 Channel configuration
           =3 SFR (ADC0L, 0xBD);                     // ADC0 Data Low
           =3 SFR (ADC0H, 0xBE);                     // ADC0 Data High
           =3 SFR (SMB0CN, 0xC0);                    // SMBus0 Control
           =3 SFR (SMB0CF, 0xC1);                    // SMBus0 Configuration
           =3 SFR (SMB0DAT, 0xC2);                   // SMBus0 Data
           =3 SFR (ADC0GTL, 0xC3);                   // ADC0 Greater-Than Compare Low
           =3 SFR (ADC0GTH, 0xC4);                   // ADC0 Greater-Than Compare High
           =3 SFR (ADC0LTL, 0xC5);                   // ADC0 Less-Than Compare Word Low
           =3 SFR (ADC0LTH, 0xC6);                   // ADC0 Less-Than Compare Word High
           =3 SFR (XBR3, 0xC6);                      // Port I/O Crossbar Control 3
           =3 SFR (XBR2, 0xC7);                      // Port I/O Crossbar Control 2
           =3 SFR (TMR2CN, 0xC8);                    // Timer/Counter 2 Control
           =3 SFR (TMR4CN, 0xC8);                    // Timer/Counter 4 Control
C51 COMPILER V9.51   MGR_ISP                                                               11/17/2023 14:48:45 PAGE 76  

           =3 SFR (REG0CN, 0xC9);                    // Regulator Control
           =3 SFR (LIN0CF, 0xC9);                    // LIN 0 Configuration
           =3 SFR (TMR4CF, 0xC9);                    // Timer/Counter 4 Configuration
           =3 SFR (TMR2RLL, 0xCA);                   // Timer/Counter 2 Reload Low
           =3 SFR (TMR4CAPL, 0xCA);                  // Timer/Counter 4 Capture Low
           =3 SFR (TMR2RLH, 0xCB);                   // Timer/Counter 2 Reload High
           =3 SFR (TMR4CAPH, 0xCB);                  // Timer/Counter 4 Capture High
           =3 SFR (TMR2L, 0xCC);                     // Timer/Counter 2 Low
           =3 SFR (TMR4L, 0xCC);                     // Timer/Counter 4 Low
           =3 SFR (TMR2H, 0xCD);                     // Timer/Counter 2 High
           =3 SFR (TMR4H, 0xCD);                     // Timer/Counter 4 High
           =3 SFR (PCA0CPL5, 0xCE);                  // PCA0 Capture 5 Low
           =3 SFR (PCA1CPL11, 0xCE);                 // PCA1 Capture 11 Low
           =3 SFR (PCA0CPH5, 0xCF);                  // PCA0 Capture 5 High
           =3 SFR (PCA1CPH11, 0xCF);                 // PCA1 Capture 11 High
           =3 SFR (PSW, 0xD0);                       // Program Status Word
           =3 SFR (REF0CN, 0xD1);                    // Voltage Reference Control
           =3 SFR (LIN0DAT, 0xD2);                   // LIN0 Data
           =3 SFR (LIN0ADR, 0xD3);                   // LIN0 Address
           =3 SFR (P0SKIP, 0xD4);                    // Port 0 Skip
           =3 SFR (P1SKIP, 0xD5);                    // Port 1 Skip
           =3 SFR (P2SKIP, 0xD6);                    // Port 2 Skip
           =3 SFR (P3SKIP, 0xD7);                    // Port 3 Skip
           =3 SFR (PCA0CN, 0xD8);                    // PCA0 Control
           =3 SFR (PCA1CN, 0xD8);                    // PCA1 Control
           =3 SFR (PCA0MD, 0xD9);                    // PCA0 Mode
           =3 SFR (PCA1MD, 0xD9);                    // PCA1 Mode
           =3 SFR (PCA0PWM, 0xD9);                   // PCA0 PWM Control
           =3 SFR (PCA0CPM0, 0xDA);                  // PCA0 Module 0 Mode
           =3 SFR (PCA1CPM6, 0xDA);                  // PCA1 Module 6 Mode
           =3 SFR (PCA1PWM, 0xDA);                   // PCA1 PWM Control
           =3 SFR (PCA0CPM1, 0xDB);                  // PCA0 Module 1  Mode
           =3 SFR (PCA1CPM7, 0xDB);                  // PCA1 Module 7  Mode
           =3 SFR (PCA0CPM2, 0xDC);                  // PCA0 Module 2  Mode
           =3 SFR (PCA1CPM8, 0xDC);                  // PCA1 Module 8  Mode
           =3 SFR (PCA0CPM3, 0xDD);                  // PCA0 Module 3  Mode
           =3 SFR (PCA1CPM9, 0xDD);                  // PCA1 Module 9  Mode
           =3 SFR (PCA0CPM4, 0xDE);                  // PCA0 Module 4  Mode
           =3 SFR (PCA1CPM10, 0xDE);                  // PCA1 Module 10 Mode
           =3 SFR (PCA0CPM5, 0xDF);                  // PCA0 Module 5  Mode
           =3 SFR (PCA1CPM11, 0xDF);                  // PCA1 Module 11 Mode
           =3 SFR (ACC, 0xE0);                       // Accumulator
           =3 SFR (XBR0, 0xE1);                      // Port I/O Crossbar Control 0
           =3 SFR (XBR1, 0xE2);                      // Port I/O Crossbar Control 1
           =3 SFR (CCH0CN, 0xE3);                    // Cache control
           =3 SFR (IT01CF, 0xE4);                    // INT0/INT1 Configuration
           =3 SFR (EIE1, 0xE6);                      // Extended Interrupt Enable 2
           =3 SFR (EIE2, 0xE7);                      // Extended Interrupt Enable 2
           =3 SFR (ADC0CN, 0xE8);                    // ADC0 Control
           =3 SFR (PCA0CPL1, 0xE9);                  // PCA0 Capture 1 Low
           =3 SFR (PCA1CPL1, 0xE9);                  // PCA1 Capture 7 Low
           =3 SFR (PCA0CPH1, 0xEA);                  // PCA0 Capture 1 High
           =3 SFR (PCA1CPH1, 0xEA);                  // PCA1 Capture 7 High
           =3 SFR (PCA0CPL2, 0xEB);                  // PCA0 Capture 2 Low
           =3 SFR (PCA1CPL2, 0xEB);                  // PCA1 Capture 8 Low
           =3 SFR (PCA0CPH2, 0xEC);                  // PCA0 Capture 2 High
           =3 SFR (PCA1CPH2, 0xEC);                  // PCA1 Capture 8 High
           =3 SFR (PCA0CPL3, 0xED);                  // PCA0 Capture 3 Low
           =3 SFR (PCA1CPL3, 0xED);                  // PCA1 Capture 9 Low
           =3 SFR (PCA0CPH3, 0xEE);                  // PCA0 Capture 3 High
           =3 SFR (PCA1CPH3, 0xEE);                  // PCA1 Capture 9 High
           =3 SFR (RSTSRC, 0xEF);                    // Reset Source Configuration/Status
C51 COMPILER V9.51   MGR_ISP                                                               11/17/2023 14:48:45 PAGE 77  

           =3 SFR (B, 0xF0);                         // B Register
           =3 SFR (P0MAT, 0xF1);                     // Port 0 Match
           =3 SFR (P0MDIN, 0xF1);                    // Port 0 Input Mode
           =3 SFR (P0MASK, 0xF2);                    // Port 0 Mask
           =3 SFR (P1MDIN, 0xF2);                    // Port 1 Input Mode
           =3 SFR (P1MAT, 0xF3);                     // Port 1 Match
           =3 SFR (P2MDIN, 0xF3);                    // Port 2 Input Mode
           =3 SFR (P1MASK, 0xF4);                    // Port 1 Mask
           =3 SFR (P3MDIN, 0xF4);                    // Port 3 Input Mode
           =3 SFR (PSBANK, 0xF5);                    // Program Space Bank Select
           =3 SFR (EIP1, 0xF6);                      // External Interrupt Priority 1
           =3 SFR (EIP2, 0xF7);                      // External Interrupt Priority 2
           =3 SFR (SPI0CN, 0xF8);                    // SPI0 Control
           =3 SFR (PCA0L, 0xF9);                     // PCA0 Counter Low
           =3 SFR (PCA1L, 0xF9);                     // PCA1 Counter Low
           =3 SFR (SN0, 0xF9);                       // Serial Number 0
           =3 SFR (PCA0H, 0xFA);                     // PCA0 Counter High
           =3 SFR (PCA1H, 0xFA);                     // PCA1 Counter High
           =3 SFR (SN1, 0xFA);                       // Serial Number 1
           =3 SFR (PCA0CPL0, 0xFB);                  // PCA0 Capture 0 Low
           =3 SFR (PCA1CPL6, 0xFB);                  // PCA1 Capture 6 Low
           =3 SFR (SN2, 0xFB);                       // Serial Number 2
           =3 SFR (PCA0CPH0, 0xFC);                  // PCA0 Capture 0 High
           =3 SFR (PCA1CPH6, 0xFC);                  // PCA1 Capture 6 High
           =3 SFR (SN3, 0xFC);                       // Serial Number 3
           =3 SFR (PCA0CPL4, 0xFD);                  // PCA0 Capture 4 Low
           =3 SFR (PCA1CPL10, 0xFD);                 // PCA1 Capture 10 Low
           =3 SFR (PCA0CPH4, 0xFE);                  // PCA0 Capture 4 High
           =3 SFR (PCA1CPH10, 0xFE);                 // PCA1 Capture 10 High
           =3 SFR (VDM0CN, 0xFF);                    // VDD Monitor Control
           =3 
           =3 //-----------------------------------------------------------------------------
           =3 // Page C (CAN0) Registers
           =3 //-----------------------------------------------------------------------------
           =3 
           =3 SFR (CAN0CFG, 0x92);                   // CAN0 Clock Configuration
           =3 SFR (CAN0STAT, 0x94);                  // Status Register Low Byte
           =3 SFR (CAN0ERRL, 0x96);                  // Error Counter Low Byte
           =3 SFR (CAN0ERRH, 0x97);                  // Error Counter High Byte
           =3 SFR (CAN0BTL, 0x9A);                   // Bit Timing Register Low Byte
           =3 SFR (CAN0BTH, 0x9B);                   // Bit Timing Register High Byte
           =3 SFR (CAN0IIDL, 0x9C);                  // Interrupt Register Low Byte
           =3 SFR (CAN0IIDH, 0x9D);                  // Interrupt Register High Byte
           =3 SFR (CAN0TST, 0x9E);                   // Test Register Low Byte
           =3 SFR (CAN0BRPE, 0xA1);                  // BRP Extension Register Low Byte
           =3 SFR (CAN0TR1L, 0xA2);                  // Transmission Request 1 Low Byte
           =3 SFR (CAN0TR1H, 0xA3);                  // Transmission Request 1 High Byte
           =3 SFR (CAN0TR2L, 0xA4);                  // Transmission Request 2 Low Byte
           =3 SFR (CAN0TR2H, 0xA5);                  // Transmission Request 2 High Byte
           =3 SFR (CAN0ND1L, 0xAA);                  // New Data 1 Low Byte
           =3 SFR (CAN0ND1H, 0xAB);                  // New Data 1 High Byte
           =3 SFR (CAN0ND2L, 0xAC);                  // New Data 2 Low Byte
           =3 SFR (CAN0ND2H, 0xAD);                  // New Data 2 High Byte
           =3 SFR (CAN0IP1L, 0xAE);                  // Interrupt Pending 1 Low Byte
           =3 SFR (CAN0IP1H, 0xAF);                  // Interrupt Pending 1 High Byte
           =3 SFR (CAN0IP2L, 0xB2);                  // Interrupt Pending 2 Low Byte
           =3 SFR (CAN0IP2H, 0xB3);                  // Interrupt Pending 2 High Byte
           =3 SFR (CAN0MV1L, 0xBA);                  // Message Valid 1 Low Byte
           =3 SFR (CAN0MV1H, 0xBB);                  // Message Valid 1 High Byte
           =3 SFR (CAN0MV2L, 0xBC);                  // Message Valid 2 Low Byte
           =3 SFR (CAN0MV2H, 0xBD);                  // Message Valid 2 High Byte
           =3 SFR (CAN0IF1CRL, 0xBE);                // IF1 Command Request Low Byte
C51 COMPILER V9.51   MGR_ISP                                                               11/17/2023 14:48:45 PAGE 78  

           =3 SFR (CAN0IF1CRH, 0xBF);                // IF1 Command Request High Byte
           =3 SFR (CAN0CN, 0xC0);                    // CAN Control Register Low Byte
           =3 SFR (CAN0IF1CML, 0xC2);                // IF1 Command Mask Low Byte
           =3 SFR (CAN0IF1CMH, 0xC3);                // IF1 Command Mask High Byte
           =3 SFR (CAN0IF1M1L, 0xC4);                // IF1 Mask 1 Low Byte
           =3 SFR (CAN0IF1M1H, 0xC5);                // IF1 Mask 1 High Byte
           =3 SFR (CAN0IF1M2L, 0xC6);                // IF1 Mask 2 Low Byte
           =3 SFR (CAN0IF1M2H, 0xC7);                // IF1 Mask 2 High Byte
           =3 SFR (CAN0IF1A1L, 0xCA);                // IF1 Arbitration 1 Low Byte
           =3 SFR (CAN0IF1A1H, 0xCB);                // IF1 Arbitration 1 High Byte
           =3 SFR (CAN0IF1A2L, 0xCC);                // IF1 Arbitration 2 Low Byte
           =3 SFR (CAN0IF1A2H, 0xCD);                // IF1 Arbitration 2 High Byte
           =3 SFR (CAN0IF2MCL, 0xCE);                // IF2 Message Control Low Byte
           =3 SFR (CAN0IF2MCH, 0xCF);                // IF2 Message Control High Byte
           =3 SFR (CAN0IF1MCL, 0xD2);                // IF1 Message Control Low Byte
           =3 SFR (CAN0IF1MCH, 0xD3);                // IF1 Message Control High Byte
           =3 SFR (CAN0IF1DA1L, 0xD4);               // IF1 Data A 1 Low Byte
           =3 SFR (CAN0IF1DA1H, 0xD5);               // IF1 Data A 1 High Byte
           =3 SFR (CAN0IF1DA2L, 0xD6);               // IF1 Data A 2 Low Byte
           =3 SFR (CAN0IF1DA2H, 0xD7);               // IF1 Data A 2 High Byte
           =3 SFR (CAN0IF1DB1L, 0xDA);               // IF1 Data B 1 Low Byte
           =3 SFR (CAN0IF1DB1H, 0xDB);               // IF1 Data B 1 High Byte
           =3 SFR (CAN0IF1DB2L, 0xDC);               // IF1 Data B 2 Low Byte
           =3 SFR (CAN0IF1DB2H, 0xDD);               // IF1 Data B 2 High Byte
           =3 SFR (CAN0IF2CRL, 0xDE);                // IF2 Command Request Low Byte
           =3 SFR (CAN0IF2CRH, 0xDF);                // IF2 Command Request High Byte
           =3 SFR (CAN0IF2CML, 0xE2);                // IF2 Command Mask Low Byte
           =3 SFR (CAN0IF2CMH, 0xE3);                // IF2 Command Mask High Byte
           =3 SFR (CAN0IF2M1L, 0xEA);                // IF2 Mask 1 Low Byte
           =3 SFR (CAN0IF2M1H, 0xEB);                // IF2 Mask 1 High Byte
           =3 SFR (CAN0IF2M2L, 0xEC);                // IF2 Mask 2 Low Byte
           =3 SFR (CAN0IF2M2H, 0xED);                // IF2 Mask 2 High Byte
           =3 SFR (CAN0IF2A1L, 0xEE);                // IF2 Arbitration 1 Low Byte
           =3 SFR (CAN0IF2A1H, 0xEF);                // IF2 Arbitration 1 High Byte
           =3 SFR (CAN0IF2A2L, 0xF2);                // IF2 Arbitration 2 Low Byte
           =3 SFR (CAN0IF2A2H, 0xF3);                // IF2 Arbitration 2 High Byte
           =3 SFR (CAN0IF2DA1L, 0xF6);               // IF2 Data A 1 Low Byte
           =3 SFR (CAN0IF2DA1H, 0xF7);               // IF2 Data A 1 High Byte
           =3 SFR (CAN0IF2DA2L, 0xFA);               // IF2 Data A 2 Low Byte
           =3 SFR (CAN0IF2DA2H, 0xFB);               // IF2 Data A 2 High Byte
           =3 SFR (CAN0IF2DB1L, 0xFC);               // IF2 Data B 1 Low Byte
           =3 SFR (CAN0IF2DB1H, 0xFD);               // IF2 Data B 1 High Byte
           =3 SFR (CAN0IF2DB2L, 0xFE);               // IF2 Data B 2 Low Byte
           =3 SFR (CAN0IF2DB2H, 0xFF);               // IF2 Data B 2 High Byte
           =3 
           =3 
           =3 //-----------------------------------------------------------------------------
           =3 // 16-bit Register Definitions (might not be supported by all compilers)
           =3 //-----------------------------------------------------------------------------
           =3 
           =3 SFR16 (DP, 0x82);                      // Data Pointer
           =3 SFR16 (TMR3RL, 0x92);                  // Timer 3 Reload
           =3 SFR16 (TMR5CAP, 0x92);                 // Timer 5 Capture
           =3 SFR16 (TMR3, 0x94);                    // Timer 3 Capture / Reload
           =3 SFR16 (TMR5, 0x94);                    // Timer 5
           =3 SFR16 (SBRL0, 0xAC);                   // UART0 Reload
           =3 SFR16 (ADC0, 0xBD);                    // ADC0 data
           =3 SFR16 (ADC0GT, 0xC3);                  // ADC0 Greater Than Window
           =3 SFR16 (ADC0LT, 0xC5);                  // ADC0 Less Than Window
           =3 SFR16 (TMR2RL, 0xCA);                  // Timer 2 Reload
           =3 SFR16 (TMR4CAP, 0xCA);                 // Timer 4 Capture
           =3 SFR16 (TMR2, 0xCC);                    // Timer 2 Capture / Reload
C51 COMPILER V9.51   MGR_ISP                                                               11/17/2023 14:48:45 PAGE 79  

           =3 SFR16 (TMR4, 0xCC);                    // Timer 4
           =3 SFR16 (PCA0CP5, 0xCE);                 // PCA0 Module 5 Capture
           =3 SFR16 (PCA1CP11, 0xCE);                // PCA1 Module 11 Capture
           =3 SFR16 (PCA0CP1, 0xE9);                 // PCA0 Module 1 Capture
           =3 SFR16 (PCA1CP7, 0xE9);                 // PCA1 Module 7 Capture
           =3 SFR16 (PCA0CP2, 0xEB);                 // PCA0 Module 2 Capture
           =3 SFR16 (PCA1CP8, 0xEB);                 // PCA1 Module 8 Capture
           =3 SFR16 (PCA0CP3, 0xED);                 // PCA0 Module 3 Capture
           =3 SFR16 (PCA1CP9, 0xED);                 // PCA1 Module 9 Capture
           =3 SFR16 (PCA0, 0xF9);                    // PCA0 Counter
           =3 SFR16 (PCA1, 0xF9);                    // PCA1 Counter
           =3 SFR16 (PCA0CP0, 0xFB);                 // PCA0 Module 0 Capture
           =3 SFR16 (PCA1CP6, 0xFB);                 // PCA1 Module 6 Capture
           =3 SFR16 (PCA0CP4, 0xFD);                 // PCA0 Module 4 Capture
           =3 SFR16 (PCA1CP10, 0xFD);                 // PCA1 Module 10 Capture
           =3 
           =3 SFR16 (CAN0ERR, 0x96);                 // Error Counter
           =3 SFR16 (CAN0BT, 0x9A);                  // Bit Timing Register
           =3 SFR16 (CAN0IID, 0x9C);                 // Interrupt Register
           =3 SFR16 (CAN0TR1, 0xA2);                 // Transmission Request 1
           =3 SFR16 (CAN0TR2, 0xA4);                 // Transmission Request 2
           =3 SFR16 (CAN0ND1, 0xAA);                 // New Data 1
           =3 SFR16 (CAN0ND2, 0xAC);                 // New Data 2
           =3 SFR16 (CAN0IP1, 0xAE);                 // Interrupt Pending 1
           =3 SFR16 (CAN0IP2, 0xB2);                 // Interrupt Pending 2
           =3 SFR16 (CAN0MV1, 0xBA);                 // Message Valid 1
           =3 SFR16 (CAN0MV2, 0xBC);                 // Message Valid 2
           =3 SFR16 (CAN0IF1CR, 0xBE);               // IF1 Command Request
           =3 SFR16 (CAN0IF1CM, 0xC2);               // IF1 Command Mask
           =3 SFR16 (CAN0IF1M1, 0xC4);               // IF1 Mask 1
           =3 SFR16 (CAN0IF1M2, 0xC6);               // IF1 Mask 2
           =3 SFR16 (CAN0IF1A1, 0xCA);               // IF1 Arbitration 1
           =3 SFR16 (CAN0IF1A2, 0xCC);               // IF1 Arbitration 2
           =3 SFR16 (CAN0IF1MC, 0xD2);               // IF1 Message Control
           =3 SFR16 (CAN0IF1DA1, 0xD4);              // IF1 Data A 1
           =3 SFR16 (CAN0IF1DA2, 0xD6);              // IF1 Data A 2
           =3 SFR16 (CAN0IF1DB1, 0xDA);              // IF1 Data B 1
           =3 SFR16 (CAN0IF1DB2, 0xDC);              // IF1 Data B 2
           =3 SFR16 (CAN0IF2CR, 0xDE);               // IF2 Command Request
           =3 SFR16 (CAN0IF2CM, 0xE2);               // IF2 Command Mask
           =3 SFR16 (CAN0IF2M1, 0xEA);               // IF2 Mask 1
           =3 SFR16 (CAN0IF2M2, 0xEC);               // IF2 Mask 2
           =3 SFR16 (CAN0IF2A1, 0xEE);               // IF2 Arbitration 1
           =3 SFR16 (CAN0IF2A2, 0xF2);               // IF2 Arbitration 2
           =3 SFR16 (CAN0IF2MC, 0xCE);               // IF2 Message Control
           =3 SFR16 (CAN0IF2DA1, 0xF6);              // IF2 Data A 1
           =3 SFR16 (CAN0IF2DA2, 0xFA);              // IF2 Data A 2
           =3 SFR16 (CAN0IF2DB1, 0xFC);              // IF2 Data B 1
           =3 SFR16 (CAN0IF2DB2, 0xFE);              // IF2 Data B 2
           =3 
           =3 //-----------------------------------------------------------------------------
           =3 // LIN0 Indirect Registers
           =3 //-----------------------------------------------------------------------------
           =3 
           =3 #define  LIN0DT1   0x00                // LIN0 Data Byte 1
           =3 #define  LIN0DT2   0x01                // LIN0 Data Byte 2
           =3 #define  LIN0DT3   0x02                // LIN0 Data Byte 3
           =3 #define  LIN0DT4   0x03                // LIN0 Data Byte 4
           =3 #define  LIN0DT5   0x04                // LIN0 Data Byte 5
           =3 #define  LIN0DT6   0x05                // LIN0 Data Byte 6
           =3 #define  LIN0DT7   0x06                // LIN0 Data Byte 7
           =3 #define  LIN0DT8   0x07                // LIN0 Data Byte 8
C51 COMPILER V9.51   MGR_ISP                                                               11/17/2023 14:48:45 PAGE 80  

           =3 #define  LIN0CTRL  0x08                // LIN0 Control
           =3 #define  LIN0ST    0x09                // LIN0 Status
           =3 #define  LIN0ERR   0x0A                // LIN0 Error
           =3 #define  LIN0SIZE  0x0B                // LIN0 Message Size
           =3 #define  LIN0DIV   0x0C                // LIN0 Divider
           =3 #define  LIN0MUL   0x0D                // LIN0 Multiplier
           =3 #define  LIN0ID    0x0E                // LIN0 Identifier
           =3 
           =3 //-----------------------------------------------------------------------------
           =3 // Address Definitions for Bit-addressable Registers
           =3 //-----------------------------------------------------------------------------
           =3 
           =3 #define SFR_P0       0x80
           =3 #define SFR_TCON     0x88
           =3 #define SFR_P1       0x90
           =3 #define SFR_SCON0    0x98
           =3 #define SFR_SCON1    0x98
           =3 #define SFR_P2       0xA0
           =3 #define SFR_IE       0xA8
           =3 #define SFR_P3       0xB0
           =3 #define SFR_IP       0xB8
           =3 #define SFR_SMB0CN   0xC0
           =3 #define SFR_TMR2CN   0xC8
           =3 #define SFR_TMR4CN   0xC8
           =3 #define SFR_PSW      0xD0
           =3 #define SFR_PCA0CN   0xD8
           =3 #define SFR_PCA1CN   0xD8
           =3 #define SFR_ACC      0xE0
           =3 #define SFR_ADC0CN   0xE8
           =3 #define SFR_B        0xF0
           =3 #define SFR_SPI0CN   0xF8
           =3 
           =3 //-----------------------------------------------------------------------------
           =3 // Bit Definitions
           =3 //-----------------------------------------------------------------------------
           =3 
           =3 // TCON 0x88
           =3 SBIT (TF1, SFR_TCON, 7);               // Timer 1 Overflow Flag
           =3 SBIT (TR1, SFR_TCON, 6);               // Timer 1 On/Off Control
           =3 SBIT (TF0, SFR_TCON, 5);               // Timer 0 Overflow Flag
           =3 SBIT (TR0, SFR_TCON, 4);               // Timer 0 On/Off Control
           =3 SBIT (IE1, SFR_TCON, 3);               // Ext. Interrupt 1 Edge Flag
           =3 SBIT (IT1, SFR_TCON, 2);               // Ext. Interrupt 1 Type
           =3 SBIT (IE0, SFR_TCON, 1);               // Ext. Interrupt 0 Edge Flag
           =3 SBIT (IT0, SFR_TCON, 0);               // Ext. Interrupt 0 Type
           =3 
           =3 // SCON0 0x98
           =3 SBIT (OVR0, SFR_SCON0, 7);             // UART0 Receive FIFO Overrun Flag
           =3 SBIT (PERR0, SFR_SCON0, 6);            // UART0 Parity Error Flag
           =3 SBIT (THRE0, SFR_SCON0, 5);            // UART0 Transmit Register Empty Flag
           =3 SBIT (REN0, SFR_SCON0, 4);             // UART0 RX Enable
           =3 SBIT (TBX0, SFR_SCON0, 3);             // UART0 Extra Transmission Bit
           =3 SBIT (RBX0, SFR_SCON0, 2);             // UART0 Extra Receive Bit
           =3 SBIT (TI0, SFR_SCON0, 1);              // UART0 TX Interrupt Flag
           =3 SBIT (RI0, SFR_SCON0, 0);              // UART0 RX Interrupt Flag
           =3 
           =3 // SCON1 0x98
           =3 SBIT (S1MODE, SFR_SCON1, 7);           // UART1 Mode 0
           =3                                        // Bit 6 UNUSED
           =3 SBIT (MCE1, SFR_SCON1, 5);             // UART1 Multiprocessor enable
           =3 SBIT (REN1, SFR_SCON1, 4);             // UART1 RX Enable
           =3 SBIT (TB81, SFR_SCON1, 3);             // UART1 TX Bit 8
C51 COMPILER V9.51   MGR_ISP                                                               11/17/2023 14:48:45 PAGE 81  

           =3 SBIT (RB81, SFR_SCON1, 2);             // UART1 RX Bit 8
           =3 SBIT (TI1, SFR_SCON1, 1);              // UART1 TX Interrupt Flag
           =3 SBIT (RI1, SFR_SCON1, 0);              // UART1 RX Interrupt Flag
           =3 
           =3 // IE 0xA8
           =3 SBIT (EA, SFR_IE, 7);                  // Global Interrupt Enable
           =3 SBIT (ESPI0, SFR_IE, 6);               // SPI0 Interrupt Enable
           =3 SBIT (ET2, SFR_IE, 5);                 // Timer 2 Interrupt Enable
           =3 SBIT (ES0, SFR_IE, 4);                 // UART0 Interrupt Enable
           =3 SBIT (ET1, SFR_IE, 3);                 // Timer 1 Interrupt Enable
           =3 SBIT (EX1, SFR_IE, 2);                 // External Interrupt 1 Enable
           =3 SBIT (ET0, SFR_IE, 1);                 // Timer 0 Interrupt Enable
           =3 SBIT (EX0, SFR_IE, 0);                 // External Interrupt 0 Enable
           =3 
           =3 // IP 0xB8
           =3                                        // Bit 7 unused
           =3 SBIT (PSPI0, SFR_IP, 6);               // SPI0 Interrupt Priority
           =3 SBIT (PT2, SFR_IP, 5);                 // Timer 2 Priority
           =3 SBIT (PS0, SFR_IP, 4);                 // UART0 Priority
           =3 SBIT (PS, SFR_IP, 4);                  // UART0 Priority
           =3 SBIT (PT1, SFR_IP, 3);                 // Timer 1 Priority
           =3 SBIT (PX1, SFR_IP, 2);                 // External Interrupt 1 Priority
           =3 SBIT (PT0, SFR_IP, 1);                 // Timer 0 Priority
           =3 SBIT (PX0, SFR_IP, 0);                 // External Interrupt 0 Priority
           =3 
           =3 // SMB0CN 0xC0
           =3 SBIT (MASTER, SFR_SMB0CN, 7);          // SMBus0 Master/Slave Indicator
           =3 SBIT (TXMODE, SFR_SMB0CN, 6);          // SMBus0 Transmit Mode Indicator
           =3 SBIT (STA, SFR_SMB0CN, 5);             // SMBus0 Start Flag
           =3 SBIT (STO, SFR_SMB0CN, 4);             // SMBus0 Stop Flag
           =3 SBIT (ACKRQ, SFR_SMB0CN, 3);           // SMBus0 Acknowledge Request
           =3 SBIT (ARBLOST, SFR_SMB0CN, 2);         // SMBus0 Arbitration Lost Indicator
           =3 SBIT (ACK, SFR_SMB0CN, 1);             // SMBus0 Acknowledge
           =3 SBIT (SI, SFR_SMB0CN, 0);              // SMBus0 Interrupt Flag
           =3 
           =3 // TMR2CN 0xC8
           =3 SBIT (TF2H, SFR_TMR2CN, 7);            // Timer 2 High-Byte Overflow Flag
           =3 SBIT (TF2L, SFR_TMR2CN, 6);            // Timer 2 Low-Byte  Overflow Flag
           =3 SBIT (TF2LEN, SFR_TMR2CN, 5);          // Timer 2 Low-Byte Flag Enable
           =3 SBIT (TF2CEN, SFR_TMR2CN, 4);          // Timer 2 Capture Enable
           =3 SBIT (T2SPLIT, SFR_TMR2CN, 3);         // Timer 2 Split-Mode Enable
           =3 SBIT (TR2, SFR_TMR2CN, 2);             // Timer 2 Run Enable
           =3 SBIT (T2RCLK, SFR_TMR2CN, 1);          // Timer 2 Xclk/Rclk Select
           =3 SBIT (T2XCLK, SFR_TMR2CN, 0);          // Timer 2 Clk/8 Clock Source
           =3 
           =3 // TMR4CN 0xC8
           =3 SBIT (TF4, SFR_TMR4CN, 7);             // Timer 4 Overflow/Underflow Flag
           =3 SBIT (EXF4, SFR_TMR4CN, 6);            // Timer 4 External Flag
           =3                                        // Bit 5 unused
           =3                                        // Bit 4 unused
           =3 SBIT (EXE4, SFR_TMR4CN, 3);            // Timer 4 External Enable
           =3 SBIT (TR4, SFR_TMR4CN, 2);             // Timer 4 Run Enable
           =3 SBIT (CT4, SFR_TMR4CN, 1);             // Timer 4 Counter/Timer Select
           =3 SBIT (CPRL4, SFR_TMR4CN, 0);           // Timer 4 Capture/Reload Select
           =3 
           =3 // PSW 0xD0
           =3 SBIT (CY, SFR_PSW, 7);                 // Carry Flag
           =3 SBIT (AC, SFR_PSW, 6);                 // Auxiliary Carry Flag
           =3 SBIT (F0, SFR_PSW, 5);                 // User Flag 0
           =3 SBIT (RS1, SFR_PSW, 4);                // Register Bank Select 1
           =3 SBIT (RS0, SFR_PSW, 3);                // Register Bank Select 0
           =3 SBIT (OV, SFR_PSW, 2);                 // Overflow Flag
C51 COMPILER V9.51   MGR_ISP                                                               11/17/2023 14:48:45 PAGE 82  

           =3 SBIT (F1, SFR_PSW, 1);                 // User Flag 1
           =3 SBIT (P, SFR_PSW, 0);                  // Accumulator Parity Flag
           =3 
           =3 // PCA0CN 0xD8
           =3 SBIT (CF, SFR_PCA0CN, 7);              // PCA0 Counter Overflow Flag
           =3 SBIT (CR, SFR_PCA0CN, 6);              // PCA0 Counter Run Control Bit
           =3 SBIT (CCF5, SFR_PCA0CN, 5);            // PCA0 Module 5 Interrupt Flag
           =3 SBIT (CCF4, SFR_PCA0CN, 4);            // PCA0 Module 4 Interrupt Flag
           =3 SBIT (CCF3, SFR_PCA0CN, 3);            // PCA0 Module 3 Interrupt Flag
           =3 SBIT (CCF2, SFR_PCA0CN, 2);            // PCA0 Module 2 Interrupt Flag
           =3 SBIT (CCF1, SFR_PCA0CN, 1);            // PCA0 Module 1 Interrupt Flag
           =3 SBIT (CCF0, SFR_PCA0CN, 0);            // PCA0 Module 0 Interrupt Flag
           =3 
           =3 // PCA1CN 0xD8
           =3 SBIT (CF1, SFR_PCA1CN, 7);             // PCA1 Counter Overflow Flag
           =3 SBIT (CR1, SFR_PCA1CN, 6);             // PCA1 Counter Run Control Bit
           =3 SBIT (CCF11, SFR_PCA1CN, 5);           // PCA1 Module 11 Interrupt Flag
           =3 SBIT (CCF10, SFR_PCA1CN, 4);           // PCA1 Module 10 Interrupt Flag
           =3 SBIT (CCF9, SFR_PCA1CN, 3);            // PCA1 Module 9 Interrupt Flag
           =3 SBIT (CCF8, SFR_PCA1CN, 2);            // PCA1 Module 8 Interrupt Flag
           =3 SBIT (CCF7, SFR_PCA1CN, 1);            // PCA1 Module 7 Interrupt Flag
           =3 SBIT (CCF6, SFR_PCA1CN, 0);            // PCA1 Module 6 Interrupt Flag
           =3 
           =3 // ADC0CN 0xE8
           =3 SBIT (AD0EN, SFR_ADC0CN, 7);           // ADC0 Enable
           =3 SBIT (BURSTEN, SFR_ADC0CN, 6);         // ADC0 Burst Enable
           =3 SBIT (AD0INT, SFR_ADC0CN, 5);          // ADC0 EOC Interrupt Flag
           =3 SBIT (AD0BUSY, SFR_ADC0CN, 4);         // ADC0 Busy Flag
           =3 SBIT (AD0WINT, SFR_ADC0CN, 3);         // ADC0 Window Compare Interrupt Flag
           =3 SBIT (AD0LJST, SFR_ADC0CN, 2);         // ADC0 Left Justified
           =3 SBIT (AD0CM1, SFR_ADC0CN, 1);          // ADC0 Start Of Conversion Mode Bit 1
           =3 SBIT (AD0CM0, SFR_ADC0CN, 0);          // ADC0 Start Of Conversion Mode Bit 0
           =3 
           =3 // SPI0CN 0xF8
           =3 SBIT (SPIF, SFR_SPI0CN, 7);            // SPI0 Interrupt Flag
           =3 SBIT (WCOL, SFR_SPI0CN, 6);            // SPI0 Write Collision Flag
           =3 SBIT (MODF, SFR_SPI0CN, 5);            // SPI0 Mode Fault Flag
           =3 SBIT (RXOVRN, SFR_SPI0CN, 4);          // SPI0 RX Overrun Flag
           =3 SBIT (NSSMD1, SFR_SPI0CN, 3);          // SPI0 Slave Select Mode 1
           =3 SBIT (NSSMD0, SFR_SPI0CN, 2);          // SPI0 Slave Select Mode 0
           =3 SBIT (TXBMT, SFR_SPI0CN, 1);           // SPI0 TX Buffer Empty Flag
           =3 SBIT (SPIEN, SFR_SPI0CN, 0);           // SPI0 Enable
           =3 
           =3 //-----------------------------------------------------------------------------
           =3 // Interrupt Priorities
           =3 //-----------------------------------------------------------------------------
           =3 
           =3 #define INTERRUPT_INT0             0   // External Interrupt 0
           =3 #define INTERRUPT_TIMER0           1   // Timer 0 Overflow
           =3 #define INTERRUPT_INT1             2   // External Interrupt 1
           =3 #define INTERRUPT_TIMER1           3   // Timer 1 Overflow
           =3 #define INTERRUPT_UART0            4   // UART0
           =3 #define INTERRUPT_TIMER2           5   // Timer 2 Overflow
           =3 #define INTERRUPT_SPI0             6   // SPI0
           =3 #define INTERRUPT_SMBUS0           7   // SMBus0 Interface
           =3 #define INTERRUPT_ADC0_WINDOW      8   // ADC0 Window Comparison
           =3 #define INTERRUPT_ADC0_EOC         9   // ADC0 End Of Conversion
           =3 #define INTERRUPT_PCA0            10   // PCA0 Peripheral
           =3 #define INTERRUPT_COMPARATOR0     11   // Comparator 0 Comparison
           =3 #define INTERRUPT_COMPARATOR1     12   // Comparator 1 Comparison
           =3 #define INTERRUPT_TIMER3          13   // Timer 3 Overflow
           =3 #define INTERRUPT_LIN0            14   // LIN Bus Interrupt
C51 COMPILER V9.51   MGR_ISP                                                               11/17/2023 14:48:45 PAGE 83  

           =3 #define INTERRUPT_VREG            15   // Voltage Regulator
           =3 #define INTERRUPT_CAN0            16   // CAN Bus Interrupt
           =3 #define INTERRUPT_PORT_MATCH      17   // Port Match
           =3 #define INTERRUPT_UART1           18   // UART1
           =3 #define INTERRUPT_PCA1            19   // PCA1 Peripheral
           =3 #define INTERRUPT_COMPARATOR2     20   // Comparator 2 Comparison
           =3 #define INTERRUPT_TIMER4          21   // Timer 4 Overflow
           =3 #define INTERRUPT_TIMER5          22   // Timer 5 Overflow
           =3 
           =3 
           =3 //-----------------------------------------------------------------------------
           =3 // SFR Page Definitions
           =3 //-----------------------------------------------------------------------------
           =3 
           =3 #define  CONFIG_PAGE       0x0F        // System and Port Configuration Page
           =3 #define  ACTIVE_PAGE       0x00        // Active Use Page
           =3 #define  ACTIVE2_PAGE      0x10        // Active Use Page 2
           =3 #define  CAN0_PAGE         0x0C        // CAN0 Registers
           =3 
           =3 //-----------------------------------------------------------------------------
           =3 // SDCC PDATA External Memory Paging Support
           =3 //-----------------------------------------------------------------------------
           =3 
           =3 #if defined SDCC
           =3 
           =3 SFR(_XPAGE, 0xAA); // Point to the EMI0CN register
           =3 
           =3 #endif
           =3 
           =3 //-----------------------------------------------------------------------------
           =3 // Header File PreProcessor Directive
           =3 //-----------------------------------------------------------------------------
           =3 
           =3 #endif                                 // #define C8051F580_DEFS_H
 607      =3  
 608      =3  //-----------------------------------------------------------------------------
 609      =3  // End Of File
 610      =3  //-----------------------------------------------------------------------------
   9      =2  
  10      =2  /* ----- Global Define -------------------------------*/
  11      =2  //DTC INFO
  12      =2  #define DTC_MCU_WT_ERR                          0x00U
  13      =2  #define DTC_MCU_MC_ERR                          0x01U
  14      =2  #define DTC_SENSOR_FV_ERR                       0x02U
  15      =2  #define DTC_SENSOR_FC_ERR                       0x03U
  16      =2  #define DTC_SENSOR_ISPSTAT_ERR          0x04U
  17      =2  #define DTC_SENSOR_COMM_ERR                     0x05U
  18      =2  #define DTC_SENOSR_INIT_ERR                     0x06U
  19      =2  #define DTC_VIDEO_OUT_CUT_ERR           0x07U
  20      =2  #define DTC_VIDEO_OVER_VOL_ERR          0x08U
  21      =2  #define DTC_CODE_COUNT                          0x09U
  22      =2  
  23      =2  #define DTC_CODE_INTERNAL_ERROR         0x00U
  24      =2  #define DTC_CODE_SENSOR_ERROR           0x01U
  25      =2  #define DTC_CODE_OUTPUT_ERROR           0x02U
  26      =2  
  27      =2  
  28      =2  #define DTC_MCU_WD_ERROR                        Record_DTC_Error(DTC_MCU_WT_ERR)
  29      =2  #define DTC_MCU_WD_CLEAR                        Record_DTC_Clear(DTC_MCU_WT_ERR)
  30      =2  #define DTC_MCU_MC_ERROR                        Record_DTC_Error(DTC_MCU_MC_ERR)
  31      =2  #define DTC_MCU_MC_CLEAR                        Record_DTC_Clear(DTC_MCU_MC_ERR)
  32      =2  #define DTC_ISP_FV_ERROR                        Record_DTC_Error(DTC_SENSOR_FV_ERR)
C51 COMPILER V9.51   MGR_ISP                                                               11/17/2023 14:48:45 PAGE 84  

  33      =2  #define DTC_ISP_FV_CLEAR                        Record_DTC_Clear(DTC_SENSOR_FV_ERR)
  34      =2  #define DTC_ISP_FC_ERROR                        Record_DTC_Error(DTC_SENSOR_FC_ERR)
  35      =2  #define DTC_ISP_FC_CLEAR                        Record_DTC_Clear(DTC_SENSOR_FC_ERR)
  36      =2  #define DTC_ISP_IS_ERROR                        Record_DTC_Error(DTC_SENSOR_ISPSTAT_ERR)
  37      =2  #define DTC_ISP_IS_CLEAR                        Record_DTC_Clear(DTC_SENSOR_ISPSTAT_ERR)
  38      =2  #define DTC_ISP_CM_ERROR                        Record_DTC_Error(DTC_SENSOR_COMM_ERR)
  39      =2  #define DTC_ISP_CM_CLEAR                        Record_DTC_Clear(DTC_SENSOR_COMM_ERR)
  40      =2  #define DTC_ISP_IT_ERROR                        Record_DTC_Error(DTC_SENOSR_INIT_ERR)
  41      =2  #define DTC_ISP_IT_CLEAR                        Record_DTC_Clear(DTC_SENOSR_INIT_ERR)
  42      =2  #define DTC_VID_OC_ERROR                        Record_DTC_Error(DTC_VIDEO_OUT_CUT_ERR)
  43      =2  #define DTC_VID_OC_CLEAR                        Record_DTC_Clear(DTC_VIDEO_OUT_CUT_ERR)
  44      =2  #define DTC_VID_VO_ERROR                        Record_DTC_Error(DTC_VIDEO_OVER_VOL_ERR)
  45      =2  #define DTC_VID_VO_CLEAR                        Record_DTC_Clear(DTC_VIDEO_OVER_VOL_ERR)
  46      =2          
  47      =2  
  48      =2  #define DTC_CURRENT_ERROR                       0x09U
  49      =2  #define DTC_CONFIRM_ERROR                       0x08U
  50      =2  #define DTC_CLEAR                                       0xFFU
  51      =2  
  52      =2  //SYSTEM INFO
  53      =2  #define SYS_HMC_SPEC                            0x02U
  54      =2  #define SYS_HMC_SPEC_L                          0x03U
  55      =2  
  56      =2  #define SYS_PART_NUMBER                         0x87U
  57      =2  #define SYS_PART_NUMBER_L                       0x00U
  58      =2  #define SYS_MANU_DATE                           0x8BU
  59      =2  #define SYS_MANU_DATE_L                         (U8)SYS_PART_NUMBER_L+0x0aU
  60      =2  #define SYS_HW_VERSION                          0x93U
  61      =2  #define SYS_HW_VERSION_L                        (U8)SYS_MANU_DATE_L + 0x08U
  62      =2  #define SYS_SW_VERSION                          0x95U
  63      =2  #define SYS_SW_VERSION_L                        (U8)SYS_HW_VERSION_L + 0x03U
  64      =2  #define SYS_CAN_VERSION                         0x00U
  65      =2  #define SYS_CAN_VERSION_L                       (U8)SYS_SW_VERSION_L + 0x03U
  66      =2  #define SYS_CODE_COUNT                          0x07U
  67      =2  #define SYS_CODE_SIZE                           0x25U
  68      =2  #define SYS_WRITE_CODE_SIZE                     0x27U
  69      =2  //ROUTINE CONTROL 
  70      =2  
  71      =2  #define RTN_CTRL_ERASE_MEMORY           0xFF00U
  72      =2  #define RTN_CTRL_CHECK_PRG_DEPEND       0xFF01U
  73      =2  #define RTN_CTRL_SENSOR_RESET           0xF1F0U
  74      =2  #define RTN_CTRL_GUIDE_ONOFF            0xF1F1U
  75      =2  #define RTN_CTRL_WARNING_ONOFF          0xF1F2U
  76      =2  
  77      =2  #define RTN_CTRL_DEFAULT                        0x00U
  78      =2  #define RTN_CTRL_FIMR_UPDATE            0x01U //only RTN_CTRL_ERASE_MEMORY
  79      =2  #define RTN_CTRL_BINARY_UPDATE          0x02U //only RTN_CTRL_ERASE_MEMORY 
  80      =2  
  81      =2  #define HMC_SPEC_OPTIC_X_HIGH_PID                        4U
  82      =2  #define HMC_SPEC_OPTIC_X_LOW_PID                         5U
  83      =2  #define HMC_SPEC_OPTIC_Y_HIGH_PID                        6U
  84      =2  #define HMC_SPEC_OPTIC_Y_LOW_PID                         7U
  85      =2  #define HMC_SPEC_COUNTRY_CFG_PID                         8U
  86      =2  #define HMC_SPEC_TEMPERATURE_PID                         9U
  87      =2  #define HMC_SPEC_SAS_ANGLE_HIGH_PID                     10U
  88      =2  #define HMC_SPEC_SAS_ANGLE_LOW_PID                      11U
  89      =2  #define HMC_SPEC_DTC_CURRENT_HIGH_PID           12U
  90      =2  #define HMC_SPEC_DTC_CURRENT_LOW_PID            13U
  91      =2  #define HMC_SPEC_DTC_CONFIRM_HIGH_PID           14U
  92      =2  #define HMC_SPEC_DTC_CONFIRM_LOW_PID            15U
  93      =2  #define HMC_SPEC_RELATIVE_OPTIC_X_PID           16U
  94      =2  #define HMC_SPEC_RELATIVE_OPTIC_Y_PID           17U
C51 COMPILER V9.51   MGR_ISP                                                               11/17/2023 14:48:45 PAGE 85  

  95      =2  #define HMC_SPEC_TOTAL_COUNT                            18U
  96      =2  
  97      =2  #define OPTIC_X_HIGH_PID_1                       0x80U
  98      =2  #define OPTIC_X_LOW_PID_2                        0x40U
  99      =2  #define OPTIC_Y_HIGH_PID_3                       0x20U
 100      =2  #define OPTIC_Y_LOW_PID_4                        0x10U
 101      =2  #define COUNTRY_CFG_PID_5                        0x08U
 102      =2  #define TEMPERATURE_PID_6                        0x04U
 103      =2  #define SAS_ANGLE_HIGH_PID_7             0x02U
 104      =2  #define SAS_ANGLE_LOW_PID_8                      0x01U
 105      =2  #define DTC_CURRENT_HIGH_PID_9           0x80U
 106      =2  #define DTC_CURRENT_LOW_PID_A            0x40U
 107      =2  #define DTC_CONFIRM_HIGH_PID_B           0x20U
 108      =2  #define DTC_CONFIRM_LOW_PID_C            0x10U
 109      =2  
 110      =2  #define USE_CASE_1BYTE                           0xFFU  
 111      =2  #define USE_CASE_2BYTE                           0xFCU
 112      =2  #define USE_CASE_3BYTE                           0x00U
 113      =2  #define USE_CASE_4BYTE                           0x00U
 114      =2  
 115      =2  #define SAS_CLEAR                                        0x00U
 116      =2  #define SAS_ON                                           0x01U
 117      =2  #define SAS_PRE_ON                                       0x02U
 118      =2  
 119      =2  #define OPTIC_SETTING                           0x00U
 120      =2  #define ERASE_ONESPEC                           0x01U
 121      =2  #define ERASE_FLASH_ALL                         0x02U
 122      =2  
 123      =2  #define CALIBRATION_MODE_START          0x00U
 124      =2  #define CALIBRATION_MODE_STOP           0x01U
 125      =2  #define CALIBRATION_MOVE_DEFAULT        0x02U
 126      =2  #define CALIBRATION_MOVE_LEFT           0x03U
 127      =2  #define CALIBRATION_MOVE_RIGHT          0x04U
 128      =2  #define CALIBRATION_MOVE_UP                     0x05U
 129      =2  #define CALIBRATION_MOVE_DOWN           0x06U
 130      =2  
 131      =2  //Calibration mode
 132      =2  #define DIAG_CALIBRATION_MODE_ACTIVE(flag)      ((CalibrationMode_OnOff) = (flag))
 133      =2  #define DIAG_CALIBRATION_MODE_STATE                     (CalibrationMode_OnOff)
 134      =2  
 135      =2  #define DIAG_OPTIC_OFFSET_SET_ACTIVE(flag)      ((OpticOffset_Set) = (flag))
 136      =2  #define DIAG_OPTIC_OFFSET_SET_STATE                     (OpticOffset_Set)
 137      =2  
 138      =2  #define OPTIC_X_LIMIT_PLUS                      0x18U
 139      =2  #define OPTIC_X_LIMIT_MINUS                     0xE8U
 140      =2  #define OPTIC_Y_LIMIT_PLUS                      0x20U
 141      =2  #define OPTIC_Y_LIMIT_MINUS                     0xE0U
 142      =2  
 143      =2  #define IGN_CLEAR                                        0x00U
 144      =2  #define IGN_ON                                           0x01U
 145      =2  #define IGN_PRE_ON                                       0x02U
 146      =2  /*----------------------------------------------------*/
 147      =2  
 148      =2  /* ----- Function ------------------------------------*/
 149      =2  void Reset_Diag(void);
 150      =2  void Init_DiagTask(void);
 151      =2  void Operate_DiagTask(void);
 152      =2  
 153      =2  void Diag_Ecu_Reset(void);
 154      =2  void Diag_Clear_DTC(void);
 155      =2  U8   Diag_Read_Dtc(U8 index);
 156      =2  void Diag_DTC_Error_WT(void);
C51 COMPILER V9.51   MGR_ISP                                                               11/17/2023 14:48:45 PAGE 86  

 157      =2  void Diag_Sensor_Reset(void);
 158      =2  void Diag_Guid_OnOff(U8 OnOff);
 159      =2  
 160      =2  
 161      =2  void Clear_DTC_Struct(void);
 162      =2  void Clear_DTC_Status(void);
 163      =2  void Record_DTC_Error(U8 ID);
 164      =2  void Record_DTC_Clear(U8 ID);
 165      =2  void Diag_Read_Sys(U8 ID, U8 *Buf,U8 Length);
 166      =2  void Diag_Write_Sys(U8 *Write_Buf,U8 Length);
 167      =2  
 168      =2  void Firmware_Update(void);
 169      =2  
 170      =2  void Diag_Write_Transfer_Data(U8 *Buf);
 171      =2  void TGT_Set_Addr (U8 *Write_Addr);
 172      =2  void    Diag_DTC_Set_On(void);
 173      =2  void    Diag_DTC_Set_Off(void);
 174      =2  void Flash_DTC_Write(void);
 175      =2  void Flash_DTC_Read(void);
 176      =2  void Diag_Exit_Update(void);
 177      =2  U16   Diag_Get_Time(void);
 178      =2  void SYS_Flash_Read(U8 ID,U8 *Read_Buf,U8 Length);
 179      =2  void Diag_Read_Address(U8 *Read_Buf, U32 DataAddr, U16 DataLen);
 180      =2  void Diag_Extra_Data_Process(U8 *Write_Buf);
 181      =2  void Diag_Eeprom_Update(void);
 182      =2  void Diag_Calibration_Mode_start(void);
 183      =2  void Diag_Calibration_Mode(U8 Ctrl_Para);
 184      =2  /*----------------------------------------------------*/
 185      =2  
 186      =2  /* ----- Extern Function -----------------------------*/
 187      =2  extern SEG_XDATA volatile tMsg_CAN_Rx_Data_s tCAN_Rx_Msg[USE_CAN_COUNT];
 188      =2  extern SEG_XDATA volatile U8 CalibrationMode_OnOff;
 189      =2  extern SEG_XDATA volatile U8 OpticOffset_Set;
 190      =2  /*----------------------------------------------------*/
 191      =2  
 192      =2  /* ----- Global Value --------------------------------*/
 193      =2  typedef struct {
 194      =2          U8 Status;
 195      =2          U8 Count;
 196      =2  } tMsg_DTC_Type;
 197      =2  
 198      =2  
 199      =2  typedef struct {
 200      =2          tMsg_DTC_Type tDTC_Type[DTC_CODE_COUNT];
 201      =2          U8 DTC_Clear_Count[3U];
 202      =2          U8 DTC_State[3U];
 203      =2          U8 Checksum;
 204      =2  } tMsg_Ext_DTC_Type;
 205      =2  typedef struct {
 206      =2          U8 update_set;
 207      =2          U8 write_count;
 208      =2          U8 erase_set;
 209      =2          U32 total_write_cnt;
 210      =2          U32 write_cnt;
 211      =2          U32 size;       
 212      =2  } tMsg_Update;
 213      =2  extern SEG_XDATA tMsg_Ext_DTC_Type ga_Ext_tDTC_Type_Msg;
 214      =2  #endif
 215      =2  /*----------------------------------------------------*/
 216      =2  
 217      =2  
 218      =2  
C51 COMPILER V9.51   MGR_ISP                                                               11/17/2023 14:48:45 PAGE 87  

 219      =2  
  21      =1  #include "mgr_comm.h"
   1      =2  #ifndef MGR_COMM_H
           =2 #define MGR_COMM_H
           =2 
           =2 #include "compiler_defs.h"
           =2 #include "C8051F580_defs.h"
           =2 
           =2 /* ----- Global Define -------------------------------*/
           =2 /*
           =2 #define TW8836          0x00U
           =2 #define DESERIALIZE     0x01U
           =2 #define SERIALIZE       0x02U
           =2 */
           =2 #define  TW8836_SLAVE_ADDRESS   (U8)0x8A
           =2 #define  TW8836_ID_ADRESS           (U8)0x00
           =2 #define  TW8836_ID                              (U16)0x0036
           =2 
           =2 #define  INIT                           0x00U           // (MR) data byte received
           =2 #define  RX                                     0x01U           // (MR) data byte received
           =2 #define  TX                                     0x02U           // (MR) data byte received
           =2 
           =2 #define USE_MDPS11                              0x00U
           =2 #define USE_LANGUAGEINFO                0x01U
           =2 #define USE_HUTYPE                              0x02U
           =2 #define USE_GATEWAY                             0x03U
           =2 #define USE_NAVIONOFF                   0x04U
           =2 #define USE_G_SEL_DISP                  0x05U
           =2 #define USE_IGN_SW                              0x06U
           =2 #define USE_RVM_CAMERAOFF               0x07U
           =2 #define FCZC_RVM_SW                             0x08U
           =2 #define USE_4WDERR                              0x09U
           =2 #define USE_ENGVOL                              0x0AU
           =2 #define USE_CAN_COUNT                   0x0BU           
           =2 
           =2 #define TYPE_2WD                                0x00U
           =2 #define TYPE_4WD                                0x01U
           =2 
           =2 #define TYPE_ENGVOL20                   0x14U
           =2 #define TYPE_ENGVOL22                   0x16U
           =2 #define TYPE_ENGVOL33                   0x21U
           =2 /*----------------------------------------------------*/
           =2 
           =2 /* ----- Function ------------------------------------*/
           =2 void Init_CommTask(void);
           =2 void Operate_CommTask(void);
           =2 void Rx_Data_Process(void);
           =2 //void Comm_I2C_Tx_Data(void);
           =2 void Comm_I2C_Tx(U8 Slave_Addr,U8 Length,U16 Addr, U16 TData,U16 RData );
           =2 U16   Comm_I2C_Rx(U8 Slave_Addr,U8 Length,U16 Addr, U16 TData,U16 RData );
           =2 void Clear_I2C_Tx_Data(void);
           =2 void Clear_CAN_Tx_Data(void);
           =2 void Clear_Can_Data(void);
           =2 void Clear_Sas_Data(void);
           =2 
           =2 void Comm_RearView_Data(void);
           =2 void Comm_Tuning_Value_Type(U8 Type4WdErr, U8 TypeEngVol);
           =2 U8 Comm_Sas_Data(U8 *pa_Data);
           =2 U8 Comm_Hutype_Data(U8 *pa_Data);
           =2 U8 Comm_Language_Data(U8 *pa_Data);
           =2 U8 Comm_G_Sel_Disp_Data(U8 *Data);
           =2 U8 Comm_IGN_Sw_Data(U8 *Data);
C51 COMPILER V9.51   MGR_ISP                                                               11/17/2023 14:48:45 PAGE 88  

           =2 U8 Comm_RVM_CameraOff_Data(U8 *Data);
           =2 U8 Comm_RVM_SW_Data(U8 *Data);
           =2 U8 Comm_ENG_Vol_Data(U8 *pa_Data);
           =2 U8 Comm_4WD_Err_Data(U8 *pa_Data);
           =2 void Comm_Tx_RVM_View(U8 sigData);
           =2 void Comm_Tx_RVM_SW_IND(U8 sigData);
           =2 
           =2 void Flash_OneSpec_Write(void);
           =2 void Flash_OneSpec_Read(void);
           =2 void Comm_Error_Check(void);
           =2 /*----------------------------------------------------*/
           =2 
           =2 /* ----- Extern Function -----------------------------*/
           =2 /*----------------------------------------------------*/
           =2 
           =2 /* ----- Global Value --------------------------------*/
           =2 
           =2 typedef struct {
           =2         U8  Slave;
           =2         U8  Length;
           =2         U8  TRX_Flag;
           =2         U16 Addr;
           =2         U16 TxData;
           =2         U16 RxData;
           =2 }tMsg_I2C_Tx_Data_s;
           =2 
           =2 typedef struct {
           =2         U8  Slave;
           =2         U8  Length;
           =2         U8  TRX_Flag;
           =2         U16 Addr;
           =2         U16 TxData;
           =2         U16 RxData;
           =2 }tMsg_CAN_Tx_Data_s;
           =2 
           =2 typedef struct {
           =2         U8 Is_Change;
           =2         U8 Change_Count;
           =2         U8 Time_Out;
           =2         U8 Cur_Data;
           =2         U8 Mid_Data;
           =2         U8 Pre_Data;
           =2         U16 Chatter_Time;
           =2 }tMsg_CAN_Rx_Data_s;
           =2 
           =2 typedef struct {
           =2         U8  Is_Change;
           =2         U8  Pre_Sign;
           =2         U8  Angle;
           =2         U8  Angle_Pre_Sign;
           =2         U8  Time_Out;
           =2         U16 Pre_Data;
           =2         U8      Tuning_Type;
           =2 }tMsg_CAN_SAS_Data_s;
           =2 
           =2 typedef struct {
           =2         U8  Is_Change;
           =2         U8  Pre_Sign;
           =2         U8  Angle;
           =2         U16 Pre_Data;
           =2 }tMsg_CAN_State_s;
           =2 
C51 COMPILER V9.51   MGR_ISP                                                               11/17/2023 14:48:45 PAGE 89  

           =2 
           =2 /*
           =2 struct tCAN_Tx_Data_s {
           =2         U8 Flag;
           =2         U8 Dest;
           =2         U8 Length;
           =2         U8 *TxData;
           =2 }
           =2 
           =2 struct tCAN_Rx_Data_s {
           =2         U8 Flag;
           =2         U8 Src;
           =2         U8 Length;
           =2         U8 RxData;
           =2 }
           =2 */
           =2 /*----------------------------------------------------*/
           =2 
           =2 extern SEG_XDATA volatile tMsg_CAN_SAS_Data_s tCAN_Rx_SAS_Msg;
           =2 #endif
 143      =2  
  22      =1  //-----------------------------------------------------------------------------
  23      =1  // Open Header #define
  24      =1  //-----------------------------------------------------------------------------
  25      =1  
  26      =1  
  27      =1  
  28      =1  //-----------------------------------------------------------------------------
  29      =1  // Structures, Unions, Enumerations, and Type Definitions
  30      =1  //-----------------------------------------------------------------------------
  31      =1  //BANK1
  32      =1  //#define DTCCODE_ADDRESS                               0xFC00U //0xF800U
  33      =1  //#define ONESPEC_ADDRESS                               0xFD00U //0xFA00U
  34      =1  //#define SYSINFO_ADDRESS                               0xFE00U //0xFC00U
  35      =1  //#define OPTIC_ADDRESS                                 0xFF00U //0xFE00U
  36      =1  //BANK2
  37      =1  #define DTCCODE_ADDRESS                                 0xF800U
  38      =1  #define ONESPEC_ADDRESS                                 0xFA00U
  39      =1  #define SYSINFO_ADDRESS                                 0xFC00U
  40      =1  #define OPTIC_ADDRESS                                   0xFE00U
  41      =1  
  42      =1  #define PAGE_SIZE                                               0x100
  43      =1  
  44      =1  typedef U16 FLADDR;
  45      =1  
  46      =1  //-----------------------------------------------------------------------------
  47      =1  // Global Constants
  48      =1  //-----------------------------------------------------------------------------
  49      =1  
  50      =1  #ifndef FLASH_PAGESIZE
  51      =1  #define FLASH_PAGESIZE (512)
  52      =1  #endif
  53      =1  
  54      =1  #ifndef FLASH_TEMP
  55      =1  #define FLASH_TEMP 0x7800L             // For 32K Flash devices
  56      =1  //#define FLASH_TEMP 0x3C00L           // For 16K Flash devices
  57      =1  #endif
  58      =1  
  59      =1  #ifndef FLASH_LAST
  60      =1  #define FLASH_LAST 0x7A00L             // For 32K Flash devices
  61      =1  //#define FLASH_LAST 0x3E00L           // For 16K Flash devices
  62      =1  #endif
C51 COMPILER V9.51   MGR_ISP                                                               11/17/2023 14:48:45 PAGE 90  

  63      =1  
  64      =1  //-----------------------------------------------------------------------------
  65      =1  // Exported Function Prototypes
  66      =1  //-----------------------------------------------------------------------------
  67      =1  
  68      =1  // FLASH read/write/erase routines
  69      =1  extern volatile U8 FLKEY1;
  70      =1  extern volatile U8 FLKEY2;
  71      =1  
  72      =1  #define FLASH_ByteWriteWithKey(addr, byte, bank) FLASH_ByteWrite(addr, byte, bank, FLKEY1, FLKEY2);
  73      =1  #define FLASH_PageEraseWithKey(addr, bank) FLASH_PageErase(addr, bank, FLKEY1, FLKEY2);
  74      =1  // FLASH update/copy routines
  75      =1  void FLASH_Update (FLADDR dest, U8 *src, U16 numbytes);
  76      =1  void FLASH_Copy (FLADDR dest, FLADDR src, U16 numbytes);
  77      =1  
  78      =1  // FLASH test routines
  79      =1  void F560_FLASH_Fill (FLADDR addr, U16 length, U8 fill);
  80      =1  //-----------------------------------------------------------------------------
  81      =1  // Close Header #define
  82      =1  //-----------------------------------------------------------------------------
  83      =1  void Mem_Flash_DTC_Read(tMsg_DTC_Type *dtc_type);
  84      =1  
  85      =1  U8 FLASH_ByteWrite (FLADDR addr, U8 byte, U8 bank, U8 flkey1, U8 flkey2);
  86      =1  U8  FLASH_ByteRead  (FLADDR addr, U8 bank);
  87      =1  U8 FLASH_PageErase (FLADDR addr,U8 bank, U8 flkey1, U8 flkey2);
  88      =1  void FLASH_Write_Buf (FLADDR dest, U8 *src, U16 numbytes,U8 bank);
  89      =1  void FLASH_Read_Buf (U8 *dest, FLADDR src, U16 numbytes,U8 bank);
  90      =1  void FLASH_Erase_Buf (FLADDR dest,U8 bank);
  91      =1  
  92      =1  #endif    // _F560_FLASHPRIMITIVES_H_
  93      =1  
  94      =1  //-----------------------------------------------------------------------------
  95      =1  // End Of File
  96      =1  //-----------------------------------------------------------------------------
   9          #include "drv_pca.h"
   1      =1  #ifndef DRV_PCA_H
   2      =1  #define DRV_PCA_H
   3      =1  #include "compiler_defs.h"
   1      =2  //-----------------------------------------------------------------------------
   2      =2  // compiler_defs.h
   3      =2  //-----------------------------------------------------------------------------
   4      =2  // Portions of this file are copyright Maarten Brock
   5      =2  // http://sdcc.sourceforge.net
   6      =2  // Portions of this file are copyright 2010, Silicon Laboratories, Inc.
   7      =2  // http://www.silabs.com
   8      =2  //
   9      =2  // GNU LGPL boilerplate:
  10      =2  /** This library is free software; you can redistribute it and/or
  11      =2    * modify it under the terms of the GNU Lesser General Public
  12      =2    * License as published by the Free Software Foundation; either
  13      =2    * version 2.1 of the License, or (at your option) any later version.
  14      =2    *
  15      =2    * This library is distributed in the hope that it will be useful,
  16      =2    * but WITHOUT ANY WARRANTY; without even the implied warranty of
  17      =2    * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
  18      =2    * Lesser General Public License for more details.
  19      =2    *
  20      =2    * You should have received a copy of the GNU Lesser General Public
  21      =2    * License along with this library; if not, write to the Free Software
  22      =2    * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
  23      =2    *
  24      =2    * In other words, you are welcome to use, share and improve this program.
C51 COMPILER V9.51   MGR_ISP                                                               11/17/2023 14:48:45 PAGE 91  

  25      =2    * You are forbidden to forbid anyone else to use, share and improve
  26      =2    * what you give them. Help stamp out software-hoarding!
  27      =2  **/
  28      =2  // Program Description:
  29      =2  //
  30      =2  // **Important Note**: This header file should be included before including
  31      =2  // a device-specific header file such as C8051F300_defs.h.
  32      =2  //
  33      =2  // Macro definitions to accomodate 8051 compiler differences in specifying
  34      =2  // special function registers and other 8051-specific features such as NOP
  35      =2  // generation, and locating variables in memory-specific segments.  The
  36      =2  // compilers are identified by their unique predefined macros. See also:
  37      =2  // http://predef.sourceforge.net/precomp.html
  38      =2  //
  39      =2  // SBIT and SFR define special bit and special function registers at the given
  40      =2  // address. SFR16 and SFR32 define sfr combinations at adjacent addresses in
  41      =2  // little-endian format. SFR16E and SFR32E define sfr combinations without
  42      =2  // prerequisite byte order or adjacency. None of these multi-byte sfr
  43      =2  // combinations will guarantee the order in which they are accessed when read
  44      =2  // or written.
  45      =2  //
  46      =2  // SFR16X and SFR32X for 16 bit and 32 bit xdata registers are not defined
  47      =2  // to avoid portability issues because of compiler endianness.
  48      =2  //
  49      =2  // Example:
  50      =2  // // my_mcu.c: main 'c' file for my mcu
  51      =2  // #include <compiler_defs.h>  // this file
  52      =2  // #include <C8051xxxx_defs.h> // SFR definitions for specific MCU target
  53      =2  //
  54      =2  // SBIT  (P0_1, 0x80, 1);      // Port 0 pin 1
  55      =2  // SFR   (P0, 0x80);           // Port 0
  56      =2  // SFRX  (CPUCS, 0xE600);      // Cypress FX2 Control and Status register in
  57      =2  //                             // xdata memory at 0xE600
  58      =2  // SFR16 (TMR2, 0xCC);         // Timer 2, lsb at 0xCC, msb at 0xCD
  59      =2  // SFR16E(TMR0, 0x8C8A);       // Timer 0, lsb at 0x8A, msb at 0x8C
  60      =2  // SFR32 (MAC0ACC, 0x93);      // SiLabs C8051F120 32 bits MAC0 Accumulator,
  61      =2  //                             // lsb at 0x93, msb at 0x96
  62      =2  // SFR32E(SUMR, 0xE5E4E3E2);   // TI MSC1210 SUMR 32 bits Summation register,
  63      =2  //                             // lsb at 0xE2, msb at 0xE5
  64      =2  //
  65      =2  // Target:         C8051xxxx
  66      =2  // Tool chain:     Generic
  67      =2  // Command Line:   None
  68      =2  // 
  69      =2  // Release 2.6 - 14 DEC 2012 (GO)
  70      =2  //        -Added define for deprecated SDCC keyword 'at'
  71      =2  // Release 2.5 - 12 SEP 2012 (TP)
  72      =2  //    -Added defines for deprecated SDCC keywords bit and code
  73      =2  // Release 2.4 - 27 AUG 2012 (TP)
  74      =2  //    -Added defines for deprecated SDCC keywords interrupt, _asm, and _endasm
  75      =2  // Release 2.3 - 27 MAY 2010 (DM)
  76      =2  //    -Removed 'LOCATED_VARIABLE' pragma from Keil because it is not supported
  77      =2  // Release 2.2 - 06 APR 2010 (ES)
  78      =2  //    -Removed 'PATHINCLUDE' pragma from Raisonance section
  79      =2  // Release 2.1 - 16 JUL 2009 (ES)
  80      =2  //    -Added SEGMENT_POINTER macro definitions for SDCC, Keil, and Raisonance
  81      =2  //    -Added LOCATED_VARIABLE_NO_INIT macro definitions for Raisonance
  82      =2  // Release 2.0 - 19 MAY 2009 (ES)
  83      =2  //    -Added LOCATED_VARIABLE_NO_INIT macro definitions for SDCC and Keil
  84      =2  // Release 1.9 - 23 OCT 2008 (ES)
  85      =2  //    -Updated Hi-Tech INTERRUPT and INTERRUPT_USING macro definitions
  86      =2  //    -Added SFR16 macro defintion for Hi-Tech
C51 COMPILER V9.51   MGR_ISP                                                               11/17/2023 14:48:45 PAGE 92  

  87      =2  // Release 1.8 - 31 JUL 2008 (ES)
  88      =2  //    -Added INTERRUPT_USING and FUNCTION_USING macro's
  89      =2  //    -Added macro's for IAR
  90      =2  //    -Corrected Union definitions for Hi-Tech and added SFR16 macro defintion
  91      =2  // Release 1.7 - 11 SEP 2007 (BW)
  92      =2  //    -Added support for Raisonance EVAL 03.03.42 and Tasking Eval 7.2r1
  93      =2  // Release 1.6 - 27 AUG 2007 (BW)
  94      =2  //    -Updated copyright notice per agreement with Maartin Brock
  95      =2  //    -Added SDCC 2.7.0 "compiler.h" bug fixes
  96      =2  //    -Added memory segment defines (SEG_XDATA, for example)
  97      =2  // Release 1.5 - 24 AUG 2007 (BW)
  98      =2  //    -Added support for NOP () macro
  99      =2  //    -Added support for Hi-Tech ver 9.01
 100      =2  // Release 1.4 - 07 AUG 2007 (PKC)
 101      =2  //    -Removed FID and fixed formatting.
 102      =2  // Release 1.3 - 30 SEP 2007 (TP)
 103      =2  //    -Added INTERRUPT_PROTO_USING to properly support ISR context switching
 104      =2  //     under SDCC.
 105      =2  // Release 1.2 - (BW)
 106      =2  //    -Added support for U8,U16,U32,S8,S16,S32,UU16,UU32 data types
 107      =2  // Release 1.1 - (BW)
 108      =2  //    -Added support for INTERRUPT, INTERRUPT_USING, INTERRUPT_PROTO,
 109      =2  //     SEGMENT_VARIABLE, VARIABLE_SEGMENT_POINTER,
 110      =2  //     SEGMENT_VARIABLE_SEGMENT_POINTER, and LOCATED_VARIABLE
 111      =2  // Release 1.0 - 29 SEP 2006 (PKC)
 112      =2  //    -Initial revision
 113      =2  
 114      =2  //-----------------------------------------------------------------------------
 115      =2  // Header File Preprocessor Directive
 116      =2  //-----------------------------------------------------------------------------
 117      =2  
 118      =2  #ifndef COMPILER_DEFS_H
           =2 #define COMPILER_DEFS_H
           =2 
           =2 //-----------------------------------------------------------------------------
           =2 // Macro definitions
           =2 //-----------------------------------------------------------------------------
           =2 
           =2 // SDCC - Small Device C Compiler
           =2 // http://sdcc.sourceforge.net
           =2 
           =2 #if defined SDCC
           =2 
           =2 #if (SDCC >= 300)
           =2 
           =2 #define interrupt __interrupt
           =2 #define _asm __asm
           =2 #define _endasm __endasm
           =2 #define bit __bit
           =2 #define code __code
           =2 #define at __at
           =2 
           =2 #endif
           =2 
           =2 # define SEG_GENERIC
           =2 # define SEG_FAR   __xdata
           =2 # define SEG_DATA  __data
           =2 # define SEG_NEAR  __data
           =2 # define SEG_IDATA __idata
           =2 # define SEG_XDATA __xdata
           =2 # define SEG_PDATA __pdata
           =2 # define SEG_CODE  __code
C51 COMPILER V9.51   MGR_ISP                                                               11/17/2023 14:48:45 PAGE 93  

           =2 # define SEG_BDATA __bdata
           =2 
           =2 # define SBIT(name, addr, bit)  __sbit  __at(addr+bit)                  name
           =2 # define SFR(name, addr)        __sfr   __at(addr)                      name
           =2 # define SFRX(name, addr)       xdata volatile unsigned char __at(addr) name
           =2 # define SFR16(name, addr)      __sfr16 __at(((addr+1U)<<8) | addr)     name
           =2 # define SFR16E(name, fulladdr) __sfr16 __at(fulladdr)                  name
           =2 # define SFR32(name, addr)      __sfr32 __at(((addr+3UL)<<24) | ((addr+2UL)<<16) | ((addr+1UL)<<8) | addr)
             - name
           =2 # define SFR32E(name, fulladdr) __sfr32 __at(fulladdr)                  name
           =2 
           =2 # define INTERRUPT(name, vector) void name (void) interrupt (vector)
           =2 # define INTERRUPT_USING(name, vector, regnum) void name (void) interrupt (vector) using (regnum)
           =2 # define INTERRUPT_PROTO(name, vector) void name (void) interrupt (vector)
           =2 # define INTERRUPT_PROTO_USING(name, vector, regnum) void name (void) interrupt (vector) using (regnum)
           =2 
           =2 # define FUNCTION_USING(name, return_value, parameter, regnum) return_value name (parameter) using (regnum
             -)
           =2 # define FUNCTION_PROTO_USING(name, return_value, parameter, regnum) return_value name (parameter) using (
             -regnum)
           =2 // Note: Parameter must be either 'void' or include a variable type and name. (Ex: char temp_variable)
           =2 
           =2 # define SEGMENT_VARIABLE(name, vartype, locsegment) locsegment vartype name
           =2 # define VARIABLE_SEGMENT_POINTER(name, vartype, targsegment) targsegment vartype * name
           =2 # define SEGMENT_VARIABLE_SEGMENT_POINTER(name, vartype, targsegment, locsegment) targsegment vartype * lo
             -csegment name
           =2 # define SEGMENT_POINTER(name, vartype, locsegment) vartype * locsegment name
           =2 # define LOCATED_VARIABLE(name, vartype, locsegment, addr, init) locsegment at (addr) vartype name = init
           =2 # define LOCATED_VARIABLE_NO_INIT(name, vartype, locsegment, addr) locsegment at (addr) vartype name
           =2 
           =2 // used with UU16
           =2 # define LSB 0
           =2 # define MSB 1
           =2 
           =2 // used with UU32 (b0 is least-significant byte)
           =2 //# define b0 0
           =2 //# define b1 1
           =2 //# define b2 2
           =2 //# define b3 3
           =2 
           =2 typedef unsigned char U8;
           =2 typedef unsigned int U16;
           =2 typedef unsigned long U32;
           =2 
           =2 typedef signed char S8;
           =2 typedef signed int S16;
           =2 typedef signed long S32;
           =2 
           =2 typedef union UU16
           =2 {
           =2    U16 U16;
           =2    S16 S16;
           =2    U8 U8[2];
           =2    S8 S8[2];
           =2 } UU16;
           =2 
           =2 typedef union UU32
           =2 {
           =2    U32 U32;
           =2    S32 S32;
           =2    UU16 UU16[2];
           =2    U16 U16[2];
C51 COMPILER V9.51   MGR_ISP                                                               11/17/2023 14:48:45 PAGE 94  

           =2    S16 S16[2];
           =2    U8 U8[4];
           =2    S8 S8[4];
           =2 } UU32;
           =2 
           =2 // NOP () macro support
           =2 #define NOP() _asm NOP _endasm
           =2 
           =2 
           =2 //-----------------------------------------------------------------------------
           =2 
           =2 // Raisonance (must be placed before Keil C51)
           =2 // http://www.raisonance.com
           =2 
           =2 #elif defined __RC51__
           =2 
           =2 //#error Raisonance C51 detected.
           =2 
           =2 # define SEG_GENERIC generic     //SEG_GENERIC only applies to pointers in Raisonance, not variables.
           =2 # define SEG_FAR   xdata
           =2 # define SEG_DATA  data
           =2 # define SEG_NEAR  data
           =2 # define SEG_IDATA idata
           =2 # define SEG_XDATA xdata
           =2 # define SEG_PDATA pdata
           =2 # define SEG_CODE  code
           =2 # define SEG_BDATA bdata
           =2 
           =2 # define SBIT(name, addr, bit)  at (addr+bit) sbit         name
           =2 # define SFR(name, addr)        sfr at addr                name
           =2 # define SFR16(name, addr)      sfr16 at addr              name
           =2 # define SFR16E(name, fulladdr) /* not supported */
           =2 # define SFR32(name, fulladdr)  /* not supported */
           =2 # define SFR32E(name, fulladdr) /* not supported */
           =2 
           =2 # define INTERRUPT(name, vector) void name (void) interrupt vector
           =2 # define INTERRUPT_USING(name, vector, regnum) void name (void) interrupt vector using regnum
           =2 # define INTERRUPT_PROTO(name, vector) void name (void)
           =2 # define INTERRUPT_PROTO_USING(name, vector, regnum) void name (void)
           =2 
           =2 # define FUNCTION_USING(name, return_value, parameter, regnum) return_value name (parameter) using regnum
           =2 # define FUNCTION_PROTO_USING(name, return_value, parameter, regnum) return_value name (parameter)
           =2 // Note: Parameter must be either 'void' or include a variable type and name. (Ex: char temp_variable)
           =2 
           =2 # define SEGMENT_VARIABLE(name, vartype, locsegment) vartype locsegment name
           =2 # define VARIABLE_SEGMENT_POINTER(name, vartype, targsegment) vartype targsegment * name
           =2 # define SEGMENT_VARIABLE_SEGMENT_POINTER(name, vartype, targsegment, locsegment) vartype targsegment * lo
             -csegment name
           =2 # define SEGMENT_POINTER(name, vartype, locsegment) vartype * locsegment name
           =2 # define LOCATED_VARIABLE(name, vartype, locsegment, addr, init) at addr locsegment vartype name
           =2 # define LOCATED_VARIABLE_NO_INIT(name, vartype, locsegment, addr) at addr locsegment vartype name
           =2 
           =2 
           =2 // used with UU16
           =2 # define LSB 1
           =2 # define MSB 0
           =2 
           =2 // used with UU32 (b0 is least-significant byte)
           =2 //# define b0 3
           =2 //# define b1 2
           =2 //# define b2 1
           =2 //# define b3 0
C51 COMPILER V9.51   MGR_ISP                                                               11/17/2023 14:48:45 PAGE 95  

           =2 
           =2 typedef unsigned char U8;
           =2 typedef unsigned int U16;
           =2 typedef unsigned long U32;
           =2 
           =2 typedef signed char S8;
           =2 typedef signed int S16;
           =2 typedef signed long S32;
           =2 
           =2 typedef union UU16
           =2 {
           =2    U16 U16;
           =2    S16 S16;
           =2    U8 U8[2];
           =2    S8 S8[2];
           =2 } UU16;
           =2 
           =2 typedef union UU32
           =2 {
           =2    U32 U32;
           =2    S32 S32;
           =2    UU16 UU16[2];
           =2    U16 U16[2];
           =2    S16 S16[2];
           =2    U8 U8[4];
           =2    S8 S8[4];
           =2 } UU32;
           =2 
           =2 // NOP () macro support -- NOP is opcode 0x00
           =2 #define NOP() asm { 0x00 }
           =2 
           =2 
           =2 //-----------------------------------------------------------------------------
           =2 
           =2 
           =2 // Keil C51
           =2 // http://www.keil.com
           =2 
           =2 #elif defined __C51__
           =2 
           =2 //#error Keil C51 detected.
           =2 
           =2 # define SEG_GENERIC
           =2 # define SEG_FAR   xdata
           =2 # define SEG_DATA  data
           =2 # define SEG_NEAR  data
           =2 # define SEG_IDATA idata
           =2 # define SEG_XDATA xdata
           =2 # define SEG_PDATA pdata
           =2 # define SEG_CODE  code
           =2 # define SEG_BDATA bdata
           =2 
           =2 # define SBIT(name, addr, bit)  sbit  name = addr^bit
           =2 # define SFR(name, addr)        sfr   name = addr
           =2 # define SFR16(name, addr)      sfr16 name = addr
           =2 # define SFR16E(name, fulladdr) /* not supported */
           =2 # define SFR32(name, fulladdr)  /* not supported */
           =2 # define SFR32E(name, fulladdr) /* not supported */
           =2 
           =2 # define INTERRUPT(name, vector) void name (void) interrupt vector
           =2 # define INTERRUPT_USING(name, vector, regnum) void name (void) interrupt vector using regnum
           =2 # define INTERRUPT_PROTO(name, vector) void name (void)
C51 COMPILER V9.51   MGR_ISP                                                               11/17/2023 14:48:45 PAGE 96  

           =2 # define INTERRUPT_PROTO_USING(name, vector, regnum) void name (void)
           =2 
           =2 # define FUNCTION_USING(name, return_value, parameter, regnum) return_value name (parameter) using regnum
           =2 # define FUNCTION_PROTO_USING(name, return_value, parameter, regnum) return_value name (parameter)
           =2 // Note: Parameter must be either 'void' or include a variable type and name. (Ex: char temp_variable)
           =2 
           =2 # define SEGMENT_VARIABLE(name, vartype, locsegment) vartype locsegment name
           =2 # define VARIABLE_SEGMENT_POINTER(name, vartype, targsegment) vartype targsegment * name
           =2 # define SEGMENT_VARIABLE_SEGMENT_POINTER(name, vartype, targsegment, locsegment) vartype targsegment * lo
             -csegment name
           =2 # define SEGMENT_POINTER(name, vartype, locsegment) vartype * locsegment name
           =2 # define LOCATED_VARIABLE_NO_INIT(name, vartype, locsegment, addr) vartype locsegment name _at_ addr
           =2 
           =2 // used with UU16
           =2 # define LSB 1
           =2 # define MSB 0
           =2 
           =2 // used with UU32 (b0 is least-significant byte)
           =2 //# define b0 3
           =2 // define b1 2
           =2 //# define b2 1
           =2 //# define b3 0
           =2 
           =2 typedef unsigned char U8;
           =2 typedef unsigned int U16;
           =2 typedef unsigned long U32;
           =2 
           =2 typedef signed char S8;
           =2 typedef signed int S16;
           =2 typedef signed long S32;
           =2 
           =2 typedef union UU16
           =2 {
           =2    U16 U16;
           =2    S16 S16;
           =2    U8 U8[2];
           =2    S8 S8[2];
           =2 } UU16;
           =2 
           =2 typedef union UU32
           =2 {
           =2    U32 U32;
           =2    S32 S32;
           =2    UU16 UU16[2];
           =2    U16 U16[2];
           =2    S16 S16[2];
           =2    U8 U8[4];
           =2    S8 S8[4];
           =2 } UU32;
           =2 
           =2 // NOP () macro support
           =2 extern void _nop_ (void);
           =2 #define NOP() _nop_()
           =2 
           =2 //-----------------------------------------------------------------------------
           =2 
           =2 // Hi-Tech 8051
           =2 // http://www.htsoft.com
           =2 
           =2 #elif defined HI_TECH_C
           =2 
           =2 # define SEG_GENERIC
C51 COMPILER V9.51   MGR_ISP                                                               11/17/2023 14:48:45 PAGE 97  

           =2 # define SEG_FAR   far
           =2 # define SEG_DATA  data
           =2 # define SEG_NEAR  near
           =2 # define SEG_IDATA idata
           =2 # define SEG_XDATA xdata
           =2 # define SEG_PDATA pdata
           =2 # define SEG_CODE  code
           =2 # define SEG_BDATA bdata
           =2 
           =2 
           =2 # define SBIT(name, addr, thebit) static volatile bit name @ (addr + thebit)
           =2 # define SFR(name, addr)          static volatile unsigned char name @ addr
           =2 # define SFR16(name, addr)        static volatile unsigned int name @ addr
           =2 # define SFR16E(name, fulladdr) /* not supported */
           =2 # define SFR32(name, fulladdr)  /* not supported */
           =2 # define SFR32E(name, fulladdr) /* not supported */
           =2 
           =2 # define INTERRUPT(name, vector)       void name (void) interrupt vector
           =2 # define INTERRUPT_PROTO(name, vector)
           =2 # define INTERRUPT_USING(name, vector, regnum) void name (void) interrupt vector using regnum
           =2 # define INTERRUPT_PROTO_USING(name, vector, regnum)
           =2 
           =2 # define FUNCTION_USING(name, return_value, parameter, regnum) /* not supported */
           =2 # define FUNCTION_PROTO_USING(name, return_value, parameter, regnum) /* not supported */
           =2 // Note: Hi-Tech does not support functions using different register banks. Register
           =2 //       banks can only be specified in interrupts. If a function is called from
           =2 //       inside an interrupt, it will use the same register bank as the interrupt.
           =2 
           =2 # define SEGMENT_VARIABLE(name, vartype, locsegment) locsegment vartype name
           =2 # define VARIABLE_SEGMENT_POINTER(name, vartype, targsegment) targsegment vartype * name
           =2 # define SEGMENT_VARIABLE_SEGMENT_POINTER(name, vartype, targsegment, locsegment) targsegment vartype * lo
             -csegment name
           =2 # define LOCATED_VARIABLE(name, vartype, locsegment, addr, init) locsegment vartype name @ addr
           =2 
           =2 // used with UU16
           =2 # define LSB 0
           =2 # define MSB 1
           =2 
           =2 // used with UU32 (b0 is least-significant byte)
           =2 # define b0 0
           =2 # define b1 1
           =2 # define b2 2
           =2 # define b3 3
           =2 
           =2 typedef unsigned char U8;
           =2 typedef unsigned int U16;
           =2 typedef unsigned long U32;
           =2 
           =2 typedef signed char S8;
           =2 typedef signed int S16;
           =2 typedef signed long S32;
           =2 
           =2 typedef union UU16
           =2 {
           =2    U16 U16;
           =2    S16 S16;
           =2    U8 U8[2];
           =2    S8 S8[2];
           =2 } UU16;
           =2 
           =2 typedef union UU32
           =2 {
C51 COMPILER V9.51   MGR_ISP                                                               11/17/2023 14:48:45 PAGE 98  

           =2    U32 U32;
           =2    S32 S32;
           =2    UU16 UU16[2];
           =2    U16 U16[2];
           =2    S16 S16[2];
           =2    U8 U8[4];
           =2    S8 S8[4];
           =2 } UU32;
           =2 
           =2 // NOP () macro support
           =2 #define NOP() asm(" nop ")
           =2 
           =2 //-----------------------------------------------------------------------------
           =2 
           =2 // Tasking / Altium
           =2 // http://www.altium.com/tasking
           =2 
           =2 
           =2 #elif defined _CC51
           =2 
           =2 # define SEG_GENERIC
           =2 # define SEG_FAR   _xdat
           =2 # define SEG_DATA  _data
           =2 # define SEG_NEAR  _data
           =2 # define SEG_IDATA _idat
           =2 # define SEG_XDATA _xdat
           =2 # define SEG_PDATA _pdat
           =2 # define SEG_CODE  _rom
           =2 # define SEG_BDATA _bdat
           =2 
           =2 # define SBIT(name, addr, bit)  _sfrbit  name _at(addr+bit)
           =2 # define SFR(name, addr)        _sfrbyte name _at(addr)
           =2 # define SFRX(name, addr)       _xdat volatile unsigned char name _at(addr)
           =2 #if _CC51 > 71
           =2 # define SFR16(name, addr)      _sfrword _little name _at(addr)
           =2 #else
           =2 # define SFR16(name, addr)      /* not supported */
           =2 #endif
           =2 # define SFR16E(name, fulladdr) /* not supported */
           =2 # define SFR32(name, fulladdr)  /* not supported */
           =2 # define SFR32E(name, fulladdr) /* not supported */
           =2 
           =2 # define INTERRUPT(name, vector) _interrupt (vector) void name (void)
           =2 # define INTERRUPT_USING(name, vector, regnum) _interrupt (vector) _using(regnum) void name (void)
           =2 # define INTERRUPT_PROTO(name, vector) _interrupt (vector) void name (void)
           =2 # define INTERRUPT_PROTO_USING(name, vector, regnum) _interrupt (vector) _using(regnum) void name (void)
           =2 
           =2 // When calling FUNCTION_USING in Tasking, the function must be called from an interrupt or Main which
           =2 // is also using the same register bank. If not, the compiler will generate an error.
           =2 # define FUNCTION_USING(name, return_value, parameter, regnum) _using(regnum) return_value name (parameter
             -)
           =2 # define FUNCTION_PROTO_USING(name, return_value, parameter, regnum) _using(regnum) return_value name (par
             -ameter)
           =2 // Note: Parameter must be either 'void' or include a variable type and name. (Ex: char temp_variable)
           =2 
           =2 # define SEGMENT_VARIABLE(name, vartype, locsegment) vartype locsegment name
           =2 # define VARIABLE_SEGMENT_POINTER(name, vartype, targsegment) vartype targsegment * name
           =2 # define SEGMENT_VARIABLE_SEGMENT_POINTER(name, vartype, targsegment, locsegment) vartype targsegment * lo
             -csegment name
           =2 # define LOCATED_VARIABLE(name, vartype, locsegment, addr, init) vartype locsegment name _at( addr )
           =2 
           =2 // used with UU16
C51 COMPILER V9.51   MGR_ISP                                                               11/17/2023 14:48:45 PAGE 99  

           =2 # define LSB 1
           =2 # define MSB 0
           =2 
           =2 // used with UU32 (b0 is least-significant byte)
           =2 //# define b0 3
           =2 //# define b1 2
           =2 //# define b2 1
           =2 //# define b3 0
           =2 
           =2 typedef unsigned char U8;
           =2 typedef unsigned int U16;
           =2 typedef unsigned long U32;
           =2 
           =2 typedef signed char S8;
           =2 typedef signed int S16;
           =2 typedef signed long S32;
           =2 
           =2 typedef union UU16
           =2 {
           =2    U16 U16;
           =2    S16 S16;
           =2    U8 U8[2];
           =2    S8 S8[2];
           =2 } UU16;
           =2 
           =2 typedef union UU32
           =2 {
           =2    U32 U32;
           =2    S32 S32;
           =2    UU16 UU16[2];
           =2    U16 U16[2];
           =2    S16 S16[2];
           =2    U8 U8[4];
           =2    S8 S8[4];
           =2 } UU32;
           =2 
           =2 // NOP () macro support
           =2 extern void _nop (void);
           =2 #define NOP() _nop()
           =2 
           =2 //-----------------------------------------------------------------------------
           =2 
           =2 
           =2 // IAR 8051
           =2 // http://www.iar.com
           =2 
           =2 #elif defined __ICC8051__
           =2 
           =2 #include <stdbool.h>
           =2 #include <intrinsics.h>
           =2 
           =2 # define SBIT(name, addr, bit)  __bit __no_init volatile bool name @ (addr+bit)
           =2 # define SFR(name, addr)        __sfr __no_init volatile unsigned char name @ addr
           =2 # define SFRX(name, addr)       __xdata __no_init volatile unsigned char name @ addr
           =2 # define SFR16(name, addr)      __sfr __no_init volatile unsigned int  name @ addr
           =2 # define SFR16E(name, fulladdr) /* not supported */
           =2 # define SFR32(name, fulladdr) /* not supported */
           =2 # define SFR32E(name, fulladdr) /* not supported */
           =2 
           =2 # define SEG_GENERIC __generic
           =2 # define SEG_FAR  __xdata
           =2 # define SEG_DATA __data
C51 COMPILER V9.51   MGR_ISP                                                               11/17/2023 14:48:45 PAGE 100 

           =2 # define SEG_NEAR __data
           =2 # define SEG_IDATA __idata
           =2 # define SEG_XDATA __xdata
           =2 # define SEG_PDATA __pdata
           =2 # define SEG_CODE  __code
           =2 # define SEG_BDATA __bdata
           =2 
           =2 #define bit bool
           =2 
           =2 # define _PPTOSTR_(x) #x
           =2 # define _PPARAM_(address) _PPTOSTR_(vector=address * 8 + 3)
           =2 # define _PPARAM2_(regbank) _PPTOSTR_(register_bank=regbank)
           =2 # define INTERRUPT(name, vector) _Pragma(_PPARAM_(vector)) __interrupt void name(void)
           =2 # define INTERRUPT_PROTO(name, vector)  __interrupt void name(void)
           =2 # define INTERRUPT_USING(name, vector, regnum) _Pragma(_PPARAM2_(regnum)) _Pragma(_PPARAM_(vector)) __inte
             -rrupt void name(void)
           =2 # define INTERRUPT_PROTO_USING(name, vector, regnum) __interrupt void name(void)
           =2 
           =2 # define FUNCTION_USING(name, return_value, parameter, regnum) /* not supported */
           =2 # define FUNCTION_PROTO_USING(name, return_value, parameter, regnum) /* not supported */
           =2 // Note: IAR does not support functions using different register banks. Register
           =2 //       banks can only be specified in interrupts. If a function is called from
           =2 //       inside an interrupt, it will use the same register bank as the interrupt.
           =2 
           =2 # define SEGMENT_VARIABLE(name, vartype, locsegment)  locsegment vartype name
           =2 # define VARIABLE_SEGMENT_POINTER(name, vartype, targsegment) vartype targsegment  * name
           =2 # define SEGMENT_VARIABLE_SEGMENT_POINTER(name, vartype, targsegment, locsegment) vartype targsegment * lo
             -csegment name
           =2 
           =2 # define LOCATED_VARIABLE(name, vartype, locsegment, addr, init) locsegment __no_init vartype name @ addr
           =2 
           =2 // used with UU16
           =2 # define LSB 0
           =2 # define MSB 1
           =2 
           =2 // used with UU32 (b0 is least-significant byte)
           =2 //# define b0 0
           =2 //# define b1 1
           =2 //# define b2 2
           =2 //# define b3 3
           =2 
           =2 typedef unsigned char U8;
           =2 typedef unsigned int U16;
           =2 typedef unsigned long U32;
           =2 
           =2 typedef signed char S8;
           =2 typedef signed int S16;
           =2 typedef signed long S32;
           =2 
           =2 typedef union UU16
           =2 {
           =2    U16 U16;
           =2    S16 S16;
           =2    U8 U8[2];
           =2    S8 S8[2];
           =2 } UU16;
           =2 
           =2 typedef union UU32
           =2 {
           =2    U32 U32;
           =2    S32 S32;
           =2    UU16 UU16[2];
C51 COMPILER V9.51   MGR_ISP                                                               11/17/2023 14:48:45 PAGE 101 

           =2    U16 U16[2];
           =2    S16 S16[2];
           =2    U8 U8[4];
           =2    S8 S8[4];
           =2 } UU32;
           =2 
           =2 
           =2 #define NOP() __no_operation();
           =2 //-----------------------------------------------------------------------------
           =2 
           =2 // Crossware
           =2 // http://www.crossware.com
           =2 
           =2 #elif defined _XC51_VER
           =2 # define SBIT(name, addr, bit)  _sfrbit  name = (addr+bit)
           =2 # define SFR(name, addr)        _sfr     name = addr
           =2 # define SFR16(name, addr)      _sfrword name = addr
           =2 # define SFR16E(name, fulladdr) /* not supported */
           =2 # define SFR32(name, fulladdr)  /* not supported */
           =2 # define SFR32E(name, fulladdr) /* not supported */
           =2 
           =2 //-----------------------------------------------------------------------------
           =2 
           =2 // Wickenhäuser
           =2 // http://www.wickenhaeuser.de
           =2 
           =2 #elif defined __UC__
           =2 # define SBIT(name, addr, bit)  unsigned char bit  name @ (addr+bit)
           =2 # define SFR(name, addr)        near unsigned char name @ addr
           =2 # define SFR16(name, addr)      /* not supported */
           =2 # define SFR16E(name, fulladdr) /* not supported */
           =2 # define SFR32(name, fulladdr)  /* not supported */
           =2 # define SFR32E(name, fulladdr) /* not supported */
           =2 
           =2 //-----------------------------------------------------------------------------
           =2 
           =2 // Default
           =2 // Unknown compiler
           =2 
           =2 #else
           =2 # warning unrecognized compiler
           =2 # define SBIT(name, addr, bit)  volatile bool           name
           =2 # define SFR(name, addr)        volatile unsigned char  name
           =2 # define SFRX(name, addr)       volatile unsigned char  name
           =2 # define SFR16(name, addr)      volatile unsigned short name
           =2 # define SFR16E(name, fulladdr) volatile unsigned short name
           =2 # define SFR32(name, fulladdr)  volatile unsigned long  name
           =2 # define SFR32E(name, fulladdr) volatile unsigned long  name
           =2 
           =2 #endif
           =2 
           =2 //-----------------------------------------------------------------------------
           =2 // Header File PreProcessor Directive
           =2 //-----------------------------------------------------------------------------
           =2 
           =2 #endif                                 // #define COMPILER_DEFS_H
 689      =2  
 690      =2  //-----------------------------------------------------------------------------
 691      =2  // End Of File
 692      =2  //-----------------------------------------------------------------------------
   4      =1  #include "C8051F580_defs.h"
   1      =2  //-----------------------------------------------------------------------------
C51 COMPILER V9.51   MGR_ISP                                                               11/17/2023 14:48:45 PAGE 102 

   2      =2  // C8051F580_defs.h
   3      =2  //-----------------------------------------------------------------------------
   4      =2  // Copyright 2008, Silicon Laboratories, Inc.
   5      =2  // http://www.silabs.com
   6      =2  //
   7      =2  // Program Description:
   8      =2  //
   9      =2  // Register/bit definitions for the C8051F58x family.
  10      =2  // **Important Note**: The compiler_defs.h header file should be included
  11      =2  // before including this header file.
  12      =2  //
  13      =2  // Target:         C8051F580/1/2/3/4/5/6/7,8/9-F590/1
  14      =2  // Tool chain:     Generic
  15      =2  // Command Line:   None
  16      =2  //
  17      =2  // Release 0.6 - 20 AUG 2012 (TP)
  18      =2  //    -Added #define for _XPAGE to provide support for SDCC memory paging
  19      =2  //     (pdata)
  20      =2  //
  21      =2  // Release 0.5 - 10 SEP 2011 (GP)
  22      =2  //    - Fixed SFR16 definition for CAN0IF2MC
  23      =2  //
  24      =2  // Release 0.4 - 08 OCT 2010 (TP)
  25      =2  //    - Fixed bit definitions for SCON0
  26      =2  //
  27      =2  // Release 0.3 - 01 APR 2009 (GP)
  28      =2  //    - Added SN0-SN3
  29      =2  //
  30      =2  // Release 0.2 - 29 JUL 2008 (ADT)
  31      =2  //    - Added Timer 4 bit definitions
  32      =2  //
  33      =2  // Release 0.1 - 09 JUL 2008 (GP)
  34      =2  //    - Initial Revision
  35      =2  //
  36      =2  //-----------------------------------------------------------------------------
  37      =2  // Header File Preprocessor Directive
  38      =2  //-----------------------------------------------------------------------------
  39      =2  
  40      =2  #ifndef C8051F580_DEFS_H
           =2 #define C8051F580_DEFS_H
           =2 
           =2 //-----------------------------------------------------------------------------
           =2 // Page 0, Page 1 and Page F Registers
           =2 //-----------------------------------------------------------------------------
           =2 
           =2 SFR (P0, 0x80);                        // Port 0 Latch
           =2 SFR (SP, 0x81);                        // Stack Pointer
           =2 SFR (DPL, 0x82);                       // Data Pointer Low
           =2 SFR (DPH, 0x83);                       // Data Pointer High
           =2 SFR (SFR0CN, 0x84);                    // SFR Page Control
           =2 SFR (SFRNEXT, 0x85);                   // SFR stack next page
           =2 SFR (SFRLAST, 0x86);                   // SFR stack last page
           =2 SFR (PCON, 0x87);                      // Power Control
           =2 SFR (TCON, 0x88);                      // Timer/Counter Control
           =2 SFR (TMOD, 0x89);                      // Timer/Counter Mode
           =2 SFR (TL0, 0x8A);                       // Timer/Counter 0 Low
           =2 SFR (TL1, 0x8B);                       // Timer/Counter 1 Low
           =2 SFR (TH0, 0x8C);                       // Timer/Counter 0 High
           =2 SFR (TH1, 0x8D);                       // Timer/Counter 1 High
           =2 SFR (CKCON, 0x8E);                     // Clock Control
           =2 SFR (PSCTL, 0x8F);                     // Program Store R/W Control
           =2 SFR (CLKSEL, 0x8F);                    // System clock select
C51 COMPILER V9.51   MGR_ISP                                                               11/17/2023 14:48:45 PAGE 103 

           =2 SFR (P1, 0x90);                        // Port 1 Latch
           =2 SFR (TMR3CN, 0x91);                    // Timer/Counter 3 Control
           =2 SFR (TMR5CN, 0x91);                    // Timer/Counter 5 Control
           =2 SFR (TMR3RLL, 0x92);                   // Timer/Counter 3 Reload Low
           =2 SFR (TMR5CAPL, 0x92);                  // Timer/Counter 5 Capture Low
           =2 SFR (TMR3RLH, 0x93);                   // Timer/Counter 3 Reload High
           =2 SFR (TMR5CAPH, 0x93);                  // Timer/Counter 5 Capture High
           =2 SFR (TMR3L, 0x94);                     // Timer/Counter 3 Low
           =2 SFR (TMR5L, 0x94);                     // Timer/Counter 5 Low
           =2 SFR (TMR3H, 0x95);                     // Timer/Counter 3 High
           =2 SFR (TMR5H, 0x95);                     // Timer/Counter 5 High
           =2 SFR (TMR5CF, 0x96);                    // Timer/Counter 5 Configuration
           =2 SFR (CLKMUL, 0x97);                    // Clock Multiplier
           =2 SFR (SCON0, 0x98);                     // UART0 Control
           =2 SFR (SCON1, 0x98);                     // UART1 Control
           =2 SFR (SBUF0, 0x99);                     // UART0 Data Buffer
           =2 SFR (SBUF1, 0x99);                     // UART1 Data Buffer
           =2 SFR (CPT0CN, 0x9A);                    // Comparator 0 Control
           =2 SFR (CPT2CN, 0x9A);                    // Comparator 2 Control
           =2 SFR (CPT0MD, 0x9B);                    // Comparator 0 Mode
           =2 SFR (CPT2MD, 0x9B);                    // Comparator 2 Mode
           =2 SFR (CPT0MX, 0x9C);                    // Comparator 0 Mux
           =2 SFR (CPT2MX, 0x9C);                    // Comparator 2 Mux
           =2 SFR (CPT1CN, 0x9D);                    // Comparator 1 Control
           =2 SFR (CPT1MD, 0x9E);                    // Comparator 0 Mode
           =2 SFR (OSCIFIN, 0x9E);                   // Internal Oscillator Fine Control
           =2 SFR (CPT1MX, 0x9F);                    // Comparator 1 Mux
           =2 SFR (OSCXCN, 0x9F);                    // External Oscillator Control
           =2 SFR (P2, 0xA0);                        // Port 2 Latch
           =2 SFR (SPI0CFG, 0xA1);                   // SPI0 Configuration
           =2 SFR (OSCICN, 0xA1);                    // Internal Oscillator Control
           =2 SFR (SPI0CKR, 0xA2);                   // SPI0 Clock rate control
           =2 SFR (OSCICRS, 0xA2);                   // Internal Oscillator Coarse Control
           =2 SFR (SPI0DAT, 0xA3);                   // SPI0 Data Buffer
           =2 SFR (P0MDOUT, 0xA4);                   // Port 0 Output Mode
           =2 SFR (P1MDOUT, 0xA5);                   // Port 1 Output Mode
           =2 SFR (P2MDOUT, 0xA6);                   // Port 2 Output Mode
           =2 SFR (SFRPAGE, 0xA7);                   // SFR Page Select
           =2 SFR (IE, 0xA8);                        // Interrupt Enable
           =2 SFR (SMOD0, 0xA9);                     // Serial Port 0 Control
           =2 SFR (EMI0CN, 0xAA);                    // EMIF Control
           =2 SFR (EMI0TC, 0xAA);                    // EMIF Timing control
           =2 SFR (SBCON0, 0xAB);                    // UART0 Baud Rate Generator Control
           =2 SFR (SBRLL0, 0xAC);                    // UART0 Baud Rate Generator Low
           =2 SFR (SBRLH0, 0xAD);                    // UART0 Baud Rate Generator High
           =2 SFR (P3MAT, 0xAE);                     // Port 3 Match
           =2 SFR (P3MDOUT, 0xAE);                   // Port 3 Mode
           =2 SFR (P3MASK, 0xAF);                    // Port 3 Mask
           =2 SFR (P4MDOUT, 0xAF);                   // Port 4 Mode
           =2 SFR (P3, 0xB0);                        // Port 3 Latch
           =2 SFR (P2MAT, 0xB1);                     // Port 2 Match
           =2 SFR (P2MASK, 0xB2);                    // Port 2 Mask
           =2 SFR (EMI0CF, 0xB2);                    // EMIF Configuration
           =2 SFR (P4, 0xB5);                        // Port 4 Latch
           =2 SFR (FLSCL, 0xB6);                     // Flash Scale
           =2 SFR (FLKEY, 0xB7);                     // Flash access limit
           =2 SFR (IP, 0xB8);                        // Interrupt Priority
           =2 SFR (SMB0ADR, 0xB9);                   // SMBus0 Slave address
           =2 SFR (ADC0TK, 0xBA);                    // ADC0 Tracking Mode Select
           =2 SFR (SMB0ADM, 0xBA);                   // SMBus0 Address Mask
           =2 SFR (ADC0MX, 0xBB);                    // AMUX0 Channel select
           =2 SFR (ADC0CF, 0xBC);                    // AMUX0 Channel configuration
C51 COMPILER V9.51   MGR_ISP                                                               11/17/2023 14:48:45 PAGE 104 

           =2 SFR (ADC0L, 0xBD);                     // ADC0 Data Low
           =2 SFR (ADC0H, 0xBE);                     // ADC0 Data High
           =2 SFR (SMB0CN, 0xC0);                    // SMBus0 Control
           =2 SFR (SMB0CF, 0xC1);                    // SMBus0 Configuration
           =2 SFR (SMB0DAT, 0xC2);                   // SMBus0 Data
           =2 SFR (ADC0GTL, 0xC3);                   // ADC0 Greater-Than Compare Low
           =2 SFR (ADC0GTH, 0xC4);                   // ADC0 Greater-Than Compare High
           =2 SFR (ADC0LTL, 0xC5);                   // ADC0 Less-Than Compare Word Low
           =2 SFR (ADC0LTH, 0xC6);                   // ADC0 Less-Than Compare Word High
           =2 SFR (XBR3, 0xC6);                      // Port I/O Crossbar Control 3
           =2 SFR (XBR2, 0xC7);                      // Port I/O Crossbar Control 2
           =2 SFR (TMR2CN, 0xC8);                    // Timer/Counter 2 Control
           =2 SFR (TMR4CN, 0xC8);                    // Timer/Counter 4 Control
           =2 SFR (REG0CN, 0xC9);                    // Regulator Control
           =2 SFR (LIN0CF, 0xC9);                    // LIN 0 Configuration
           =2 SFR (TMR4CF, 0xC9);                    // Timer/Counter 4 Configuration
           =2 SFR (TMR2RLL, 0xCA);                   // Timer/Counter 2 Reload Low
           =2 SFR (TMR4CAPL, 0xCA);                  // Timer/Counter 4 Capture Low
           =2 SFR (TMR2RLH, 0xCB);                   // Timer/Counter 2 Reload High
           =2 SFR (TMR4CAPH, 0xCB);                  // Timer/Counter 4 Capture High
           =2 SFR (TMR2L, 0xCC);                     // Timer/Counter 2 Low
           =2 SFR (TMR4L, 0xCC);                     // Timer/Counter 4 Low
           =2 SFR (TMR2H, 0xCD);                     // Timer/Counter 2 High
           =2 SFR (TMR4H, 0xCD);                     // Timer/Counter 4 High
           =2 SFR (PCA0CPL5, 0xCE);                  // PCA0 Capture 5 Low
           =2 SFR (PCA1CPL11, 0xCE);                 // PCA1 Capture 11 Low
           =2 SFR (PCA0CPH5, 0xCF);                  // PCA0 Capture 5 High
           =2 SFR (PCA1CPH11, 0xCF);                 // PCA1 Capture 11 High
           =2 SFR (PSW, 0xD0);                       // Program Status Word
           =2 SFR (REF0CN, 0xD1);                    // Voltage Reference Control
           =2 SFR (LIN0DAT, 0xD2);                   // LIN0 Data
           =2 SFR (LIN0ADR, 0xD3);                   // LIN0 Address
           =2 SFR (P0SKIP, 0xD4);                    // Port 0 Skip
           =2 SFR (P1SKIP, 0xD5);                    // Port 1 Skip
           =2 SFR (P2SKIP, 0xD6);                    // Port 2 Skip
           =2 SFR (P3SKIP, 0xD7);                    // Port 3 Skip
           =2 SFR (PCA0CN, 0xD8);                    // PCA0 Control
           =2 SFR (PCA1CN, 0xD8);                    // PCA1 Control
           =2 SFR (PCA0MD, 0xD9);                    // PCA0 Mode
           =2 SFR (PCA1MD, 0xD9);                    // PCA1 Mode
           =2 SFR (PCA0PWM, 0xD9);                   // PCA0 PWM Control
           =2 SFR (PCA0CPM0, 0xDA);                  // PCA0 Module 0 Mode
           =2 SFR (PCA1CPM6, 0xDA);                  // PCA1 Module 6 Mode
           =2 SFR (PCA1PWM, 0xDA);                   // PCA1 PWM Control
           =2 SFR (PCA0CPM1, 0xDB);                  // PCA0 Module 1  Mode
           =2 SFR (PCA1CPM7, 0xDB);                  // PCA1 Module 7  Mode
           =2 SFR (PCA0CPM2, 0xDC);                  // PCA0 Module 2  Mode
           =2 SFR (PCA1CPM8, 0xDC);                  // PCA1 Module 8  Mode
           =2 SFR (PCA0CPM3, 0xDD);                  // PCA0 Module 3  Mode
           =2 SFR (PCA1CPM9, 0xDD);                  // PCA1 Module 9  Mode
           =2 SFR (PCA0CPM4, 0xDE);                  // PCA0 Module 4  Mode
           =2 SFR (PCA1CPM10, 0xDE);                  // PCA1 Module 10 Mode
           =2 SFR (PCA0CPM5, 0xDF);                  // PCA0 Module 5  Mode
           =2 SFR (PCA1CPM11, 0xDF);                  // PCA1 Module 11 Mode
           =2 SFR (ACC, 0xE0);                       // Accumulator
           =2 SFR (XBR0, 0xE1);                      // Port I/O Crossbar Control 0
           =2 SFR (XBR1, 0xE2);                      // Port I/O Crossbar Control 1
           =2 SFR (CCH0CN, 0xE3);                    // Cache control
           =2 SFR (IT01CF, 0xE4);                    // INT0/INT1 Configuration
           =2 SFR (EIE1, 0xE6);                      // Extended Interrupt Enable 2
           =2 SFR (EIE2, 0xE7);                      // Extended Interrupt Enable 2
           =2 SFR (ADC0CN, 0xE8);                    // ADC0 Control
C51 COMPILER V9.51   MGR_ISP                                                               11/17/2023 14:48:45 PAGE 105 

           =2 SFR (PCA0CPL1, 0xE9);                  // PCA0 Capture 1 Low
           =2 SFR (PCA1CPL1, 0xE9);                  // PCA1 Capture 7 Low
           =2 SFR (PCA0CPH1, 0xEA);                  // PCA0 Capture 1 High
           =2 SFR (PCA1CPH1, 0xEA);                  // PCA1 Capture 7 High
           =2 SFR (PCA0CPL2, 0xEB);                  // PCA0 Capture 2 Low
           =2 SFR (PCA1CPL2, 0xEB);                  // PCA1 Capture 8 Low
           =2 SFR (PCA0CPH2, 0xEC);                  // PCA0 Capture 2 High
           =2 SFR (PCA1CPH2, 0xEC);                  // PCA1 Capture 8 High
           =2 SFR (PCA0CPL3, 0xED);                  // PCA0 Capture 3 Low
           =2 SFR (PCA1CPL3, 0xED);                  // PCA1 Capture 9 Low
           =2 SFR (PCA0CPH3, 0xEE);                  // PCA0 Capture 3 High
           =2 SFR (PCA1CPH3, 0xEE);                  // PCA1 Capture 9 High
           =2 SFR (RSTSRC, 0xEF);                    // Reset Source Configuration/Status
           =2 SFR (B, 0xF0);                         // B Register
           =2 SFR (P0MAT, 0xF1);                     // Port 0 Match
           =2 SFR (P0MDIN, 0xF1);                    // Port 0 Input Mode
           =2 SFR (P0MASK, 0xF2);                    // Port 0 Mask
           =2 SFR (P1MDIN, 0xF2);                    // Port 1 Input Mode
           =2 SFR (P1MAT, 0xF3);                     // Port 1 Match
           =2 SFR (P2MDIN, 0xF3);                    // Port 2 Input Mode
           =2 SFR (P1MASK, 0xF4);                    // Port 1 Mask
           =2 SFR (P3MDIN, 0xF4);                    // Port 3 Input Mode
           =2 SFR (PSBANK, 0xF5);                    // Program Space Bank Select
           =2 SFR (EIP1, 0xF6);                      // External Interrupt Priority 1
           =2 SFR (EIP2, 0xF7);                      // External Interrupt Priority 2
           =2 SFR (SPI0CN, 0xF8);                    // SPI0 Control
           =2 SFR (PCA0L, 0xF9);                     // PCA0 Counter Low
           =2 SFR (PCA1L, 0xF9);                     // PCA1 Counter Low
           =2 SFR (SN0, 0xF9);                       // Serial Number 0
           =2 SFR (PCA0H, 0xFA);                     // PCA0 Counter High
           =2 SFR (PCA1H, 0xFA);                     // PCA1 Counter High
           =2 SFR (SN1, 0xFA);                       // Serial Number 1
           =2 SFR (PCA0CPL0, 0xFB);                  // PCA0 Capture 0 Low
           =2 SFR (PCA1CPL6, 0xFB);                  // PCA1 Capture 6 Low
           =2 SFR (SN2, 0xFB);                       // Serial Number 2
           =2 SFR (PCA0CPH0, 0xFC);                  // PCA0 Capture 0 High
           =2 SFR (PCA1CPH6, 0xFC);                  // PCA1 Capture 6 High
           =2 SFR (SN3, 0xFC);                       // Serial Number 3
           =2 SFR (PCA0CPL4, 0xFD);                  // PCA0 Capture 4 Low
           =2 SFR (PCA1CPL10, 0xFD);                 // PCA1 Capture 10 Low
           =2 SFR (PCA0CPH4, 0xFE);                  // PCA0 Capture 4 High
           =2 SFR (PCA1CPH10, 0xFE);                 // PCA1 Capture 10 High
           =2 SFR (VDM0CN, 0xFF);                    // VDD Monitor Control
           =2 
           =2 //-----------------------------------------------------------------------------
           =2 // Page C (CAN0) Registers
           =2 //-----------------------------------------------------------------------------
           =2 
           =2 SFR (CAN0CFG, 0x92);                   // CAN0 Clock Configuration
           =2 SFR (CAN0STAT, 0x94);                  // Status Register Low Byte
           =2 SFR (CAN0ERRL, 0x96);                  // Error Counter Low Byte
           =2 SFR (CAN0ERRH, 0x97);                  // Error Counter High Byte
           =2 SFR (CAN0BTL, 0x9A);                   // Bit Timing Register Low Byte
           =2 SFR (CAN0BTH, 0x9B);                   // Bit Timing Register High Byte
           =2 SFR (CAN0IIDL, 0x9C);                  // Interrupt Register Low Byte
           =2 SFR (CAN0IIDH, 0x9D);                  // Interrupt Register High Byte
           =2 SFR (CAN0TST, 0x9E);                   // Test Register Low Byte
           =2 SFR (CAN0BRPE, 0xA1);                  // BRP Extension Register Low Byte
           =2 SFR (CAN0TR1L, 0xA2);                  // Transmission Request 1 Low Byte
           =2 SFR (CAN0TR1H, 0xA3);                  // Transmission Request 1 High Byte
           =2 SFR (CAN0TR2L, 0xA4);                  // Transmission Request 2 Low Byte
           =2 SFR (CAN0TR2H, 0xA5);                  // Transmission Request 2 High Byte
C51 COMPILER V9.51   MGR_ISP                                                               11/17/2023 14:48:45 PAGE 106 

           =2 SFR (CAN0ND1L, 0xAA);                  // New Data 1 Low Byte
           =2 SFR (CAN0ND1H, 0xAB);                  // New Data 1 High Byte
           =2 SFR (CAN0ND2L, 0xAC);                  // New Data 2 Low Byte
           =2 SFR (CAN0ND2H, 0xAD);                  // New Data 2 High Byte
           =2 SFR (CAN0IP1L, 0xAE);                  // Interrupt Pending 1 Low Byte
           =2 SFR (CAN0IP1H, 0xAF);                  // Interrupt Pending 1 High Byte
           =2 SFR (CAN0IP2L, 0xB2);                  // Interrupt Pending 2 Low Byte
           =2 SFR (CAN0IP2H, 0xB3);                  // Interrupt Pending 2 High Byte
           =2 SFR (CAN0MV1L, 0xBA);                  // Message Valid 1 Low Byte
           =2 SFR (CAN0MV1H, 0xBB);                  // Message Valid 1 High Byte
           =2 SFR (CAN0MV2L, 0xBC);                  // Message Valid 2 Low Byte
           =2 SFR (CAN0MV2H, 0xBD);                  // Message Valid 2 High Byte
           =2 SFR (CAN0IF1CRL, 0xBE);                // IF1 Command Request Low Byte
           =2 SFR (CAN0IF1CRH, 0xBF);                // IF1 Command Request High Byte
           =2 SFR (CAN0CN, 0xC0);                    // CAN Control Register Low Byte
           =2 SFR (CAN0IF1CML, 0xC2);                // IF1 Command Mask Low Byte
           =2 SFR (CAN0IF1CMH, 0xC3);                // IF1 Command Mask High Byte
           =2 SFR (CAN0IF1M1L, 0xC4);                // IF1 Mask 1 Low Byte
           =2 SFR (CAN0IF1M1H, 0xC5);                // IF1 Mask 1 High Byte
           =2 SFR (CAN0IF1M2L, 0xC6);                // IF1 Mask 2 Low Byte
           =2 SFR (CAN0IF1M2H, 0xC7);                // IF1 Mask 2 High Byte
           =2 SFR (CAN0IF1A1L, 0xCA);                // IF1 Arbitration 1 Low Byte
           =2 SFR (CAN0IF1A1H, 0xCB);                // IF1 Arbitration 1 High Byte
           =2 SFR (CAN0IF1A2L, 0xCC);                // IF1 Arbitration 2 Low Byte
           =2 SFR (CAN0IF1A2H, 0xCD);                // IF1 Arbitration 2 High Byte
           =2 SFR (CAN0IF2MCL, 0xCE);                // IF2 Message Control Low Byte
           =2 SFR (CAN0IF2MCH, 0xCF);                // IF2 Message Control High Byte
           =2 SFR (CAN0IF1MCL, 0xD2);                // IF1 Message Control Low Byte
           =2 SFR (CAN0IF1MCH, 0xD3);                // IF1 Message Control High Byte
           =2 SFR (CAN0IF1DA1L, 0xD4);               // IF1 Data A 1 Low Byte
           =2 SFR (CAN0IF1DA1H, 0xD5);               // IF1 Data A 1 High Byte
           =2 SFR (CAN0IF1DA2L, 0xD6);               // IF1 Data A 2 Low Byte
           =2 SFR (CAN0IF1DA2H, 0xD7);               // IF1 Data A 2 High Byte
           =2 SFR (CAN0IF1DB1L, 0xDA);               // IF1 Data B 1 Low Byte
           =2 SFR (CAN0IF1DB1H, 0xDB);               // IF1 Data B 1 High Byte
           =2 SFR (CAN0IF1DB2L, 0xDC);               // IF1 Data B 2 Low Byte
           =2 SFR (CAN0IF1DB2H, 0xDD);               // IF1 Data B 2 High Byte
           =2 SFR (CAN0IF2CRL, 0xDE);                // IF2 Command Request Low Byte
           =2 SFR (CAN0IF2CRH, 0xDF);                // IF2 Command Request High Byte
           =2 SFR (CAN0IF2CML, 0xE2);                // IF2 Command Mask Low Byte
           =2 SFR (CAN0IF2CMH, 0xE3);                // IF2 Command Mask High Byte
           =2 SFR (CAN0IF2M1L, 0xEA);                // IF2 Mask 1 Low Byte
           =2 SFR (CAN0IF2M1H, 0xEB);                // IF2 Mask 1 High Byte
           =2 SFR (CAN0IF2M2L, 0xEC);                // IF2 Mask 2 Low Byte
           =2 SFR (CAN0IF2M2H, 0xED);                // IF2 Mask 2 High Byte
           =2 SFR (CAN0IF2A1L, 0xEE);                // IF2 Arbitration 1 Low Byte
           =2 SFR (CAN0IF2A1H, 0xEF);                // IF2 Arbitration 1 High Byte
           =2 SFR (CAN0IF2A2L, 0xF2);                // IF2 Arbitration 2 Low Byte
           =2 SFR (CAN0IF2A2H, 0xF3);                // IF2 Arbitration 2 High Byte
           =2 SFR (CAN0IF2DA1L, 0xF6);               // IF2 Data A 1 Low Byte
           =2 SFR (CAN0IF2DA1H, 0xF7);               // IF2 Data A 1 High Byte
           =2 SFR (CAN0IF2DA2L, 0xFA);               // IF2 Data A 2 Low Byte
           =2 SFR (CAN0IF2DA2H, 0xFB);               // IF2 Data A 2 High Byte
           =2 SFR (CAN0IF2DB1L, 0xFC);               // IF2 Data B 1 Low Byte
           =2 SFR (CAN0IF2DB1H, 0xFD);               // IF2 Data B 1 High Byte
           =2 SFR (CAN0IF2DB2L, 0xFE);               // IF2 Data B 2 Low Byte
           =2 SFR (CAN0IF2DB2H, 0xFF);               // IF2 Data B 2 High Byte
           =2 
           =2 
           =2 //-----------------------------------------------------------------------------
           =2 // 16-bit Register Definitions (might not be supported by all compilers)
           =2 //-----------------------------------------------------------------------------
C51 COMPILER V9.51   MGR_ISP                                                               11/17/2023 14:48:45 PAGE 107 

           =2 
           =2 SFR16 (DP, 0x82);                      // Data Pointer
           =2 SFR16 (TMR3RL, 0x92);                  // Timer 3 Reload
           =2 SFR16 (TMR5CAP, 0x92);                 // Timer 5 Capture
           =2 SFR16 (TMR3, 0x94);                    // Timer 3 Capture / Reload
           =2 SFR16 (TMR5, 0x94);                    // Timer 5
           =2 SFR16 (SBRL0, 0xAC);                   // UART0 Reload
           =2 SFR16 (ADC0, 0xBD);                    // ADC0 data
           =2 SFR16 (ADC0GT, 0xC3);                  // ADC0 Greater Than Window
           =2 SFR16 (ADC0LT, 0xC5);                  // ADC0 Less Than Window
           =2 SFR16 (TMR2RL, 0xCA);                  // Timer 2 Reload
           =2 SFR16 (TMR4CAP, 0xCA);                 // Timer 4 Capture
           =2 SFR16 (TMR2, 0xCC);                    // Timer 2 Capture / Reload
           =2 SFR16 (TMR4, 0xCC);                    // Timer 4
           =2 SFR16 (PCA0CP5, 0xCE);                 // PCA0 Module 5 Capture
           =2 SFR16 (PCA1CP11, 0xCE);                // PCA1 Module 11 Capture
           =2 SFR16 (PCA0CP1, 0xE9);                 // PCA0 Module 1 Capture
           =2 SFR16 (PCA1CP7, 0xE9);                 // PCA1 Module 7 Capture
           =2 SFR16 (PCA0CP2, 0xEB);                 // PCA0 Module 2 Capture
           =2 SFR16 (PCA1CP8, 0xEB);                 // PCA1 Module 8 Capture
           =2 SFR16 (PCA0CP3, 0xED);                 // PCA0 Module 3 Capture
           =2 SFR16 (PCA1CP9, 0xED);                 // PCA1 Module 9 Capture
           =2 SFR16 (PCA0, 0xF9);                    // PCA0 Counter
           =2 SFR16 (PCA1, 0xF9);                    // PCA1 Counter
           =2 SFR16 (PCA0CP0, 0xFB);                 // PCA0 Module 0 Capture
           =2 SFR16 (PCA1CP6, 0xFB);                 // PCA1 Module 6 Capture
           =2 SFR16 (PCA0CP4, 0xFD);                 // PCA0 Module 4 Capture
           =2 SFR16 (PCA1CP10, 0xFD);                 // PCA1 Module 10 Capture
           =2 
           =2 SFR16 (CAN0ERR, 0x96);                 // Error Counter
           =2 SFR16 (CAN0BT, 0x9A);                  // Bit Timing Register
           =2 SFR16 (CAN0IID, 0x9C);                 // Interrupt Register
           =2 SFR16 (CAN0TR1, 0xA2);                 // Transmission Request 1
           =2 SFR16 (CAN0TR2, 0xA4);                 // Transmission Request 2
           =2 SFR16 (CAN0ND1, 0xAA);                 // New Data 1
           =2 SFR16 (CAN0ND2, 0xAC);                 // New Data 2
           =2 SFR16 (CAN0IP1, 0xAE);                 // Interrupt Pending 1
           =2 SFR16 (CAN0IP2, 0xB2);                 // Interrupt Pending 2
           =2 SFR16 (CAN0MV1, 0xBA);                 // Message Valid 1
           =2 SFR16 (CAN0MV2, 0xBC);                 // Message Valid 2
           =2 SFR16 (CAN0IF1CR, 0xBE);               // IF1 Command Request
           =2 SFR16 (CAN0IF1CM, 0xC2);               // IF1 Command Mask
           =2 SFR16 (CAN0IF1M1, 0xC4);               // IF1 Mask 1
           =2 SFR16 (CAN0IF1M2, 0xC6);               // IF1 Mask 2
           =2 SFR16 (CAN0IF1A1, 0xCA);               // IF1 Arbitration 1
           =2 SFR16 (CAN0IF1A2, 0xCC);               // IF1 Arbitration 2
           =2 SFR16 (CAN0IF1MC, 0xD2);               // IF1 Message Control
           =2 SFR16 (CAN0IF1DA1, 0xD4);              // IF1 Data A 1
           =2 SFR16 (CAN0IF1DA2, 0xD6);              // IF1 Data A 2
           =2 SFR16 (CAN0IF1DB1, 0xDA);              // IF1 Data B 1
           =2 SFR16 (CAN0IF1DB2, 0xDC);              // IF1 Data B 2
           =2 SFR16 (CAN0IF2CR, 0xDE);               // IF2 Command Request
           =2 SFR16 (CAN0IF2CM, 0xE2);               // IF2 Command Mask
           =2 SFR16 (CAN0IF2M1, 0xEA);               // IF2 Mask 1
           =2 SFR16 (CAN0IF2M2, 0xEC);               // IF2 Mask 2
           =2 SFR16 (CAN0IF2A1, 0xEE);               // IF2 Arbitration 1
           =2 SFR16 (CAN0IF2A2, 0xF2);               // IF2 Arbitration 2
           =2 SFR16 (CAN0IF2MC, 0xCE);               // IF2 Message Control
           =2 SFR16 (CAN0IF2DA1, 0xF6);              // IF2 Data A 1
           =2 SFR16 (CAN0IF2DA2, 0xFA);              // IF2 Data A 2
           =2 SFR16 (CAN0IF2DB1, 0xFC);              // IF2 Data B 1
           =2 SFR16 (CAN0IF2DB2, 0xFE);              // IF2 Data B 2
C51 COMPILER V9.51   MGR_ISP                                                               11/17/2023 14:48:45 PAGE 108 

           =2 
           =2 //-----------------------------------------------------------------------------
           =2 // LIN0 Indirect Registers
           =2 //-----------------------------------------------------------------------------
           =2 
           =2 #define  LIN0DT1   0x00                // LIN0 Data Byte 1
           =2 #define  LIN0DT2   0x01                // LIN0 Data Byte 2
           =2 #define  LIN0DT3   0x02                // LIN0 Data Byte 3
           =2 #define  LIN0DT4   0x03                // LIN0 Data Byte 4
           =2 #define  LIN0DT5   0x04                // LIN0 Data Byte 5
           =2 #define  LIN0DT6   0x05                // LIN0 Data Byte 6
           =2 #define  LIN0DT7   0x06                // LIN0 Data Byte 7
           =2 #define  LIN0DT8   0x07                // LIN0 Data Byte 8
           =2 #define  LIN0CTRL  0x08                // LIN0 Control
           =2 #define  LIN0ST    0x09                // LIN0 Status
           =2 #define  LIN0ERR   0x0A                // LIN0 Error
           =2 #define  LIN0SIZE  0x0B                // LIN0 Message Size
           =2 #define  LIN0DIV   0x0C                // LIN0 Divider
           =2 #define  LIN0MUL   0x0D                // LIN0 Multiplier
           =2 #define  LIN0ID    0x0E                // LIN0 Identifier
           =2 
           =2 //-----------------------------------------------------------------------------
           =2 // Address Definitions for Bit-addressable Registers
           =2 //-----------------------------------------------------------------------------
           =2 
           =2 #define SFR_P0       0x80
           =2 #define SFR_TCON     0x88
           =2 #define SFR_P1       0x90
           =2 #define SFR_SCON0    0x98
           =2 #define SFR_SCON1    0x98
           =2 #define SFR_P2       0xA0
           =2 #define SFR_IE       0xA8
           =2 #define SFR_P3       0xB0
           =2 #define SFR_IP       0xB8
           =2 #define SFR_SMB0CN   0xC0
           =2 #define SFR_TMR2CN   0xC8
           =2 #define SFR_TMR4CN   0xC8
           =2 #define SFR_PSW      0xD0
           =2 #define SFR_PCA0CN   0xD8
           =2 #define SFR_PCA1CN   0xD8
           =2 #define SFR_ACC      0xE0
           =2 #define SFR_ADC0CN   0xE8
           =2 #define SFR_B        0xF0
           =2 #define SFR_SPI0CN   0xF8
           =2 
           =2 //-----------------------------------------------------------------------------
           =2 // Bit Definitions
           =2 //-----------------------------------------------------------------------------
           =2 
           =2 // TCON 0x88
           =2 SBIT (TF1, SFR_TCON, 7);               // Timer 1 Overflow Flag
           =2 SBIT (TR1, SFR_TCON, 6);               // Timer 1 On/Off Control
           =2 SBIT (TF0, SFR_TCON, 5);               // Timer 0 Overflow Flag
           =2 SBIT (TR0, SFR_TCON, 4);               // Timer 0 On/Off Control
           =2 SBIT (IE1, SFR_TCON, 3);               // Ext. Interrupt 1 Edge Flag
           =2 SBIT (IT1, SFR_TCON, 2);               // Ext. Interrupt 1 Type
           =2 SBIT (IE0, SFR_TCON, 1);               // Ext. Interrupt 0 Edge Flag
           =2 SBIT (IT0, SFR_TCON, 0);               // Ext. Interrupt 0 Type
           =2 
           =2 // SCON0 0x98
           =2 SBIT (OVR0, SFR_SCON0, 7);             // UART0 Receive FIFO Overrun Flag
           =2 SBIT (PERR0, SFR_SCON0, 6);            // UART0 Parity Error Flag
C51 COMPILER V9.51   MGR_ISP                                                               11/17/2023 14:48:45 PAGE 109 

           =2 SBIT (THRE0, SFR_SCON0, 5);            // UART0 Transmit Register Empty Flag
           =2 SBIT (REN0, SFR_SCON0, 4);             // UART0 RX Enable
           =2 SBIT (TBX0, SFR_SCON0, 3);             // UART0 Extra Transmission Bit
           =2 SBIT (RBX0, SFR_SCON0, 2);             // UART0 Extra Receive Bit
           =2 SBIT (TI0, SFR_SCON0, 1);              // UART0 TX Interrupt Flag
           =2 SBIT (RI0, SFR_SCON0, 0);              // UART0 RX Interrupt Flag
           =2 
           =2 // SCON1 0x98
           =2 SBIT (S1MODE, SFR_SCON1, 7);           // UART1 Mode 0
           =2                                        // Bit 6 UNUSED
           =2 SBIT (MCE1, SFR_SCON1, 5);             // UART1 Multiprocessor enable
           =2 SBIT (REN1, SFR_SCON1, 4);             // UART1 RX Enable
           =2 SBIT (TB81, SFR_SCON1, 3);             // UART1 TX Bit 8
           =2 SBIT (RB81, SFR_SCON1, 2);             // UART1 RX Bit 8
           =2 SBIT (TI1, SFR_SCON1, 1);              // UART1 TX Interrupt Flag
           =2 SBIT (RI1, SFR_SCON1, 0);              // UART1 RX Interrupt Flag
           =2 
           =2 // IE 0xA8
           =2 SBIT (EA, SFR_IE, 7);                  // Global Interrupt Enable
           =2 SBIT (ESPI0, SFR_IE, 6);               // SPI0 Interrupt Enable
           =2 SBIT (ET2, SFR_IE, 5);                 // Timer 2 Interrupt Enable
           =2 SBIT (ES0, SFR_IE, 4);                 // UART0 Interrupt Enable
           =2 SBIT (ET1, SFR_IE, 3);                 // Timer 1 Interrupt Enable
           =2 SBIT (EX1, SFR_IE, 2);                 // External Interrupt 1 Enable
           =2 SBIT (ET0, SFR_IE, 1);                 // Timer 0 Interrupt Enable
           =2 SBIT (EX0, SFR_IE, 0);                 // External Interrupt 0 Enable
           =2 
           =2 // IP 0xB8
           =2                                        // Bit 7 unused
           =2 SBIT (PSPI0, SFR_IP, 6);               // SPI0 Interrupt Priority
           =2 SBIT (PT2, SFR_IP, 5);                 // Timer 2 Priority
           =2 SBIT (PS0, SFR_IP, 4);                 // UART0 Priority
           =2 SBIT (PS, SFR_IP, 4);                  // UART0 Priority
           =2 SBIT (PT1, SFR_IP, 3);                 // Timer 1 Priority
           =2 SBIT (PX1, SFR_IP, 2);                 // External Interrupt 1 Priority
           =2 SBIT (PT0, SFR_IP, 1);                 // Timer 0 Priority
           =2 SBIT (PX0, SFR_IP, 0);                 // External Interrupt 0 Priority
           =2 
           =2 // SMB0CN 0xC0
           =2 SBIT (MASTER, SFR_SMB0CN, 7);          // SMBus0 Master/Slave Indicator
           =2 SBIT (TXMODE, SFR_SMB0CN, 6);          // SMBus0 Transmit Mode Indicator
           =2 SBIT (STA, SFR_SMB0CN, 5);             // SMBus0 Start Flag
           =2 SBIT (STO, SFR_SMB0CN, 4);             // SMBus0 Stop Flag
           =2 SBIT (ACKRQ, SFR_SMB0CN, 3);           // SMBus0 Acknowledge Request
           =2 SBIT (ARBLOST, SFR_SMB0CN, 2);         // SMBus0 Arbitration Lost Indicator
           =2 SBIT (ACK, SFR_SMB0CN, 1);             // SMBus0 Acknowledge
           =2 SBIT (SI, SFR_SMB0CN, 0);              // SMBus0 Interrupt Flag
           =2 
           =2 // TMR2CN 0xC8
           =2 SBIT (TF2H, SFR_TMR2CN, 7);            // Timer 2 High-Byte Overflow Flag
           =2 SBIT (TF2L, SFR_TMR2CN, 6);            // Timer 2 Low-Byte  Overflow Flag
           =2 SBIT (TF2LEN, SFR_TMR2CN, 5);          // Timer 2 Low-Byte Flag Enable
           =2 SBIT (TF2CEN, SFR_TMR2CN, 4);          // Timer 2 Capture Enable
           =2 SBIT (T2SPLIT, SFR_TMR2CN, 3);         // Timer 2 Split-Mode Enable
           =2 SBIT (TR2, SFR_TMR2CN, 2);             // Timer 2 Run Enable
           =2 SBIT (T2RCLK, SFR_TMR2CN, 1);          // Timer 2 Xclk/Rclk Select
           =2 SBIT (T2XCLK, SFR_TMR2CN, 0);          // Timer 2 Clk/8 Clock Source
           =2 
           =2 // TMR4CN 0xC8
           =2 SBIT (TF4, SFR_TMR4CN, 7);             // Timer 4 Overflow/Underflow Flag
           =2 SBIT (EXF4, SFR_TMR4CN, 6);            // Timer 4 External Flag
           =2                                        // Bit 5 unused
C51 COMPILER V9.51   MGR_ISP                                                               11/17/2023 14:48:45 PAGE 110 

           =2                                        // Bit 4 unused
           =2 SBIT (EXE4, SFR_TMR4CN, 3);            // Timer 4 External Enable
           =2 SBIT (TR4, SFR_TMR4CN, 2);             // Timer 4 Run Enable
           =2 SBIT (CT4, SFR_TMR4CN, 1);             // Timer 4 Counter/Timer Select
           =2 SBIT (CPRL4, SFR_TMR4CN, 0);           // Timer 4 Capture/Reload Select
           =2 
           =2 // PSW 0xD0
           =2 SBIT (CY, SFR_PSW, 7);                 // Carry Flag
           =2 SBIT (AC, SFR_PSW, 6);                 // Auxiliary Carry Flag
           =2 SBIT (F0, SFR_PSW, 5);                 // User Flag 0
           =2 SBIT (RS1, SFR_PSW, 4);                // Register Bank Select 1
           =2 SBIT (RS0, SFR_PSW, 3);                // Register Bank Select 0
           =2 SBIT (OV, SFR_PSW, 2);                 // Overflow Flag
           =2 SBIT (F1, SFR_PSW, 1);                 // User Flag 1
           =2 SBIT (P, SFR_PSW, 0);                  // Accumulator Parity Flag
           =2 
           =2 // PCA0CN 0xD8
           =2 SBIT (CF, SFR_PCA0CN, 7);              // PCA0 Counter Overflow Flag
           =2 SBIT (CR, SFR_PCA0CN, 6);              // PCA0 Counter Run Control Bit
           =2 SBIT (CCF5, SFR_PCA0CN, 5);            // PCA0 Module 5 Interrupt Flag
           =2 SBIT (CCF4, SFR_PCA0CN, 4);            // PCA0 Module 4 Interrupt Flag
           =2 SBIT (CCF3, SFR_PCA0CN, 3);            // PCA0 Module 3 Interrupt Flag
           =2 SBIT (CCF2, SFR_PCA0CN, 2);            // PCA0 Module 2 Interrupt Flag
           =2 SBIT (CCF1, SFR_PCA0CN, 1);            // PCA0 Module 1 Interrupt Flag
           =2 SBIT (CCF0, SFR_PCA0CN, 0);            // PCA0 Module 0 Interrupt Flag
           =2 
           =2 // PCA1CN 0xD8
           =2 SBIT (CF1, SFR_PCA1CN, 7);             // PCA1 Counter Overflow Flag
           =2 SBIT (CR1, SFR_PCA1CN, 6);             // PCA1 Counter Run Control Bit
           =2 SBIT (CCF11, SFR_PCA1CN, 5);           // PCA1 Module 11 Interrupt Flag
           =2 SBIT (CCF10, SFR_PCA1CN, 4);           // PCA1 Module 10 Interrupt Flag
           =2 SBIT (CCF9, SFR_PCA1CN, 3);            // PCA1 Module 9 Interrupt Flag
           =2 SBIT (CCF8, SFR_PCA1CN, 2);            // PCA1 Module 8 Interrupt Flag
           =2 SBIT (CCF7, SFR_PCA1CN, 1);            // PCA1 Module 7 Interrupt Flag
           =2 SBIT (CCF6, SFR_PCA1CN, 0);            // PCA1 Module 6 Interrupt Flag
           =2 
           =2 // ADC0CN 0xE8
           =2 SBIT (AD0EN, SFR_ADC0CN, 7);           // ADC0 Enable
           =2 SBIT (BURSTEN, SFR_ADC0CN, 6);         // ADC0 Burst Enable
           =2 SBIT (AD0INT, SFR_ADC0CN, 5);          // ADC0 EOC Interrupt Flag
           =2 SBIT (AD0BUSY, SFR_ADC0CN, 4);         // ADC0 Busy Flag
           =2 SBIT (AD0WINT, SFR_ADC0CN, 3);         // ADC0 Window Compare Interrupt Flag
           =2 SBIT (AD0LJST, SFR_ADC0CN, 2);         // ADC0 Left Justified
           =2 SBIT (AD0CM1, SFR_ADC0CN, 1);          // ADC0 Start Of Conversion Mode Bit 1
           =2 SBIT (AD0CM0, SFR_ADC0CN, 0);          // ADC0 Start Of Conversion Mode Bit 0
           =2 
           =2 // SPI0CN 0xF8
           =2 SBIT (SPIF, SFR_SPI0CN, 7);            // SPI0 Interrupt Flag
           =2 SBIT (WCOL, SFR_SPI0CN, 6);            // SPI0 Write Collision Flag
           =2 SBIT (MODF, SFR_SPI0CN, 5);            // SPI0 Mode Fault Flag
           =2 SBIT (RXOVRN, SFR_SPI0CN, 4);          // SPI0 RX Overrun Flag
           =2 SBIT (NSSMD1, SFR_SPI0CN, 3);          // SPI0 Slave Select Mode 1
           =2 SBIT (NSSMD0, SFR_SPI0CN, 2);          // SPI0 Slave Select Mode 0
           =2 SBIT (TXBMT, SFR_SPI0CN, 1);           // SPI0 TX Buffer Empty Flag
           =2 SBIT (SPIEN, SFR_SPI0CN, 0);           // SPI0 Enable
           =2 
           =2 //-----------------------------------------------------------------------------
           =2 // Interrupt Priorities
           =2 //-----------------------------------------------------------------------------
           =2 
           =2 #define INTERRUPT_INT0             0   // External Interrupt 0
           =2 #define INTERRUPT_TIMER0           1   // Timer 0 Overflow
C51 COMPILER V9.51   MGR_ISP                                                               11/17/2023 14:48:45 PAGE 111 

           =2 #define INTERRUPT_INT1             2   // External Interrupt 1
           =2 #define INTERRUPT_TIMER1           3   // Timer 1 Overflow
           =2 #define INTERRUPT_UART0            4   // UART0
           =2 #define INTERRUPT_TIMER2           5   // Timer 2 Overflow
           =2 #define INTERRUPT_SPI0             6   // SPI0
           =2 #define INTERRUPT_SMBUS0           7   // SMBus0 Interface
           =2 #define INTERRUPT_ADC0_WINDOW      8   // ADC0 Window Comparison
           =2 #define INTERRUPT_ADC0_EOC         9   // ADC0 End Of Conversion
           =2 #define INTERRUPT_PCA0            10   // PCA0 Peripheral
           =2 #define INTERRUPT_COMPARATOR0     11   // Comparator 0 Comparison
           =2 #define INTERRUPT_COMPARATOR1     12   // Comparator 1 Comparison
           =2 #define INTERRUPT_TIMER3          13   // Timer 3 Overflow
           =2 #define INTERRUPT_LIN0            14   // LIN Bus Interrupt
           =2 #define INTERRUPT_VREG            15   // Voltage Regulator
           =2 #define INTERRUPT_CAN0            16   // CAN Bus Interrupt
           =2 #define INTERRUPT_PORT_MATCH      17   // Port Match
           =2 #define INTERRUPT_UART1           18   // UART1
           =2 #define INTERRUPT_PCA1            19   // PCA1 Peripheral
           =2 #define INTERRUPT_COMPARATOR2     20   // Comparator 2 Comparison
           =2 #define INTERRUPT_TIMER4          21   // Timer 4 Overflow
           =2 #define INTERRUPT_TIMER5          22   // Timer 5 Overflow
           =2 
           =2 
           =2 //-----------------------------------------------------------------------------
           =2 // SFR Page Definitions
           =2 //-----------------------------------------------------------------------------
           =2 
           =2 #define  CONFIG_PAGE       0x0F        // System and Port Configuration Page
           =2 #define  ACTIVE_PAGE       0x00        // Active Use Page
           =2 #define  ACTIVE2_PAGE      0x10        // Active Use Page 2
           =2 #define  CAN0_PAGE         0x0C        // CAN0 Registers
           =2 
           =2 //-----------------------------------------------------------------------------
           =2 // SDCC PDATA External Memory Paging Support
           =2 //-----------------------------------------------------------------------------
           =2 
           =2 #if defined SDCC
           =2 
           =2 SFR(_XPAGE, 0xAA); // Point to the EMI0CN register
           =2 
           =2 #endif
           =2 
           =2 //-----------------------------------------------------------------------------
           =2 // Header File PreProcessor Directive
           =2 //-----------------------------------------------------------------------------
           =2 
           =2 #endif                                 // #define C8051F580_DEFS_H
 607      =2  
 608      =2  //-----------------------------------------------------------------------------
 609      =2  // End Of File
 610      =2  //-----------------------------------------------------------------------------
   5      =1  /* ----- Global Define -------------------------------*/
   6      =1  
   7      =1  /*----------------------------------------------------*/
   8      =1  
   9      =1  /* ----- Global Value --------------------------------*/
  10      =1  
  11      =1  /*----------------------------------------------------*/
  12      =1  
  13      =1  /* ----- Function ------------------------------------*/
  14      =1  
  15      =1  void Watchdog_Init(void);
C51 COMPILER V9.51   MGR_ISP                                                               11/17/2023 14:48:45 PAGE 112 

  16      =1  void WDT_Clear(void);
  17      =1  void PCA_Init(void);
  18      =1  /*----------------------------------------------------*/
  19      =1  
  20      =1  /* ----- Extern Function -----------------------------*/
  21      =1  
  22      =1  /*----------------------------------------------------*/
  23      =1  #endif
  10          #include "drv_adc.h"
   1      =1  #ifndef DRV_ADC_H
   2      =1  #define DRV_ADC_H
   3      =1  
   4      =1  
   5      =1  /* ----- Global Define -------------------------------*/
   6      =1  
   7      =1  /*----------------------------------------------------*/
   8      =1  
   9      =1  /* ----- Global Value --------------------------------*/
  10      =1  
  11      =1  /*----------------------------------------------------*/
  12      =1  
  13      =1  
  14      =1  /* ----- Function ------------------------------------*/
  15      =1  void ADC_Init(void);
  16      =1  U8 Get_Video_Signal(void);
  17      =1  U8 Get_Temperature(void);
  18      =1  /*----------------------------------------------------*/
  19      =1  
  20      =1  
  21      =1  /* ----- INTERRUPT -----------------------------------*/
  22      =1  
  23      =1  /*----------------------------------------------------*/
  24      =1  
  25      =1  /* ----- Extern Function -----------------------------*/
  26      =1  extern SEG_XDATA U16 RESULT;
  27      =1  /*----------------------------------------------------*/
  28      =1  
  29      =1  #endif
  30      =1  
  11          #include "mgr_isp.h"
   1      =1  /* ----- Global Define -------------------------------*/
   2      =1  #ifndef MGR_ISP_H
   3      =1  #define MGR_ISP_H
   4      =1  
   5      =1  #include "mgr_comm.h"
   1      =2  #ifndef MGR_COMM_H
           =2 #define MGR_COMM_H
           =2 
           =2 #include "compiler_defs.h"
           =2 #include "C8051F580_defs.h"
           =2 
           =2 /* ----- Global Define -------------------------------*/
           =2 /*
           =2 #define TW8836          0x00U
           =2 #define DESERIALIZE     0x01U
           =2 #define SERIALIZE       0x02U
           =2 */
           =2 #define  TW8836_SLAVE_ADDRESS   (U8)0x8A
           =2 #define  TW8836_ID_ADRESS           (U8)0x00
           =2 #define  TW8836_ID                              (U16)0x0036
           =2 
           =2 #define  INIT                           0x00U           // (MR) data byte received
C51 COMPILER V9.51   MGR_ISP                                                               11/17/2023 14:48:45 PAGE 113 

           =2 #define  RX                                     0x01U           // (MR) data byte received
           =2 #define  TX                                     0x02U           // (MR) data byte received
           =2 
           =2 #define USE_MDPS11                              0x00U
           =2 #define USE_LANGUAGEINFO                0x01U
           =2 #define USE_HUTYPE                              0x02U
           =2 #define USE_GATEWAY                             0x03U
           =2 #define USE_NAVIONOFF                   0x04U
           =2 #define USE_G_SEL_DISP                  0x05U
           =2 #define USE_IGN_SW                              0x06U
           =2 #define USE_RVM_CAMERAOFF               0x07U
           =2 #define FCZC_RVM_SW                             0x08U
           =2 #define USE_4WDERR                              0x09U
           =2 #define USE_ENGVOL                              0x0AU
           =2 #define USE_CAN_COUNT                   0x0BU           
           =2 
           =2 #define TYPE_2WD                                0x00U
           =2 #define TYPE_4WD                                0x01U
           =2 
           =2 #define TYPE_ENGVOL20                   0x14U
           =2 #define TYPE_ENGVOL22                   0x16U
           =2 #define TYPE_ENGVOL33                   0x21U
           =2 /*----------------------------------------------------*/
           =2 
           =2 /* ----- Function ------------------------------------*/
           =2 void Init_CommTask(void);
           =2 void Operate_CommTask(void);
           =2 void Rx_Data_Process(void);
           =2 //void Comm_I2C_Tx_Data(void);
           =2 void Comm_I2C_Tx(U8 Slave_Addr,U8 Length,U16 Addr, U16 TData,U16 RData );
           =2 U16   Comm_I2C_Rx(U8 Slave_Addr,U8 Length,U16 Addr, U16 TData,U16 RData );
           =2 void Clear_I2C_Tx_Data(void);
           =2 void Clear_CAN_Tx_Data(void);
           =2 void Clear_Can_Data(void);
           =2 void Clear_Sas_Data(void);
           =2 
           =2 void Comm_RearView_Data(void);
           =2 void Comm_Tuning_Value_Type(U8 Type4WdErr, U8 TypeEngVol);
           =2 U8 Comm_Sas_Data(U8 *pa_Data);
           =2 U8 Comm_Hutype_Data(U8 *pa_Data);
           =2 U8 Comm_Language_Data(U8 *pa_Data);
           =2 U8 Comm_G_Sel_Disp_Data(U8 *Data);
           =2 U8 Comm_IGN_Sw_Data(U8 *Data);
           =2 U8 Comm_RVM_CameraOff_Data(U8 *Data);
           =2 U8 Comm_RVM_SW_Data(U8 *Data);
           =2 U8 Comm_ENG_Vol_Data(U8 *pa_Data);
           =2 U8 Comm_4WD_Err_Data(U8 *pa_Data);
           =2 void Comm_Tx_RVM_View(U8 sigData);
           =2 void Comm_Tx_RVM_SW_IND(U8 sigData);
           =2 
           =2 void Flash_OneSpec_Write(void);
           =2 void Flash_OneSpec_Read(void);
           =2 void Comm_Error_Check(void);
           =2 /*----------------------------------------------------*/
           =2 
           =2 /* ----- Extern Function -----------------------------*/
           =2 /*----------------------------------------------------*/
           =2 
           =2 /* ----- Global Value --------------------------------*/
           =2 
           =2 typedef struct {
           =2         U8  Slave;
C51 COMPILER V9.51   MGR_ISP                                                               11/17/2023 14:48:45 PAGE 114 

           =2         U8  Length;
           =2         U8  TRX_Flag;
           =2         U16 Addr;
           =2         U16 TxData;
           =2         U16 RxData;
           =2 }tMsg_I2C_Tx_Data_s;
           =2 
           =2 typedef struct {
           =2         U8  Slave;
           =2         U8  Length;
           =2         U8  TRX_Flag;
           =2         U16 Addr;
           =2         U16 TxData;
           =2         U16 RxData;
           =2 }tMsg_CAN_Tx_Data_s;
           =2 
           =2 typedef struct {
           =2         U8 Is_Change;
           =2         U8 Change_Count;
           =2         U8 Time_Out;
           =2         U8 Cur_Data;
           =2         U8 Mid_Data;
           =2         U8 Pre_Data;
           =2         U16 Chatter_Time;
           =2 }tMsg_CAN_Rx_Data_s;
           =2 
           =2 typedef struct {
           =2         U8  Is_Change;
           =2         U8  Pre_Sign;
           =2         U8  Angle;
           =2         U8  Angle_Pre_Sign;
           =2         U8  Time_Out;
           =2         U16 Pre_Data;
           =2         U8      Tuning_Type;
           =2 }tMsg_CAN_SAS_Data_s;
           =2 
           =2 typedef struct {
           =2         U8  Is_Change;
           =2         U8  Pre_Sign;
           =2         U8  Angle;
           =2         U16 Pre_Data;
           =2 }tMsg_CAN_State_s;
           =2 
           =2 
           =2 /*
           =2 struct tCAN_Tx_Data_s {
           =2         U8 Flag;
           =2         U8 Dest;
           =2         U8 Length;
           =2         U8 *TxData;
           =2 }
           =2 
           =2 struct tCAN_Rx_Data_s {
           =2         U8 Flag;
           =2         U8 Src;
           =2         U8 Length;
           =2         U8 RxData;
           =2 }
           =2 */
           =2 /*----------------------------------------------------*/
           =2 
           =2 extern SEG_XDATA volatile tMsg_CAN_SAS_Data_s tCAN_Rx_SAS_Msg;
C51 COMPILER V9.51   MGR_ISP                                                               11/17/2023 14:48:45 PAGE 115 

           =2 #endif
 143      =2  
   6      =1  
   7      =1  #define LOAD_COMMAND_SIZE                               (4)
   8      =1  #define CLEAR_COMMAND_SIZE                              (3)
   9      =1  
  10      =1  #define STEERING_ANGLE_LIMIT            (0x0028U)
  11      =1  
  12      =1  //G_SEL_DISP
  13      =1  #define GEAR_P                                          0x00U
  14      =1  #define GEAR_D                                          0x05U
  15      =1  #define GEAR_N                                          0x06U
  16      =1  #define GEAR_R                                          0x07U
  17      =1  #define GEAR_INVALID                            0x09U
  18      =1  #define GEAR_INTERMEDIATE                       0x0EU
  19      =1  
  20      =1  //IGN SW
  21      =1  #define IGN_SW_KEY_OFF                          0x00U
  22      =1  #define IGN_SW_ON                                       0x03U
  23      =1  
  24      =1  //RVM CameraOff
  25      =1  #define RVM_CAMERA_DEFAULT                      0x00U
  26      =1  #define RVM_CAMERA_OFF                          0x01U
  27      =1  #define RVM_CAMERA_INVALID                      0x03U
  28      =1  
  29      =1  //FCZC RVM SW
  30      =1  #define FCZC_RVM_SW_OFF                         0x00U
  31      =1  #define FCZC_RVM_SW_ON                          0x01U
  32      =1  
  33      =1  //RVM VIEW
  34      =1  #define RVM_VIEW_OFF                            0x00U
  35      =1  #define RVM_PARKING_ASSIST_VIEW         0x01U
  36      =1  #define RVM_DRIVING_ASSIST_VIEW         0x02U
  37      =1  #define RVM_VIEW_INVALID                        0x0FU
  38      =1  
  39      =1  //RVM SW IND
  40      =1  #define RVM_SW_IND_OFF                          0x00U
  41      =1  #define RVM_SW_IND_ON                           0x01U
  42      =1  #define RVM_SW_IND_INVALID                      0x03U
  43      =1  
  44      =1  #define NORMAL_3M_GUIDE_LINE_ADDR               (0x0001)
  45      =1  
  46      =1  //RVM CONFIG
  47      =1  #define          CMD_PARKING_CONFIG                     (0x0000U)
  48      =1  #define          CMD_DRIVING_CONFIG                     (0x0001U)
  49      =1  
  50      =1  #define         CHECKING_LAYER_DATA                     (0x4F08U)
  51      =1  #define         CHECKING_LAYER0_DATA            (0x4F0AU)
  52      =1  #define         CHECKING_LAYER1_DATA            (0x4F0CU)
  53      =1  #define         CHECKING_LAYER2_DATA            (0x4F0EU)
  54      =1  
  55      =1  #define         CMD_PARAM_POOL_0_ADDR           (0xFC00U)
  56      =1  #define         CMD_PARAM_POOL_1_ADDR           (0xFC01U)
  57      =1  #define         CMD_PARAM_POOL_2_ADDR           (0xFC02U)
  58      =1  #define         CMD_PARAM_POOL_3_ADDR           (0xFC03U)
  59      =1  #define         CMD_PARAM_POOL_4_ADDR           (0xFC04U)
  60      =1  #define         CMD_PARAM_POOL_5_ADDR           (0xFC04U)
  61      =1  #define         CMD_PARAM_POOL_6_ADDR           (0xFC06U)
  62      =1  #define         CMD_PARAM_POOL_7_ADDR           (0xFC07U)
  63      =1  #define         CMD_PARAM_POOL_8_ADDR           (0xFC08U)
  64      =1  
  65      =1  #define         CMD_REGISTER_ADDR                       (0x0040U)
C51 COMPILER V9.51   MGR_ISP                                                               11/17/2023 14:48:45 PAGE 116 

  66      =1  
  67      =1  #define         CMD_SET_STATE                           (0x8100U)
  68      =1  #define         CMD_GET_STATE                           (0x8101U)
  69      =1  
  70      =1  #define         CMD_OVRL_LOAD_BUFFER            (0x8206U)
  71      =1  #define         CMD_OVRL_LOAD_STATUS            (0x8207U)
  72      =1  
  73      =1  #define         OVRL_ENABLE_DATA                        (0x0100U)
  74      =1  #define         OVRL_DISABLE_DATA                       (0x0000U)
  75      =1  
  76      =1  #define         OVR_LAYER0_DATA                         (0x0000U)
  77      =1  #define         OVR_LAYER1_DATA                         (0x0100U)
  78      =1  #define         OVR_LAYER2_DATA                         (0x0200U)
  79      =1  #define         OVR_LAYER3_DATA                         (0x0300U)
  80      =1  
  81      =1  #define         BUFFER0_LAYER0_DATA                     (0x0000U)
  82      =1  #define         BUFFER1_LAYER0_DATA                     (0x0100U)
  83      =1  #define         BUFFER2_LAYER0_DATA                     (0x0200U)
  84      =1  #define         BUFFER3_LAYER0_DATA                     (0x0300U)
  85      =1  #define         BUFFER4_LAYER0_DATA                     (0x0400U)
  86      =1  #define         BUFFER5_LAYER0_DATA                     (0x0500U)
  87      =1  #define         BUFFER6_LAYER0_DATA                     (0x0600U)
  88      =1  
  89      =1  #define         BUFFER0_LAYER1_DATA                     (0x0001U)
  90      =1  #define         BUFFER1_LAYER1_DATA                     (0x0101U)
  91      =1  #define         BUFFER2_LAYER1_DATA                     (0x0201U)
  92      =1  #define         BUFFER3_LAYER1_DATA                     (0x0301U)
  93      =1  #define         BUFFER4_LAYER1_DATA                     (0x0401U)
  94      =1  #define         BUFFER5_LAYER1_DATA                     (0x0501U)
  95      =1  #define         BUFFER6_LAYER1_DATA                     (0x0601U)
  96      =1  
  97      =1  #define         BUFFER0_LAYER2_DATA                     (0x0002U)
  98      =1  #define         BUFFER1_LAYER2_DATA                     (0x0102U)
  99      =1  #define         BUFFER2_LAYER2_DATA                     (0x0202U)
 100      =1  #define         BUFFER3_LAYER2_DATA                     (0x0302U)
 101      =1  #define         BUFFER4_LAYER2_DATA                     (0x0402U)
 102      =1  #define         BUFFER5_LAYER2_DATA                     (0x0502U)
 103      =1  #define         BUFFER6_LAYER2_DATA                     (0x0602U)
 104      =1  
 105      =1  #define         BUFFER0_LAYER3_DATA                     (0x0003U)
 106      =1  #define         BUFFER1_LAYER3_DATA                     (0x0103U)
 107      =1  #define         BUFFER2_LAYER3_DATA                     (0x0203U)
 108      =1  #define         BUFFER3_LAYER3_DATA                     (0x0303U)
 109      =1  #define         BUFFER4_LAYER3_DATA                     (0x0403U)
 110      =1  #define         BUFFER5_LAYER3_DATA                     (0x0503U)
 111      =1  #define         BUFFER6_LAYER3_DATA                     (0x0603U)
 112      =1  
 113      =1  #define         EXTRA_BUFFER0_DATA                      (BUFFER0_LAYER0_DATA)
 114      =1  #define         EXTRA_BUFFER1_DATA                      (BUFFER1_LAYER0_DATA)
 115      =1  #define         EXTRA_BUFFER2_DATA                      (BUFFER2_LAYER0_DATA)
 116      =1  #define         EXTRA_BUFFER3_DATA                      (BUFFER3_LAYER0_DATA)
 117      =1  #define         EXTRA_BUFFER4_DATA                      (BUFFER4_LAYER0_DATA)
 118      =1  #define         EXTRA_BUFFER5_DATA                      (BUFFER5_LAYER0_DATA)
 119      =1  #define         EXTRA_BUFFER6_DATA                      (BUFFER6_LAYER0_DATA)
 120      =1  
 121      =1  #define         WARNING_BUFFER0_DATA            (BUFFER0_LAYER1_DATA)
 122      =1  #define         WARNING_BUFFER1_DATA            (BUFFER1_LAYER1_DATA)
 123      =1  #define         WARNING_BUFFER2_DATA            (BUFFER2_LAYER1_DATA)
 124      =1  #define         WARNING_BUFFER3_DATA            (BUFFER3_LAYER1_DATA)
 125      =1  #define         WARNING_BUFFER4_DATA            (BUFFER4_LAYER1_DATA)
 126      =1  #define         WARNING_BUFFER5_DATA            (BUFFER5_LAYER1_DATA)
 127      =1  #define         WARNING_BUFFER6_DATA            (BUFFER6_LAYER1_DATA)
C51 COMPILER V9.51   MGR_ISP                                                               11/17/2023 14:48:45 PAGE 117 

 128      =1  
 129      =1  #define         GUIDELINE_BUFFER0_DATA          (BUFFER0_LAYER2_DATA)
 130      =1  #define         GUIDELINE_BUFFER1_DATA          (BUFFER1_LAYER2_DATA)
 131      =1  #define         GUIDELINE_BUFFER2_DATA          (BUFFER2_LAYER2_DATA)
 132      =1  #define         GUIDELINE_BUFFER3_DATA          (BUFFER3_LAYER2_DATA)
 133      =1  #define         GUIDELINE_BUFFER4_DATA          (BUFFER4_LAYER2_DATA)
 134      =1  #define         GUIDELINE_BUFFER5_DATA          (BUFFER5_LAYER2_DATA)
 135      =1  #define         GUIDELINE_BUFFER6_DATA          (BUFFER6_LAYER2_DATA)
 136      =1  
 137      =1  #define         FIXED_GUIDELINE_BUFFER0_DATA            (BUFFER0_LAYER3_DATA)
 138      =1  #define         FIXED_GUIDELINE_BUFFER1_DATA            (BUFFER1_LAYER3_DATA)
 139      =1  #define         FIXED_GUIDELINE_BUFFER2_DATA            (BUFFER2_LAYER3_DATA)
 140      =1  #define         FIXED_GUIDELINE_BUFFER3_DATA            (BUFFER3_LAYER3_DATA)
 141      =1  #define         FIXED_GUIDELINE_BUFFER4_DATA            (BUFFER4_LAYER3_DATA)
 142      =1  #define         FIXED_GUIDELINE_BUFFER5_DATA            (BUFFER5_LAYER3_DATA)
 143      =1  #define         FIXED_GUIDELINE_BUFFER6_DATA            (BUFFER6_LAYER3_DATA)
 144      =1  
 145      =1  // Language Address in Flash
 146      =1  #define         MEM_FIXED_GUIDE_ADDR                    (0x0074U)       // 0x006DU 0x0048U
 147      =1  #define         MEM_FIXED_GUIDE_ADDR_D                  (0x0075U)
 148      =1  #define         MEM_BLACK_IMAGE_ADDR                    (0x0076U)
 149      =1  #define         MEM_LAN_START_ADDR                              (0x0053U)       // 0x004CU 0x0048U
 150      =1  #define         MEM_LAN_INVALID_ADDR                    (0x0072U)       // 0x006CU
 151      =1  #define         CAN_LAN_OFF_ADDR                                (0x0000U)
 152      =1  #define         CAN_LAN_INVALID_ADDR                    (0x001FU)
 153      =1  
 154      =1  #define AP0100_SENSOR_X_OFFSET  0xc8A8U
 155      =1  #define AP0100_SENSOR_Y_OFFSET  0xc8A9U
 156      =1  
 157      =1  #define ASX344_SENSOR_X_OFFSET  0xc860U
 158      =1  #define ASX344_SENSOR_Y_OFFSET  0xc861U
 159      =1  
 160      =1  #define AP0100_FRAME_COUNT_REGISTER             0x8006U
 161      =1  #define ASX344_FRAME_COUNT_REGISTER             0x8004U
 162      =1  
 163      =1  #define SENSOR_INIT                                             0x01U
 164      =1  #define SENSOR_RUNNING                                  0x02U
 165      =1  #define SENSOR_STATE_STREAMING                  0x3100U
 166      =1  
 167      =1  /*----------------------------------------------------*/
 168      =1  /* ----- Function ------------------------------------*/
 169      =1  void    Init_IspTask(void);
 170      =1  void    ui_event_process(void);
 171      =1  void    steering_angle_display_guide_line(S8 display_flag);
 172      =1  void Sensor_XY_Offset_set(U8 x, U8 y );
 173      =1  U8              CheckCommandStatusLoop(void);
 174      =1  
 175      =1  void Init_IspTask(void);
 176      =1  void Isp_InterInit(void);
 177      =1  void Operate_IspTask(void);
 178      =1  void Isp_Parking_Assist_View(void);
 179      =1  void Isp_Driving_Assist_View(void);
 180      =1  void Isp_View_Mode_Change(volatile U8 ViewMode);
 181      =1  void Isp_Off(void);
 182      =1  void Isp_On(void);
 183      =1  
 184      =1  void Fixed_Guidline_On(const U8 ViewMode);
 185      =1  void Fixed_Guidline_Off(void);
 186      =1  void Guidline_On(void);
 187      =1  void Guidline_Off(void);
 188      =1  void isp_guide_on_off(U8 Guide_On_Off);
 189      =1  void V_STB_Check(void);
C51 COMPILER V9.51   MGR_ISP                                                               11/17/2023 14:48:45 PAGE 118 

 190      =1  void Video_Signal_Check(void);
 191      =1  void Frame_Count_Check(void);
 192      =1  void Frame_Valide_Check(void);
 193      =1  void Check_Isp_InitState(void);
 194      =1  /*--------------------*/
 195      =1  
 196      =1  /* ----- Global Value --------------------------------*/
 197      =1  
 198      =1  /*----------------------------------------------------*/
 199      =1  typedef struct {
 200      =1          U8 IGNSw;
 201      =1          U8 Pre_Gear;
 202      =1          U8 Cur_Gear;
 203      =1          U8 Pre_RVM_CamOff;
 204      =1          U8 Cur_RVM_CamOff;
 205      =1          U8 Pre_RVM_SW;
 206      =1          U8 Cur_RVM_SW;
 207      =1          U8 Pre_SW_IND;
 208      =1          U8 Cur_SW_IND;
 209      =1          U8 Pre_ViewMode;
 210      =1          U8 Cur_ViewMode;
 211      =1          U8 RVM_SW_Status;
 212      =1  }tMsg_ISP_Function;
 213      =1  
 214      =1  /* ----- Extern Function -----------------------------*/
 215      =1  extern SEG_XDATA volatile tMsg_CAN_SAS_Data_s tCAN_Rx_SAS_Msg;
 216      =1  extern SEG_XDATA volatile tMsg_CAN_Rx_Data_s tCAN_Rx_Msg[USE_CAN_COUNT];
 217      =1  extern SEG_XDATA volatile U8 g_I2C_Err_Cnt;  // Counter for the number of errors.
 218      =1  extern SEG_XDATA volatile tMsg_ISP_Function tISP_Func_Msg;
 219      =1  /*----------------------------------------------------*/
 220      =1  
 221      =1  #endif
 222      =1  
 223      =1  
  12          #include "mgr_comm.h"
   1      =1  #ifndef MGR_COMM_H
           =1 #define MGR_COMM_H
           =1 
           =1 #include "compiler_defs.h"
           =1 #include "C8051F580_defs.h"
           =1 
           =1 /* ----- Global Define -------------------------------*/
           =1 /*
           =1 #define TW8836          0x00U
           =1 #define DESERIALIZE     0x01U
           =1 #define SERIALIZE       0x02U
           =1 */
           =1 #define  TW8836_SLAVE_ADDRESS   (U8)0x8A
           =1 #define  TW8836_ID_ADRESS           (U8)0x00
           =1 #define  TW8836_ID                              (U16)0x0036
           =1 
           =1 #define  INIT                           0x00U           // (MR) data byte received
           =1 #define  RX                                     0x01U           // (MR) data byte received
           =1 #define  TX                                     0x02U           // (MR) data byte received
           =1 
           =1 #define USE_MDPS11                              0x00U
           =1 #define USE_LANGUAGEINFO                0x01U
           =1 #define USE_HUTYPE                              0x02U
           =1 #define USE_GATEWAY                             0x03U
           =1 #define USE_NAVIONOFF                   0x04U
           =1 #define USE_G_SEL_DISP                  0x05U
           =1 #define USE_IGN_SW                              0x06U
C51 COMPILER V9.51   MGR_ISP                                                               11/17/2023 14:48:45 PAGE 119 

           =1 #define USE_RVM_CAMERAOFF               0x07U
           =1 #define FCZC_RVM_SW                             0x08U
           =1 #define USE_4WDERR                              0x09U
           =1 #define USE_ENGVOL                              0x0AU
           =1 #define USE_CAN_COUNT                   0x0BU           
           =1 
           =1 #define TYPE_2WD                                0x00U
           =1 #define TYPE_4WD                                0x01U
           =1 
           =1 #define TYPE_ENGVOL20                   0x14U
           =1 #define TYPE_ENGVOL22                   0x16U
           =1 #define TYPE_ENGVOL33                   0x21U
           =1 /*----------------------------------------------------*/
           =1 
           =1 /* ----- Function ------------------------------------*/
           =1 void Init_CommTask(void);
           =1 void Operate_CommTask(void);
           =1 void Rx_Data_Process(void);
           =1 //void Comm_I2C_Tx_Data(void);
           =1 void Comm_I2C_Tx(U8 Slave_Addr,U8 Length,U16 Addr, U16 TData,U16 RData );
           =1 U16   Comm_I2C_Rx(U8 Slave_Addr,U8 Length,U16 Addr, U16 TData,U16 RData );
           =1 void Clear_I2C_Tx_Data(void);
           =1 void Clear_CAN_Tx_Data(void);
           =1 void Clear_Can_Data(void);
           =1 void Clear_Sas_Data(void);
           =1 
           =1 void Comm_RearView_Data(void);
           =1 void Comm_Tuning_Value_Type(U8 Type4WdErr, U8 TypeEngVol);
           =1 U8 Comm_Sas_Data(U8 *pa_Data);
           =1 U8 Comm_Hutype_Data(U8 *pa_Data);
           =1 U8 Comm_Language_Data(U8 *pa_Data);
           =1 U8 Comm_G_Sel_Disp_Data(U8 *Data);
           =1 U8 Comm_IGN_Sw_Data(U8 *Data);
           =1 U8 Comm_RVM_CameraOff_Data(U8 *Data);
           =1 U8 Comm_RVM_SW_Data(U8 *Data);
           =1 U8 Comm_ENG_Vol_Data(U8 *pa_Data);
           =1 U8 Comm_4WD_Err_Data(U8 *pa_Data);
           =1 void Comm_Tx_RVM_View(U8 sigData);
           =1 void Comm_Tx_RVM_SW_IND(U8 sigData);
           =1 
           =1 void Flash_OneSpec_Write(void);
           =1 void Flash_OneSpec_Read(void);
           =1 void Comm_Error_Check(void);
           =1 /*----------------------------------------------------*/
           =1 
           =1 /* ----- Extern Function -----------------------------*/
           =1 /*----------------------------------------------------*/
           =1 
           =1 /* ----- Global Value --------------------------------*/
           =1 
           =1 typedef struct {
           =1         U8  Slave;
           =1         U8  Length;
           =1         U8  TRX_Flag;
           =1         U16 Addr;
           =1         U16 TxData;
           =1         U16 RxData;
           =1 }tMsg_I2C_Tx_Data_s;
           =1 
           =1 typedef struct {
           =1         U8  Slave;
           =1         U8  Length;
C51 COMPILER V9.51   MGR_ISP                                                               11/17/2023 14:48:45 PAGE 120 

           =1         U8  TRX_Flag;
           =1         U16 Addr;
           =1         U16 TxData;
           =1         U16 RxData;
           =1 }tMsg_CAN_Tx_Data_s;
           =1 
           =1 typedef struct {
           =1         U8 Is_Change;
           =1         U8 Change_Count;
           =1         U8 Time_Out;
           =1         U8 Cur_Data;
           =1         U8 Mid_Data;
           =1         U8 Pre_Data;
           =1         U16 Chatter_Time;
           =1 }tMsg_CAN_Rx_Data_s;
           =1 
           =1 typedef struct {
           =1         U8  Is_Change;
           =1         U8  Pre_Sign;
           =1         U8  Angle;
           =1         U8  Angle_Pre_Sign;
           =1         U8  Time_Out;
           =1         U16 Pre_Data;
           =1         U8      Tuning_Type;
           =1 }tMsg_CAN_SAS_Data_s;
           =1 
           =1 typedef struct {
           =1         U8  Is_Change;
           =1         U8  Pre_Sign;
           =1         U8  Angle;
           =1         U16 Pre_Data;
           =1 }tMsg_CAN_State_s;
           =1 
           =1 
           =1 /*
           =1 struct tCAN_Tx_Data_s {
           =1         U8 Flag;
           =1         U8 Dest;
           =1         U8 Length;
           =1         U8 *TxData;
           =1 }
           =1 
           =1 struct tCAN_Rx_Data_s {
           =1         U8 Flag;
           =1         U8 Src;
           =1         U8 Length;
           =1         U8 RxData;
           =1 }
           =1 */
           =1 /*----------------------------------------------------*/
           =1 
           =1 extern SEG_XDATA volatile tMsg_CAN_SAS_Data_s tCAN_Rx_SAS_Msg;
           =1 #endif
 143      =1  
  13          #include "mgr_diag.h"
   1      =1  //#include "drv_i2c.h"
   2      =1  
   3      =1  #ifndef MGR_DIAG_H
           =1 #define MGR_DIAG_H
           =1 
           =1 #include "mgr_comm.h"
           =1 #include "compiler_defs.h"
C51 COMPILER V9.51   MGR_ISP                                                               11/17/2023 14:48:45 PAGE 121 

           =1 #include "C8051F580_defs.h"
           =1 
           =1 /* ----- Global Define -------------------------------*/
           =1 //DTC INFO
           =1 #define DTC_MCU_WT_ERR                          0x00U
           =1 #define DTC_MCU_MC_ERR                          0x01U
           =1 #define DTC_SENSOR_FV_ERR                       0x02U
           =1 #define DTC_SENSOR_FC_ERR                       0x03U
           =1 #define DTC_SENSOR_ISPSTAT_ERR          0x04U
           =1 #define DTC_SENSOR_COMM_ERR                     0x05U
           =1 #define DTC_SENOSR_INIT_ERR                     0x06U
           =1 #define DTC_VIDEO_OUT_CUT_ERR           0x07U
           =1 #define DTC_VIDEO_OVER_VOL_ERR          0x08U
           =1 #define DTC_CODE_COUNT                          0x09U
           =1 
           =1 #define DTC_CODE_INTERNAL_ERROR         0x00U
           =1 #define DTC_CODE_SENSOR_ERROR           0x01U
           =1 #define DTC_CODE_OUTPUT_ERROR           0x02U
           =1 
           =1 
           =1 #define DTC_MCU_WD_ERROR                        Record_DTC_Error(DTC_MCU_WT_ERR)
           =1 #define DTC_MCU_WD_CLEAR                        Record_DTC_Clear(DTC_MCU_WT_ERR)
           =1 #define DTC_MCU_MC_ERROR                        Record_DTC_Error(DTC_MCU_MC_ERR)
           =1 #define DTC_MCU_MC_CLEAR                        Record_DTC_Clear(DTC_MCU_MC_ERR)
           =1 #define DTC_ISP_FV_ERROR                        Record_DTC_Error(DTC_SENSOR_FV_ERR)
           =1 #define DTC_ISP_FV_CLEAR                        Record_DTC_Clear(DTC_SENSOR_FV_ERR)
           =1 #define DTC_ISP_FC_ERROR                        Record_DTC_Error(DTC_SENSOR_FC_ERR)
           =1 #define DTC_ISP_FC_CLEAR                        Record_DTC_Clear(DTC_SENSOR_FC_ERR)
           =1 #define DTC_ISP_IS_ERROR                        Record_DTC_Error(DTC_SENSOR_ISPSTAT_ERR)
           =1 #define DTC_ISP_IS_CLEAR                        Record_DTC_Clear(DTC_SENSOR_ISPSTAT_ERR)
           =1 #define DTC_ISP_CM_ERROR                        Record_DTC_Error(DTC_SENSOR_COMM_ERR)
           =1 #define DTC_ISP_CM_CLEAR                        Record_DTC_Clear(DTC_SENSOR_COMM_ERR)
           =1 #define DTC_ISP_IT_ERROR                        Record_DTC_Error(DTC_SENOSR_INIT_ERR)
           =1 #define DTC_ISP_IT_CLEAR                        Record_DTC_Clear(DTC_SENOSR_INIT_ERR)
           =1 #define DTC_VID_OC_ERROR                        Record_DTC_Error(DTC_VIDEO_OUT_CUT_ERR)
           =1 #define DTC_VID_OC_CLEAR                        Record_DTC_Clear(DTC_VIDEO_OUT_CUT_ERR)
           =1 #define DTC_VID_VO_ERROR                        Record_DTC_Error(DTC_VIDEO_OVER_VOL_ERR)
           =1 #define DTC_VID_VO_CLEAR                        Record_DTC_Clear(DTC_VIDEO_OVER_VOL_ERR)
           =1         
           =1 
           =1 #define DTC_CURRENT_ERROR                       0x09U
           =1 #define DTC_CONFIRM_ERROR                       0x08U
           =1 #define DTC_CLEAR                                       0xFFU
           =1 
           =1 //SYSTEM INFO
           =1 #define SYS_HMC_SPEC                            0x02U
           =1 #define SYS_HMC_SPEC_L                          0x03U
           =1 
           =1 #define SYS_PART_NUMBER                         0x87U
           =1 #define SYS_PART_NUMBER_L                       0x00U
           =1 #define SYS_MANU_DATE                           0x8BU
           =1 #define SYS_MANU_DATE_L                         (U8)SYS_PART_NUMBER_L+0x0aU
           =1 #define SYS_HW_VERSION                          0x93U
           =1 #define SYS_HW_VERSION_L                        (U8)SYS_MANU_DATE_L + 0x08U
           =1 #define SYS_SW_VERSION                          0x95U
           =1 #define SYS_SW_VERSION_L                        (U8)SYS_HW_VERSION_L + 0x03U
           =1 #define SYS_CAN_VERSION                         0x00U
           =1 #define SYS_CAN_VERSION_L                       (U8)SYS_SW_VERSION_L + 0x03U
           =1 #define SYS_CODE_COUNT                          0x07U
           =1 #define SYS_CODE_SIZE                           0x25U
           =1 #define SYS_WRITE_CODE_SIZE                     0x27U
           =1 //ROUTINE CONTROL 
C51 COMPILER V9.51   MGR_ISP                                                               11/17/2023 14:48:45 PAGE 122 

           =1 
           =1 #define RTN_CTRL_ERASE_MEMORY           0xFF00U
           =1 #define RTN_CTRL_CHECK_PRG_DEPEND       0xFF01U
           =1 #define RTN_CTRL_SENSOR_RESET           0xF1F0U
           =1 #define RTN_CTRL_GUIDE_ONOFF            0xF1F1U
           =1 #define RTN_CTRL_WARNING_ONOFF          0xF1F2U
           =1 
           =1 #define RTN_CTRL_DEFAULT                        0x00U
           =1 #define RTN_CTRL_FIMR_UPDATE            0x01U //only RTN_CTRL_ERASE_MEMORY
           =1 #define RTN_CTRL_BINARY_UPDATE          0x02U //only RTN_CTRL_ERASE_MEMORY 
           =1 
           =1 #define HMC_SPEC_OPTIC_X_HIGH_PID                        4U
           =1 #define HMC_SPEC_OPTIC_X_LOW_PID                         5U
           =1 #define HMC_SPEC_OPTIC_Y_HIGH_PID                        6U
           =1 #define HMC_SPEC_OPTIC_Y_LOW_PID                         7U
           =1 #define HMC_SPEC_COUNTRY_CFG_PID                         8U
           =1 #define HMC_SPEC_TEMPERATURE_PID                         9U
           =1 #define HMC_SPEC_SAS_ANGLE_HIGH_PID                     10U
           =1 #define HMC_SPEC_SAS_ANGLE_LOW_PID                      11U
           =1 #define HMC_SPEC_DTC_CURRENT_HIGH_PID           12U
           =1 #define HMC_SPEC_DTC_CURRENT_LOW_PID            13U
           =1 #define HMC_SPEC_DTC_CONFIRM_HIGH_PID           14U
           =1 #define HMC_SPEC_DTC_CONFIRM_LOW_PID            15U
           =1 #define HMC_SPEC_RELATIVE_OPTIC_X_PID           16U
           =1 #define HMC_SPEC_RELATIVE_OPTIC_Y_PID           17U
           =1 #define HMC_SPEC_TOTAL_COUNT                            18U
           =1 
           =1 #define OPTIC_X_HIGH_PID_1                       0x80U
           =1 #define OPTIC_X_LOW_PID_2                        0x40U
           =1 #define OPTIC_Y_HIGH_PID_3                       0x20U
           =1 #define OPTIC_Y_LOW_PID_4                        0x10U
           =1 #define COUNTRY_CFG_PID_5                        0x08U
           =1 #define TEMPERATURE_PID_6                        0x04U
           =1 #define SAS_ANGLE_HIGH_PID_7             0x02U
           =1 #define SAS_ANGLE_LOW_PID_8                      0x01U
           =1 #define DTC_CURRENT_HIGH_PID_9           0x80U
           =1 #define DTC_CURRENT_LOW_PID_A            0x40U
           =1 #define DTC_CONFIRM_HIGH_PID_B           0x20U
           =1 #define DTC_CONFIRM_LOW_PID_C            0x10U
           =1 
           =1 #define USE_CASE_1BYTE                           0xFFU  
           =1 #define USE_CASE_2BYTE                           0xFCU
           =1 #define USE_CASE_3BYTE                           0x00U
           =1 #define USE_CASE_4BYTE                           0x00U
           =1 
           =1 #define SAS_CLEAR                                        0x00U
           =1 #define SAS_ON                                           0x01U
           =1 #define SAS_PRE_ON                                       0x02U
           =1 
           =1 #define OPTIC_SETTING                           0x00U
           =1 #define ERASE_ONESPEC                           0x01U
           =1 #define ERASE_FLASH_ALL                         0x02U
           =1 
           =1 #define CALIBRATION_MODE_START          0x00U
           =1 #define CALIBRATION_MODE_STOP           0x01U
           =1 #define CALIBRATION_MOVE_DEFAULT        0x02U
           =1 #define CALIBRATION_MOVE_LEFT           0x03U
           =1 #define CALIBRATION_MOVE_RIGHT          0x04U
           =1 #define CALIBRATION_MOVE_UP                     0x05U
           =1 #define CALIBRATION_MOVE_DOWN           0x06U
           =1 
           =1 //Calibration mode
C51 COMPILER V9.51   MGR_ISP                                                               11/17/2023 14:48:45 PAGE 123 

           =1 #define DIAG_CALIBRATION_MODE_ACTIVE(flag)      ((CalibrationMode_OnOff) = (flag))
           =1 #define DIAG_CALIBRATION_MODE_STATE                     (CalibrationMode_OnOff)
           =1 
           =1 #define DIAG_OPTIC_OFFSET_SET_ACTIVE(flag)      ((OpticOffset_Set) = (flag))
           =1 #define DIAG_OPTIC_OFFSET_SET_STATE                     (OpticOffset_Set)
           =1 
           =1 #define OPTIC_X_LIMIT_PLUS                      0x18U
           =1 #define OPTIC_X_LIMIT_MINUS                     0xE8U
           =1 #define OPTIC_Y_LIMIT_PLUS                      0x20U
           =1 #define OPTIC_Y_LIMIT_MINUS                     0xE0U
           =1 
           =1 #define IGN_CLEAR                                        0x00U
           =1 #define IGN_ON                                           0x01U
           =1 #define IGN_PRE_ON                                       0x02U
           =1 /*----------------------------------------------------*/
           =1 
           =1 /* ----- Function ------------------------------------*/
           =1 void Reset_Diag(void);
           =1 void Init_DiagTask(void);
           =1 void Operate_DiagTask(void);
           =1 
           =1 void Diag_Ecu_Reset(void);
           =1 void Diag_Clear_DTC(void);
           =1 U8   Diag_Read_Dtc(U8 index);
           =1 void Diag_DTC_Error_WT(void);
           =1 void Diag_Sensor_Reset(void);
           =1 void Diag_Guid_OnOff(U8 OnOff);
           =1 
           =1 
           =1 void Clear_DTC_Struct(void);
           =1 void Clear_DTC_Status(void);
           =1 void Record_DTC_Error(U8 ID);
           =1 void Record_DTC_Clear(U8 ID);
           =1 void Diag_Read_Sys(U8 ID, U8 *Buf,U8 Length);
           =1 void Diag_Write_Sys(U8 *Write_Buf,U8 Length);
           =1 
           =1 void Firmware_Update(void);
           =1 
           =1 void Diag_Write_Transfer_Data(U8 *Buf);
           =1 void TGT_Set_Addr (U8 *Write_Addr);
           =1 void    Diag_DTC_Set_On(void);
           =1 void    Diag_DTC_Set_Off(void);
           =1 void Flash_DTC_Write(void);
           =1 void Flash_DTC_Read(void);
           =1 void Diag_Exit_Update(void);
           =1 U16   Diag_Get_Time(void);
           =1 void SYS_Flash_Read(U8 ID,U8 *Read_Buf,U8 Length);
           =1 void Diag_Read_Address(U8 *Read_Buf, U32 DataAddr, U16 DataLen);
           =1 void Diag_Extra_Data_Process(U8 *Write_Buf);
           =1 void Diag_Eeprom_Update(void);
           =1 void Diag_Calibration_Mode_start(void);
           =1 void Diag_Calibration_Mode(U8 Ctrl_Para);
           =1 /*----------------------------------------------------*/
           =1 
           =1 /* ----- Extern Function -----------------------------*/
           =1 extern SEG_XDATA volatile tMsg_CAN_Rx_Data_s tCAN_Rx_Msg[USE_CAN_COUNT];
           =1 extern SEG_XDATA volatile U8 CalibrationMode_OnOff;
           =1 extern SEG_XDATA volatile U8 OpticOffset_Set;
           =1 /*----------------------------------------------------*/
           =1 
           =1 /* ----- Global Value --------------------------------*/
           =1 typedef struct {
C51 COMPILER V9.51   MGR_ISP                                                               11/17/2023 14:48:45 PAGE 124 

           =1         U8 Status;
           =1         U8 Count;
           =1 } tMsg_DTC_Type;
           =1 
           =1 
           =1 typedef struct {
           =1         tMsg_DTC_Type tDTC_Type[DTC_CODE_COUNT];
           =1         U8 DTC_Clear_Count[3U];
           =1         U8 DTC_State[3U];
           =1         U8 Checksum;
           =1 } tMsg_Ext_DTC_Type;
           =1 typedef struct {
           =1         U8 update_set;
           =1         U8 write_count;
           =1         U8 erase_set;
           =1         U32 total_write_cnt;
           =1         U32 write_cnt;
           =1         U32 size;       
           =1 } tMsg_Update;
           =1 extern SEG_XDATA tMsg_Ext_DTC_Type ga_Ext_tDTC_Type_Msg;
           =1 #endif
 215      =1  /*----------------------------------------------------*/
 216      =1  
 217      =1  
 218      =1  
 219      =1  
  14          
  15          /*--------------------------------------------------------------*/
  16          
  17          static SEG_XDATA U8     g_Overlay_Stauts_Loop_Check_Time;
  18          static SEG_XDATA U8     g_Guideline_OnOff = TRUE;
  19          static SEG_XDATA U8     g_Pre_Calibration_Mode = FALSE;
  20          static SEG_XDATA U8     Overlay_Guideline_flag = 0x00U;
  21          static SEG_XDATA U8     warning_msg_flag = 0x00U;
  22          static SEG_XDATA U8     Asix[3U] = {0x00U,0x00U,0x00U};
  23          SEG_XDATA volatile tMsg_ISP_Function tISP_Func_Msg;
  24          SEG_XDATA volatile U8   Optical_Axis_Data[9U] = {0x00U,0x00U,0x00U,0x00U,0x00U,0x00U,0x00U,0x00U,0x00U};
  25          
  26          static void Overlay_Guideline(S16 steering_cur, S8 sign);
  27          static U8 Sensor_ID_Check(U8 State);
  28          void DoorbellCheck( void );
  29          static void warning_msg(U8 hutype, U8 Lang);
  30          void Comm_Error_Check(void);
  31          static void Check_Isp_InitState(void);
  32          
  33          void Init_IspTask(void)
  34          {
  35   1              FLASH_Read_Buf(Optical_Axis_Data,(FLADDR)OPTIC_ADDRESS,9U,BANK2);
  36   1              if ( (Optical_Axis_Data[0U] == 0xFFU) && (Optical_Axis_Data[1U] == 0xFFU) )
  37   1              {
  38   2                      if ( Optical_Axis_Data[2U] == 0xFFU )
  39   2                      {
  40   3                              //Default
  41   3                              Optical_Axis_Data[0U] = 0x00U;
  42   3                              Optical_Axis_Data[1U] = 0x00U;
  43   3                      }
  44   2              }
  45   1      
  46   1              if ( (Optical_Axis_Data[6] == 0xFFU) && (Optical_Axis_Data[7] == 0xFFU) )
  47   1              {
  48   2                      if ( Optical_Axis_Data[8] == 0xFFU )
  49   2                      {
C51 COMPILER V9.51   MGR_ISP                                                               11/17/2023 14:48:45 PAGE 125 

  50   3                              //Default
  51   3                              Optical_Axis_Data[6] = 0x00U;
  52   3                              Optical_Axis_Data[7] = 0x00U;
  53   3                      }
  54   2              }
  55   1              Flash_OneSpec_Read();
  56   1      
  57   1              g_Pre_Calibration_Mode = FALSE;
  58   1              DIAG_CALIBRATION_MODE_ACTIVE(FALSE);
  59   1              DIAG_OPTIC_OFFSET_SET_ACTIVE(FALSE);
  60   1      
  61   1              tISP_Func_Msg.IGNSw = IGN_SW_KEY_OFF;                   // start value : 0x00
  62   1              tISP_Func_Msg.Pre_Gear = GEAR_INVALID;                  // start value : 0x09
  63   1              tISP_Func_Msg.Cur_Gear = GEAR_INVALID;
  64   1              tISP_Func_Msg.Pre_RVM_CamOff = RVM_CAMERA_INVALID;      // start value : 0x03
  65   1              tISP_Func_Msg.Cur_RVM_CamOff = RVM_CAMERA_INVALID;      // start value : 0x03
  66   1              tISP_Func_Msg.Pre_RVM_SW = FCZC_RVM_SW_OFF;                     // start value : 0x00
  67   1              tISP_Func_Msg.Cur_RVM_SW = FCZC_RVM_SW_OFF;                     // start value : 0x00
  68   1              tISP_Func_Msg.Pre_SW_IND = RVM_SW_IND_INVALID;  // start value : 0x03
  69   1              tISP_Func_Msg.Cur_SW_IND = RVM_SW_IND_INVALID;
  70   1              tISP_Func_Msg.Pre_ViewMode = RVM_VIEW_INVALID;  // start value : 0x0F
  71   1              tISP_Func_Msg.Cur_ViewMode = RVM_VIEW_INVALID;
  72   1              tISP_Func_Msg.RVM_SW_Status = FCZC_RVM_SW_OFF;
  73   1      
  74   1              g_Overlay_Stauts_Loop_Check_Time = FALSE;
  75   1      
  76   1              Isp_InterInit();
  77   1      }
  78          /*
  79          static U8 Sensor_ID_Check(U8 State)
  80          {
  81                  SEG_XDATA U16 sensor_Id = 0x00U;
  82                  SEG_XDATA U8 ret = 0x00U;
  83                  sensor_Id = Comm_I2C_Rx(ISP_SLAVE_ADDRESS,I2C_2BYTE_RW,(U16)0x00U,(U16)0x00,(U16)0x00);
  84                  if(1)//sensor_Id == 0x0242U
  85                  {
  86                          ret = TRUE;
  87                          if ( State == SENSOR_RUNNING )
  88                          {
  89                                  DTC_ISP_CM_CLEAR;
  90                          }
  91                  }
  92                  else
  93                  {
  94                          ret = FALSE;
  95                          if ( State == SENSOR_RUNNING )
  96                          {
  97                                  DTC_ISP_CM_ERROR;
  98                          }
  99          
 100                  }
 101                  
 102                  if ( g_I2C_Err_Cnt > 0x00U )
 103                  {
 104                          g_I2C_Err_Cnt = 0x00U ;
 105                          ret = FALSE;
 106                  }
 107                  ret = TRUE;
 108                  return ret;
 109          }*/
 110          
 111          void Isp_InterInit(void)
C51 COMPILER V9.51   MGR_ISP                                                               11/17/2023 14:48:45 PAGE 126 

 112          {       
 113   1              SEG_XDATA U16 count = 0x00U;
 114   1              SEG_XDATA U8 ret = 0x00U;
 115   1      
 116   1              Device_Init(APTINA_AP0100);
 117   1      
 118   1              Comm_Tx_RVM_View(RVM_VIEW_INVALID);
 119   1              Comm_Tx_RVM_SW_IND(RVM_SW_IND_INVALID);
 120   1              tISP_Func_Msg.Pre_ViewMode = RVM_VIEW_INVALID;
 121   1              tISP_Func_Msg.Pre_SW_IND = RVM_SW_IND_INVALID;
 122   1      
 123   1              Check_Isp_InitState();
 124   1      
 125   1              Asix[0] = Optical_Axis_Data[0] + Optical_Axis_Data[6];
 126   1              Asix[1] = Optical_Axis_Data[1] + Optical_Axis_Data[7];
 127   1      
 128   1              Sensor_XY_Offset_set(Asix[0],Asix[1]);
 129   1              //Wait_ms(10U);
 130   1              Fixed_Guidline_On(RVM_PARKING_ASSIST_VIEW);
 131   1              Wait_ms(10U);
 132   1      
 133   1              if ( tCAN_Rx_Msg[USE_LANGUAGEINFO].Pre_Data != 0xFFU )
 134   1              {
 135   2                      warning_msg(tCAN_Rx_Msg[USE_HUTYPE].Pre_Data,tCAN_Rx_Msg[USE_LANGUAGEINFO].Pre_Data);
 136   2                      Wait_ms(10U);
 137   2              }
 138   1      
 139   1              Overlay_Guideline((S16)0x00,(S8)0x00);
 140   1              //Comm_Tuning_Value_Type(tCAN_Rx_Msg[USE_4WDERR].Pre_Data, tCAN_Rx_Msg[USE_ENGVOL].Pre_Data); //ENG_ONESP
             -EC
 141   1              Wait_ms(10U);
 142   1              Frame_Sync_Status();
 143   1              Delay_Time_Set(TID_OVERLAY_GUIDELINE,DT_OVERLAY_GUIDELINE);
 144   1              Delay_Time_Set(TID_FRAME_VALIDE,DT_FRAME_VALIDE);
 145   1              Delay_Time_Set(TID_FRAME_COUNT,DT_FRAME_COUNT);
 146   1              Delay_Time_Set(TID_I2C_COMM_CHECK,DT_I2C_COMM_CHECK);
 147   1              //DTC_ISP_IT_CLEAR;
 148   1      }
 149          
 150          void Operate_IspTask(void)
 151          {
 152   1              SEG_XDATA U8 On_Time;
 153   1              SEG_XDATA U8 ret;
 154   1      
 155   1              if (/*(DIAG_CALIBRATION_MODE_STATE == TRUE) && */(DIAG_OPTIC_OFFSET_SET_STATE == TRUE))
 156   1              {
 157   2                      DIAG_OPTIC_OFFSET_SET_ACTIVE(FALSE);
 158   2      
 159   2                      Asix[0] = Optical_Axis_Data[0] + Optical_Axis_Data[6];
 160   2                      Asix[1] = Optical_Axis_Data[1] + Optical_Axis_Data[7];
 161   2      
 162   2                      Sensor_XY_Offset_set(Asix[0],Asix[1]);
 163   2              }
 164   1      
 165   1              if ((g_Pre_Calibration_Mode == FALSE) && (DIAG_CALIBRATION_MODE_STATE == TRUE))
 166   1              {
 167   2                      g_Pre_Calibration_Mode = TRUE;
 168   2                      warning_msg((U8)0x00,(U8)0x00);
 169   2                      Wait_ms(10U);
 170   2              }
 171   1      
 172   1              Comm_RearView_Data();
C51 COMPILER V9.51   MGR_ISP                                                               11/17/2023 14:48:45 PAGE 127 

 173   1              if ((tISP_Func_Msg.Pre_ViewMode != tISP_Func_Msg.Cur_ViewMode) || (tISP_Func_Msg.Pre_SW_IND != tISP_Func_
             -Msg.Cur_SW_IND))
 174   1              {
 175   2                      Comm_Tx_RVM_View(tISP_Func_Msg.Cur_ViewMode);
 176   2                      Comm_Tx_RVM_SW_IND(tISP_Func_Msg.Cur_SW_IND);
 177   2      
 178   2                      if ((tISP_Func_Msg.Pre_ViewMode == RVM_DRIVING_ASSIST_VIEW) || (tISP_Func_Msg.Cur_ViewMode == RVM_DRIVIN
             -G_ASSIST_VIEW))
 179   2                      {
 180   3                              Isp_View_Mode_Change(tISP_Func_Msg.Cur_ViewMode);
 181   3                      }
 182   2                      tISP_Func_Msg.Pre_ViewMode = tISP_Func_Msg.Cur_ViewMode;
 183   2                      tISP_Func_Msg.Pre_SW_IND = tISP_Func_Msg.Cur_SW_IND;
 184   2              }
 185   1      
 186   1              if ( ga_Ext_tDTC_Type_Msg.tDTC_Type[DTC_SENSOR_COMM_ERR].Status != DTC_CURRENT_ERROR )
 187   1              {               
 188   2                      if (tISP_Func_Msg.Pre_ViewMode == RVM_DRIVING_ASSIST_VIEW)
 189   2                      {
 190   3                              Isp_Driving_Assist_View();
 191   3                      }
 192   2                      else
 193   2                      {
 194   3                              Isp_Parking_Assist_View();
 195   3                      }
 196   2              }
 197   1              //STATUS LOOP CHECK 
 198   1              On_Time = Delay_Time_Get(TID_CHECKSTATUS_LOOP);
 199   1              if ( On_Time == TRUE)
 200   1              {
 201   2                      ret = CheckCommandStatusLoop();
 202   2                      if ( ret == FALSE )
 203   2                      {
 204   3                              g_Overlay_Stauts_Loop_Check_Time = TRUE;
 205   3                              DTC_ISP_IS_ERROR;
 206   3                      }
 207   2                      else if ( ret == TRUE)
 208   2                      {
 209   3                              g_Overlay_Stauts_Loop_Check_Time = TRUE;
 210   3                              DTC_ISP_IS_CLEAR;
 211   3                      }
 212   2                      else
 213   2                      {
 214   3                              g_Overlay_Stauts_Loop_Check_Time = FALSE;
 215   3                      }
 216   2              }
 217   1      }
 218          
 219          void Isp_Parking_Assist_View(void)
 220          {
 221   1              SEG_XDATA U8 Sas_Data[2] = {0x00U, };
 222   1              SEG_XDATA U8 HU_Type_Data = 0x00U;
 223   1              SEG_XDATA U8 Language_Data = 0x00U;
 224   1              SEG_XDATA U8 On_Time;
 225   1              SEG_XDATA U8 ret;
 226   1              static SEG_XDATA volatile U8 overlay_flag = 0x00U;
 227   1      
 228   1      
 229   1              if ( g_Guideline_OnOff == TRUE )
 230   1              {
 231   2                      On_Time = Delay_Time_Get(TID_OVERLAY_GUIDELINE);
 232   2                      if( On_Time == TRUE)
C51 COMPILER V9.51   MGR_ISP                                                               11/17/2023 14:48:45 PAGE 128 

 233   2                      {
 234   3                              if (DIAG_CALIBRATION_MODE_STATE == FALSE)
 235   3                              {
 236   4                                      ret = Comm_Sas_Data(Sas_Data);
 237   4                                      HU_Type_Data = tCAN_Rx_Msg[USE_HUTYPE].Pre_Data;
 238   4                                      Language_Data = tCAN_Rx_Msg[USE_LANGUAGEINFO].Pre_Data;
 239   4                              }
 240   3                              else
 241   3                              {
 242   4                                      Sas_Data[0] = 0x00U;
 243   4                                      HU_Type_Data = 0x00U;
 244   4                                      Language_Data = 0x00U;
 245   4                              }
 246   3      
 247   3                              if (overlay_flag == 100U)
 248   3                              {
 249   4                                      Fixed_Guidline_On(RVM_PARKING_ASSIST_VIEW);
 250   4                                      //Wait_ms(40U);
 251   4                                      overlay_flag++;
 252   4                              }                       
 253   3                              else if (overlay_flag == 200U)
 254   3                              {
 255   4                                      if ( tCAN_Rx_Msg[USE_LANGUAGEINFO].Pre_Data != 0xFFU )
 256   4                                      {
 257   5                                              warning_msg((U8)HU_Type_Data, (U8)Language_Data);
 258   5                                              //Wait_ms(40U);
 259   5                                      }
 260   4                                      overlay_flag = 0x00;
 261   4                              }
 262   3                              else
 263   3                              {
 264   4                                      Overlay_Guideline((S16)Sas_Data[0],(S8)Sas_Data[1]);
 265   4                                      overlay_flag++;
 266   4                              }
 267   3                      }
 268   2              }
 269   1              else
 270   1              {
 271   2                      Overlay_Guideline((S16)0x00,(S8)0x00);
 272   2              }
 273   1      
 274   1              if (DIAG_CALIBRATION_MODE_STATE == FALSE)
 275   1              {
 276   2                      if ((tCAN_Rx_Msg[USE_LANGUAGEINFO].Is_Change == TRUE ) ||  (tCAN_Rx_Msg[USE_HUTYPE].Is_Change == TRUE ))
 277   2                      {
 278   3                              tCAN_Rx_Msg[USE_LANGUAGEINFO].Is_Change = FALSE;
 279   3                              tCAN_Rx_Msg[USE_HUTYPE].Is_Change = FALSE;
 280   3                              if( tCAN_Rx_Msg[USE_LANGUAGEINFO].Pre_Data != CAN_LAN_INVALID_ADDR )
 281   3                              {
 282   4                                      Flash_OneSpec_Write();
 283   4                              }
 284   3                              warning_msg(tCAN_Rx_Msg[USE_HUTYPE].Pre_Data,tCAN_Rx_Msg[USE_LANGUAGEINFO].Pre_Data);
 285   3                              Wait_ms(10U); // Need fixed delay
 286   3                      }
 287   2                      
 288   2                      if (g_Pre_Calibration_Mode == TRUE)
 289   2                      {
 290   3                              g_Pre_Calibration_Mode = FALSE;
 291   3                      }
 292   2              }
 293   1      }
 294          
C51 COMPILER V9.51   MGR_ISP                                                               11/17/2023 14:48:45 PAGE 129 

 295          void Isp_Driving_Assist_View(void)
 296          {
 297   1              static SEG_XDATA volatile U8 overlay_flag = 0x00U;
 298   1              SEG_XDATA U8 On_Time;
 299   1      
 300   1              On_Time = Delay_Time_Get(TID_OVERLAY_GUIDELINE);
 301   1              if( On_Time == TRUE)
 302   1              {
 303   2                      if (overlay_flag >= 100U)
 304   2                      {
 305   3                              Fixed_Guidline_On(RVM_DRIVING_ASSIST_VIEW);
 306   3                              overlay_flag = 0U;
 307   3                      }
 308   2      
 309   2                      overlay_flag++;
 310   2              }
 311   1      }
 312          
 313          void Isp_View_Mode_Change(volatile U8 ViewMode)
 314          {
 315   1              static SEG_XDATA U16 read_data = 0U, chk_Buffer= 0U;
 316   1              U8 i = 0U;
 317   1      
 318   1              DoorbellCheck();
 319   1              //Wait_ms(100U);
 320   1      
 321   1              // Draw black Image in Layer0
 322   1              Comm_I2C_Tx(ISP_SLAVE_ADDRESS,I2C_2BYTE_RW,(U16)CMD_PARAM_POOL_0_ADDR,(U16)EXTRA_BUFFER0_DATA,(U16)0x00);
 323   1              Comm_I2C_Tx(ISP_SLAVE_ADDRESS,I2C_2BYTE_RW,(U16)CMD_PARAM_POOL_2_ADDR,(U16)MEM_BLACK_IMAGE_ADDR,(U16)0x00
             -);
 324   1              Comm_I2C_Tx(ISP_SLAVE_ADDRESS,I2C_2BYTE_RW,(U16)CMD_PARAM_POOL_4_ADDR,(U16)OVRL_ENABLE_DATA,(U16)0x00);
 325   1              Comm_I2C_Tx(ISP_SLAVE_ADDRESS,I2C_2BYTE_RW,(U16)CMD_REGISTER_ADDR,(U16)CMD_OVRL_LOAD_BUFFER,(U16)0x00);
 326   1              DoorbellCheck();
 327   1      
 328   1              // Disable OSD (warning msg, guideline)
 329   1              if (ViewMode == RVM_DRIVING_ASSIST_VIEW)
 330   1              {
 331   2                      Comm_I2C_Tx(ISP_SLAVE_ADDRESS,I2C_2BYTE_RW,(U16)CMD_PARAM_POOL_0_ADDR,(U16)OVR_LAYER1_DATA,(U16)0x00);
 332   2                      Comm_I2C_Tx(ISP_SLAVE_ADDRESS,I2C_2BYTE_RW,(U16)CMD_PARAM_POOL_2_ADDR,(U16)0x0000,(U16)0x00);
 333   2                      Comm_I2C_Tx(ISP_SLAVE_ADDRESS,I2C_2BYTE_RW,(U16)CMD_REGISTER_ADDR,(U16)0x820AU,(U16)0x00);
 334   2                      DoorbellCheck();
 335   2                      Comm_I2C_Tx(ISP_SLAVE_ADDRESS,I2C_2BYTE_RW,(U16)CMD_PARAM_POOL_0_ADDR,(U16)OVR_LAYER2_DATA,(U16)0x00);
 336   2                      Comm_I2C_Tx(ISP_SLAVE_ADDRESS,I2C_2BYTE_RW,(U16)CMD_PARAM_POOL_2_ADDR,(U16)0x0000,(U16)0x00);
 337   2                      Comm_I2C_Tx(ISP_SLAVE_ADDRESS,I2C_2BYTE_RW,(U16)CMD_REGISTER_ADDR,(U16)0x820AU,(U16)0x00);
 338   2                      DoorbellCheck();
 339   2                      //read Layer status and retry
 340   2                      
 341   2                      chk_Buffer = Comm_I2C_Rx(ISP_SLAVE_ADDRESS,I2C_2BYTE_RW,(U16)CHECKING_LAYER0_DATA,(U16)0x00,(U16)0x00);
 342   2                      if (chk_Buffer != 0)
 343   2                      {
 344   3                              Comm_I2C_Tx(ISP_SLAVE_ADDRESS,I2C_2BYTE_RW,(U16)CMD_PARAM_POOL_0_ADDR,(U16)OVR_LAYER1_DATA,(U16)0x00);
 345   3                              Comm_I2C_Tx(ISP_SLAVE_ADDRESS,I2C_2BYTE_RW,(U16)CMD_PARAM_POOL_2_ADDR,(U16)0x0000,(U16)0x00);
 346   3                              Comm_I2C_Tx(ISP_SLAVE_ADDRESS,I2C_2BYTE_RW,(U16)CMD_REGISTER_ADDR,(U16)0x820AU,(U16)0x00);
 347   3                              DoorbellCheck();
 348   3                      }
 349   2                      chk_Buffer = Comm_I2C_Rx(ISP_SLAVE_ADDRESS,I2C_2BYTE_RW,(U16)CHECKING_LAYER1_DATA,(U16)0x00,(U16)0x00);
 350   2                      if (chk_Buffer != 0)
 351   2                      {
 352   3                              Comm_I2C_Tx(ISP_SLAVE_ADDRESS,I2C_2BYTE_RW,(U16)CMD_PARAM_POOL_0_ADDR,(U16)OVR_LAYER2_DATA,(U16)0x00);
 353   3                              Comm_I2C_Tx(ISP_SLAVE_ADDRESS,I2C_2BYTE_RW,(U16)CMD_PARAM_POOL_2_ADDR,(U16)0x0000,(U16)0x00);
 354   3                              Comm_I2C_Tx(ISP_SLAVE_ADDRESS,I2C_2BYTE_RW,(U16)CMD_REGISTER_ADDR,(U16)0x820AU,(U16)0x00);
 355   3                              DoorbellCheck();
C51 COMPILER V9.51   MGR_ISP                                                               11/17/2023 14:48:45 PAGE 130 

 356   3                      }
 357   2              }       
 358   1      
 359   1              // Draw fixed guideline
 360   1              if (ViewMode == RVM_DRIVING_ASSIST_VIEW)
 361   1              {
 362   2                      Fixed_Guidline_On(RVM_DRIVING_ASSIST_VIEW);
 363   2              }
 364   1              else
 365   1              {
 366   2                      Fixed_Guidline_On(RVM_PARKING_ASSIST_VIEW);
 367   2                      if ( tCAN_Rx_Msg[USE_LANGUAGEINFO].Pre_Data != 0xFFU )
 368   2                      {
 369   3                              warning_msg(tCAN_Rx_Msg[USE_HUTYPE].Pre_Data,tCAN_Rx_Msg[USE_LANGUAGEINFO].Pre_Data);
 370   3                      }
 371   2              }
 372   1      
 373   1              // STE load
 374   1              Comm_I2C_Tx(ISP_SLAVE_ADDRESS,I2C_2BYTE_RW,(U16)0x098EU,(U16)0x7C00U,(U16)0x00);
 375   1              if (ViewMode == RVM_DRIVING_ASSIST_VIEW)
 376   1              {
 377   2                      Comm_I2C_Tx(ISP_SLAVE_ADDRESS,I2C_2BYTE_RW,(U16)0xfc00U,(U16)0x0001U,(U16)0x00);
 378   2              }
 379   1              else
 380   1              {
 381   2                      Comm_I2C_Tx(ISP_SLAVE_ADDRESS,I2C_2BYTE_RW,(U16)0xfc00U,(U16)0x0000U,(U16)0x00);
 382   2              }
 383   1              Comm_I2C_Tx(ISP_SLAVE_ADDRESS,I2C_2BYTE_RW,(U16)0x0040U,(U16)0x8311U,(U16)0x00);
 384   1      
 385   1              DoorbellCheck();
 386   1              while(1)
 387   1              {
 388   2                      Comm_I2C_Tx(ISP_SLAVE_ADDRESS,I2C_2BYTE_RW,(U16)0x0040U,(U16)0x8101U,(U16)0x00);
 389   2                      Wait_ms(10U);
 390   2                      read_data = Comm_I2C_Rx(ISP_SLAVE_ADDRESS,I2C_2BYTE_RW,(U16)0x0040U,(U16)0x00,(U16)0x00);
 391   2                      if ( read_data != (U16)0x0009 )
 392   2                      {
 393   3                              break;
 394   3                      }
 395   2                      DoorbellCheck();
 396   2              }
 397   1      
 398   1              // Change config
 399   1              Comm_I2C_Tx(ISP_SLAVE_ADDRESS,I2C_2BYTE_RW,(U16)0xfc00U,(U16)0x2800U,(U16)0x00);
 400   1              Comm_I2C_Tx(ISP_SLAVE_ADDRESS,I2C_2BYTE_RW,(U16)0x0040U,(U16)0x8100U,(U16)0x00);
 401   1              DoorbellCheck();
 402   1              Comm_I2C_Tx(ISP_SLAVE_ADDRESS,I2C_2BYTE_RW,(U16)0xfc00U,(U16)0x2800U,(U16)0x00);
 403   1              Comm_I2C_Tx(ISP_SLAVE_ADDRESS,I2C_2BYTE_RW,(U16)0x0040U,(U16)0x8100U,(U16)0x00);
 404   1              DoorbellCheck();
 405   1              Comm_I2C_Tx(ISP_SLAVE_ADDRESS,I2C_2BYTE_RW,(U16)0x0040U,(U16)0x8101U,(U16)0x00);
 406   1      
 407   1              // Disable Layer0 (black image)
 408   1              Comm_I2C_Tx(ISP_SLAVE_ADDRESS,I2C_2BYTE_RW,(U16)CMD_PARAM_POOL_0_ADDR,(U16)OVR_LAYER0_DATA,(U16)0x00);
 409   1              Comm_I2C_Tx(ISP_SLAVE_ADDRESS,I2C_2BYTE_RW,(U16)CMD_PARAM_POOL_2_ADDR,(U16)0x0000,(U16)0x00);
 410   1              Comm_I2C_Tx(ISP_SLAVE_ADDRESS,I2C_2BYTE_RW,(U16)CMD_REGISTER_ADDR,(U16)0x820AU,(U16)0x00);
 411   1              DoorbellCheck();
 412   1      
 413   1              chk_Buffer = Comm_I2C_Rx(ISP_SLAVE_ADDRESS,I2C_2BYTE_RW,(U16)CHECKING_LAYER0_DATA,(U16)0x00,(U16)0x00);
 414   1              if (chk_Buffer != 0)
 415   1              {
 416   2                      Comm_I2C_Tx(ISP_SLAVE_ADDRESS,I2C_2BYTE_RW,(U16)CMD_PARAM_POOL_0_ADDR,(U16)OVR_LAYER0_DATA,(U16)0x00);
 417   2                      Comm_I2C_Tx(ISP_SLAVE_ADDRESS,I2C_2BYTE_RW,(U16)CMD_PARAM_POOL_2_ADDR,(U16)0x0000,(U16)0x00);
C51 COMPILER V9.51   MGR_ISP                                                               11/17/2023 14:48:45 PAGE 131 

 418   2                      Comm_I2C_Tx(ISP_SLAVE_ADDRESS,I2C_2BYTE_RW,(U16)CMD_REGISTER_ADDR,(U16)0x820AU,(U16)0x00);
 419   2                      DoorbellCheck();
 420   2              }
 421   1      
 422   1              //Wait_ms(100U);
 423   1      
 424   1              for (i = DTC_SENSOR_FV_ERR; i < DTC_CODE_COUNT; i++)
 425   1              {
 426   2                      ga_Ext_tDTC_Type_Msg.tDTC_Type[i].Count = 0x00U;
 427   2              }
 428   1      }
 429          
 430          void V_STB_Check(void)
 431          {
 432   1              SEG_XDATA U8 ret = FALSE;
 433   1              static SEG_XDATA U8 v_stb_error_count = 0x00U;
 434   1              static SEG_XDATA U8 v_stb_nomal_count = 0x00U;
 435   1      
 436   1              ret = (U8)AMP_V_STB;
 437   1              if ( ret == TRUE )
 438   1              {
 439   2                      v_stb_nomal_count = 0x00U;
 440   2                      v_stb_error_count++;
 441   2                      if ( v_stb_error_count >= 20U)  //2s
 442   2                      {
 443   3                              DTC_VID_VO_ERROR;
 444   3                              v_stb_error_count = 0x00U;
 445   3                      }
 446   2              }
 447   1              else
 448   1              {
 449   2                      v_stb_error_count = 0x00U;
 450   2                      v_stb_nomal_count++;
 451   2                      if ( v_stb_nomal_count >= 20U)  //2s
 452   2                      {
 453   3                              DTC_VID_VO_CLEAR;
 454   3                              v_stb_nomal_count = 0x00U;
 455   3                      }
 456   2              }
 457   1      }
 458          
 459          void Check_Isp_InitState(void)
 460          {
 461   1              static SEG_XDATA U16 chk_data = 0x0000U;
 462   1              static SEG_XDATA U8 lpcn = 0x00U;
 463   1              //SEG_XDATA U8 rcv_data = FALSE;
 464   1              SEG_XDATA volatile U8 Ret_State = FALSE;
 465   1              lpcn = 0;
 466   1              Comm_I2C_Tx(ISP_SLAVE_ADDRESS,I2C_2BYTE_RW,(U16)CMD_REGISTER_ADDR,(U16)CMD_GET_STATE,(U16)0x00);
 467   1              while(1)
 468   1              {
 469   2                      chk_data = Comm_I2C_Rx(ISP_SLAVE_ADDRESS,I2C_2BYTE_RW,(U16)CMD_REGISTER_ADDR,(U16)0x00,(U16)0x00);
 470   2                      if( (chk_data & 0x8000U) == 0x0000U )
 471   2                      {
 472   3                              chk_data = Comm_I2C_Rx(ISP_SLAVE_ADDRESS,I2C_2BYTE_RW,(U16)CMD_PARAM_POOL_0_ADDR,(U16)0x00,(U16)0x00);
 473   3                              chk_data &= 0xFF00U;
 474   3                              lpcn++;
 475   3                              if ( (lpcn >= 15U) || (chk_data == SENSOR_STATE_STREAMING))
 476   3                              {
 477   4                                      if ( lpcn >= 15U )
 478   4                                      {
 479   5                                              DTC_ISP_IT_ERROR;
C51 COMPILER V9.51   MGR_ISP                                                               11/17/2023 14:48:45 PAGE 132 

 480   5                                      }
 481   4                                      else
 482   4                                      {
 483   5                                              DTC_ISP_IT_CLEAR;
 484   5                                      }               
 485   4                                      break;
 486   4                              }
 487   3                              Wait_ms(20U);
 488   3                      }
 489   2      
 490   2              }
 491   1              lpcn = 0;
 492   1      }
 493          
 494          void Frame_Count_Check(void)
 495          {
 496   1              static SEG_XDATA U16 Cur_FC_Data = (U16)0x00U;
 497   1              static SEG_XDATA U16 Pre_FC_Data = (U16)0x00U;
 498   1      
 499   1              Cur_FC_Data = Comm_I2C_Rx(ISP_SLAVE_ADDRESS,I2C_2BYTE_RW,(U16)AP0100_FRAME_COUNT_REGISTER,(U16)0x00,(U16)
             -0x00);
 500   1      
 501   1              if( Pre_FC_Data == Cur_FC_Data )
 502   1              {
 503   2                      DTC_ISP_FC_ERROR;
 504   2              }
 505   1              else
 506   1              {
 507   2                      DTC_ISP_FC_CLEAR;
 508   2                      Pre_FC_Data = Cur_FC_Data;
 509   2              }
 510   1      }
 511          
 512          void Frame_Valide_Check(void)
 513          {
 514   1              SEG_XDATA U8 volatile Frame_value = 0U;
 515   1              Frame_value = Frame_Sync_Status();
 516   1      
 517   1              if ( (Frame_value >= 2U) && (Frame_value < 4U))
 518   1              {
 519   2                      DTC_ISP_FV_CLEAR;
 520   2              }
 521   1              else 
 522   1              {
 523   2                      DTC_ISP_FV_ERROR;
 524   2              }
 525   1      }
 526          
 527          void Video_Signal_Check(void)
 528          {
 529   1              SEG_XDATA U8 ret = TRUE;
 530   1              static SEG_XDATA U8 video_error_count = 0x00U;
 531   1              static SEG_XDATA U8 video_nomal_count = 0x00U;
 532   1      
 533   1              // ADC
 534   1              ret = Get_Video_Signal();
 535   1              if ( ret == FALSE )
 536   1              {
 537   2                      video_nomal_count = 0x00U;
 538   2                      video_error_count++;
 539   2                      if ( video_error_count >= 20U)  //2s
 540   2                      {
C51 COMPILER V9.51   MGR_ISP                                                               11/17/2023 14:48:45 PAGE 133 

 541   3                              DTC_VID_OC_ERROR;
 542   3                              video_error_count = 0x00U;
 543   3                      }
 544   2              }
 545   1              else
 546   1              {
 547   2                      video_error_count = 0x00U;
 548   2                      video_nomal_count++;
 549   2                      if ( video_nomal_count >= 20U)  //2s
 550   2                      {
 551   3                              DTC_VID_OC_CLEAR;
 552   3                              video_nomal_count = 0x00U;
 553   3                      }
 554   2              }
 555   1      }
 556          
 557          void DoorbellCheck( void )
 558          {
 559   1              SEG_XDATA U8 On_Time = FALSE;
 560   1              SEG_DATA U16 chk_data = 0x8000U;
 561   1              SEG_DATA U8 lpcnt = 0x00U;
 562   1      
 563   1              Delay_Time_Set(TID_DOORBELL_CHECK, DT_DOORBELL_CHECK);
 564   1              do
 565   1              {
 566   2                      On_Time = Delay_Time_Get(TID_DOORBELL_CHECK);
 567   2                      if ( On_Time == TRUE)
 568   2                      {
 569   3                              lpcnt++;
 570   3                               // Wait_ms(10U);
 571   3                              chk_data = Comm_I2C_Rx(ISP_SLAVE_ADDRESS,I2C_2BYTE_RW,(U16)0x0040U,(U16)0x00,(U16)0x00);
 572   3                              WDT_Clear();
 573   3                      }
 574   2              }
 575   1              while ( ((chk_data & 0x8000U) == 0x8000U) && (lpcnt < (U8)10) );
 576   1      
 577   1              Delay_Time_Expire(TID_DOORBELL_CHECK);
 578   1      }
 579          
 580          static void Overlay_Guideline(S16 steering_cur, S8 sign)
 581          {
 582   1              SEG_DATA volatile U16 read_data = 0x0000U;
 583   1              //SEG_XDATA S8  = 0;
 584   1      
 585   1              DoorbellCheck();
 586   1      
 587   1              if(sign == 0)
 588   1              {
 589   2                      steering_cur = -steering_cur;
 590   2              }
 591   1      
 592   1              steering_cur = (S16)NORMAL_3M_GUIDE_LINE_ADDR + (S16)STEERING_ANGLE_LIMIT + steering_cur;
 593   1      
 594   1              if(Overlay_Guideline_flag == 0){
 595   2                      //i2c_master_write( (U16)CMD_PARAM_POOL_0_ADDR, (U16)GUIDELINE_BUFFER2_DATA );
 596   2                      Comm_I2C_Tx(ISP_SLAVE_ADDRESS,I2C_2BYTE_RW,(U16)CMD_PARAM_POOL_0_ADDR,(U16)GUIDELINE_BUFFER2_DATA,(U16)0
             -x00);
 597   2                      Overlay_Guideline_flag = 1;
 598   2              }
 599   1              else{
 600   2                      //i2c_master_write( (U16)CMD_PARAM_POOL_0_ADDR, (U16)GUIDELINE_BUFFER3_DATA );
 601   2                      Comm_I2C_Tx(ISP_SLAVE_ADDRESS,I2C_2BYTE_RW,(U16)CMD_PARAM_POOL_0_ADDR,(U16)GUIDELINE_BUFFER3_DATA,(U16)0
C51 COMPILER V9.51   MGR_ISP                                                               11/17/2023 14:48:45 PAGE 134 

             -x00);
 602   2                      Overlay_Guideline_flag = 0;
 603   2              }       
 604   1      
 605   1              Comm_I2C_Tx(ISP_SLAVE_ADDRESS,I2C_2BYTE_RW,(U16)CMD_PARAM_POOL_2_ADDR,(U16)steering_cur,(U16)0x00);
 606   1              if ( g_Guideline_OnOff == TRUE)
 607   1              {
 608   2                      Comm_I2C_Tx(ISP_SLAVE_ADDRESS,I2C_2BYTE_RW,(U16)CMD_PARAM_POOL_4_ADDR,(U16)OVRL_ENABLE_DATA,(U16)0x00);
 609   2              }
 610   1              else
 611   1              {
 612   2                      Comm_I2C_Tx(ISP_SLAVE_ADDRESS,I2C_2BYTE_RW,(U16)CMD_PARAM_POOL_4_ADDR,(U16)OVRL_DISABLE_DATA,(U16)0x00);
 613   2              }
 614   1              WDT_Clear();
 615   1              Comm_I2C_Tx(ISP_SLAVE_ADDRESS,I2C_2BYTE_RW,(U16)CMD_REGISTER_ADDR,(U16)CMD_OVRL_LOAD_BUFFER,(U16)0x00); 
 616   1              g_Overlay_Stauts_Loop_Check_Time = FALSE;
 617   1              //Delay_Time_Set(TID_CHECKSTATUS_LOOP,DT_CHECKSTATUS_LOOP);
 618   1      
 619   1              DoorbellCheck();
 620   1      }
 621          
 622          /***********************************
 623           **  Check for command status
 624           ***********************************/
 625          U8 CheckCommandStatusLoop( void )
 626          {
 627   1              static SEG_XDATA U16 chk_data = 0x0000;
 628   1              static SEG_XDATA U8 lpcnt = 0;
 629   1              SEG_XDATA U8 ret = TRUE;
 630   1              
 631   1              lpcnt++;
 632   1              //chk_data = i2c_master_read( (U16)CMD_REGISTER_ADDR );
 633   1              chk_data = Comm_I2C_Rx(ISP_SLAVE_ADDRESS,I2C_2BYTE_RW,(U16)CMD_REGISTER_ADDR,(U16)0x00,(U16)0x00);
 634   1              if( (chk_data & 0x8000U) == 0x0000U )
 635   1              {
 636   2                      ret = TRUE;
 637   2                      lpcnt = 0x00U;
 638   2                      Delay_Time_Expire(TID_CHECKSTATUS_LOOP);
 639   2                      WDT_Clear();
 640   2              }       
 641   1              else
 642   1              {
 643   2                      if ( lpcnt >= 5U )
 644   2                      {
 645   3      #ifndef DIAG_TEST_MCU_WD_ERR
 646   3                      WDT_Clear();
 647   3      #endif
 648   3                              ret = FALSE;
 649   3                              lpcnt = 0x00U;
 650   3                              Delay_Time_Expire(TID_CHECKSTATUS_LOOP);
 651   3                      }
 652   2                      else
 653   2                      {
 654   3                              ret = 0x03U;            //is confirmimg
 655   3                      }
 656   2              }
 657   1              return ret;
 658   1      }
 659          
 660          void Guidline_Off(void)
 661          {
 662   1              Comm_I2C_Tx(ISP_SLAVE_ADDRESS,I2C_2BYTE_RW,(U16)CMD_PARAM_POOL_4_ADDR,(U16)OVRL_DISABLE_DATA,(U16)0x00);
C51 COMPILER V9.51   MGR_ISP                                                               11/17/2023 14:48:45 PAGE 135 

 663   1              Comm_I2C_Tx(ISP_SLAVE_ADDRESS,I2C_2BYTE_RW,(U16)CMD_REGISTER_ADDR,(U16)CMD_OVRL_LOAD_BUFFER,(U16)0x00); 
 664   1              g_Guideline_OnOff = FALSE;
 665   1      }
 666          
 667          void Guidline_On(void)
 668          {
 669   1              Comm_I2C_Tx(ISP_SLAVE_ADDRESS,I2C_2BYTE_RW,(U16)CMD_PARAM_POOL_4_ADDR,(U16)OVRL_ENABLE_DATA,(U16)0x00);
 670   1              Comm_I2C_Tx(ISP_SLAVE_ADDRESS,I2C_2BYTE_RW,(U16)CMD_REGISTER_ADDR,(U16)CMD_OVRL_LOAD_BUFFER,(U16)0x00); 
 671   1              g_Guideline_OnOff = TRUE;
 672   1      }
 673          
 674          void Isp_Off(void)
 675          {
 676   1              MCU_SENSOR_RESET = 0x00;
 677   1      }
 678          
 679          void Isp_On(void)
 680          {
 681   1              Init_IspTask();
 682   1      }
 683          
 684          void Fixed_Guidline_On(const U8 ViewMode)
 685          {
 686   1              static SEG_XDATA S8 overlay_buffer_flag = 0;
 687   1      
 688   1              DoorbellCheck();
 689   1      
 690   1              if ( overlay_buffer_flag == 0x00U)
 691   1              {
 692   2                      Comm_I2C_Tx(ISP_SLAVE_ADDRESS,I2C_2BYTE_RW,(U16)CMD_PARAM_POOL_0_ADDR,(U16)FIXED_GUIDELINE_BUFFER4_DATA,
             -(U16)0x00);
 693   2                      overlay_buffer_flag = 0x01U;
 694   2              }
 695   1              else
 696   1              {
 697   2                      Comm_I2C_Tx(ISP_SLAVE_ADDRESS,I2C_2BYTE_RW,(U16)CMD_PARAM_POOL_0_ADDR,(U16)FIXED_GUIDELINE_BUFFER5_DATA,
             -(U16)0x00);
 698   2                      overlay_buffer_flag = 0x00U;
 699   2              }
 700   1              if (ViewMode == RVM_DRIVING_ASSIST_VIEW)
 701   1              {
 702   2                      Comm_I2C_Tx(ISP_SLAVE_ADDRESS,I2C_2BYTE_RW,(U16)CMD_PARAM_POOL_2_ADDR,(U16)MEM_FIXED_GUIDE_ADDR_D,(U16)0
             -x00);
 703   2              }
 704   1              else
 705   1              {
 706   2                      Comm_I2C_Tx(ISP_SLAVE_ADDRESS,I2C_2BYTE_RW,(U16)CMD_PARAM_POOL_2_ADDR,(U16)MEM_FIXED_GUIDE_ADDR,(U16)0x0
             -0);
 707   2              }
 708   1              if (g_Guideline_OnOff == TRUE)
 709   1              {
 710   2                      Comm_I2C_Tx(ISP_SLAVE_ADDRESS,I2C_2BYTE_RW,(U16)CMD_PARAM_POOL_4_ADDR,(U16)OVRL_ENABLE_DATA,(U16)0x00);
 711   2              }
 712   1              else
 713   1              {
 714   2                      Comm_I2C_Tx(ISP_SLAVE_ADDRESS,I2C_2BYTE_RW,(U16)CMD_PARAM_POOL_4_ADDR,(U16)OVRL_DISABLE_DATA,(U16)0x00);
 715   2              }
 716   1              Comm_I2C_Tx(ISP_SLAVE_ADDRESS,I2C_2BYTE_RW,(U16)CMD_REGISTER_ADDR,(U16)CMD_OVRL_LOAD_BUFFER,(U16)0x00);
 717   1              
 718   1              DoorbellCheck();        
 719   1      }
 720          
C51 COMPILER V9.51   MGR_ISP                                                               11/17/2023 14:48:45 PAGE 136 

 721          void Fixed_Guidline_Off(void)
 722          {
 723   1              Comm_I2C_Tx(ISP_SLAVE_ADDRESS,I2C_2BYTE_RW,(U16)CMD_PARAM_POOL_4_ADDR,(U16)OVRL_DISABLE_DATA,(U16)0x00);
 724   1              Comm_I2C_Tx(ISP_SLAVE_ADDRESS,I2C_2BYTE_RW,(U16)CMD_REGISTER_ADDR,(U16)CMD_OVRL_LOAD_BUFFER,(U16)0x00);
 725   1      }
 726          
 727          static void warning_msg(U8 hutype, U8 Lang)
 728          {
 729   1              static SEG_XDATA U16 lan_start_addr = MEM_LAN_START_ADDR;
 730   1              static SEG_XDATA U16 Pre_Lang = 0xFFU ;
 731   1              SEG_DATA volatile U16 read_data = 0x0000U;
 732   1              SEG_XDATA U8 ret = FALSE;
 733   1      
 734   1              DoorbellCheck();
 735   1      
 736   1              if ( ((hutype >= 0x10U) && (hutype <= 0x21U)) || ((hutype >= 0x60U) && (hutype <= 0x68U)) || 
 737   1                    (hutype == 0x41U) || (hutype == 0x70U) || (hutype == 0xFAU) || (Lang > 0x1FU) )
 738   1              {       
 739   2                      ret = FALSE;
 740   2              }
 741   1              else
 742   1              {
 743   2                      ret = TRUE;
 744   2              }
 745   1              
 746   1              if ( Lang == 0xFFU )
 747   1              {
 748   2                      ret = FALSE;
 749   2              }
 750   1      
 751   1              if(ret == TRUE)
 752   1              {
 753   2                      if(Lang == CAN_LAN_INVALID_ADDR) 
 754   2                      {
 755   3                              Lang = Pre_Lang;                // Invalid address. previous value
 756   3                      }
 757   2                      else 
 758   2                      {
 759   3                              Lang += (U8)lan_start_addr;     // language id and flash address matching
 760   3                      }
 761   2              }
 762   1              else 
 763   1              {
 764   2                      Lang = MEM_LAN_INVALID_ADDR;            // Invalid address. blank value
 765   2              }
 766   1      
 767   1              Pre_Lang = Lang;
 768   1      
 769   1              if (warning_msg_flag == 0x00U)
 770   1              {
 771   2                      Comm_I2C_Tx(ISP_SLAVE_ADDRESS,I2C_2BYTE_RW,(U16)CMD_PARAM_POOL_0_ADDR,(U16)WARNING_BUFFER6_DATA,(U16)0x0
             -0);
 772   2                      warning_msg_flag = 0x01U;
 773   2              }
 774   1              else
 775   1              {
 776   2                      Comm_I2C_Tx(ISP_SLAVE_ADDRESS,I2C_2BYTE_RW,(U16)CMD_PARAM_POOL_0_ADDR,(U16)WARNING_BUFFER1_DATA,(U16)0x0
             -0);
 777   2                      warning_msg_flag = 0x00U;
 778   2              }
 779   1              Comm_I2C_Tx(ISP_SLAVE_ADDRESS,I2C_2BYTE_RW,(U16)CMD_PARAM_POOL_2_ADDR,(U16)Lang,(U16)0x00);
 780   1              if(ret == TRUE)
C51 COMPILER V9.51   MGR_ISP                                                               11/17/2023 14:48:45 PAGE 137 

 781   1              {
 782   2                      Comm_I2C_Tx(ISP_SLAVE_ADDRESS,I2C_2BYTE_RW,(U16)CMD_PARAM_POOL_4_ADDR,(U16)OVRL_ENABLE_DATA,(U16)0x00);
 783   2              }
 784   1              Comm_I2C_Tx(ISP_SLAVE_ADDRESS,I2C_2BYTE_RW,(U16)CMD_REGISTER_ADDR,(U16)CMD_OVRL_LOAD_BUFFER,(U16)0x00);
 785   1      
 786   1              DoorbellCheck();
 787   1      }
 788          
 789          static void Sensor_XY_Offset_set(U8 x, U8 y )
 790          {
 791   1              SEG_DATA volatile U16 read_data = 0x0000U;
 792   1              U16 write_data = 0x0000U;
 793   1      
 794   1              write_data = (U16)(((U16)x << (U16)8) | (U16)y);
 795   1              
 796   1              DoorbellCheck();
 797   1      
 798   1              while(1)
 799   1              {
 800   2                      Comm_I2C_Tx(ISP_SLAVE_ADDRESS,I2C_2BYTE_RW,(U16)0x0040U,(U16)0x8101U,(U16)0x00);
 801   2                      Wait_ms(10U);
 802   2                      read_data = Comm_I2C_Rx(ISP_SLAVE_ADDRESS,I2C_2BYTE_RW,(U16)0x0040U,(U16)0x00,(U16)0x00);
 803   2                      if ( read_data != (U16)0x0009 )
 804   2                      {
 805   3                              break;
 806   3                      }
 807   2                      DoorbellCheck();
 808   2              }
 809   1      
 810   1              Comm_I2C_Tx(ISP_SLAVE_ADDRESS,I2C_2BYTE_RW,(U16)0x098EU,(U16)AP0100_SENSOR_X_OFFSET,(U16)0x00);
 811   1              Comm_I2C_Tx(ISP_SLAVE_ADDRESS,I2C_2BYTE_RW,(U16)AP0100_SENSOR_X_OFFSET,(U16)write_data,(U16)0x00);
 812   1      
 813   1              Comm_I2C_Tx(ISP_SLAVE_ADDRESS,I2C_2BYTE_RW,(U16)0xfc00U,(U16)0x2800U,(U16)0x00);
 814   1              Comm_I2C_Tx(ISP_SLAVE_ADDRESS,I2C_2BYTE_RW,(U16)0x0040U,(U16)0x8100U,(U16)0x00);
 815   1              Comm_I2C_Tx(ISP_SLAVE_ADDRESS,I2C_2BYTE_RW,(U16)0xfc00U,(U16)0x2800U,(U16)0x00);
 816   1              Comm_I2C_Tx(ISP_SLAVE_ADDRESS,I2C_2BYTE_RW,(U16)0x0040U,(U16)0x8100U,(U16)0x00);
 817   1              Comm_I2C_Tx(ISP_SLAVE_ADDRESS,I2C_2BYTE_RW,(U16)0x0040U,(U16)0x8101U,(U16)0x00);
 818   1      
 819   1              DoorbellCheck();
 820   1      }
 821          
 822          void isp_guide_on_off(U8 Guide_On_Off)
 823          {
 824   1              g_Guideline_OnOff = Guide_On_Off;
 825   1      }
C51 COMPILER V9.51   MGR_ISP                                                               11/17/2023 14:48:45 PAGE 138 

ASSEMBLY LISTING OF GENERATED OBJECT CODE


             ; FUNCTION Init_IspTask (BEGIN)
                                           ; SOURCE LINE # 33
                                           ; SOURCE LINE # 34
                                           ; SOURCE LINE # 35
0000 7B01              MOV     R3,#01H
0002 7A00        R     MOV     R2,#HIGH Optical_Axis_Data
0004 7900        R     MOV     R1,#LOW Optical_Axis_Data
0006 900000      E     MOV     DPTR,#?_FLASH_Read_Buf?BYTE+05H
0009 E4                CLR     A
000A F0                MOVX    @DPTR,A
000B A3                INC     DPTR
000C 7409              MOV     A,#09H
000E F0                MOVX    @DPTR,A
000F A3                INC     DPTR
0010 7420              MOV     A,#020H
0012 F0                MOVX    @DPTR,A
0013 7D00              MOV     R5,#00H
0015 7CFE              MOV     R4,#0FEH
0017 120000      E     LCALL   _FLASH_Read_Buf
                                           ; SOURCE LINE # 36
001A 900000      R     MOV     DPTR,#Optical_Axis_Data
001D E0                MOVX    A,@DPTR
001E B4FF11            CJNE    A,#0FFH,?C0001
0021 A3                INC     DPTR
0022 E0                MOVX    A,@DPTR
0023 B4FF0C            CJNE    A,#0FFH,?C0001
                                           ; SOURCE LINE # 37
                                           ; SOURCE LINE # 38
0026 A3                INC     DPTR
0027 E0                MOVX    A,@DPTR
0028 B4FF07            CJNE    A,#0FFH,?C0001
                                           ; SOURCE LINE # 39
                                           ; SOURCE LINE # 41
002B E4                CLR     A
002C 900000      R     MOV     DPTR,#Optical_Axis_Data
002F F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 42
0030 A3                INC     DPTR
0031 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 43
                                           ; SOURCE LINE # 44
0032         ?C0001:
                                           ; SOURCE LINE # 46
0032 900000      R     MOV     DPTR,#Optical_Axis_Data+06H
0035 E0                MOVX    A,@DPTR
0036 B4FF11            CJNE    A,#0FFH,?C0003
0039 A3                INC     DPTR
003A E0                MOVX    A,@DPTR
003B B4FF0C            CJNE    A,#0FFH,?C0003
                                           ; SOURCE LINE # 47
                                           ; SOURCE LINE # 48
003E A3                INC     DPTR
003F E0                MOVX    A,@DPTR
0040 B4FF07            CJNE    A,#0FFH,?C0003
                                           ; SOURCE LINE # 49
                                           ; SOURCE LINE # 51
0043 E4                CLR     A
0044 900000      R     MOV     DPTR,#Optical_Axis_Data+06H
0047 F0                MOVX    @DPTR,A
C51 COMPILER V9.51   MGR_ISP                                                               11/17/2023 14:48:45 PAGE 139 

                                           ; SOURCE LINE # 52
0048 A3                INC     DPTR
0049 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 53
                                           ; SOURCE LINE # 54
004A         ?C0003:
                                           ; SOURCE LINE # 55
004A 120000      E     LCALL   Flash_OneSpec_Read
                                           ; SOURCE LINE # 57
004D E4                CLR     A
004E 900000      R     MOV     DPTR,#g_Pre_Calibration_Mode
0051 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 58
0052 900000      E     MOV     DPTR,#CalibrationMode_OnOff
0055 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 59
0056 900000      E     MOV     DPTR,#OpticOffset_Set
0059 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 61
005A 900000      R     MOV     DPTR,#tISP_Func_Msg
005D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 62
005E A3                INC     DPTR
005F 7409              MOV     A,#09H
0061 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 63
0062 A3                INC     DPTR
0063 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 64
0064 A3                INC     DPTR
0065 7403              MOV     A,#03H
0067 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 65
0068 A3                INC     DPTR
0069 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 66
006A E4                CLR     A
006B A3                INC     DPTR
006C F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 67
006D A3                INC     DPTR
006E F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 68
006F A3                INC     DPTR
0070 7403              MOV     A,#03H
0072 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 69
0073 A3                INC     DPTR
0074 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 70
0075 A3                INC     DPTR
0076 740F              MOV     A,#0FH
0078 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 71
0079 A3                INC     DPTR
007A F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 72
007B E4                CLR     A
007C A3                INC     DPTR
007D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 74
007E A3                INC     DPTR
C51 COMPILER V9.51   MGR_ISP                                                               11/17/2023 14:48:45 PAGE 140 

007F F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 76
0080 120000      R     LCALL   Isp_InterInit
                                           ; SOURCE LINE # 77
0083 22                RET     
             ; FUNCTION Init_IspTask (END)

             ; FUNCTION Isp_InterInit (BEGIN)
                                           ; SOURCE LINE # 111
                                           ; SOURCE LINE # 112
                                           ; SOURCE LINE # 113
0000 E4                CLR     A
0001 900000      R     MOV     DPTR,#count
0004 F0                MOVX    @DPTR,A
0005 A3                INC     DPTR
0006 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 114
0007 A3                INC     DPTR
0008 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 116
0009 7F03              MOV     R7,#03H
000B 120000      E     LCALL   _Device_Init
                                           ; SOURCE LINE # 118
000E 7F0F              MOV     R7,#0FH
0010 120000      E     LCALL   _Comm_Tx_RVM_View
                                           ; SOURCE LINE # 119
0013 7F03              MOV     R7,#03H
0015 120000      E     LCALL   _Comm_Tx_RVM_SW_IND
                                           ; SOURCE LINE # 120
0018 900000      R     MOV     DPTR,#tISP_Func_Msg+09H
001B 740F              MOV     A,#0FH
001D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 121
001E 900000      R     MOV     DPTR,#tISP_Func_Msg+07H
0021 7403              MOV     A,#03H
0023 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 123
0024 120000      R     LCALL   Check_Isp_InitState
                                           ; SOURCE LINE # 125
0027 900000      R     MOV     DPTR,#Optical_Axis_Data+06H
002A E0                MOVX    A,@DPTR
002B FF                MOV     R7,A
002C 900000      R     MOV     DPTR,#Optical_Axis_Data
002F E0                MOVX    A,@DPTR
0030 2F                ADD     A,R7
0031 900000      R     MOV     DPTR,#Asix
0034 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 126
0035 900000      R     MOV     DPTR,#Optical_Axis_Data+07H
0038 E0                MOVX    A,@DPTR
0039 FF                MOV     R7,A
003A 900000      R     MOV     DPTR,#Optical_Axis_Data+01H
003D E0                MOVX    A,@DPTR
003E 2F                ADD     A,R7
003F 900000      R     MOV     DPTR,#Asix+01H
0042 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 128
0043 900000      R     MOV     DPTR,#Asix
0046 E0                MOVX    A,@DPTR
0047 FF                MOV     R7,A
0048 A3                INC     DPTR
0049 E0                MOVX    A,@DPTR
C51 COMPILER V9.51   MGR_ISP                                                               11/17/2023 14:48:45 PAGE 141 

004A FD                MOV     R5,A
004B 120000      R     LCALL   _Sensor_XY_Offset_set
                                           ; SOURCE LINE # 130
004E 7F01              MOV     R7,#01H
0050 120000      R     LCALL   _Fixed_Guidline_On
                                           ; SOURCE LINE # 131
0053 7F0A              MOV     R7,#0AH
0055 7E00              MOV     R6,#00H
0057 120000      E     LCALL   _Wait_ms
                                           ; SOURCE LINE # 133
005A 900000      E     MOV     DPTR,#tCAN_Rx_Msg+0DH
005D E0                MOVX    A,@DPTR
005E F4                CPL     A
005F 6014              JZ      ?C0006
                                           ; SOURCE LINE # 134
                                           ; SOURCE LINE # 135
0061 900000      E     MOV     DPTR,#tCAN_Rx_Msg+015H
0064 E0                MOVX    A,@DPTR
0065 FF                MOV     R7,A
0066 900000      E     MOV     DPTR,#tCAN_Rx_Msg+0DH
0069 E0                MOVX    A,@DPTR
006A FD                MOV     R5,A
006B 120000      R     LCALL   _warning_msg
                                           ; SOURCE LINE # 136
006E 7F0A              MOV     R7,#0AH
0070 7E00              MOV     R6,#00H
0072 120000      E     LCALL   _Wait_ms
                                           ; SOURCE LINE # 137
0075         ?C0006:
                                           ; SOURCE LINE # 139
0075 E4                CLR     A
0076 FD                MOV     R5,A
0077 FF                MOV     R7,A
0078 FE                MOV     R6,A
0079 120000      R     LCALL   _Overlay_Guideline
                                           ; SOURCE LINE # 141
007C 7F0A              MOV     R7,#0AH
007E 7E00              MOV     R6,#00H
0080 120000      E     LCALL   _Wait_ms
                                           ; SOURCE LINE # 142
0083 120000      E     LCALL   Frame_Sync_Status
                                           ; SOURCE LINE # 143
0086 7D32              MOV     R5,#032H
0088 7C00              MOV     R4,#00H
008A 7F03              MOV     R7,#03H
008C 120000      E     LCALL   _Delay_Time_Set
                                           ; SOURCE LINE # 144
008F 7D64              MOV     R5,#064H
0091 7C00              MOV     R4,#00H
0093 7F01              MOV     R7,#01H
0095 120000      E     LCALL   _Delay_Time_Set
                                           ; SOURCE LINE # 145
0098 7D64              MOV     R5,#064H
009A 7C00              MOV     R4,#00H
009C 7F02              MOV     R7,#02H
009E 120000      E     LCALL   _Delay_Time_Set
                                           ; SOURCE LINE # 146
00A1 7D64              MOV     R5,#064H
00A3 7C00              MOV     R4,#00H
00A5 7F05              MOV     R7,#05H
00A7 120000      E     LCALL   _Delay_Time_Set
                                           ; SOURCE LINE # 148
C51 COMPILER V9.51   MGR_ISP                                                               11/17/2023 14:48:45 PAGE 142 

00AA 22                RET     
             ; FUNCTION Isp_InterInit (END)

             ; FUNCTION Operate_IspTask (BEGIN)
                                           ; SOURCE LINE # 150
                                           ; SOURCE LINE # 151
                                           ; SOURCE LINE # 155
0000 900000      E     MOV     DPTR,#OpticOffset_Set
0003 E0                MOVX    A,@DPTR
0004 6401              XRL     A,#01H
0006 7028              JNZ     ?C0008
                                           ; SOURCE LINE # 156
                                           ; SOURCE LINE # 157
0008 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 159
0009 900000      R     MOV     DPTR,#Optical_Axis_Data+06H
000C E0                MOVX    A,@DPTR
000D FF                MOV     R7,A
000E 900000      R     MOV     DPTR,#Optical_Axis_Data
0011 E0                MOVX    A,@DPTR
0012 2F                ADD     A,R7
0013 900000      R     MOV     DPTR,#Asix
0016 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 160
0017 900000      R     MOV     DPTR,#Optical_Axis_Data+07H
001A E0                MOVX    A,@DPTR
001B FF                MOV     R7,A
001C 900000      R     MOV     DPTR,#Optical_Axis_Data+01H
001F E0                MOVX    A,@DPTR
0020 2F                ADD     A,R7
0021 900000      R     MOV     DPTR,#Asix+01H
0024 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 162
0025 900000      R     MOV     DPTR,#Asix
0028 E0                MOVX    A,@DPTR
0029 FF                MOV     R7,A
002A A3                INC     DPTR
002B E0                MOVX    A,@DPTR
002C FD                MOV     R5,A
002D 120000      R     LCALL   _Sensor_XY_Offset_set
                                           ; SOURCE LINE # 163
0030         ?C0008:
                                           ; SOURCE LINE # 165
0030 900000      R     MOV     DPTR,#g_Pre_Calibration_Mode
0033 E0                MOVX    A,@DPTR
0034 701A              JNZ     ?C0009
0036 900000      E     MOV     DPTR,#CalibrationMode_OnOff
0039 E0                MOVX    A,@DPTR
003A B40113            CJNE    A,#01H,?C0009
                                           ; SOURCE LINE # 166
                                           ; SOURCE LINE # 167
003D 900000      R     MOV     DPTR,#g_Pre_Calibration_Mode
0040 7401              MOV     A,#01H
0042 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 168
0043 E4                CLR     A
0044 FD                MOV     R5,A
0045 FF                MOV     R7,A
0046 120000      R     LCALL   _warning_msg
                                           ; SOURCE LINE # 169
0049 7F0A              MOV     R7,#0AH
004B 7E00              MOV     R6,#00H
C51 COMPILER V9.51   MGR_ISP                                                               11/17/2023 14:48:45 PAGE 143 

004D 120000      E     LCALL   _Wait_ms
                                           ; SOURCE LINE # 170
0050         ?C0009:
                                           ; SOURCE LINE # 172
0050 120000      E     LCALL   Comm_RearView_Data
                                           ; SOURCE LINE # 173
0053 900000      R     MOV     DPTR,#tISP_Func_Msg+0AH
0056 E0                MOVX    A,@DPTR
0057 FF                MOV     R7,A
0058 900000      R     MOV     DPTR,#tISP_Func_Msg+09H
005B E0                MOVX    A,@DPTR
005C 6F                XRL     A,R7
005D 700C              JNZ     ?C0011
005F 900000      R     MOV     DPTR,#tISP_Func_Msg+08H
0062 E0                MOVX    A,@DPTR
0063 FF                MOV     R7,A
0064 900000      R     MOV     DPTR,#tISP_Func_Msg+07H
0067 E0                MOVX    A,@DPTR
0068 6F                XRL     A,R7
0069 6035              JZ      ?C0010
006B         ?C0011:
                                           ; SOURCE LINE # 174
                                           ; SOURCE LINE # 175
006B 900000      R     MOV     DPTR,#tISP_Func_Msg+0AH
006E E0                MOVX    A,@DPTR
006F FF                MOV     R7,A
0070 120000      E     LCALL   _Comm_Tx_RVM_View
                                           ; SOURCE LINE # 176
0073 900000      R     MOV     DPTR,#tISP_Func_Msg+08H
0076 E0                MOVX    A,@DPTR
0077 FF                MOV     R7,A
0078 120000      E     LCALL   _Comm_Tx_RVM_SW_IND
                                           ; SOURCE LINE # 178
007B 900000      R     MOV     DPTR,#tISP_Func_Msg+09H
007E E0                MOVX    A,@DPTR
007F 6402              XRL     A,#02H
0081 6005              JZ      ?C0013
0083 A3                INC     DPTR
0084 E0                MOVX    A,@DPTR
0085 B40208            CJNE    A,#02H,?C0012
0088         ?C0013:
                                           ; SOURCE LINE # 179
                                           ; SOURCE LINE # 180
0088 900000      R     MOV     DPTR,#tISP_Func_Msg+0AH
008B E0                MOVX    A,@DPTR
008C FF                MOV     R7,A
008D 120000      R     LCALL   _Isp_View_Mode_Change
                                           ; SOURCE LINE # 181
0090         ?C0012:
                                           ; SOURCE LINE # 182
0090 900000      R     MOV     DPTR,#tISP_Func_Msg+0AH
0093 E0                MOVX    A,@DPTR
0094 900000      R     MOV     DPTR,#tISP_Func_Msg+09H
0097 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 183
0098 900000      R     MOV     DPTR,#tISP_Func_Msg+08H
009B E0                MOVX    A,@DPTR
009C 900000      R     MOV     DPTR,#tISP_Func_Msg+07H
009F F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 184
00A0         ?C0010:
                                           ; SOURCE LINE # 186
C51 COMPILER V9.51   MGR_ISP                                                               11/17/2023 14:48:45 PAGE 144 

00A0 900000      E     MOV     DPTR,#ga_Ext_tDTC_Type_Msg+0AH
00A3 E0                MOVX    A,@DPTR
00A4 6409              XRL     A,#09H
00A6 600F              JZ      ?C0014
                                           ; SOURCE LINE # 187
                                           ; SOURCE LINE # 188
00A8 900000      R     MOV     DPTR,#tISP_Func_Msg+09H
00AB E0                MOVX    A,@DPTR
00AC B40205            CJNE    A,#02H,?C0015
                                           ; SOURCE LINE # 189
                                           ; SOURCE LINE # 190
00AF 120000      R     LCALL   Isp_Driving_Assist_View
                                           ; SOURCE LINE # 191
00B2 8003              SJMP    ?C0014
00B4         ?C0015:
                                           ; SOURCE LINE # 193
                                           ; SOURCE LINE # 194
00B4 120000      R     LCALL   Isp_Parking_Assist_View
                                           ; SOURCE LINE # 195
                                           ; SOURCE LINE # 196
00B7         ?C0014:
                                           ; SOURCE LINE # 198
00B7 7F0B              MOV     R7,#0BH
00B9 120000      E     LCALL   _Delay_Time_Get
;---- Variable 'On_Time' assigned to Register 'R7' ----
                                           ; SOURCE LINE # 199
00BC EF                MOV     A,R7
00BD 6401              XRL     A,#01H
00BF 702D              JNZ     ?C0022
                                           ; SOURCE LINE # 200
                                           ; SOURCE LINE # 201
00C1 120000      R     LCALL   CheckCommandStatusLoop
00C4 900000      R     MOV     DPTR,#ret
00C7 EF                MOV     A,R7
00C8 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 202
00C9 700B              JNZ     ?C0018
                                           ; SOURCE LINE # 203
                                           ; SOURCE LINE # 204
00CB 900000      R     MOV     DPTR,#g_Overlay_Stauts_Loop_Check_Time
00CE 04                INC     A
00CF F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 205
00D0 7F04              MOV     R7,#04H
00D2 120000      E     LCALL   _Record_DTC_Error
                                           ; SOURCE LINE # 206
00D5 22                RET     
00D6         ?C0018:
                                           ; SOURCE LINE # 207
00D6 900000      R     MOV     DPTR,#ret
00D9 E0                MOVX    A,@DPTR
00DA B4010C            CJNE    A,#01H,?C0020
                                           ; SOURCE LINE # 208
                                           ; SOURCE LINE # 209
00DD 900000      R     MOV     DPTR,#g_Overlay_Stauts_Loop_Check_Time
00E0 7401              MOV     A,#01H
00E2 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 210
00E3 7F04              MOV     R7,#04H
00E5 120000      E     LCALL   _Record_DTC_Clear
                                           ; SOURCE LINE # 211
00E8 22                RET     
C51 COMPILER V9.51   MGR_ISP                                                               11/17/2023 14:48:45 PAGE 145 

00E9         ?C0020:
                                           ; SOURCE LINE # 213
                                           ; SOURCE LINE # 214
00E9 E4                CLR     A
00EA 900000      R     MOV     DPTR,#g_Overlay_Stauts_Loop_Check_Time
00ED F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 215
                                           ; SOURCE LINE # 216
                                           ; SOURCE LINE # 217
00EE         ?C0022:
00EE 22                RET     
             ; FUNCTION Operate_IspTask (END)

             ; FUNCTION Isp_Parking_Assist_View (BEGIN)
                                           ; SOURCE LINE # 219
                                           ; SOURCE LINE # 220
                                           ; SOURCE LINE # 221
0000 7800        R     MOV     R0,#LOW Sas_Data
0002 7C00        R     MOV     R4,#HIGH Sas_Data
0004 7D01              MOV     R5,#01H
0006 7BFF              MOV     R3,#0FFH
0008 7A00        R     MOV     R2,#HIGH _?ix1000
000A 7900        R     MOV     R1,#LOW _?ix1000
000C 7E00              MOV     R6,#00H
000E 7F02              MOV     R7,#02H
0010 120000      E     LCALL   ?C?COPY
                                           ; SOURCE LINE # 222
0013 E4                CLR     A
0014 900000      R     MOV     DPTR,#HU_Type_Data
0017 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 223
0018 A3                INC     DPTR
0019 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 229
001A 900000      R     MOV     DPTR,#g_Guideline_OnOff
001D E0                MOVX    A,@DPTR
001E 6401              XRL     A,#01H
0020 6003              JZ      $ + 5H
0022 020000      R     LJMP    ?C0023
                                           ; SOURCE LINE # 230
                                           ; SOURCE LINE # 231
0025 7F03              MOV     R7,#03H
0027 120000      E     LCALL   _Delay_Time_Get
;---- Variable 'On_Time' assigned to Register 'R7' ----
                                           ; SOURCE LINE # 232
002A EF                MOV     A,R7
002B 6401              XRL     A,#01H
002D 6003              JZ      $ + 5H
002F 020000      R     LJMP    ?C0032
                                           ; SOURCE LINE # 233
                                           ; SOURCE LINE # 234
0032 900000      E     MOV     DPTR,#CalibrationMode_OnOff
0035 E0                MOVX    A,@DPTR
0036 7020              JNZ     ?C0025
                                           ; SOURCE LINE # 235
                                           ; SOURCE LINE # 236
0038 7B01              MOV     R3,#01H
003A 7A00        R     MOV     R2,#HIGH Sas_Data
003C 7900        R     MOV     R1,#LOW Sas_Data
003E 120000      E     LCALL   _Comm_Sas_Data
0041 900000      R     MOV     DPTR,#ret
0044 EF                MOV     A,R7
C51 COMPILER V9.51   MGR_ISP                                                               11/17/2023 14:48:45 PAGE 146 

0045 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 237
0046 900000      E     MOV     DPTR,#tCAN_Rx_Msg+015H
0049 E0                MOVX    A,@DPTR
004A 900000      R     MOV     DPTR,#HU_Type_Data
004D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 238
004E 900000      E     MOV     DPTR,#tCAN_Rx_Msg+0DH
0051 E0                MOVX    A,@DPTR
0052 900000      R     MOV     DPTR,#Language_Data
0055 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 239
0056 800B              SJMP    ?C0026
0058         ?C0025:
                                           ; SOURCE LINE # 241
                                           ; SOURCE LINE # 242
0058 E4                CLR     A
0059 900000      R     MOV     DPTR,#Sas_Data
005C F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 243
005D 900000      R     MOV     DPTR,#HU_Type_Data
0060 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 244
0061 A3                INC     DPTR
0062 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 245
0063         ?C0026:
                                           ; SOURCE LINE # 247
0063 900000      R     MOV     DPTR,#overlay_flag
0066 E0                MOVX    A,@DPTR
0067 B4640D            CJNE    A,#064H,?C0027
                                           ; SOURCE LINE # 248
                                           ; SOURCE LINE # 249
006A 7F01              MOV     R7,#01H
006C 120000      R     LCALL   _Fixed_Guidline_On
                                           ; SOURCE LINE # 251
006F 900000      R     MOV     DPTR,#overlay_flag
0072 E0                MOVX    A,@DPTR
0073 04                INC     A
0074 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 252
0075 803C              SJMP    ?C0032
0077         ?C0027:
                                           ; SOURCE LINE # 253
0077 900000      R     MOV     DPTR,#overlay_flag
007A E0                MOVX    A,@DPTR
007B B4C819            CJNE    A,#0C8H,?C0029
                                           ; SOURCE LINE # 254
                                           ; SOURCE LINE # 255
007E 900000      E     MOV     DPTR,#tCAN_Rx_Msg+0DH
0081 E0                MOVX    A,@DPTR
0082 F4                CPL     A
0083 600B              JZ      ?C0030
                                           ; SOURCE LINE # 256
                                           ; SOURCE LINE # 257
0085 900000      R     MOV     DPTR,#HU_Type_Data
0088 E0                MOVX    A,@DPTR
0089 FF                MOV     R7,A
008A A3                INC     DPTR
008B E0                MOVX    A,@DPTR
008C FD                MOV     R5,A
008D 120000      R     LCALL   _warning_msg
C51 COMPILER V9.51   MGR_ISP                                                               11/17/2023 14:48:45 PAGE 147 

                                           ; SOURCE LINE # 259
0090         ?C0030:
                                           ; SOURCE LINE # 260
0090 E4                CLR     A
0091 900000      R     MOV     DPTR,#overlay_flag
0094 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 261
0095 801C              SJMP    ?C0032
0097         ?C0029:
                                           ; SOURCE LINE # 263
                                           ; SOURCE LINE # 264
0097 900000      R     MOV     DPTR,#Sas_Data
009A E0                MOVX    A,@DPTR
009B FF                MOV     R7,A
009C 7E00              MOV     R6,#00H
009E A3                INC     DPTR
009F E0                MOVX    A,@DPTR
00A0 FD                MOV     R5,A
00A1 120000      R     LCALL   _Overlay_Guideline
                                           ; SOURCE LINE # 265
00A4 900000      R     MOV     DPTR,#overlay_flag
00A7 E0                MOVX    A,@DPTR
00A8 04                INC     A
00A9 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 266
                                           ; SOURCE LINE # 267
                                           ; SOURCE LINE # 268
00AA 8007              SJMP    ?C0032
00AC         ?C0023:
                                           ; SOURCE LINE # 270
                                           ; SOURCE LINE # 271
00AC E4                CLR     A
00AD FD                MOV     R5,A
00AE FF                MOV     R7,A
00AF FE                MOV     R6,A
00B0 120000      R     LCALL   _Overlay_Guideline
                                           ; SOURCE LINE # 272
00B3         ?C0032:
                                           ; SOURCE LINE # 274
00B3 900000      E     MOV     DPTR,#CalibrationMode_OnOff
00B6 E0                MOVX    A,@DPTR
00B7 7040              JNZ     ?C0038
                                           ; SOURCE LINE # 275
                                           ; SOURCE LINE # 276
00B9 900000      E     MOV     DPTR,#tCAN_Rx_Msg+08H
00BC E0                MOVX    A,@DPTR
00BD 6401              XRL     A,#01H
00BF 6007              JZ      ?C0035
00C1 900000      E     MOV     DPTR,#tCAN_Rx_Msg+010H
00C4 E0                MOVX    A,@DPTR
00C5 B40128            CJNE    A,#01H,?C0034
00C8         ?C0035:
                                           ; SOURCE LINE # 277
                                           ; SOURCE LINE # 278
00C8 E4                CLR     A
00C9 900000      E     MOV     DPTR,#tCAN_Rx_Msg+08H
00CC F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 279
00CD 900000      E     MOV     DPTR,#tCAN_Rx_Msg+010H
00D0 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 280
00D1 900000      E     MOV     DPTR,#tCAN_Rx_Msg+0DH
C51 COMPILER V9.51   MGR_ISP                                                               11/17/2023 14:48:45 PAGE 148 

00D4 E0                MOVX    A,@DPTR
00D5 641F              XRL     A,#01FH
00D7 6003              JZ      ?C0036
                                           ; SOURCE LINE # 281
                                           ; SOURCE LINE # 282
00D9 120000      E     LCALL   Flash_OneSpec_Write
                                           ; SOURCE LINE # 283
00DC         ?C0036:
                                           ; SOURCE LINE # 284
00DC 900000      E     MOV     DPTR,#tCAN_Rx_Msg+015H
00DF E0                MOVX    A,@DPTR
00E0 FF                MOV     R7,A
00E1 900000      E     MOV     DPTR,#tCAN_Rx_Msg+0DH
00E4 E0                MOVX    A,@DPTR
00E5 FD                MOV     R5,A
00E6 120000      R     LCALL   _warning_msg
                                           ; SOURCE LINE # 285
00E9 7F0A              MOV     R7,#0AH
00EB 7E00              MOV     R6,#00H
00ED 120000      E     LCALL   _Wait_ms
                                           ; SOURCE LINE # 286
00F0         ?C0034:
                                           ; SOURCE LINE # 288
00F0 900000      R     MOV     DPTR,#g_Pre_Calibration_Mode
00F3 E0                MOVX    A,@DPTR
00F4 B40102            CJNE    A,#01H,?C0038
                                           ; SOURCE LINE # 289
                                           ; SOURCE LINE # 290
00F7 E4                CLR     A
00F8 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 291
                                           ; SOURCE LINE # 292
                                           ; SOURCE LINE # 293
00F9         ?C0038:
00F9 22                RET     
             ; FUNCTION Isp_Parking_Assist_View (END)

             ; FUNCTION Isp_Driving_Assist_View (BEGIN)
                                           ; SOURCE LINE # 295
                                           ; SOURCE LINE # 296
                                           ; SOURCE LINE # 300
0000 7F03              MOV     R7,#03H
0002 120000      E     LCALL   _Delay_Time_Get
;---- Variable 'On_Time' assigned to Register 'R7' ----
                                           ; SOURCE LINE # 301
0005 EF                MOV     A,R7
0006 B40119            CJNE    A,#01H,?C0041
                                           ; SOURCE LINE # 302
                                           ; SOURCE LINE # 303
0009 900000      R     MOV     DPTR,#overlay_flag
000C E0                MOVX    A,@DPTR
000D C3                CLR     C
000E 9464              SUBB    A,#064H
0010 400A              JC      ?C0040
                                           ; SOURCE LINE # 304
                                           ; SOURCE LINE # 305
0012 7F02              MOV     R7,#02H
0014 120000      R     LCALL   _Fixed_Guidline_On
                                           ; SOURCE LINE # 306
0017 E4                CLR     A
0018 900000      R     MOV     DPTR,#overlay_flag
001B F0                MOVX    @DPTR,A
C51 COMPILER V9.51   MGR_ISP                                                               11/17/2023 14:48:45 PAGE 149 

                                           ; SOURCE LINE # 307
001C         ?C0040:
                                           ; SOURCE LINE # 309
001C 900000      R     MOV     DPTR,#overlay_flag
001F E0                MOVX    A,@DPTR
0020 04                INC     A
0021 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 310
                                           ; SOURCE LINE # 311
0022         ?C0041:
0022 22                RET     
             ; FUNCTION Isp_Driving_Assist_View (END)

             ; FUNCTION _Isp_View_Mode_Change (BEGIN)
                                           ; SOURCE LINE # 313
0000 900000      R     MOV     DPTR,#ViewMode
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 314
                                           ; SOURCE LINE # 316
0005 E4                CLR     A
0006 A3                INC     DPTR
0007 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 318
0008 120000      R     LCALL   DoorbellCheck
                                           ; SOURCE LINE # 322
000B E4                CLR     A
000C 900000      E     MOV     DPTR,#?_Comm_I2C_Tx?BYTE+04H
000F F0                MOVX    @DPTR,A
0010 A3                INC     DPTR
0011 F0                MOVX    @DPTR,A
0012 A3                INC     DPTR
0013 F0                MOVX    @DPTR,A
0014 A3                INC     DPTR
0015 F0                MOVX    @DPTR,A
0016 FB                MOV     R3,A
0017 7AFC              MOV     R2,#0FCH
0019 7D02              MOV     R5,#02H
001B 7F90              MOV     R7,#090H
001D 120000      E     LCALL   _Comm_I2C_Tx
                                           ; SOURCE LINE # 323
0020 900000      E     MOV     DPTR,#?_Comm_I2C_Tx?BYTE+04H
0023 E4                CLR     A
0024 F0                MOVX    @DPTR,A
0025 A3                INC     DPTR
0026 7476              MOV     A,#076H
0028 F0                MOVX    @DPTR,A
0029 E4                CLR     A
002A A3                INC     DPTR
002B F0                MOVX    @DPTR,A
002C A3                INC     DPTR
002D F0                MOVX    @DPTR,A
002E 7B02              MOV     R3,#02H
0030 7AFC              MOV     R2,#0FCH
0032 7D02              MOV     R5,#02H
0034 7F90              MOV     R7,#090H
0036 120000      E     LCALL   _Comm_I2C_Tx
                                           ; SOURCE LINE # 324
0039 900000      E     MOV     DPTR,#?_Comm_I2C_Tx?BYTE+04H
003C 7401              MOV     A,#01H
003E F0                MOVX    @DPTR,A
003F A3                INC     DPTR
C51 COMPILER V9.51   MGR_ISP                                                               11/17/2023 14:48:45 PAGE 150 

0040 E4                CLR     A
0041 F0                MOVX    @DPTR,A
0042 A3                INC     DPTR
0043 F0                MOVX    @DPTR,A
0044 A3                INC     DPTR
0045 F0                MOVX    @DPTR,A
0046 7B04              MOV     R3,#04H
0048 7AFC              MOV     R2,#0FCH
004A 7D02              MOV     R5,#02H
004C 7F90              MOV     R7,#090H
004E 120000      E     LCALL   _Comm_I2C_Tx
                                           ; SOURCE LINE # 325
0051 900000      E     MOV     DPTR,#?_Comm_I2C_Tx?BYTE+04H
0054 7482              MOV     A,#082H
0056 F0                MOVX    @DPTR,A
0057 A3                INC     DPTR
0058 7406              MOV     A,#06H
005A F0                MOVX    @DPTR,A
005B E4                CLR     A
005C A3                INC     DPTR
005D F0                MOVX    @DPTR,A
005E A3                INC     DPTR
005F F0                MOVX    @DPTR,A
0060 7B40              MOV     R3,#040H
0062 FA                MOV     R2,A
0063 7D02              MOV     R5,#02H
0065 7F90              MOV     R7,#090H
0067 120000      E     LCALL   _Comm_I2C_Tx
                                           ; SOURCE LINE # 326
006A 120000      R     LCALL   DoorbellCheck
                                           ; SOURCE LINE # 329
006D 900000      R     MOV     DPTR,#ViewMode
0070 E0                MOVX    A,@DPTR
0071 6402              XRL     A,#02H
0073 6003              JZ      $ + 5H
0075 020000      R     LJMP    ?C0042
                                           ; SOURCE LINE # 330
                                           ; SOURCE LINE # 331
0078 900000      E     MOV     DPTR,#?_Comm_I2C_Tx?BYTE+04H
007B 04                INC     A
007C F0                MOVX    @DPTR,A
007D A3                INC     DPTR
007E E4                CLR     A
007F F0                MOVX    @DPTR,A
0080 A3                INC     DPTR
0081 F0                MOVX    @DPTR,A
0082 A3                INC     DPTR
0083 F0                MOVX    @DPTR,A
0084 FB                MOV     R3,A
0085 7AFC              MOV     R2,#0FCH
0087 7D02              MOV     R5,#02H
0089 7F90              MOV     R7,#090H
008B 120000      E     LCALL   _Comm_I2C_Tx
                                           ; SOURCE LINE # 332
008E E4                CLR     A
008F 900000      E     MOV     DPTR,#?_Comm_I2C_Tx?BYTE+04H
0092 F0                MOVX    @DPTR,A
0093 A3                INC     DPTR
0094 F0                MOVX    @DPTR,A
0095 A3                INC     DPTR
0096 F0                MOVX    @DPTR,A
0097 A3                INC     DPTR
C51 COMPILER V9.51   MGR_ISP                                                               11/17/2023 14:48:45 PAGE 151 

0098 F0                MOVX    @DPTR,A
0099 7B02              MOV     R3,#02H
009B 7AFC              MOV     R2,#0FCH
009D 7D02              MOV     R5,#02H
009F 7F90              MOV     R7,#090H
00A1 120000      E     LCALL   _Comm_I2C_Tx
                                           ; SOURCE LINE # 333
00A4 900000      E     MOV     DPTR,#?_Comm_I2C_Tx?BYTE+04H
00A7 7482              MOV     A,#082H
00A9 F0                MOVX    @DPTR,A
00AA A3                INC     DPTR
00AB 740A              MOV     A,#0AH
00AD F0                MOVX    @DPTR,A
00AE E4                CLR     A
00AF A3                INC     DPTR
00B0 F0                MOVX    @DPTR,A
00B1 A3                INC     DPTR
00B2 F0                MOVX    @DPTR,A
00B3 7B40              MOV     R3,#040H
00B5 FA                MOV     R2,A
00B6 7D02              MOV     R5,#02H
00B8 7F90              MOV     R7,#090H
00BA 120000      E     LCALL   _Comm_I2C_Tx
                                           ; SOURCE LINE # 334
00BD 120000      R     LCALL   DoorbellCheck
                                           ; SOURCE LINE # 335
00C0 900000      E     MOV     DPTR,#?_Comm_I2C_Tx?BYTE+04H
00C3 7402              MOV     A,#02H
00C5 F0                MOVX    @DPTR,A
00C6 A3                INC     DPTR
00C7 E4                CLR     A
00C8 F0                MOVX    @DPTR,A
00C9 A3                INC     DPTR
00CA F0                MOVX    @DPTR,A
00CB A3                INC     DPTR
00CC F0                MOVX    @DPTR,A
00CD FB                MOV     R3,A
00CE 7AFC              MOV     R2,#0FCH
00D0 7D02              MOV     R5,#02H
00D2 7F90              MOV     R7,#090H
00D4 120000      E     LCALL   _Comm_I2C_Tx
                                           ; SOURCE LINE # 336
00D7 E4                CLR     A
00D8 900000      E     MOV     DPTR,#?_Comm_I2C_Tx?BYTE+04H
00DB F0                MOVX    @DPTR,A
00DC A3                INC     DPTR
00DD F0                MOVX    @DPTR,A
00DE A3                INC     DPTR
00DF F0                MOVX    @DPTR,A
00E0 A3                INC     DPTR
00E1 F0                MOVX    @DPTR,A
00E2 7B02              MOV     R3,#02H
00E4 7AFC              MOV     R2,#0FCH
00E6 7D02              MOV     R5,#02H
00E8 7F90              MOV     R7,#090H
00EA 120000      E     LCALL   _Comm_I2C_Tx
                                           ; SOURCE LINE # 337
00ED 900000      E     MOV     DPTR,#?_Comm_I2C_Tx?BYTE+04H
00F0 7482              MOV     A,#082H
00F2 F0                MOVX    @DPTR,A
00F3 A3                INC     DPTR
00F4 740A              MOV     A,#0AH
C51 COMPILER V9.51   MGR_ISP                                                               11/17/2023 14:48:45 PAGE 152 

00F6 F0                MOVX    @DPTR,A
00F7 E4                CLR     A
00F8 A3                INC     DPTR
00F9 F0                MOVX    @DPTR,A
00FA A3                INC     DPTR
00FB F0                MOVX    @DPTR,A
00FC 7B40              MOV     R3,#040H
00FE FA                MOV     R2,A
00FF 7D02              MOV     R5,#02H
0101 7F90              MOV     R7,#090H
0103 120000      E     LCALL   _Comm_I2C_Tx
                                           ; SOURCE LINE # 338
0106 120000      R     LCALL   DoorbellCheck
                                           ; SOURCE LINE # 341
0109 E4                CLR     A
010A 900000      E     MOV     DPTR,#?_Comm_I2C_Rx?BYTE+04H
010D F0                MOVX    @DPTR,A
010E A3                INC     DPTR
010F F0                MOVX    @DPTR,A
0110 A3                INC     DPTR
0111 F0                MOVX    @DPTR,A
0112 A3                INC     DPTR
0113 F0                MOVX    @DPTR,A
0114 7B0A              MOV     R3,#0AH
0116 7A4F              MOV     R2,#04FH
0118 7D02              MOV     R5,#02H
011A 7F90              MOV     R7,#090H
011C 120000      E     LCALL   _Comm_I2C_Rx
011F 900000      R     MOV     DPTR,#chk_Buffer
0122 EE                MOV     A,R6
0123 F0                MOVX    @DPTR,A
0124 A3                INC     DPTR
0125 EF                MOV     A,R7
0126 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 342
0127 4E                ORL     A,R6
0128 6049              JZ      ?C0043
                                           ; SOURCE LINE # 343
                                           ; SOURCE LINE # 344
012A 900000      E     MOV     DPTR,#?_Comm_I2C_Tx?BYTE+04H
012D 7401              MOV     A,#01H
012F F0                MOVX    @DPTR,A
0130 A3                INC     DPTR
0131 E4                CLR     A
0132 F0                MOVX    @DPTR,A
0133 A3                INC     DPTR
0134 F0                MOVX    @DPTR,A
0135 A3                INC     DPTR
0136 F0                MOVX    @DPTR,A
0137 FB                MOV     R3,A
0138 7AFC              MOV     R2,#0FCH
013A 7D02              MOV     R5,#02H
013C 7F90              MOV     R7,#090H
013E 120000      E     LCALL   _Comm_I2C_Tx
                                           ; SOURCE LINE # 345
0141 E4                CLR     A
0142 900000      E     MOV     DPTR,#?_Comm_I2C_Tx?BYTE+04H
0145 F0                MOVX    @DPTR,A
0146 A3                INC     DPTR
0147 F0                MOVX    @DPTR,A
0148 A3                INC     DPTR
0149 F0                MOVX    @DPTR,A
C51 COMPILER V9.51   MGR_ISP                                                               11/17/2023 14:48:45 PAGE 153 

014A A3                INC     DPTR
014B F0                MOVX    @DPTR,A
014C 7B02              MOV     R3,#02H
014E 7AFC              MOV     R2,#0FCH
0150 7D02              MOV     R5,#02H
0152 7F90              MOV     R7,#090H
0154 120000      E     LCALL   _Comm_I2C_Tx
                                           ; SOURCE LINE # 346
0157 900000      E     MOV     DPTR,#?_Comm_I2C_Tx?BYTE+04H
015A 7482              MOV     A,#082H
015C F0                MOVX    @DPTR,A
015D A3                INC     DPTR
015E 740A              MOV     A,#0AH
0160 F0                MOVX    @DPTR,A
0161 E4                CLR     A
0162 A3                INC     DPTR
0163 F0                MOVX    @DPTR,A
0164 A3                INC     DPTR
0165 F0                MOVX    @DPTR,A
0166 7B40              MOV     R3,#040H
0168 FA                MOV     R2,A
0169 7D02              MOV     R5,#02H
016B 7F90              MOV     R7,#090H
016D 120000      E     LCALL   _Comm_I2C_Tx
                                           ; SOURCE LINE # 347
0170 120000      R     LCALL   DoorbellCheck
                                           ; SOURCE LINE # 348
0173         ?C0043:
                                           ; SOURCE LINE # 349
0173 E4                CLR     A
0174 900000      E     MOV     DPTR,#?_Comm_I2C_Rx?BYTE+04H
0177 F0                MOVX    @DPTR,A
0178 A3                INC     DPTR
0179 F0                MOVX    @DPTR,A
017A A3                INC     DPTR
017B F0                MOVX    @DPTR,A
017C A3                INC     DPTR
017D F0                MOVX    @DPTR,A
017E 7B0C              MOV     R3,#0CH
0180 7A4F              MOV     R2,#04FH
0182 7D02              MOV     R5,#02H
0184 7F90              MOV     R7,#090H
0186 120000      E     LCALL   _Comm_I2C_Rx
0189 900000      R     MOV     DPTR,#chk_Buffer
018C EE                MOV     A,R6
018D F0                MOVX    @DPTR,A
018E A3                INC     DPTR
018F EF                MOV     A,R7
0190 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 350
0191 4E                ORL     A,R6
0192 6049              JZ      ?C0042
                                           ; SOURCE LINE # 351
                                           ; SOURCE LINE # 352
0194 900000      E     MOV     DPTR,#?_Comm_I2C_Tx?BYTE+04H
0197 7402              MOV     A,#02H
0199 F0                MOVX    @DPTR,A
019A A3                INC     DPTR
019B E4                CLR     A
019C F0                MOVX    @DPTR,A
019D A3                INC     DPTR
019E F0                MOVX    @DPTR,A
C51 COMPILER V9.51   MGR_ISP                                                               11/17/2023 14:48:45 PAGE 154 

019F A3                INC     DPTR
01A0 F0                MOVX    @DPTR,A
01A1 FB                MOV     R3,A
01A2 7AFC              MOV     R2,#0FCH
01A4 7D02              MOV     R5,#02H
01A6 7F90              MOV     R7,#090H
01A8 120000      E     LCALL   _Comm_I2C_Tx
                                           ; SOURCE LINE # 353
01AB E4                CLR     A
01AC 900000      E     MOV     DPTR,#?_Comm_I2C_Tx?BYTE+04H
01AF F0                MOVX    @DPTR,A
01B0 A3                INC     DPTR
01B1 F0                MOVX    @DPTR,A
01B2 A3                INC     DPTR
01B3 F0                MOVX    @DPTR,A
01B4 A3                INC     DPTR
01B5 F0                MOVX    @DPTR,A
01B6 7B02              MOV     R3,#02H
01B8 7AFC              MOV     R2,#0FCH
01BA 7D02              MOV     R5,#02H
01BC 7F90              MOV     R7,#090H
01BE 120000      E     LCALL   _Comm_I2C_Tx
                                           ; SOURCE LINE # 354
01C1 900000      E     MOV     DPTR,#?_Comm_I2C_Tx?BYTE+04H
01C4 7482              MOV     A,#082H
01C6 F0                MOVX    @DPTR,A
01C7 A3                INC     DPTR
01C8 740A              MOV     A,#0AH
01CA F0                MOVX    @DPTR,A
01CB E4                CLR     A
01CC A3                INC     DPTR
01CD F0                MOVX    @DPTR,A
01CE A3                INC     DPTR
01CF F0                MOVX    @DPTR,A
01D0 7B40              MOV     R3,#040H
01D2 FA                MOV     R2,A
01D3 7D02              MOV     R5,#02H
01D5 7F90              MOV     R7,#090H
01D7 120000      E     LCALL   _Comm_I2C_Tx
                                           ; SOURCE LINE # 355
01DA 120000      R     LCALL   DoorbellCheck
                                           ; SOURCE LINE # 356
                                           ; SOURCE LINE # 357
01DD         ?C0042:
                                           ; SOURCE LINE # 360
01DD 900000      R     MOV     DPTR,#ViewMode
01E0 E0                MOVX    A,@DPTR
01E1 B40207            CJNE    A,#02H,?C0045
                                           ; SOURCE LINE # 361
                                           ; SOURCE LINE # 362
01E4 7F02              MOV     R7,#02H
01E6 120000      R     LCALL   _Fixed_Guidline_On
                                           ; SOURCE LINE # 363
01E9 8019              SJMP    ?C0046
01EB         ?C0045:
                                           ; SOURCE LINE # 365
                                           ; SOURCE LINE # 366
01EB 7F01              MOV     R7,#01H
01ED 120000      R     LCALL   _Fixed_Guidline_On
                                           ; SOURCE LINE # 367
01F0 900000      E     MOV     DPTR,#tCAN_Rx_Msg+0DH
01F3 E0                MOVX    A,@DPTR
C51 COMPILER V9.51   MGR_ISP                                                               11/17/2023 14:48:45 PAGE 155 

01F4 F4                CPL     A
01F5 600D              JZ      ?C0046
                                           ; SOURCE LINE # 368
                                           ; SOURCE LINE # 369
01F7 900000      E     MOV     DPTR,#tCAN_Rx_Msg+015H
01FA E0                MOVX    A,@DPTR
01FB FF                MOV     R7,A
01FC 900000      E     MOV     DPTR,#tCAN_Rx_Msg+0DH
01FF E0                MOVX    A,@DPTR
0200 FD                MOV     R5,A
0201 120000      R     LCALL   _warning_msg
                                           ; SOURCE LINE # 370
                                           ; SOURCE LINE # 371
0204         ?C0046:
                                           ; SOURCE LINE # 374
0204 900000      E     MOV     DPTR,#?_Comm_I2C_Tx?BYTE+04H
0207 747C              MOV     A,#07CH
0209 F0                MOVX    @DPTR,A
020A A3                INC     DPTR
020B E4                CLR     A
020C F0                MOVX    @DPTR,A
020D A3                INC     DPTR
020E F0                MOVX    @DPTR,A
020F A3                INC     DPTR
0210 F0                MOVX    @DPTR,A
0211 7B8E              MOV     R3,#08EH
0213 7A09              MOV     R2,#09H
0215 7D02              MOV     R5,#02H
0217 7F90              MOV     R7,#090H
0219 120000      E     LCALL   _Comm_I2C_Tx
                                           ; SOURCE LINE # 375
021C 900000      R     MOV     DPTR,#ViewMode
021F E0                MOVX    A,@DPTR
0220 B40219            CJNE    A,#02H,?C0048
                                           ; SOURCE LINE # 376
                                           ; SOURCE LINE # 377
0223 900000      E     MOV     DPTR,#?_Comm_I2C_Tx?BYTE+04H
0226 E4                CLR     A
0227 F0                MOVX    @DPTR,A
0228 A3                INC     DPTR
0229 04                INC     A
022A F0                MOVX    @DPTR,A
022B E4                CLR     A
022C A3                INC     DPTR
022D F0                MOVX    @DPTR,A
022E A3                INC     DPTR
022F F0                MOVX    @DPTR,A
0230 FB                MOV     R3,A
0231 7AFC              MOV     R2,#0FCH
0233 7D02              MOV     R5,#02H
0235 7F90              MOV     R7,#090H
0237 120000      E     LCALL   _Comm_I2C_Tx
                                           ; SOURCE LINE # 378
023A 8015              SJMP    ?C0049
023C         ?C0048:
                                           ; SOURCE LINE # 380
                                           ; SOURCE LINE # 381
023C E4                CLR     A
023D 900000      E     MOV     DPTR,#?_Comm_I2C_Tx?BYTE+04H
0240 F0                MOVX    @DPTR,A
0241 A3                INC     DPTR
0242 F0                MOVX    @DPTR,A
C51 COMPILER V9.51   MGR_ISP                                                               11/17/2023 14:48:45 PAGE 156 

0243 A3                INC     DPTR
0244 F0                MOVX    @DPTR,A
0245 A3                INC     DPTR
0246 F0                MOVX    @DPTR,A
0247 FB                MOV     R3,A
0248 7AFC              MOV     R2,#0FCH
024A 7D02              MOV     R5,#02H
024C 7F90              MOV     R7,#090H
024E 120000      E     LCALL   _Comm_I2C_Tx
                                           ; SOURCE LINE # 382
0251         ?C0049:
                                           ; SOURCE LINE # 383
0251 900000      E     MOV     DPTR,#?_Comm_I2C_Tx?BYTE+04H
0254 7483              MOV     A,#083H
0256 F0                MOVX    @DPTR,A
0257 A3                INC     DPTR
0258 7411              MOV     A,#011H
025A F0                MOVX    @DPTR,A
025B E4                CLR     A
025C A3                INC     DPTR
025D F0                MOVX    @DPTR,A
025E A3                INC     DPTR
025F F0                MOVX    @DPTR,A
0260 7B40              MOV     R3,#040H
0262 FA                MOV     R2,A
0263 7D02              MOV     R5,#02H
0265 7F90              MOV     R7,#090H
0267 120000      E     LCALL   _Comm_I2C_Tx
                                           ; SOURCE LINE # 385
026A 120000      R     LCALL   DoorbellCheck
026D         ?C0050:
                                           ; SOURCE LINE # 386
                                           ; SOURCE LINE # 387
                                           ; SOURCE LINE # 388
026D 900000      E     MOV     DPTR,#?_Comm_I2C_Tx?BYTE+04H
0270 7481              MOV     A,#081H
0272 F0                MOVX    @DPTR,A
0273 A3                INC     DPTR
0274 7401              MOV     A,#01H
0276 F0                MOVX    @DPTR,A
0277 E4                CLR     A
0278 A3                INC     DPTR
0279 F0                MOVX    @DPTR,A
027A A3                INC     DPTR
027B F0                MOVX    @DPTR,A
027C 7B40              MOV     R3,#040H
027E FA                MOV     R2,A
027F 7D02              MOV     R5,#02H
0281 7F90              MOV     R7,#090H
0283 120000      E     LCALL   _Comm_I2C_Tx
                                           ; SOURCE LINE # 389
0286 7F0A              MOV     R7,#0AH
0288 7E00              MOV     R6,#00H
028A 120000      E     LCALL   _Wait_ms
                                           ; SOURCE LINE # 390
028D E4                CLR     A
028E 900000      E     MOV     DPTR,#?_Comm_I2C_Rx?BYTE+04H
0291 F0                MOVX    @DPTR,A
0292 A3                INC     DPTR
0293 F0                MOVX    @DPTR,A
0294 A3                INC     DPTR
0295 F0                MOVX    @DPTR,A
C51 COMPILER V9.51   MGR_ISP                                                               11/17/2023 14:48:45 PAGE 157 

0296 A3                INC     DPTR
0297 F0                MOVX    @DPTR,A
0298 7B40              MOV     R3,#040H
029A FA                MOV     R2,A
029B 7D02              MOV     R5,#02H
029D 7F90              MOV     R7,#090H
029F 120000      E     LCALL   _Comm_I2C_Rx
02A2 900000      R     MOV     DPTR,#read_data
02A5 EE                MOV     A,R6
02A6 F0                MOVX    @DPTR,A
02A7 A3                INC     DPTR
02A8 EF                MOV     A,R7
02A9 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 391
02AA 6409              XRL     A,#09H
02AC 4E                ORL     A,R6
02AD 7005              JNZ     ?C0051
                                           ; SOURCE LINE # 392
                                           ; SOURCE LINE # 393
                                           ; SOURCE LINE # 394
02AF         ?C0052:
                                           ; SOURCE LINE # 395
02AF 120000      R     LCALL   DoorbellCheck
                                           ; SOURCE LINE # 396
02B2 80B9              SJMP    ?C0050
02B4         ?C0051:
                                           ; SOURCE LINE # 399
02B4 900000      E     MOV     DPTR,#?_Comm_I2C_Tx?BYTE+04H
02B7 7428              MOV     A,#028H
02B9 F0                MOVX    @DPTR,A
02BA A3                INC     DPTR
02BB E4                CLR     A
02BC F0                MOVX    @DPTR,A
02BD A3                INC     DPTR
02BE F0                MOVX    @DPTR,A
02BF A3                INC     DPTR
02C0 F0                MOVX    @DPTR,A
02C1 FB                MOV     R3,A
02C2 7AFC              MOV     R2,#0FCH
02C4 7D02              MOV     R5,#02H
02C6 7F90              MOV     R7,#090H
02C8 120000      E     LCALL   _Comm_I2C_Tx
                                           ; SOURCE LINE # 400
02CB 900000      E     MOV     DPTR,#?_Comm_I2C_Tx?BYTE+04H
02CE 7481              MOV     A,#081H
02D0 F0                MOVX    @DPTR,A
02D1 A3                INC     DPTR
02D2 E4                CLR     A
02D3 F0                MOVX    @DPTR,A
02D4 A3                INC     DPTR
02D5 F0                MOVX    @DPTR,A
02D6 A3                INC     DPTR
02D7 F0                MOVX    @DPTR,A
02D8 7B40              MOV     R3,#040H
02DA FA                MOV     R2,A
02DB 7D02              MOV     R5,#02H
02DD 7F90              MOV     R7,#090H
02DF 120000      E     LCALL   _Comm_I2C_Tx
                                           ; SOURCE LINE # 401
02E2 120000      R     LCALL   DoorbellCheck
                                           ; SOURCE LINE # 402
02E5 900000      E     MOV     DPTR,#?_Comm_I2C_Tx?BYTE+04H
C51 COMPILER V9.51   MGR_ISP                                                               11/17/2023 14:48:45 PAGE 158 

02E8 7428              MOV     A,#028H
02EA F0                MOVX    @DPTR,A
02EB A3                INC     DPTR
02EC E4                CLR     A
02ED F0                MOVX    @DPTR,A
02EE A3                INC     DPTR
02EF F0                MOVX    @DPTR,A
02F0 A3                INC     DPTR
02F1 F0                MOVX    @DPTR,A
02F2 FB                MOV     R3,A
02F3 7AFC              MOV     R2,#0FCH
02F5 7D02              MOV     R5,#02H
02F7 7F90              MOV     R7,#090H
02F9 120000      E     LCALL   _Comm_I2C_Tx
                                           ; SOURCE LINE # 403
02FC 900000      E     MOV     DPTR,#?_Comm_I2C_Tx?BYTE+04H
02FF 7481              MOV     A,#081H
0301 F0                MOVX    @DPTR,A
0302 A3                INC     DPTR
0303 E4                CLR     A
0304 F0                MOVX    @DPTR,A
0305 A3                INC     DPTR
0306 F0                MOVX    @DPTR,A
0307 A3                INC     DPTR
0308 F0                MOVX    @DPTR,A
0309 7B40              MOV     R3,#040H
030B FA                MOV     R2,A
030C 7D02              MOV     R5,#02H
030E 7F90              MOV     R7,#090H
0310 120000      E     LCALL   _Comm_I2C_Tx
                                           ; SOURCE LINE # 404
0313 120000      R     LCALL   DoorbellCheck
                                           ; SOURCE LINE # 405
0316 900000      E     MOV     DPTR,#?_Comm_I2C_Tx?BYTE+04H
0319 7481              MOV     A,#081H
031B F0                MOVX    @DPTR,A
031C A3                INC     DPTR
031D 7401              MOV     A,#01H
031F F0                MOVX    @DPTR,A
0320 E4                CLR     A
0321 A3                INC     DPTR
0322 F0                MOVX    @DPTR,A
0323 A3                INC     DPTR
0324 F0                MOVX    @DPTR,A
0325 7B40              MOV     R3,#040H
0327 FA                MOV     R2,A
0328 7D02              MOV     R5,#02H
032A 7F90              MOV     R7,#090H
032C 120000      E     LCALL   _Comm_I2C_Tx
                                           ; SOURCE LINE # 408
032F E4                CLR     A
0330 900000      E     MOV     DPTR,#?_Comm_I2C_Tx?BYTE+04H
0333 F0                MOVX    @DPTR,A
0334 A3                INC     DPTR
0335 F0                MOVX    @DPTR,A
0336 A3                INC     DPTR
0337 F0                MOVX    @DPTR,A
0338 A3                INC     DPTR
0339 F0                MOVX    @DPTR,A
033A FB                MOV     R3,A
033B 7AFC              MOV     R2,#0FCH
033D 7D02              MOV     R5,#02H
C51 COMPILER V9.51   MGR_ISP                                                               11/17/2023 14:48:45 PAGE 159 

033F 7F90              MOV     R7,#090H
0341 120000      E     LCALL   _Comm_I2C_Tx
                                           ; SOURCE LINE # 409
0344 E4                CLR     A
0345 900000      E     MOV     DPTR,#?_Comm_I2C_Tx?BYTE+04H
0348 F0                MOVX    @DPTR,A
0349 A3                INC     DPTR
034A F0                MOVX    @DPTR,A
034B A3                INC     DPTR
034C F0                MOVX    @DPTR,A
034D A3                INC     DPTR
034E F0                MOVX    @DPTR,A
034F 7B02              MOV     R3,#02H
0351 7AFC              MOV     R2,#0FCH
0353 7D02              MOV     R5,#02H
0355 7F90              MOV     R7,#090H
0357 120000      E     LCALL   _Comm_I2C_Tx
                                           ; SOURCE LINE # 410
035A 900000      E     MOV     DPTR,#?_Comm_I2C_Tx?BYTE+04H
035D 7482              MOV     A,#082H
035F F0                MOVX    @DPTR,A
0360 A3                INC     DPTR
0361 740A              MOV     A,#0AH
0363 F0                MOVX    @DPTR,A
0364 E4                CLR     A
0365 A3                INC     DPTR
0366 F0                MOVX    @DPTR,A
0367 A3                INC     DPTR
0368 F0                MOVX    @DPTR,A
0369 7B40              MOV     R3,#040H
036B FA                MOV     R2,A
036C 7D02              MOV     R5,#02H
036E 7F90              MOV     R7,#090H
0370 120000      E     LCALL   _Comm_I2C_Tx
                                           ; SOURCE LINE # 411
0373 120000      R     LCALL   DoorbellCheck
                                           ; SOURCE LINE # 413
0376 E4                CLR     A
0377 900000      E     MOV     DPTR,#?_Comm_I2C_Rx?BYTE+04H
037A F0                MOVX    @DPTR,A
037B A3                INC     DPTR
037C F0                MOVX    @DPTR,A
037D A3                INC     DPTR
037E F0                MOVX    @DPTR,A
037F A3                INC     DPTR
0380 F0                MOVX    @DPTR,A
0381 7B0A              MOV     R3,#0AH
0383 7A4F              MOV     R2,#04FH
0385 7D02              MOV     R5,#02H
0387 7F90              MOV     R7,#090H
0389 120000      E     LCALL   _Comm_I2C_Rx
038C 900000      R     MOV     DPTR,#chk_Buffer
038F EE                MOV     A,R6
0390 F0                MOVX    @DPTR,A
0391 A3                INC     DPTR
0392 EF                MOV     A,R7
0393 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 414
0394 4E                ORL     A,R6
0395 6047              JZ      ?C0053
                                           ; SOURCE LINE # 415
                                           ; SOURCE LINE # 416
C51 COMPILER V9.51   MGR_ISP                                                               11/17/2023 14:48:45 PAGE 160 

0397 E4                CLR     A
0398 900000      E     MOV     DPTR,#?_Comm_I2C_Tx?BYTE+04H
039B F0                MOVX    @DPTR,A
039C A3                INC     DPTR
039D F0                MOVX    @DPTR,A
039E A3                INC     DPTR
039F F0                MOVX    @DPTR,A
03A0 A3                INC     DPTR
03A1 F0                MOVX    @DPTR,A
03A2 FB                MOV     R3,A
03A3 7AFC              MOV     R2,#0FCH
03A5 7D02              MOV     R5,#02H
03A7 7F90              MOV     R7,#090H
03A9 120000      E     LCALL   _Comm_I2C_Tx
                                           ; SOURCE LINE # 417
03AC E4                CLR     A
03AD 900000      E     MOV     DPTR,#?_Comm_I2C_Tx?BYTE+04H
03B0 F0                MOVX    @DPTR,A
03B1 A3                INC     DPTR
03B2 F0                MOVX    @DPTR,A
03B3 A3                INC     DPTR
03B4 F0                MOVX    @DPTR,A
03B5 A3                INC     DPTR
03B6 F0                MOVX    @DPTR,A
03B7 7B02              MOV     R3,#02H
03B9 7AFC              MOV     R2,#0FCH
03BB 7D02              MOV     R5,#02H
03BD 7F90              MOV     R7,#090H
03BF 120000      E     LCALL   _Comm_I2C_Tx
                                           ; SOURCE LINE # 418
03C2 900000      E     MOV     DPTR,#?_Comm_I2C_Tx?BYTE+04H
03C5 7482              MOV     A,#082H
03C7 F0                MOVX    @DPTR,A
03C8 A3                INC     DPTR
03C9 740A              MOV     A,#0AH
03CB F0                MOVX    @DPTR,A
03CC E4                CLR     A
03CD A3                INC     DPTR
03CE F0                MOVX    @DPTR,A
03CF A3                INC     DPTR
03D0 F0                MOVX    @DPTR,A
03D1 7B40              MOV     R3,#040H
03D3 FA                MOV     R2,A
03D4 7D02              MOV     R5,#02H
03D6 7F90              MOV     R7,#090H
03D8 120000      E     LCALL   _Comm_I2C_Tx
                                           ; SOURCE LINE # 419
03DB 120000      R     LCALL   DoorbellCheck
                                           ; SOURCE LINE # 420
03DE         ?C0053:
                                           ; SOURCE LINE # 424
03DE 900000      R     MOV     DPTR,#i
03E1 7402              MOV     A,#02H
03E3 F0                MOVX    @DPTR,A
03E4         ?C0054:
03E4 900000      R     MOV     DPTR,#i
03E7 E0                MOVX    A,@DPTR
03E8 FF                MOV     R7,A
03E9 C3                CLR     C
03EA 9409              SUBB    A,#09H
03EC 5016              JNC     ?C0057
                                           ; SOURCE LINE # 425
C51 COMPILER V9.51   MGR_ISP                                                               11/17/2023 14:48:45 PAGE 161 

                                           ; SOURCE LINE # 426
03EE EF                MOV     A,R7
03EF 25E0              ADD     A,ACC
03F1 2400        E     ADD     A,#LOW ga_Ext_tDTC_Type_Msg+01H
03F3 F582              MOV     DPL,A
03F5 E4                CLR     A
03F6 3400        E     ADDC    A,#HIGH ga_Ext_tDTC_Type_Msg+01H
03F8 F583              MOV     DPH,A
03FA E4                CLR     A
03FB F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 427
03FC 900000      R     MOV     DPTR,#i
03FF E0                MOVX    A,@DPTR
0400 04                INC     A
0401 F0                MOVX    @DPTR,A
0402 80E0              SJMP    ?C0054
                                           ; SOURCE LINE # 428
0404         ?C0057:
0404 22                RET     
             ; FUNCTION _Isp_View_Mode_Change (END)

             ; FUNCTION V_STB_Check (BEGIN)
                                           ; SOURCE LINE # 430
                                           ; SOURCE LINE # 431
                                           ; SOURCE LINE # 432
;---- Variable 'ret' assigned to Register 'R7' ----
0000 E4                CLR     A
0001 FF                MOV     R7,A
                                           ; SOURCE LINE # 436
0002 A2A2              MOV     C,AMP_V_STB
0004 33                RLC     A
0005 FF                MOV     R7,A
                                           ; SOURCE LINE # 437
0006 B4011C            CJNE    A,#01H,?C0058
                                           ; SOURCE LINE # 438
                                           ; SOURCE LINE # 439
0009 E4                CLR     A
000A 900000      R     MOV     DPTR,#v_stb_nomal_count
000D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 440
000E 900000      R     MOV     DPTR,#v_stb_error_count
0011 E0                MOVX    A,@DPTR
0012 04                INC     A
0013 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 441
0014 E0                MOVX    A,@DPTR
0015 C3                CLR     C
0016 9414              SUBB    A,#014H
0018 4024              JC      ?C0062
                                           ; SOURCE LINE # 442
                                           ; SOURCE LINE # 443
001A 7F08              MOV     R7,#08H
001C 120000      E     LCALL   _Record_DTC_Error
                                           ; SOURCE LINE # 444
001F E4                CLR     A
0020 900000      R     MOV     DPTR,#v_stb_error_count
0023 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 445
                                           ; SOURCE LINE # 446
0024 22                RET     
0025         ?C0058:
                                           ; SOURCE LINE # 448
C51 COMPILER V9.51   MGR_ISP                                                               11/17/2023 14:48:45 PAGE 162 

                                           ; SOURCE LINE # 449
0025 E4                CLR     A
0026 900000      R     MOV     DPTR,#v_stb_error_count
0029 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 450
002A A3                INC     DPTR
002B E0                MOVX    A,@DPTR
002C 04                INC     A
002D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 451
002E E0                MOVX    A,@DPTR
002F C3                CLR     C
0030 9414              SUBB    A,#014H
0032 400A              JC      ?C0062
                                           ; SOURCE LINE # 452
                                           ; SOURCE LINE # 453
0034 7F08              MOV     R7,#08H
0036 120000      E     LCALL   _Record_DTC_Clear
                                           ; SOURCE LINE # 454
0039 E4                CLR     A
003A 900000      R     MOV     DPTR,#v_stb_nomal_count
003D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 455
                                           ; SOURCE LINE # 456
                                           ; SOURCE LINE # 457
003E         ?C0062:
003E 22                RET     
             ; FUNCTION V_STB_Check (END)

             ; FUNCTION Check_Isp_InitState (BEGIN)
                                           ; SOURCE LINE # 459
                                           ; SOURCE LINE # 460
                                           ; SOURCE LINE # 464
0000 E4                CLR     A
0001 900000      R     MOV     DPTR,#Ret_State
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 465
0005 900000      R     MOV     DPTR,#lpcn
0008 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 466
0009 900000      E     MOV     DPTR,#?_Comm_I2C_Tx?BYTE+04H
000C 7481              MOV     A,#081H
000E F0                MOVX    @DPTR,A
000F A3                INC     DPTR
0010 7401              MOV     A,#01H
0012 F0                MOVX    @DPTR,A
0013 E4                CLR     A
0014 A3                INC     DPTR
0015 F0                MOVX    @DPTR,A
0016 A3                INC     DPTR
0017 F0                MOVX    @DPTR,A
0018 7B40              MOV     R3,#040H
001A FA                MOV     R2,A
001B 7D02              MOV     R5,#02H
001D 7F90              MOV     R7,#090H
001F 120000      E     LCALL   _Comm_I2C_Tx
0022         ?C0063:
                                           ; SOURCE LINE # 467
                                           ; SOURCE LINE # 468
                                           ; SOURCE LINE # 469
0022 E4                CLR     A
0023 900000      E     MOV     DPTR,#?_Comm_I2C_Rx?BYTE+04H
C51 COMPILER V9.51   MGR_ISP                                                               11/17/2023 14:48:45 PAGE 163 

0026 F0                MOVX    @DPTR,A
0027 A3                INC     DPTR
0028 F0                MOVX    @DPTR,A
0029 A3                INC     DPTR
002A F0                MOVX    @DPTR,A
002B A3                INC     DPTR
002C F0                MOVX    @DPTR,A
002D 7B40              MOV     R3,#040H
002F FA                MOV     R2,A
0030 7D02              MOV     R5,#02H
0032 7F90              MOV     R7,#090H
0034 120000      E     LCALL   _Comm_I2C_Rx
0037 900000      R     MOV     DPTR,#chk_data
003A EE                MOV     A,R6
003B F0                MOVX    @DPTR,A
003C A3                INC     DPTR
003D EF                MOV     A,R7
003E F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 470
003F EE                MOV     A,R6
0040 20E7DF            JB      ACC.7,?C0063
                                           ; SOURCE LINE # 471
                                           ; SOURCE LINE # 472
0043 E4                CLR     A
0044 900000      E     MOV     DPTR,#?_Comm_I2C_Rx?BYTE+04H
0047 F0                MOVX    @DPTR,A
0048 A3                INC     DPTR
0049 F0                MOVX    @DPTR,A
004A A3                INC     DPTR
004B F0                MOVX    @DPTR,A
004C A3                INC     DPTR
004D F0                MOVX    @DPTR,A
004E FB                MOV     R3,A
004F 7AFC              MOV     R2,#0FCH
0051 7D02              MOV     R5,#02H
0053 7F90              MOV     R7,#090H
0055 120000      E     LCALL   _Comm_I2C_Rx
0058 900000      R     MOV     DPTR,#chk_data
005B EE                MOV     A,R6
005C F0                MOVX    @DPTR,A
005D A3                INC     DPTR
005E EF                MOV     A,R7
005F F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 473
0060 E0                MOVX    A,@DPTR
0061 E4                CLR     A
0062 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 474
0063 A3                INC     DPTR
0064 E0                MOVX    A,@DPTR
0065 04                INC     A
0066 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 475
0067 E0                MOVX    A,@DPTR
0068 FF                MOV     R7,A
0069 C3                CLR     C
006A 940F              SUBB    A,#0FH
006C 500C              JNC     ?C0067
006E 900000      R     MOV     DPTR,#chk_data
0071 E0                MOVX    A,@DPTR
0072 B43119            CJNE    A,#031H,?C0066
0075 A3                INC     DPTR
C51 COMPILER V9.51   MGR_ISP                                                               11/17/2023 14:48:45 PAGE 164 

0076 E0                MOVX    A,@DPTR
0077 B40014            CJNE    A,#00H,?C0066
007A         ?C0067:
                                           ; SOURCE LINE # 476
                                           ; SOURCE LINE # 477
007A EF                MOV     A,R7
007B C3                CLR     C
007C 940F              SUBB    A,#0FH
007E 4007              JC      ?C0068
                                           ; SOURCE LINE # 478
                                           ; SOURCE LINE # 479
0080 7F06              MOV     R7,#06H
0082 120000      E     LCALL   _Record_DTC_Error
                                           ; SOURCE LINE # 480
0085 8010              SJMP    ?C0064
0087         ?C0068:
                                           ; SOURCE LINE # 482
                                           ; SOURCE LINE # 483
0087 7F06              MOV     R7,#06H
0089 120000      E     LCALL   _Record_DTC_Clear
                                           ; SOURCE LINE # 484
                                           ; SOURCE LINE # 485
008C 8009              SJMP    ?C0064
                                           ; SOURCE LINE # 486
008E         ?C0066:
                                           ; SOURCE LINE # 487
008E 7F14              MOV     R7,#014H
0090 7E00              MOV     R6,#00H
0092 120000      E     LCALL   _Wait_ms
                                           ; SOURCE LINE # 488
                                           ; SOURCE LINE # 490
0095 808B              SJMP    ?C0063
0097         ?C0064:
                                           ; SOURCE LINE # 491
0097 E4                CLR     A
0098 900000      R     MOV     DPTR,#lpcn
009B F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 492
009C 22                RET     
             ; FUNCTION Check_Isp_InitState (END)

             ; FUNCTION Frame_Count_Check (BEGIN)
                                           ; SOURCE LINE # 494
                                           ; SOURCE LINE # 495
                                           ; SOURCE LINE # 499
0000 E4                CLR     A
0001 900000      E     MOV     DPTR,#?_Comm_I2C_Rx?BYTE+04H
0004 F0                MOVX    @DPTR,A
0005 A3                INC     DPTR
0006 F0                MOVX    @DPTR,A
0007 A3                INC     DPTR
0008 F0                MOVX    @DPTR,A
0009 A3                INC     DPTR
000A F0                MOVX    @DPTR,A
000B 7B06              MOV     R3,#06H
000D 7A80              MOV     R2,#080H
000F 7D02              MOV     R5,#02H
0011 7F90              MOV     R7,#090H
0013 120000      E     LCALL   _Comm_I2C_Rx
0016 900000      R     MOV     DPTR,#Cur_FC_Data
0019 EE                MOV     A,R6
001A F0                MOVX    @DPTR,A
C51 COMPILER V9.51   MGR_ISP                                                               11/17/2023 14:48:45 PAGE 165 

001B A3                INC     DPTR
001C EF                MOV     A,R7
001D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 501
001E A3                INC     DPTR
001F E0                MOVX    A,@DPTR
0020 6E                XRL     A,R6
0021 7003              JNZ     ?C0131
0023 A3                INC     DPTR
0024 E0                MOVX    A,@DPTR
0025 6F                XRL     A,R7
0026         ?C0131:
0026 7006              JNZ     ?C0071
                                           ; SOURCE LINE # 502
                                           ; SOURCE LINE # 503
0028 7F03              MOV     R7,#03H
002A 120000      E     LCALL   _Record_DTC_Error
                                           ; SOURCE LINE # 504
002D 22                RET     
002E         ?C0071:
                                           ; SOURCE LINE # 506
                                           ; SOURCE LINE # 507
002E 7F03              MOV     R7,#03H
0030 120000      E     LCALL   _Record_DTC_Clear
                                           ; SOURCE LINE # 508
0033 900000      R     MOV     DPTR,#Cur_FC_Data
0036 E0                MOVX    A,@DPTR
0037 FF                MOV     R7,A
0038 A3                INC     DPTR
0039 E0                MOVX    A,@DPTR
003A A3                INC     DPTR
003B CF                XCH     A,R7
003C F0                MOVX    @DPTR,A
003D A3                INC     DPTR
003E EF                MOV     A,R7
003F F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 509
                                           ; SOURCE LINE # 510
0040         ?C0073:
0040 22                RET     
             ; FUNCTION Frame_Count_Check (END)

             ; FUNCTION Frame_Valide_Check (BEGIN)
                                           ; SOURCE LINE # 512
                                           ; SOURCE LINE # 513
                                           ; SOURCE LINE # 514
0000 E4                CLR     A
0001 900000      R     MOV     DPTR,#Frame_value
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 515
0005 120000      E     LCALL   Frame_Sync_Status
0008 900000      R     MOV     DPTR,#Frame_value
000B EF                MOV     A,R7
000C F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 517
000D E0                MOVX    A,@DPTR
000E C3                CLR     C
000F 9402              SUBB    A,#02H
0011 400B              JC      ?C0074
0013 E0                MOVX    A,@DPTR
0014 9404              SUBB    A,#04H
0016 5006              JNC     ?C0074
C51 COMPILER V9.51   MGR_ISP                                                               11/17/2023 14:48:45 PAGE 166 

                                           ; SOURCE LINE # 518
                                           ; SOURCE LINE # 519
0018 7F02              MOV     R7,#02H
001A 120000      E     LCALL   _Record_DTC_Clear
                                           ; SOURCE LINE # 520
001D 22                RET     
001E         ?C0074:
                                           ; SOURCE LINE # 522
                                           ; SOURCE LINE # 523
001E 7F02              MOV     R7,#02H
0020 120000      E     LCALL   _Record_DTC_Error
                                           ; SOURCE LINE # 524
                                           ; SOURCE LINE # 525
0023         ?C0076:
0023 22                RET     
             ; FUNCTION Frame_Valide_Check (END)

             ; FUNCTION Video_Signal_Check (BEGIN)
                                           ; SOURCE LINE # 527
                                           ; SOURCE LINE # 528
                                           ; SOURCE LINE # 529
0000 900000      R     MOV     DPTR,#ret
0003 7401              MOV     A,#01H
0005 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 534
0006 120000      E     LCALL   Get_Video_Signal
0009 900000      R     MOV     DPTR,#ret
000C EF                MOV     A,R7
000D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 535
000E 701B              JNZ     ?C0077
                                           ; SOURCE LINE # 536
                                           ; SOURCE LINE # 537
0010 900000      R     MOV     DPTR,#video_nomal_count
0013 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 538
0014 900000      R     MOV     DPTR,#video_error_count
0017 E0                MOVX    A,@DPTR
0018 04                INC     A
0019 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 539
001A E0                MOVX    A,@DPTR
001B C3                CLR     C
001C 9414              SUBB    A,#014H
001E 4024              JC      ?C0081
                                           ; SOURCE LINE # 540
                                           ; SOURCE LINE # 541
0020 7F07              MOV     R7,#07H
0022 120000      E     LCALL   _Record_DTC_Error
                                           ; SOURCE LINE # 542
0025 E4                CLR     A
0026 900000      R     MOV     DPTR,#video_error_count
0029 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 543
                                           ; SOURCE LINE # 544
002A 22                RET     
002B         ?C0077:
                                           ; SOURCE LINE # 546
                                           ; SOURCE LINE # 547
002B E4                CLR     A
002C 900000      R     MOV     DPTR,#video_error_count
002F F0                MOVX    @DPTR,A
C51 COMPILER V9.51   MGR_ISP                                                               11/17/2023 14:48:45 PAGE 167 

                                           ; SOURCE LINE # 548
0030 A3                INC     DPTR
0031 E0                MOVX    A,@DPTR
0032 04                INC     A
0033 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 549
0034 E0                MOVX    A,@DPTR
0035 C3                CLR     C
0036 9414              SUBB    A,#014H
0038 400A              JC      ?C0081
                                           ; SOURCE LINE # 550
                                           ; SOURCE LINE # 551
003A 7F07              MOV     R7,#07H
003C 120000      E     LCALL   _Record_DTC_Clear
                                           ; SOURCE LINE # 552
003F E4                CLR     A
0040 900000      R     MOV     DPTR,#video_nomal_count
0043 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 553
                                           ; SOURCE LINE # 554
                                           ; SOURCE LINE # 555
0044         ?C0081:
0044 22                RET     
             ; FUNCTION Video_Signal_Check (END)

             ; FUNCTION DoorbellCheck (BEGIN)
                                           ; SOURCE LINE # 557
                                           ; SOURCE LINE # 558
                                           ; SOURCE LINE # 559
0000 E4                CLR     A
0001 900000      R     MOV     DPTR,#On_Time
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 560
0005 750080      R     MOV     chk_data,#080H
0008 F500        R     MOV     chk_data+01H,A
                                           ; SOURCE LINE # 561
000A F500        R     MOV     lpcnt,A
                                           ; SOURCE LINE # 563
000C 7D0A              MOV     R5,#0AH
000E FC                MOV     R4,A
000F 7F0E              MOV     R7,#0EH
0011 120000      E     LCALL   _Delay_Time_Set
0014         ?C0084:
                                           ; SOURCE LINE # 565
                                           ; SOURCE LINE # 566
0014 7F0E              MOV     R7,#0EH
0016 120000      E     LCALL   _Delay_Time_Get
0019 900000      R     MOV     DPTR,#On_Time
001C EF                MOV     A,R7
001D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 567
001E B4011E            CJNE    A,#01H,?C0082
                                           ; SOURCE LINE # 568
                                           ; SOURCE LINE # 569
0021 0500        R     INC     lpcnt
                                           ; SOURCE LINE # 571
0023 E4                CLR     A
0024 900000      E     MOV     DPTR,#?_Comm_I2C_Rx?BYTE+04H
0027 F0                MOVX    @DPTR,A
0028 A3                INC     DPTR
0029 F0                MOVX    @DPTR,A
002A A3                INC     DPTR
C51 COMPILER V9.51   MGR_ISP                                                               11/17/2023 14:48:45 PAGE 168 

002B F0                MOVX    @DPTR,A
002C A3                INC     DPTR
002D F0                MOVX    @DPTR,A
002E 7B40              MOV     R3,#040H
0030 FA                MOV     R2,A
0031 7D02              MOV     R5,#02H
0033 7F90              MOV     R7,#090H
0035 120000      E     LCALL   _Comm_I2C_Rx
0038 8E00        R     MOV     chk_data,R6
003A 8F00        R     MOV     chk_data+01H,R7
                                           ; SOURCE LINE # 572
003C 120000      E     LCALL   WDT_Clear
                                           ; SOURCE LINE # 573
                                           ; SOURCE LINE # 574
003F         ?C0082:
                                           ; SOURCE LINE # 575
003F E500        R     MOV     A,chk_data
0041 30E707            JNB     ACC.7,?C0083
0044 E500        R     MOV     A,lpcnt
0046 C3                CLR     C
0047 940A              SUBB    A,#0AH
0049 40C9              JC      ?C0084
004B         ?C0083:
                                           ; SOURCE LINE # 577
004B 7F0E              MOV     R7,#0EH
004D 120000      E     LCALL   _Delay_Time_Expire
                                           ; SOURCE LINE # 578
0050 22                RET     
             ; FUNCTION DoorbellCheck (END)

             ; FUNCTION _Overlay_Guideline (BEGIN)
                                           ; SOURCE LINE # 580
0000 900000      R     MOV     DPTR,#steering_cur
0003 EE                MOV     A,R6
0004 F0                MOVX    @DPTR,A
0005 A3                INC     DPTR
0006 EF                MOV     A,R7
0007 F0                MOVX    @DPTR,A
0008 A3                INC     DPTR
0009 ED                MOV     A,R5
000A F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 581
                                           ; SOURCE LINE # 582
000B E4                CLR     A
000C F500        R     MOV     read_data,A
000E F500        R     MOV     read_data+01H,A
                                           ; SOURCE LINE # 585
0010 120000      R     LCALL   DoorbellCheck
                                           ; SOURCE LINE # 587
0013 900000      R     MOV     DPTR,#sign
0016 E0                MOVX    A,@DPTR
0017 7015              JNZ     ?C0088
                                           ; SOURCE LINE # 588
                                           ; SOURCE LINE # 589
0019 900000      R     MOV     DPTR,#steering_cur
001C E0                MOVX    A,@DPTR
001D FE                MOV     R6,A
001E A3                INC     DPTR
001F E0                MOVX    A,@DPTR
0020 FF                MOV     R7,A
0021 C3                CLR     C
0022 E4                CLR     A
C51 COMPILER V9.51   MGR_ISP                                                               11/17/2023 14:48:45 PAGE 169 

0023 9F                SUBB    A,R7
0024 FF                MOV     R7,A
0025 E4                CLR     A
0026 9E                SUBB    A,R6
0027 900000      R     MOV     DPTR,#steering_cur
002A F0                MOVX    @DPTR,A
002B A3                INC     DPTR
002C EF                MOV     A,R7
002D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 590
002E         ?C0088:
                                           ; SOURCE LINE # 592
002E 900000      R     MOV     DPTR,#steering_cur+01H
0031 E0                MOVX    A,@DPTR
0032 2429              ADD     A,#029H
0034 F0                MOVX    @DPTR,A
0035 900000      R     MOV     DPTR,#steering_cur
0038 E0                MOVX    A,@DPTR
0039 3400              ADDC    A,#00H
003B F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 594
003C 900000      R     MOV     DPTR,#Overlay_Guideline_flag
003F E0                MOVX    A,@DPTR
0040 701F              JNZ     ?C0089
                                           ; SOURCE LINE # 596
0042 7402              MOV     A,#02H
0044 900000      E     MOV     DPTR,#?_Comm_I2C_Tx?BYTE+04H
0047 F0                MOVX    @DPTR,A
0048 A3                INC     DPTR
0049 F0                MOVX    @DPTR,A
004A E4                CLR     A
004B A3                INC     DPTR
004C F0                MOVX    @DPTR,A
004D A3                INC     DPTR
004E F0                MOVX    @DPTR,A
004F FB                MOV     R3,A
0050 7AFC              MOV     R2,#0FCH
0052 7D02              MOV     R5,#02H
0054 7F90              MOV     R7,#090H
0056 120000      E     LCALL   _Comm_I2C_Tx
                                           ; SOURCE LINE # 597
0059 900000      R     MOV     DPTR,#Overlay_Guideline_flag
005C 7401              MOV     A,#01H
005E F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 598
005F 801D              SJMP    ?C0090
0061         ?C0089:
                                           ; SOURCE LINE # 599
                                           ; SOURCE LINE # 601
0061 900000      E     MOV     DPTR,#?_Comm_I2C_Tx?BYTE+04H
0064 7403              MOV     A,#03H
0066 F0                MOVX    @DPTR,A
0067 A3                INC     DPTR
0068 14                DEC     A
0069 F0                MOVX    @DPTR,A
006A E4                CLR     A
006B A3                INC     DPTR
006C F0                MOVX    @DPTR,A
006D A3                INC     DPTR
006E F0                MOVX    @DPTR,A
006F FB                MOV     R3,A
0070 7AFC              MOV     R2,#0FCH
C51 COMPILER V9.51   MGR_ISP                                                               11/17/2023 14:48:45 PAGE 170 

0072 7D02              MOV     R5,#02H
0074 7F90              MOV     R7,#090H
0076 120000      E     LCALL   _Comm_I2C_Tx
                                           ; SOURCE LINE # 602
0079 E4                CLR     A
007A 900000      R     MOV     DPTR,#Overlay_Guideline_flag
007D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 603
007E         ?C0090:
                                           ; SOURCE LINE # 605
007E 900000      R     MOV     DPTR,#steering_cur
0081 E0                MOVX    A,@DPTR
0082 FF                MOV     R7,A
0083 A3                INC     DPTR
0084 E0                MOVX    A,@DPTR
0085 900000      E     MOV     DPTR,#?_Comm_I2C_Tx?BYTE+04H
0088 CF                XCH     A,R7
0089 F0                MOVX    @DPTR,A
008A A3                INC     DPTR
008B EF                MOV     A,R7
008C F0                MOVX    @DPTR,A
008D E4                CLR     A
008E A3                INC     DPTR
008F F0                MOVX    @DPTR,A
0090 A3                INC     DPTR
0091 F0                MOVX    @DPTR,A
0092 7B02              MOV     R3,#02H
0094 7AFC              MOV     R2,#0FCH
0096 7D02              MOV     R5,#02H
0098 7F90              MOV     R7,#090H
009A 120000      E     LCALL   _Comm_I2C_Tx
                                           ; SOURCE LINE # 606
009D 900000      R     MOV     DPTR,#g_Guideline_OnOff
00A0 E0                MOVX    A,@DPTR
00A1 B4011A            CJNE    A,#01H,?C0091
                                           ; SOURCE LINE # 607
                                           ; SOURCE LINE # 608
00A4 900000      E     MOV     DPTR,#?_Comm_I2C_Tx?BYTE+04H
00A7 7401              MOV     A,#01H
00A9 F0                MOVX    @DPTR,A
00AA A3                INC     DPTR
00AB E4                CLR     A
00AC F0                MOVX    @DPTR,A
00AD A3                INC     DPTR
00AE F0                MOVX    @DPTR,A
00AF A3                INC     DPTR
00B0 F0                MOVX    @DPTR,A
00B1 7B04              MOV     R3,#04H
00B3 7AFC              MOV     R2,#0FCH
00B5 7D02              MOV     R5,#02H
00B7 7F90              MOV     R7,#090H
00B9 120000      E     LCALL   _Comm_I2C_Tx
                                           ; SOURCE LINE # 609
00BC 8016              SJMP    ?C0092
00BE         ?C0091:
                                           ; SOURCE LINE # 611
                                           ; SOURCE LINE # 612
00BE E4                CLR     A
00BF 900000      E     MOV     DPTR,#?_Comm_I2C_Tx?BYTE+04H
00C2 F0                MOVX    @DPTR,A
00C3 A3                INC     DPTR
00C4 F0                MOVX    @DPTR,A
C51 COMPILER V9.51   MGR_ISP                                                               11/17/2023 14:48:45 PAGE 171 

00C5 A3                INC     DPTR
00C6 F0                MOVX    @DPTR,A
00C7 A3                INC     DPTR
00C8 F0                MOVX    @DPTR,A
00C9 7B04              MOV     R3,#04H
00CB 7AFC              MOV     R2,#0FCH
00CD 7D02              MOV     R5,#02H
00CF 7F90              MOV     R7,#090H
00D1 120000      E     LCALL   _Comm_I2C_Tx
                                           ; SOURCE LINE # 613
00D4         ?C0092:
                                           ; SOURCE LINE # 614
00D4 120000      E     LCALL   WDT_Clear
                                           ; SOURCE LINE # 615
00D7 900000      E     MOV     DPTR,#?_Comm_I2C_Tx?BYTE+04H
00DA 7482              MOV     A,#082H
00DC F0                MOVX    @DPTR,A
00DD A3                INC     DPTR
00DE 7406              MOV     A,#06H
00E0 F0                MOVX    @DPTR,A
00E1 E4                CLR     A
00E2 A3                INC     DPTR
00E3 F0                MOVX    @DPTR,A
00E4 A3                INC     DPTR
00E5 F0                MOVX    @DPTR,A
00E6 7B40              MOV     R3,#040H
00E8 FA                MOV     R2,A
00E9 7D02              MOV     R5,#02H
00EB 7F90              MOV     R7,#090H
00ED 120000      E     LCALL   _Comm_I2C_Tx
                                           ; SOURCE LINE # 616
00F0 E4                CLR     A
00F1 900000      R     MOV     DPTR,#g_Overlay_Stauts_Loop_Check_Time
00F4 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 619
00F5 120000      R     LCALL   DoorbellCheck
                                           ; SOURCE LINE # 620
00F8 22                RET     
             ; FUNCTION _Overlay_Guideline (END)

             ; FUNCTION CheckCommandStatusLoop (BEGIN)
                                           ; SOURCE LINE # 625
                                           ; SOURCE LINE # 626
                                           ; SOURCE LINE # 629
0000 900000      R     MOV     DPTR,#ret
0003 7401              MOV     A,#01H
0005 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 631
0006 900000      R     MOV     DPTR,#lpcnt
0009 E0                MOVX    A,@DPTR
000A 04                INC     A
000B F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 633
000C E4                CLR     A
000D 900000      E     MOV     DPTR,#?_Comm_I2C_Rx?BYTE+04H
0010 F0                MOVX    @DPTR,A
0011 A3                INC     DPTR
0012 F0                MOVX    @DPTR,A
0013 A3                INC     DPTR
0014 F0                MOVX    @DPTR,A
0015 A3                INC     DPTR
0016 F0                MOVX    @DPTR,A
C51 COMPILER V9.51   MGR_ISP                                                               11/17/2023 14:48:45 PAGE 172 

0017 7B40              MOV     R3,#040H
0019 FA                MOV     R2,A
001A 7D02              MOV     R5,#02H
001C 7F90              MOV     R7,#090H
001E 120000      E     LCALL   _Comm_I2C_Rx
0021 900000      R     MOV     DPTR,#chk_data
0024 EE                MOV     A,R6
0025 F0                MOVX    @DPTR,A
0026 A3                INC     DPTR
0027 EF                MOV     A,R7
0028 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 634
0029 EE                MOV     A,R6
002A 20E715            JB      ACC.7,?C0094
                                           ; SOURCE LINE # 635
                                           ; SOURCE LINE # 636
002D 900000      R     MOV     DPTR,#ret
0030 7401              MOV     A,#01H
0032 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 637
0033 E4                CLR     A
0034 900000      R     MOV     DPTR,#lpcnt
0037 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 638
0038 7F0B              MOV     R7,#0BH
003A 120000      E     LCALL   _Delay_Time_Expire
                                           ; SOURCE LINE # 639
003D 120000      E     LCALL   WDT_Clear
                                           ; SOURCE LINE # 640
0040 8022              SJMP    ?C0095
0042         ?C0094:
                                           ; SOURCE LINE # 642
                                           ; SOURCE LINE # 643
0042 900000      R     MOV     DPTR,#lpcnt
0045 E0                MOVX    A,@DPTR
0046 C3                CLR     C
0047 9405              SUBB    A,#05H
0049 4013              JC      ?C0096
                                           ; SOURCE LINE # 644
                                           ; SOURCE LINE # 646
004B 120000      E     LCALL   WDT_Clear
                                           ; SOURCE LINE # 648
004E E4                CLR     A
004F 900000      R     MOV     DPTR,#ret
0052 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 649
0053 900000      R     MOV     DPTR,#lpcnt
0056 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 650
0057 7F0B              MOV     R7,#0BH
0059 120000      E     LCALL   _Delay_Time_Expire
                                           ; SOURCE LINE # 651
005C 8006              SJMP    ?C0095
005E         ?C0096:
                                           ; SOURCE LINE # 653
                                           ; SOURCE LINE # 654
005E 900000      R     MOV     DPTR,#ret
0061 7403              MOV     A,#03H
0063 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 655
                                           ; SOURCE LINE # 656
0064         ?C0095:
C51 COMPILER V9.51   MGR_ISP                                                               11/17/2023 14:48:45 PAGE 173 

                                           ; SOURCE LINE # 657
0064 900000      R     MOV     DPTR,#ret
0067 E0                MOVX    A,@DPTR
0068 FF                MOV     R7,A
                                           ; SOURCE LINE # 658
0069         ?C0098:
0069 22                RET     
             ; FUNCTION CheckCommandStatusLoop (END)

             ; FUNCTION Guidline_Off (BEGIN)
                                           ; SOURCE LINE # 660
                                           ; SOURCE LINE # 661
                                           ; SOURCE LINE # 662
0000 E4                CLR     A
0001 900000      E     MOV     DPTR,#?_Comm_I2C_Tx?BYTE+04H
0004 F0                MOVX    @DPTR,A
0005 A3                INC     DPTR
0006 F0                MOVX    @DPTR,A
0007 A3                INC     DPTR
0008 F0                MOVX    @DPTR,A
0009 A3                INC     DPTR
000A F0                MOVX    @DPTR,A
000B 7B04              MOV     R3,#04H
000D 7AFC              MOV     R2,#0FCH
000F 7D02              MOV     R5,#02H
0011 7F90              MOV     R7,#090H
0013 120000      E     LCALL   _Comm_I2C_Tx
                                           ; SOURCE LINE # 663
0016 900000      E     MOV     DPTR,#?_Comm_I2C_Tx?BYTE+04H
0019 7482              MOV     A,#082H
001B F0                MOVX    @DPTR,A
001C A3                INC     DPTR
001D 7406              MOV     A,#06H
001F F0                MOVX    @DPTR,A
0020 E4                CLR     A
0021 A3                INC     DPTR
0022 F0                MOVX    @DPTR,A
0023 A3                INC     DPTR
0024 F0                MOVX    @DPTR,A
0025 7B40              MOV     R3,#040H
0027 FA                MOV     R2,A
0028 7D02              MOV     R5,#02H
002A 7F90              MOV     R7,#090H
002C 120000      E     LCALL   _Comm_I2C_Tx
                                           ; SOURCE LINE # 664
002F E4                CLR     A
0030 900000      R     MOV     DPTR,#g_Guideline_OnOff
0033 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 665
0034 22                RET     
             ; FUNCTION Guidline_Off (END)

             ; FUNCTION Guidline_On (BEGIN)
                                           ; SOURCE LINE # 667
                                           ; SOURCE LINE # 668
                                           ; SOURCE LINE # 669
0000 900000      E     MOV     DPTR,#?_Comm_I2C_Tx?BYTE+04H
0003 7401              MOV     A,#01H
0005 F0                MOVX    @DPTR,A
0006 A3                INC     DPTR
0007 E4                CLR     A
0008 F0                MOVX    @DPTR,A
C51 COMPILER V9.51   MGR_ISP                                                               11/17/2023 14:48:45 PAGE 174 

0009 A3                INC     DPTR
000A F0                MOVX    @DPTR,A
000B A3                INC     DPTR
000C F0                MOVX    @DPTR,A
000D 7B04              MOV     R3,#04H
000F 7AFC              MOV     R2,#0FCH
0011 7D02              MOV     R5,#02H
0013 7F90              MOV     R7,#090H
0015 120000      E     LCALL   _Comm_I2C_Tx
                                           ; SOURCE LINE # 670
0018 900000      E     MOV     DPTR,#?_Comm_I2C_Tx?BYTE+04H
001B 7482              MOV     A,#082H
001D F0                MOVX    @DPTR,A
001E A3                INC     DPTR
001F 7406              MOV     A,#06H
0021 F0                MOVX    @DPTR,A
0022 E4                CLR     A
0023 A3                INC     DPTR
0024 F0                MOVX    @DPTR,A
0025 A3                INC     DPTR
0026 F0                MOVX    @DPTR,A
0027 7B40              MOV     R3,#040H
0029 FA                MOV     R2,A
002A 7D02              MOV     R5,#02H
002C 7F90              MOV     R7,#090H
002E 120000      E     LCALL   _Comm_I2C_Tx
                                           ; SOURCE LINE # 671
0031 900000      R     MOV     DPTR,#g_Guideline_OnOff
0034 7401              MOV     A,#01H
0036 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 672
0037 22                RET     
             ; FUNCTION Guidline_On (END)

             ; FUNCTION Isp_Off (BEGIN)
                                           ; SOURCE LINE # 674
                                           ; SOURCE LINE # 675
                                           ; SOURCE LINE # 676
0000 C2A4              CLR     MCU_SENSOR_RESET
                                           ; SOURCE LINE # 677
0002 22                RET     
             ; FUNCTION Isp_Off (END)

             ; FUNCTION Isp_On (BEGIN)
                                           ; SOURCE LINE # 679
                                           ; SOURCE LINE # 680
                                           ; SOURCE LINE # 681
0000 120000      R     LCALL   Init_IspTask
                                           ; SOURCE LINE # 682
0003 22                RET     
             ; FUNCTION Isp_On (END)

             ; FUNCTION _Fixed_Guidline_On (BEGIN)
                                           ; SOURCE LINE # 684
0000 900000      R     MOV     DPTR,#ViewMode
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 685
                                           ; SOURCE LINE # 688
0005 120000      R     LCALL   DoorbellCheck
                                           ; SOURCE LINE # 690
0008 900000      R     MOV     DPTR,#overlay_buffer_flag
C51 COMPILER V9.51   MGR_ISP                                                               11/17/2023 14:48:45 PAGE 175 

000B E0                MOVX    A,@DPTR
000C 7020              JNZ     ?C0103
                                           ; SOURCE LINE # 691
                                           ; SOURCE LINE # 692
000E 900000      E     MOV     DPTR,#?_Comm_I2C_Tx?BYTE+04H
0011 7404              MOV     A,#04H
0013 F0                MOVX    @DPTR,A
0014 A3                INC     DPTR
0015 14                DEC     A
0016 F0                MOVX    @DPTR,A
0017 E4                CLR     A
0018 A3                INC     DPTR
0019 F0                MOVX    @DPTR,A
001A A3                INC     DPTR
001B F0                MOVX    @DPTR,A
001C FB                MOV     R3,A
001D 7AFC              MOV     R2,#0FCH
001F 7D02              MOV     R5,#02H
0021 7F90              MOV     R7,#090H
0023 120000      E     LCALL   _Comm_I2C_Tx
                                           ; SOURCE LINE # 693
0026 900000      R     MOV     DPTR,#overlay_buffer_flag
0029 7401              MOV     A,#01H
002B F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 694
002C 801E              SJMP    ?C0104
002E         ?C0103:
                                           ; SOURCE LINE # 696
                                           ; SOURCE LINE # 697
002E 900000      E     MOV     DPTR,#?_Comm_I2C_Tx?BYTE+04H
0031 7405              MOV     A,#05H
0033 F0                MOVX    @DPTR,A
0034 A3                INC     DPTR
0035 7403              MOV     A,#03H
0037 F0                MOVX    @DPTR,A
0038 E4                CLR     A
0039 A3                INC     DPTR
003A F0                MOVX    @DPTR,A
003B A3                INC     DPTR
003C F0                MOVX    @DPTR,A
003D FB                MOV     R3,A
003E 7AFC              MOV     R2,#0FCH
0040 7D02              MOV     R5,#02H
0042 7F90              MOV     R7,#090H
0044 120000      E     LCALL   _Comm_I2C_Tx
                                           ; SOURCE LINE # 698
0047 E4                CLR     A
0048 900000      R     MOV     DPTR,#overlay_buffer_flag
004B F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 699
004C         ?C0104:
                                           ; SOURCE LINE # 700
004C 900000      R     MOV     DPTR,#ViewMode
004F E0                MOVX    A,@DPTR
0050 B4021B            CJNE    A,#02H,?C0105
                                           ; SOURCE LINE # 701
                                           ; SOURCE LINE # 702
0053 900000      E     MOV     DPTR,#?_Comm_I2C_Tx?BYTE+04H
0056 E4                CLR     A
0057 F0                MOVX    @DPTR,A
0058 A3                INC     DPTR
0059 7475              MOV     A,#075H
C51 COMPILER V9.51   MGR_ISP                                                               11/17/2023 14:48:45 PAGE 176 

005B F0                MOVX    @DPTR,A
005C E4                CLR     A
005D A3                INC     DPTR
005E F0                MOVX    @DPTR,A
005F A3                INC     DPTR
0060 F0                MOVX    @DPTR,A
0061 7B02              MOV     R3,#02H
0063 7AFC              MOV     R2,#0FCH
0065 7D02              MOV     R5,#02H
0067 7F90              MOV     R7,#090H
0069 120000      E     LCALL   _Comm_I2C_Tx
                                           ; SOURCE LINE # 703
006C 8019              SJMP    ?C0106
006E         ?C0105:
                                           ; SOURCE LINE # 705
                                           ; SOURCE LINE # 706
006E 900000      E     MOV     DPTR,#?_Comm_I2C_Tx?BYTE+04H
0071 E4                CLR     A
0072 F0                MOVX    @DPTR,A
0073 A3                INC     DPTR
0074 7474              MOV     A,#074H
0076 F0                MOVX    @DPTR,A
0077 E4                CLR     A
0078 A3                INC     DPTR
0079 F0                MOVX    @DPTR,A
007A A3                INC     DPTR
007B F0                MOVX    @DPTR,A
007C 7B02              MOV     R3,#02H
007E 7AFC              MOV     R2,#0FCH
0080 7D02              MOV     R5,#02H
0082 7F90              MOV     R7,#090H
0084 120000      E     LCALL   _Comm_I2C_Tx
                                           ; SOURCE LINE # 707
0087         ?C0106:
                                           ; SOURCE LINE # 708
0087 900000      R     MOV     DPTR,#g_Guideline_OnOff
008A E0                MOVX    A,@DPTR
008B B4011A            CJNE    A,#01H,?C0107
                                           ; SOURCE LINE # 709
                                           ; SOURCE LINE # 710
008E 900000      E     MOV     DPTR,#?_Comm_I2C_Tx?BYTE+04H
0091 7401              MOV     A,#01H
0093 F0                MOVX    @DPTR,A
0094 A3                INC     DPTR
0095 E4                CLR     A
0096 F0                MOVX    @DPTR,A
0097 A3                INC     DPTR
0098 F0                MOVX    @DPTR,A
0099 A3                INC     DPTR
009A F0                MOVX    @DPTR,A
009B 7B04              MOV     R3,#04H
009D 7AFC              MOV     R2,#0FCH
009F 7D02              MOV     R5,#02H
00A1 7F90              MOV     R7,#090H
00A3 120000      E     LCALL   _Comm_I2C_Tx
                                           ; SOURCE LINE # 711
00A6 8016              SJMP    ?C0108
00A8         ?C0107:
                                           ; SOURCE LINE # 713
                                           ; SOURCE LINE # 714
00A8 E4                CLR     A
00A9 900000      E     MOV     DPTR,#?_Comm_I2C_Tx?BYTE+04H
C51 COMPILER V9.51   MGR_ISP                                                               11/17/2023 14:48:45 PAGE 177 

00AC F0                MOVX    @DPTR,A
00AD A3                INC     DPTR
00AE F0                MOVX    @DPTR,A
00AF A3                INC     DPTR
00B0 F0                MOVX    @DPTR,A
00B1 A3                INC     DPTR
00B2 F0                MOVX    @DPTR,A
00B3 7B04              MOV     R3,#04H
00B5 7AFC              MOV     R2,#0FCH
00B7 7D02              MOV     R5,#02H
00B9 7F90              MOV     R7,#090H
00BB 120000      E     LCALL   _Comm_I2C_Tx
                                           ; SOURCE LINE # 715
00BE         ?C0108:
                                           ; SOURCE LINE # 716
00BE 900000      E     MOV     DPTR,#?_Comm_I2C_Tx?BYTE+04H
00C1 7482              MOV     A,#082H
00C3 F0                MOVX    @DPTR,A
00C4 A3                INC     DPTR
00C5 7406              MOV     A,#06H
00C7 F0                MOVX    @DPTR,A
00C8 E4                CLR     A
00C9 A3                INC     DPTR
00CA F0                MOVX    @DPTR,A
00CB A3                INC     DPTR
00CC F0                MOVX    @DPTR,A
00CD 7B40              MOV     R3,#040H
00CF FA                MOV     R2,A
00D0 7D02              MOV     R5,#02H
00D2 7F90              MOV     R7,#090H
00D4 120000      E     LCALL   _Comm_I2C_Tx
                                           ; SOURCE LINE # 718
00D7 120000      R     LCALL   DoorbellCheck
                                           ; SOURCE LINE # 719
00DA 22                RET     
             ; FUNCTION _Fixed_Guidline_On (END)

             ; FUNCTION Fixed_Guidline_Off (BEGIN)
                                           ; SOURCE LINE # 721
                                           ; SOURCE LINE # 722
                                           ; SOURCE LINE # 723
0000 E4                CLR     A
0001 900000      E     MOV     DPTR,#?_Comm_I2C_Tx?BYTE+04H
0004 F0                MOVX    @DPTR,A
0005 A3                INC     DPTR
0006 F0                MOVX    @DPTR,A
0007 A3                INC     DPTR
0008 F0                MOVX    @DPTR,A
0009 A3                INC     DPTR
000A F0                MOVX    @DPTR,A
000B 7B04              MOV     R3,#04H
000D 7AFC              MOV     R2,#0FCH
000F 7D02              MOV     R5,#02H
0011 7F90              MOV     R7,#090H
0013 120000      E     LCALL   _Comm_I2C_Tx
                                           ; SOURCE LINE # 724
0016 900000      E     MOV     DPTR,#?_Comm_I2C_Tx?BYTE+04H
0019 7482              MOV     A,#082H
001B F0                MOVX    @DPTR,A
001C A3                INC     DPTR
001D 7406              MOV     A,#06H
001F F0                MOVX    @DPTR,A
C51 COMPILER V9.51   MGR_ISP                                                               11/17/2023 14:48:45 PAGE 178 

0020 E4                CLR     A
0021 A3                INC     DPTR
0022 F0                MOVX    @DPTR,A
0023 A3                INC     DPTR
0024 F0                MOVX    @DPTR,A
0025 7B40              MOV     R3,#040H
0027 FA                MOV     R2,A
0028 7D02              MOV     R5,#02H
002A 7F90              MOV     R7,#090H
002C 120000      E     LCALL   _Comm_I2C_Tx
                                           ; SOURCE LINE # 725
002F 22                RET     
             ; FUNCTION Fixed_Guidline_Off (END)

             ; FUNCTION _warning_msg (BEGIN)
                                           ; SOURCE LINE # 727
0000 900000      R     MOV     DPTR,#hutype
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
0005 A3                INC     DPTR
0006 ED                MOV     A,R5
0007 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 728
                                           ; SOURCE LINE # 731
0008 E4                CLR     A
0009 F500        R     MOV     read_data,A
000B F500        R     MOV     read_data+01H,A
                                           ; SOURCE LINE # 732
000D A3                INC     DPTR
000E F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 734
000F 120000      R     LCALL   DoorbellCheck
                                           ; SOURCE LINE # 736
0012 900000      R     MOV     DPTR,#hutype
0015 E0                MOVX    A,@DPTR
0016 FF                MOV     R7,A
0017 C3                CLR     C
0018 9410              SUBB    A,#010H
001A 4006              JC      ?C0113
001C EF                MOV     A,R7
001D D3                SETB    C
001E 9421              SUBB    A,#021H
0020 4024              JC      ?C0112
0022         ?C0113:
0022 EF                MOV     A,R7
0023 C3                CLR     C
0024 9460              SUBB    A,#060H
0026 4006              JC      ?C0114
0028 EF                MOV     A,R7
0029 D3                SETB    C
002A 9468              SUBB    A,#068H
002C 4018              JC      ?C0112
002E         ?C0114:
002E EF                MOV     A,R7
002F 6441              XRL     A,#041H
0031 6013              JZ      ?C0112
0033 EF                MOV     A,R7
0034 6470              XRL     A,#070H
0036 600E              JZ      ?C0112
0038 EF                MOV     A,R7
0039 64FA              XRL     A,#0FAH
003B 6009              JZ      ?C0112
C51 COMPILER V9.51   MGR_ISP                                                               11/17/2023 14:48:45 PAGE 179 

003D 900000      R     MOV     DPTR,#Lang
0040 E0                MOVX    A,@DPTR
0041 D3                SETB    C
0042 941F              SUBB    A,#01FH
0044 4007              JC      ?C0111
0046         ?C0112:
                                           ; SOURCE LINE # 738
                                           ; SOURCE LINE # 739
0046 E4                CLR     A
0047 900000      R     MOV     DPTR,#ret
004A F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 740
004B 8006              SJMP    ?C0115
004D         ?C0111:
                                           ; SOURCE LINE # 742
                                           ; SOURCE LINE # 743
004D 900000      R     MOV     DPTR,#ret
0050 7401              MOV     A,#01H
0052 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 744
0053         ?C0115:
                                           ; SOURCE LINE # 746
0053 900000      R     MOV     DPTR,#Lang
0056 E0                MOVX    A,@DPTR
0057 FF                MOV     R7,A
0058 B4FF03            CJNE    A,#0FFH,?C0116
                                           ; SOURCE LINE # 747
                                           ; SOURCE LINE # 748
005B E4                CLR     A
005C A3                INC     DPTR
005D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 749
005E         ?C0116:
                                           ; SOURCE LINE # 751
005E 900000      R     MOV     DPTR,#ret
0061 E0                MOVX    A,@DPTR
0062 B4011F            CJNE    A,#01H,?C0117
                                           ; SOURCE LINE # 752
                                           ; SOURCE LINE # 753
0065 EF                MOV     A,R7
0066 B41F0C            CJNE    A,#01FH,?C0118
                                           ; SOURCE LINE # 754
                                           ; SOURCE LINE # 755
0069 900000      R     MOV     DPTR,#Pre_Lang
006C E0                MOVX    A,@DPTR
006D A3                INC     DPTR
006E E0                MOVX    A,@DPTR
006F 900000      R     MOV     DPTR,#Lang
0072 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 756
0073 8015              SJMP    ?C0120
0075         ?C0118:
                                           ; SOURCE LINE # 758
                                           ; SOURCE LINE # 759
0075 900000      R     MOV     DPTR,#lan_start_addr
0078 E0                MOVX    A,@DPTR
0079 A3                INC     DPTR
007A E0                MOVX    A,@DPTR
007B FF                MOV     R7,A
007C 900000      R     MOV     DPTR,#Lang
007F E0                MOVX    A,@DPTR
0080 2F                ADD     A,R7
C51 COMPILER V9.51   MGR_ISP                                                               11/17/2023 14:48:45 PAGE 180 

0081 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 760
                                           ; SOURCE LINE # 761
0082 8006              SJMP    ?C0120
0084         ?C0117:
                                           ; SOURCE LINE # 763
                                           ; SOURCE LINE # 764
0084 900000      R     MOV     DPTR,#Lang
0087 7472              MOV     A,#072H
0089 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 765
008A         ?C0120:
                                           ; SOURCE LINE # 767
008A 900000      R     MOV     DPTR,#Lang
008D E0                MOVX    A,@DPTR
008E FF                MOV     R7,A
008F 900000      R     MOV     DPTR,#Pre_Lang
0092 E4                CLR     A
0093 F0                MOVX    @DPTR,A
0094 A3                INC     DPTR
0095 EF                MOV     A,R7
0096 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 769
0097 900000      R     MOV     DPTR,#warning_msg_flag
009A E0                MOVX    A,@DPTR
009B 7021              JNZ     ?C0121
                                           ; SOURCE LINE # 770
                                           ; SOURCE LINE # 771
009D 900000      E     MOV     DPTR,#?_Comm_I2C_Tx?BYTE+04H
00A0 7406              MOV     A,#06H
00A2 F0                MOVX    @DPTR,A
00A3 A3                INC     DPTR
00A4 7401              MOV     A,#01H
00A6 F0                MOVX    @DPTR,A
00A7 E4                CLR     A
00A8 A3                INC     DPTR
00A9 F0                MOVX    @DPTR,A
00AA A3                INC     DPTR
00AB F0                MOVX    @DPTR,A
00AC FB                MOV     R3,A
00AD 7AFC              MOV     R2,#0FCH
00AF 7D02              MOV     R5,#02H
00B1 7F90              MOV     R7,#090H
00B3 120000      E     LCALL   _Comm_I2C_Tx
                                           ; SOURCE LINE # 772
00B6 900000      R     MOV     DPTR,#warning_msg_flag
00B9 7401              MOV     A,#01H
00BB F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 773
00BC 801C              SJMP    ?C0122
00BE         ?C0121:
                                           ; SOURCE LINE # 775
                                           ; SOURCE LINE # 776
00BE 7401              MOV     A,#01H
00C0 900000      E     MOV     DPTR,#?_Comm_I2C_Tx?BYTE+04H
00C3 F0                MOVX    @DPTR,A
00C4 A3                INC     DPTR
00C5 F0                MOVX    @DPTR,A
00C6 E4                CLR     A
00C7 A3                INC     DPTR
00C8 F0                MOVX    @DPTR,A
00C9 A3                INC     DPTR
C51 COMPILER V9.51   MGR_ISP                                                               11/17/2023 14:48:45 PAGE 181 

00CA F0                MOVX    @DPTR,A
00CB FB                MOV     R3,A
00CC 7AFC              MOV     R2,#0FCH
00CE 7D02              MOV     R5,#02H
00D0 7F90              MOV     R7,#090H
00D2 120000      E     LCALL   _Comm_I2C_Tx
                                           ; SOURCE LINE # 777
00D5 E4                CLR     A
00D6 900000      R     MOV     DPTR,#warning_msg_flag
00D9 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 778
00DA         ?C0122:
                                           ; SOURCE LINE # 779
00DA 900000      R     MOV     DPTR,#Lang
00DD E0                MOVX    A,@DPTR
00DE FF                MOV     R7,A
00DF 900000      E     MOV     DPTR,#?_Comm_I2C_Tx?BYTE+04H
00E2 E4                CLR     A
00E3 F0                MOVX    @DPTR,A
00E4 A3                INC     DPTR
00E5 EF                MOV     A,R7
00E6 F0                MOVX    @DPTR,A
00E7 E4                CLR     A
00E8 A3                INC     DPTR
00E9 F0                MOVX    @DPTR,A
00EA A3                INC     DPTR
00EB F0                MOVX    @DPTR,A
00EC 7B02              MOV     R3,#02H
00EE 7AFC              MOV     R2,#0FCH
00F0 7D02              MOV     R5,#02H
00F2 7F90              MOV     R7,#090H
00F4 120000      E     LCALL   _Comm_I2C_Tx
                                           ; SOURCE LINE # 780
00F7 900000      R     MOV     DPTR,#ret
00FA E0                MOVX    A,@DPTR
00FB B40118            CJNE    A,#01H,?C0123
                                           ; SOURCE LINE # 781
                                           ; SOURCE LINE # 782
00FE 900000      E     MOV     DPTR,#?_Comm_I2C_Tx?BYTE+04H
0101 7401              MOV     A,#01H
0103 F0                MOVX    @DPTR,A
0104 A3                INC     DPTR
0105 E4                CLR     A
0106 F0                MOVX    @DPTR,A
0107 A3                INC     DPTR
0108 F0                MOVX    @DPTR,A
0109 A3                INC     DPTR
010A F0                MOVX    @DPTR,A
010B 7B04              MOV     R3,#04H
010D 7AFC              MOV     R2,#0FCH
010F 7D02              MOV     R5,#02H
0111 7F90              MOV     R7,#090H
0113 120000      E     LCALL   _Comm_I2C_Tx
                                           ; SOURCE LINE # 783
0116         ?C0123:
                                           ; SOURCE LINE # 784
0116 900000      E     MOV     DPTR,#?_Comm_I2C_Tx?BYTE+04H
0119 7482              MOV     A,#082H
011B F0                MOVX    @DPTR,A
011C A3                INC     DPTR
011D 7406              MOV     A,#06H
011F F0                MOVX    @DPTR,A
C51 COMPILER V9.51   MGR_ISP                                                               11/17/2023 14:48:45 PAGE 182 

0120 E4                CLR     A
0121 A3                INC     DPTR
0122 F0                MOVX    @DPTR,A
0123 A3                INC     DPTR
0124 F0                MOVX    @DPTR,A
0125 7B40              MOV     R3,#040H
0127 FA                MOV     R2,A
0128 7D02              MOV     R5,#02H
012A 7F90              MOV     R7,#090H
012C 120000      E     LCALL   _Comm_I2C_Tx
                                           ; SOURCE LINE # 786
012F 120000      R     LCALL   DoorbellCheck
                                           ; SOURCE LINE # 787
0132 22                RET     
             ; FUNCTION _warning_msg (END)

             ; FUNCTION _Sensor_XY_Offset_set (BEGIN)
                                           ; SOURCE LINE # 789
;---- Variable 'y' assigned to Register 'R5' ----
;---- Variable 'x' assigned to Register 'R7' ----
                                           ; SOURCE LINE # 790
                                           ; SOURCE LINE # 791
0000 E4                CLR     A
0001 F500        R     MOV     read_data,A
0003 F500        R     MOV     read_data+01H,A
                                           ; SOURCE LINE # 792
0005 900000      R     MOV     DPTR,#write_data
0008 F0                MOVX    @DPTR,A
0009 A3                INC     DPTR
000A F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 794
000B EF                MOV     A,R7
000C FF                MOV     R7,A
000D ED                MOV     A,R5
000E 900000      R     MOV     DPTR,#write_data
0011 CF                XCH     A,R7
0012 F0                MOVX    @DPTR,A
0013 A3                INC     DPTR
0014 EF                MOV     A,R7
0015 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 796
0016 120000      R     LCALL   DoorbellCheck
0019         ?C0125:
                                           ; SOURCE LINE # 798
                                           ; SOURCE LINE # 799
                                           ; SOURCE LINE # 800
0019 900000      E     MOV     DPTR,#?_Comm_I2C_Tx?BYTE+04H
001C 7481              MOV     A,#081H
001E F0                MOVX    @DPTR,A
001F A3                INC     DPTR
0020 7401              MOV     A,#01H
0022 F0                MOVX    @DPTR,A
0023 E4                CLR     A
0024 A3                INC     DPTR
0025 F0                MOVX    @DPTR,A
0026 A3                INC     DPTR
0027 F0                MOVX    @DPTR,A
0028 7B40              MOV     R3,#040H
002A FA                MOV     R2,A
002B 7D02              MOV     R5,#02H
002D 7F90              MOV     R7,#090H
002F 120000      E     LCALL   _Comm_I2C_Tx
C51 COMPILER V9.51   MGR_ISP                                                               11/17/2023 14:48:45 PAGE 183 

                                           ; SOURCE LINE # 801
0032 7F0A              MOV     R7,#0AH
0034 7E00              MOV     R6,#00H
0036 120000      E     LCALL   _Wait_ms
                                           ; SOURCE LINE # 802
0039 E4                CLR     A
003A 900000      E     MOV     DPTR,#?_Comm_I2C_Rx?BYTE+04H
003D F0                MOVX    @DPTR,A
003E A3                INC     DPTR
003F F0                MOVX    @DPTR,A
0040 A3                INC     DPTR
0041 F0                MOVX    @DPTR,A
0042 A3                INC     DPTR
0043 F0                MOVX    @DPTR,A
0044 7B40              MOV     R3,#040H
0046 FA                MOV     R2,A
0047 7D02              MOV     R5,#02H
0049 7F90              MOV     R7,#090H
004B 120000      E     LCALL   _Comm_I2C_Rx
004E 8E00        R     MOV     read_data,R6
0050 8F00        R     MOV     read_data+01H,R7
                                           ; SOURCE LINE # 803
0052 E500        R     MOV     A,read_data+01H
0054 6409              XRL     A,#09H
0056 4500        R     ORL     A,read_data
0058 7005              JNZ     ?C0126
                                           ; SOURCE LINE # 804
                                           ; SOURCE LINE # 805
                                           ; SOURCE LINE # 806
005A         ?C0127:
                                           ; SOURCE LINE # 807
005A 120000      R     LCALL   DoorbellCheck
                                           ; SOURCE LINE # 808
005D 80BA              SJMP    ?C0125
005F         ?C0126:
                                           ; SOURCE LINE # 810
005F 900000      E     MOV     DPTR,#?_Comm_I2C_Tx?BYTE+04H
0062 74C8              MOV     A,#0C8H
0064 F0                MOVX    @DPTR,A
0065 A3                INC     DPTR
0066 74A8              MOV     A,#0A8H
0068 F0                MOVX    @DPTR,A
0069 E4                CLR     A
006A A3                INC     DPTR
006B F0                MOVX    @DPTR,A
006C A3                INC     DPTR
006D F0                MOVX    @DPTR,A
006E 7B8E              MOV     R3,#08EH
0070 7A09              MOV     R2,#09H
0072 7D02              MOV     R5,#02H
0074 7F90              MOV     R7,#090H
0076 120000      E     LCALL   _Comm_I2C_Tx
                                           ; SOURCE LINE # 811
0079 900000      R     MOV     DPTR,#write_data
007C E0                MOVX    A,@DPTR
007D FF                MOV     R7,A
007E A3                INC     DPTR
007F E0                MOVX    A,@DPTR
0080 900000      E     MOV     DPTR,#?_Comm_I2C_Tx?BYTE+04H
0083 CF                XCH     A,R7
0084 F0                MOVX    @DPTR,A
0085 A3                INC     DPTR
C51 COMPILER V9.51   MGR_ISP                                                               11/17/2023 14:48:45 PAGE 184 

0086 EF                MOV     A,R7
0087 F0                MOVX    @DPTR,A
0088 E4                CLR     A
0089 A3                INC     DPTR
008A F0                MOVX    @DPTR,A
008B A3                INC     DPTR
008C F0                MOVX    @DPTR,A
008D 7BA8              MOV     R3,#0A8H
008F 7AC8              MOV     R2,#0C8H
0091 7D02              MOV     R5,#02H
0093 7F90              MOV     R7,#090H
0095 120000      E     LCALL   _Comm_I2C_Tx
                                           ; SOURCE LINE # 813
0098 900000      E     MOV     DPTR,#?_Comm_I2C_Tx?BYTE+04H
009B 7428              MOV     A,#028H
009D F0                MOVX    @DPTR,A
009E A3                INC     DPTR
009F E4                CLR     A
00A0 F0                MOVX    @DPTR,A
00A1 A3                INC     DPTR
00A2 F0                MOVX    @DPTR,A
00A3 A3                INC     DPTR
00A4 F0                MOVX    @DPTR,A
00A5 FB                MOV     R3,A
00A6 7AFC              MOV     R2,#0FCH
00A8 7D02              MOV     R5,#02H
00AA 7F90              MOV     R7,#090H
00AC 120000      E     LCALL   _Comm_I2C_Tx
                                           ; SOURCE LINE # 814
00AF 900000      E     MOV     DPTR,#?_Comm_I2C_Tx?BYTE+04H
00B2 7481              MOV     A,#081H
00B4 F0                MOVX    @DPTR,A
00B5 A3                INC     DPTR
00B6 E4                CLR     A
00B7 F0                MOVX    @DPTR,A
00B8 A3                INC     DPTR
00B9 F0                MOVX    @DPTR,A
00BA A3                INC     DPTR
00BB F0                MOVX    @DPTR,A
00BC 7B40              MOV     R3,#040H
00BE FA                MOV     R2,A
00BF 7D02              MOV     R5,#02H
00C1 7F90              MOV     R7,#090H
00C3 120000      E     LCALL   _Comm_I2C_Tx
                                           ; SOURCE LINE # 815
00C6 900000      E     MOV     DPTR,#?_Comm_I2C_Tx?BYTE+04H
00C9 7428              MOV     A,#028H
00CB F0                MOVX    @DPTR,A
00CC A3                INC     DPTR
00CD E4                CLR     A
00CE F0                MOVX    @DPTR,A
00CF A3                INC     DPTR
00D0 F0                MOVX    @DPTR,A
00D1 A3                INC     DPTR
00D2 F0                MOVX    @DPTR,A
00D3 FB                MOV     R3,A
00D4 7AFC              MOV     R2,#0FCH
00D6 7D02              MOV     R5,#02H
00D8 7F90              MOV     R7,#090H
00DA 120000      E     LCALL   _Comm_I2C_Tx
                                           ; SOURCE LINE # 816
00DD 900000      E     MOV     DPTR,#?_Comm_I2C_Tx?BYTE+04H
C51 COMPILER V9.51   MGR_ISP                                                               11/17/2023 14:48:45 PAGE 185 

00E0 7481              MOV     A,#081H
00E2 F0                MOVX    @DPTR,A
00E3 A3                INC     DPTR
00E4 E4                CLR     A
00E5 F0                MOVX    @DPTR,A
00E6 A3                INC     DPTR
00E7 F0                MOVX    @DPTR,A
00E8 A3                INC     DPTR
00E9 F0                MOVX    @DPTR,A
00EA 7B40              MOV     R3,#040H
00EC FA                MOV     R2,A
00ED 7D02              MOV     R5,#02H
00EF 7F90              MOV     R7,#090H
00F1 120000      E     LCALL   _Comm_I2C_Tx
                                           ; SOURCE LINE # 817
00F4 900000      E     MOV     DPTR,#?_Comm_I2C_Tx?BYTE+04H
00F7 7481              MOV     A,#081H
00F9 F0                MOVX    @DPTR,A
00FA A3                INC     DPTR
00FB 7401              MOV     A,#01H
00FD F0                MOVX    @DPTR,A
00FE E4                CLR     A
00FF A3                INC     DPTR
0100 F0                MOVX    @DPTR,A
0101 A3                INC     DPTR
0102 F0                MOVX    @DPTR,A
0103 7B40              MOV     R3,#040H
0105 FA                MOV     R2,A
0106 7D02              MOV     R5,#02H
0108 7F90              MOV     R7,#090H
010A 120000      E     LCALL   _Comm_I2C_Tx
                                           ; SOURCE LINE # 819
010D 120000      R     LCALL   DoorbellCheck
                                           ; SOURCE LINE # 820
0110 22                RET     
             ; FUNCTION _Sensor_XY_Offset_set (END)

             ; FUNCTION _isp_guide_on_off (BEGIN)
                                           ; SOURCE LINE # 822
;---- Variable 'Guide_On_Off' assigned to Register 'R7' ----
                                           ; SOURCE LINE # 823
                                           ; SOURCE LINE # 824
0000 900000      R     MOV     DPTR,#g_Guideline_OnOff
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 825
0005 22                RET     
             ; FUNCTION _isp_guide_on_off (END)

C51 COMPILER V9.51   MGR_ISP                                                               11/17/2023 14:48:45 PAGE 186 

NAME                                    CLASS   MSPACE  TYPE    OFFSET  SIZE
====                                    =====   ======  ====    ======  ====


U8 . . . . . . . . . . . . . . . . . .  TYPEDEF  -----  U_CHAR   -----  1
U16. . . . . . . . . . . . . . . . . .  TYPEDEF  -----  U_INT    -----  2
U32. . . . . . . . . . . . . . . . . .  TYPEDEF  -----  U_LONG   -----  4
S8 . . . . . . . . . . . . . . . . . .  TYPEDEF  -----  CHAR     -----  1
S16. . . . . . . . . . . . . . . . . .  TYPEDEF  -----  INT      -----  2
S32. . . . . . . . . . . . . . . . . .  TYPEDEF  -----  LONG     -----  4
UU16 . . . . . . . . . . . . . . . . .  * TAG *  -----  UNION    -----  2
  U16. . . . . . . . . . . . . . . . .  MEMBER   -----  U_INT    0000H  2
  S16. . . . . . . . . . . . . . . . .  MEMBER   -----  INT      0000H  2
  U8 . . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  2
  S8 . . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  2
UU16 . . . . . . . . . . . . . . . . .  TYPEDEF  -----  UNION    -----  2
  U16. . . . . . . . . . . . . . . . .  MEMBER   -----  U_INT    0000H  2
  S16. . . . . . . . . . . . . . . . .  MEMBER   -----  INT      0000H  2
  U8 . . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  2
  S8 . . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  2
UU32 . . . . . . . . . . . . . . . . .  * TAG *  -----  UNION    -----  4
  U32. . . . . . . . . . . . . . . . .  MEMBER   -----  U_LONG   0000H  4
  S32. . . . . . . . . . . . . . . . .  MEMBER   -----  LONG     0000H  4
  UU16 . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  4
  U16. . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  4
  S16. . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  4
  U8 . . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  4
  S8 . . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  4
UU32 . . . . . . . . . . . . . . . . .  TYPEDEF  -----  UNION    -----  4
  U32. . . . . . . . . . . . . . . . .  MEMBER   -----  U_LONG   0000H  4
  S32. . . . . . . . . . . . . . . . .  MEMBER   -----  LONG     0000H  4
  UU16 . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  4
  U16. . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  4
  S16. . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  4
  U8 . . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  4
  S8 . . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  4
AMP_V_STB. . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00A2H  1
MCU_SENSOR_RESET . . . . . . . . . . .  ABSBIT   -----  BIT      00A4H  1
_Device_Init . . . . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
Frame_Sync_Status. . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
tMsg_Time_s. . . . . . . . . . . . . .  TYPEDEF  -----  STRUCT   -----  13
  Set. . . . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0000H  1
  Delay_Time . . . . . . . . . . . . .  MEMBER   -----  U_LONG   0001H  4
  Cur_Time . . . . . . . . . . . . . .  MEMBER   -----  U_LONG   0005H  4
  End_Time . . . . . . . . . . . . . .  MEMBER   -----  U_LONG   0009H  4
tMsg_Global_Tick . . . . . . . . . . .  TYPEDEF  -----  STRUCT   -----  9
  Tick_1ms . . . . . . . . . . . . . .  MEMBER   -----  U_LONG   0000H  4
  Limit. . . . . . . . . . . . . . . .  MEMBER   -----  U_LONG   0004H  4
  Over_Set . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0008H  1
_Wait_ms . . . . . . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
_Delay_Time_Set. . . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
_Delay_Time_Get. . . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
_Delay_Time_Expire . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
_Comm_I2C_Tx . . . . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
_Comm_I2C_Rx . . . . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
Comm_RearView_Data . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
_Comm_Sas_Data . . . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
_Comm_Tx_RVM_View. . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
_Comm_Tx_RVM_SW_IND. . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
Flash_OneSpec_Write. . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
Flash_OneSpec_Read . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
C51 COMPILER V9.51   MGR_ISP                                                               11/17/2023 14:48:45 PAGE 187 

NAME                                    CLASS   MSPACE  TYPE    OFFSET  SIZE
====                                    =====   ======  ====    ======  ====


tMsg_I2C_Tx_Data_s . . . . . . . . . .  TYPEDEF  -----  STRUCT   -----  9
  Slave. . . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0000H  1
  Length . . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0001H  1
  TRX_Flag . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0002H  1
  Addr . . . . . . . . . . . . . . . .  MEMBER   -----  U_INT    0003H  2
  TxData . . . . . . . . . . . . . . .  MEMBER   -----  U_INT    0005H  2
  RxData . . . . . . . . . . . . . . .  MEMBER   -----  U_INT    0007H  2
tMsg_CAN_Tx_Data_s . . . . . . . . . .  TYPEDEF  -----  STRUCT   -----  9
  Slave. . . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0000H  1
  Length . . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0001H  1
  TRX_Flag . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0002H  1
  Addr . . . . . . . . . . . . . . . .  MEMBER   -----  U_INT    0003H  2
  TxData . . . . . . . . . . . . . . .  MEMBER   -----  U_INT    0005H  2
  RxData . . . . . . . . . . . . . . .  MEMBER   -----  U_INT    0007H  2
tMsg_CAN_Rx_Data_s . . . . . . . . . .  TYPEDEF  -----  STRUCT   -----  8
  Is_Change. . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0000H  1
  Change_Count . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0001H  1
  Time_Out . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0002H  1
  Cur_Data . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0003H  1
  Mid_Data . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0004H  1
  Pre_Data . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0005H  1
  Chatter_Time . . . . . . . . . . . .  MEMBER   -----  U_INT    0006H  2
tMsg_CAN_SAS_Data_s. . . . . . . . . .  TYPEDEF  -----  STRUCT   -----  8
  Is_Change. . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0000H  1
  Pre_Sign . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0001H  1
  Angle. . . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0002H  1
  Angle_Pre_Sign . . . . . . . . . . .  MEMBER   -----  U_CHAR   0003H  1
  Time_Out . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0004H  1
  Pre_Data . . . . . . . . . . . . . .  MEMBER   -----  U_INT    0005H  2
  Tuning_Type. . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0007H  1
tMsg_CAN_State_s . . . . . . . . . . .  TYPEDEF  -----  STRUCT   -----  5
  Is_Change. . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0000H  1
  Pre_Sign . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0001H  1
  Angle. . . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0002H  1
  Pre_Data . . . . . . . . . . . . . .  MEMBER   -----  U_INT    0003H  2
_Record_DTC_Error. . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
_Record_DTC_Clear. . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
tCAN_Rx_Msg. . . . . . . . . . . . . .  EXTERN   XDATA  ARRAY    -----  88
CalibrationMode_OnOff. . . . . . . . .  EXTERN   XDATA  U_CHAR   -----  1
OpticOffset_Set. . . . . . . . . . . .  EXTERN   XDATA  U_CHAR   -----  1
tMsg_DTC_Type. . . . . . . . . . . . .  TYPEDEF  -----  STRUCT   -----  2
  Status . . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0000H  1
  Count. . . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0001H  1
tMsg_Ext_DTC_Type. . . . . . . . . . .  TYPEDEF  -----  STRUCT   -----  25
  tDTC_Type. . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  18
  DTC_Clear_Count. . . . . . . . . . .  MEMBER   -----  ARRAY    0012H  3
  DTC_State. . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0015H  3
  Checksum . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0018H  1
tMsg_Update. . . . . . . . . . . . . .  TYPEDEF  -----  STRUCT   -----  15
  update_set . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0000H  1
  write_count. . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0001H  1
  erase_set. . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0002H  1
  total_write_cnt. . . . . . . . . . .  MEMBER   -----  U_LONG   0003H  4
  write_cnt. . . . . . . . . . . . . .  MEMBER   -----  U_LONG   0007H  4
  size . . . . . . . . . . . . . . . .  MEMBER   -----  U_LONG   000BH  4
ga_Ext_tDTC_Type_Msg . . . . . . . . .  EXTERN   XDATA  STRUCT   -----  25
FLADDR . . . . . . . . . . . . . . . .  TYPEDEF  -----  U_INT    -----  2
C51 COMPILER V9.51   MGR_ISP                                                               11/17/2023 14:48:45 PAGE 188 

NAME                                    CLASS   MSPACE  TYPE    OFFSET  SIZE
====                                    =====   ======  ====    ======  ====


_FLASH_Read_Buf. . . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
WDT_Clear. . . . . . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
Get_Video_Signal . . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
Init_IspTask . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
_Sensor_XY_Offset_set. . . . . . . . .  STATIC   CODE   PROC     0000H  -----
  x. . . . . . . . . . . . . . . . . .  * REG *  DATA   U_CHAR   0007H  1
  y. . . . . . . . . . . . . . . . . .  * REG *  DATA   U_CHAR   0005H  1
  read_data. . . . . . . . . . . . . .  AUTO     DATA   U_INT    0000H  2
  write_data . . . . . . . . . . . . .  AUTO     XDATA  U_INT    0000H  2
CheckCommandStatusLoop . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  chk_data . . . . . . . . . . . . . .  STATIC   XDATA  U_INT    0011H  2
  lpcnt. . . . . . . . . . . . . . . .  STATIC   XDATA  U_CHAR   0013H  1
  ret. . . . . . . . . . . . . . . . .  AUTO     XDATA  U_CHAR   0000H  1
Isp_InterInit. . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  count. . . . . . . . . . . . . . . .  AUTO     XDATA  U_INT    0000H  2
  ret. . . . . . . . . . . . . . . . .  AUTO     XDATA  U_CHAR   0002H  1
Operate_IspTask. . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  On_Time. . . . . . . . . . . . . . .  * REG *  DATA   U_CHAR   0007H  1
  ret. . . . . . . . . . . . . . . . .  AUTO     XDATA  U_CHAR   0000H  1
Isp_Parking_Assist_View. . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  Sas_Data . . . . . . . . . . . . . .  AUTO     XDATA  ARRAY    0000H  2
  HU_Type_Data . . . . . . . . . . . .  AUTO     XDATA  U_CHAR   0002H  1
  Language_Data. . . . . . . . . . . .  AUTO     XDATA  U_CHAR   0003H  1
  On_Time. . . . . . . . . . . . . . .  * REG *  DATA   U_CHAR   0007H  1
  ret. . . . . . . . . . . . . . . . .  AUTO     XDATA  U_CHAR   0004H  1
  overlay_flag . . . . . . . . . . . .  STATIC   XDATA  U_CHAR   0000H  1
Isp_Driving_Assist_View. . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  overlay_flag . . . . . . . . . . . .  STATIC   XDATA  U_CHAR   0001H  1
  On_Time. . . . . . . . . . . . . . .  * REG *  DATA   U_CHAR   0007H  1
_Isp_View_Mode_Change. . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  ViewMode . . . . . . . . . . . . . .  AUTO     XDATA  U_CHAR   0000H  1
  read_data. . . . . . . . . . . . . .  STATIC   XDATA  U_INT    0002H  2
  chk_Buffer . . . . . . . . . . . . .  STATIC   XDATA  U_INT    0004H  2
  i. . . . . . . . . . . . . . . . . .  AUTO     XDATA  U_CHAR   0001H  1
Isp_Off. . . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
Isp_On . . . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
_Fixed_Guidline_On . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  ViewMode . . . . . . . . . . . . . .  AUTO     XDATA  U_CHAR   0000H  1
  overlay_buffer_flag. . . . . . . . .  STATIC   XDATA  CHAR     0014H  1
Fixed_Guidline_Off . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
Guidline_On. . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
Guidline_Off . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
_isp_guide_on_off. . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  Guide_On_Off . . . . . . . . . . . .  * REG *  DATA   U_CHAR   0007H  1
V_STB_Check. . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  ret. . . . . . . . . . . . . . . . .  * REG *  DATA   U_CHAR   0007H  1
  v_stb_error_count. . . . . . . . . .  STATIC   XDATA  U_CHAR   0006H  1
  v_stb_nomal_count. . . . . . . . . .  STATIC   XDATA  U_CHAR   0007H  1
Video_Signal_Check . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  ret. . . . . . . . . . . . . . . . .  AUTO     XDATA  U_CHAR   0000H  1
  video_error_count. . . . . . . . . .  STATIC   XDATA  U_CHAR   000FH  1
  video_nomal_count. . . . . . . . . .  STATIC   XDATA  U_CHAR   0010H  1
Frame_Count_Check. . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  Cur_FC_Data. . . . . . . . . . . . .  STATIC   XDATA  U_INT    000BH  2
  Pre_FC_Data. . . . . . . . . . . . .  STATIC   XDATA  U_INT    000DH  2
Frame_Valide_Check . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  Frame_value. . . . . . . . . . . . .  AUTO     XDATA  U_CHAR   0000H  1
C51 COMPILER V9.51   MGR_ISP                                                               11/17/2023 14:48:45 PAGE 189 

NAME                                    CLASS   MSPACE  TYPE    OFFSET  SIZE
====                                    =====   ======  ====    ======  ====


Check_Isp_InitState. . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  chk_data . . . . . . . . . . . . . .  STATIC   XDATA  U_INT    0008H  2
  lpcn . . . . . . . . . . . . . . . .  STATIC   XDATA  U_CHAR   000AH  1
  Ret_State. . . . . . . . . . . . . .  AUTO     XDATA  U_CHAR   0000H  1
tMsg_ISP_Function. . . . . . . . . . .  TYPEDEF  -----  STRUCT   -----  12
  IGNSw. . . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0000H  1
  Pre_Gear . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0001H  1
  Cur_Gear . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0002H  1
  Pre_RVM_CamOff . . . . . . . . . . .  MEMBER   -----  U_CHAR   0003H  1
  Cur_RVM_CamOff . . . . . . . . . . .  MEMBER   -----  U_CHAR   0004H  1
  Pre_RVM_SW . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0005H  1
  Cur_RVM_SW . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0006H  1
  Pre_SW_IND . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0007H  1
  Cur_SW_IND . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0008H  1
  Pre_ViewMode . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0009H  1
  Cur_ViewMode . . . . . . . . . . . .  MEMBER   -----  U_CHAR   000AH  1
  RVM_SW_Status. . . . . . . . . . . .  MEMBER   -----  U_CHAR   000BH  1
tISP_Func_Msg. . . . . . . . . . . . .  PUBLIC   XDATA  STRUCT   0019H  12
g_Overlay_Stauts_Loop_Check_Time . . .  STATIC   XDATA  U_CHAR   0025H  1
g_Guideline_OnOff. . . . . . . . . . .  STATIC   XDATA  U_CHAR   0026H  1
g_Pre_Calibration_Mode . . . . . . . .  STATIC   XDATA  U_CHAR   0027H  1
Overlay_Guideline_flag . . . . . . . .  STATIC   XDATA  U_CHAR   0028H  1
warning_msg_flag . . . . . . . . . . .  STATIC   XDATA  U_CHAR   0029H  1
Asix . . . . . . . . . . . . . . . . .  STATIC   XDATA  ARRAY    002AH  3
Optical_Axis_Data. . . . . . . . . . .  PUBLIC   XDATA  ARRAY    002DH  9
_Overlay_Guideline . . . . . . . . . .  STATIC   CODE   PROC     0000H  -----
  steering_cur . . . . . . . . . . . .  AUTO     XDATA  INT      0000H  2
  sign . . . . . . . . . . . . . . . .  AUTO     XDATA  CHAR     0002H  1
  read_data. . . . . . . . . . . . . .  AUTO     DATA   U_INT    0000H  2
DoorbellCheck. . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  On_Time. . . . . . . . . . . . . . .  AUTO     XDATA  U_CHAR   0000H  1
  chk_data . . . . . . . . . . . . . .  AUTO     DATA   U_INT    0000H  2
  lpcnt. . . . . . . . . . . . . . . .  AUTO     DATA   U_CHAR   0002H  1
_warning_msg . . . . . . . . . . . . .  STATIC   CODE   PROC     0000H  -----
  hutype . . . . . . . . . . . . . . .  AUTO     XDATA  U_CHAR   0000H  1
  Lang . . . . . . . . . . . . . . . .  AUTO     XDATA  U_CHAR   0001H  1
  lan_start_addr . . . . . . . . . . .  STATIC   XDATA  U_INT    0015H  2
  Pre_Lang . . . . . . . . . . . . . .  STATIC   XDATA  U_INT    0017H  2
  read_data. . . . . . . . . . . . . .  AUTO     DATA   U_INT    0000H  2
  ret. . . . . . . . . . . . . . . . .  AUTO     XDATA  U_CHAR   0002H  1
_?ix1000 . . . . . . . . . . . . . . .  STATIC   CODE   ARRAY    0000H  2


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   3651    ----
   CONSTANT SIZE    =      2    ----
   XDATA SIZE       =     54      25
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----       9
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
