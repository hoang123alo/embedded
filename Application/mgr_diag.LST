C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 1   


C51 COMPILER V9.51, COMPILATION OF MODULE MGR_DIAG
OBJECT MODULE PLACED IN mgr_diag.OBJ
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.exe mgr_diag.c DB OE BR INTVECTOR(0X4000) LARGE NOAREGS DEBUG OBJECTEXTEND SB D
                    -F(CLK_FREQUENCY=24,C_DERIVATIVE_C8051F5x) OR CD LC LARGE OT(5,SPEED) INCDIR(c:\SiLabs\MCU\Inc;D:\micom_diag\mcnex_diagno
                    -stic_bit\CANGEN_MCNEX;D:\micom_diag\mcnex_diagnostic_bit\CanBSW)

line level    source

   1          /*_____ I N C L U D E __________________________________________*/
   2          #include "compiler_defs.h"
   1      =1  //-----------------------------------------------------------------------------
   2      =1  // compiler_defs.h
   3      =1  //-----------------------------------------------------------------------------
   4      =1  // Portions of this file are copyright Maarten Brock
   5      =1  // http://sdcc.sourceforge.net
   6      =1  // Portions of this file are copyright 2010, Silicon Laboratories, Inc.
   7      =1  // http://www.silabs.com
   8      =1  //
   9      =1  // GNU LGPL boilerplate:
  10      =1  /** This library is free software; you can redistribute it and/or
  11      =1    * modify it under the terms of the GNU Lesser General Public
  12      =1    * License as published by the Free Software Foundation; either
  13      =1    * version 2.1 of the License, or (at your option) any later version.
  14      =1    *
  15      =1    * This library is distributed in the hope that it will be useful,
  16      =1    * but WITHOUT ANY WARRANTY; without even the implied warranty of
  17      =1    * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
  18      =1    * Lesser General Public License for more details.
  19      =1    *
  20      =1    * You should have received a copy of the GNU Lesser General Public
  21      =1    * License along with this library; if not, write to the Free Software
  22      =1    * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
  23      =1    *
  24      =1    * In other words, you are welcome to use, share and improve this program.
  25      =1    * You are forbidden to forbid anyone else to use, share and improve
  26      =1    * what you give them. Help stamp out software-hoarding!
  27      =1  **/
  28      =1  // Program Description:
  29      =1  //
  30      =1  // **Important Note**: This header file should be included before including
  31      =1  // a device-specific header file such as C8051F300_defs.h.
  32      =1  //
  33      =1  // Macro definitions to accomodate 8051 compiler differences in specifying
  34      =1  // special function registers and other 8051-specific features such as NOP
  35      =1  // generation, and locating variables in memory-specific segments.  The
  36      =1  // compilers are identified by their unique predefined macros. See also:
  37      =1  // http://predef.sourceforge.net/precomp.html
  38      =1  //
  39      =1  // SBIT and SFR define special bit and special function registers at the given
  40      =1  // address. SFR16 and SFR32 define sfr combinations at adjacent addresses in
  41      =1  // little-endian format. SFR16E and SFR32E define sfr combinations without
  42      =1  // prerequisite byte order or adjacency. None of these multi-byte sfr
  43      =1  // combinations will guarantee the order in which they are accessed when read
  44      =1  // or written.
  45      =1  //
  46      =1  // SFR16X and SFR32X for 16 bit and 32 bit xdata registers are not defined
  47      =1  // to avoid portability issues because of compiler endianness.
  48      =1  //
  49      =1  // Example:
  50      =1  // // my_mcu.c: main 'c' file for my mcu
  51      =1  // #include <compiler_defs.h>  // this file
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 2   

  52      =1  // #include <C8051xxxx_defs.h> // SFR definitions for specific MCU target
  53      =1  //
  54      =1  // SBIT  (P0_1, 0x80, 1);      // Port 0 pin 1
  55      =1  // SFR   (P0, 0x80);           // Port 0
  56      =1  // SFRX  (CPUCS, 0xE600);      // Cypress FX2 Control and Status register in
  57      =1  //                             // xdata memory at 0xE600
  58      =1  // SFR16 (TMR2, 0xCC);         // Timer 2, lsb at 0xCC, msb at 0xCD
  59      =1  // SFR16E(TMR0, 0x8C8A);       // Timer 0, lsb at 0x8A, msb at 0x8C
  60      =1  // SFR32 (MAC0ACC, 0x93);      // SiLabs C8051F120 32 bits MAC0 Accumulator,
  61      =1  //                             // lsb at 0x93, msb at 0x96
  62      =1  // SFR32E(SUMR, 0xE5E4E3E2);   // TI MSC1210 SUMR 32 bits Summation register,
  63      =1  //                             // lsb at 0xE2, msb at 0xE5
  64      =1  //
  65      =1  // Target:         C8051xxxx
  66      =1  // Tool chain:     Generic
  67      =1  // Command Line:   None
  68      =1  // 
  69      =1  // Release 2.6 - 14 DEC 2012 (GO)
  70      =1  //        -Added define for deprecated SDCC keyword 'at'
  71      =1  // Release 2.5 - 12 SEP 2012 (TP)
  72      =1  //    -Added defines for deprecated SDCC keywords bit and code
  73      =1  // Release 2.4 - 27 AUG 2012 (TP)
  74      =1  //    -Added defines for deprecated SDCC keywords interrupt, _asm, and _endasm
  75      =1  // Release 2.3 - 27 MAY 2010 (DM)
  76      =1  //    -Removed 'LOCATED_VARIABLE' pragma from Keil because it is not supported
  77      =1  // Release 2.2 - 06 APR 2010 (ES)
  78      =1  //    -Removed 'PATHINCLUDE' pragma from Raisonance section
  79      =1  // Release 2.1 - 16 JUL 2009 (ES)
  80      =1  //    -Added SEGMENT_POINTER macro definitions for SDCC, Keil, and Raisonance
  81      =1  //    -Added LOCATED_VARIABLE_NO_INIT macro definitions for Raisonance
  82      =1  // Release 2.0 - 19 MAY 2009 (ES)
  83      =1  //    -Added LOCATED_VARIABLE_NO_INIT macro definitions for SDCC and Keil
  84      =1  // Release 1.9 - 23 OCT 2008 (ES)
  85      =1  //    -Updated Hi-Tech INTERRUPT and INTERRUPT_USING macro definitions
  86      =1  //    -Added SFR16 macro defintion for Hi-Tech
  87      =1  // Release 1.8 - 31 JUL 2008 (ES)
  88      =1  //    -Added INTERRUPT_USING and FUNCTION_USING macro's
  89      =1  //    -Added macro's for IAR
  90      =1  //    -Corrected Union definitions for Hi-Tech and added SFR16 macro defintion
  91      =1  // Release 1.7 - 11 SEP 2007 (BW)
  92      =1  //    -Added support for Raisonance EVAL 03.03.42 and Tasking Eval 7.2r1
  93      =1  // Release 1.6 - 27 AUG 2007 (BW)
  94      =1  //    -Updated copyright notice per agreement with Maartin Brock
  95      =1  //    -Added SDCC 2.7.0 "compiler.h" bug fixes
  96      =1  //    -Added memory segment defines (SEG_XDATA, for example)
  97      =1  // Release 1.5 - 24 AUG 2007 (BW)
  98      =1  //    -Added support for NOP () macro
  99      =1  //    -Added support for Hi-Tech ver 9.01
 100      =1  // Release 1.4 - 07 AUG 2007 (PKC)
 101      =1  //    -Removed FID and fixed formatting.
 102      =1  // Release 1.3 - 30 SEP 2007 (TP)
 103      =1  //    -Added INTERRUPT_PROTO_USING to properly support ISR context switching
 104      =1  //     under SDCC.
 105      =1  // Release 1.2 - (BW)
 106      =1  //    -Added support for U8,U16,U32,S8,S16,S32,UU16,UU32 data types
 107      =1  // Release 1.1 - (BW)
 108      =1  //    -Added support for INTERRUPT, INTERRUPT_USING, INTERRUPT_PROTO,
 109      =1  //     SEGMENT_VARIABLE, VARIABLE_SEGMENT_POINTER,
 110      =1  //     SEGMENT_VARIABLE_SEGMENT_POINTER, and LOCATED_VARIABLE
 111      =1  // Release 1.0 - 29 SEP 2006 (PKC)
 112      =1  //    -Initial revision
 113      =1  
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 3   

 114      =1  //-----------------------------------------------------------------------------
 115      =1  // Header File Preprocessor Directive
 116      =1  //-----------------------------------------------------------------------------
 117      =1  
 118      =1  #ifndef COMPILER_DEFS_H
 119      =1  #define COMPILER_DEFS_H
 120      =1  
 121      =1  //-----------------------------------------------------------------------------
 122      =1  // Macro definitions
 123      =1  //-----------------------------------------------------------------------------
 124      =1  
 125      =1  // SDCC - Small Device C Compiler
 126      =1  // http://sdcc.sourceforge.net
 127      =1  
 128      =1  #if defined SDCC
           =1 
           =1 #if (SDCC >= 300)
           =1 
           =1 #define interrupt __interrupt
           =1 #define _asm __asm
           =1 #define _endasm __endasm
           =1 #define bit __bit
           =1 #define code __code
           =1 #define at __at
           =1 
           =1 #endif
           =1 
           =1 # define SEG_GENERIC
           =1 # define SEG_FAR   __xdata
           =1 # define SEG_DATA  __data
           =1 # define SEG_NEAR  __data
           =1 # define SEG_IDATA __idata
           =1 # define SEG_XDATA __xdata
           =1 # define SEG_PDATA __pdata
           =1 # define SEG_CODE  __code
           =1 # define SEG_BDATA __bdata
           =1 
           =1 # define SBIT(name, addr, bit)  __sbit  __at(addr+bit)                  name
           =1 # define SFR(name, addr)        __sfr   __at(addr)                      name
           =1 # define SFRX(name, addr)       xdata volatile unsigned char __at(addr) name
           =1 # define SFR16(name, addr)      __sfr16 __at(((addr+1U)<<8) | addr)     name
           =1 # define SFR16E(name, fulladdr) __sfr16 __at(fulladdr)                  name
           =1 # define SFR32(name, addr)      __sfr32 __at(((addr+3UL)<<24) | ((addr+2UL)<<16) | ((addr+1UL)<<8) | addr)
             - name
           =1 # define SFR32E(name, fulladdr) __sfr32 __at(fulladdr)                  name
           =1 
           =1 # define INTERRUPT(name, vector) void name (void) interrupt (vector)
           =1 # define INTERRUPT_USING(name, vector, regnum) void name (void) interrupt (vector) using (regnum)
           =1 # define INTERRUPT_PROTO(name, vector) void name (void) interrupt (vector)
           =1 # define INTERRUPT_PROTO_USING(name, vector, regnum) void name (void) interrupt (vector) using (regnum)
           =1 
           =1 # define FUNCTION_USING(name, return_value, parameter, regnum) return_value name (parameter) using (regnum
             -)
           =1 # define FUNCTION_PROTO_USING(name, return_value, parameter, regnum) return_value name (parameter) using (
             -regnum)
           =1 // Note: Parameter must be either 'void' or include a variable type and name. (Ex: char temp_variable)
           =1 
           =1 # define SEGMENT_VARIABLE(name, vartype, locsegment) locsegment vartype name
           =1 # define VARIABLE_SEGMENT_POINTER(name, vartype, targsegment) targsegment vartype * name
           =1 # define SEGMENT_VARIABLE_SEGMENT_POINTER(name, vartype, targsegment, locsegment) targsegment vartype * lo
             -csegment name
           =1 # define SEGMENT_POINTER(name, vartype, locsegment) vartype * locsegment name
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 4   

           =1 # define LOCATED_VARIABLE(name, vartype, locsegment, addr, init) locsegment at (addr) vartype name = init
           =1 # define LOCATED_VARIABLE_NO_INIT(name, vartype, locsegment, addr) locsegment at (addr) vartype name
           =1 
           =1 // used with UU16
           =1 # define LSB 0
           =1 # define MSB 1
           =1 
           =1 // used with UU32 (b0 is least-significant byte)
           =1 //# define b0 0
           =1 //# define b1 1
           =1 //# define b2 2
           =1 //# define b3 3
           =1 
           =1 typedef unsigned char U8;
           =1 typedef unsigned int U16;
           =1 typedef unsigned long U32;
           =1 
           =1 typedef signed char S8;
           =1 typedef signed int S16;
           =1 typedef signed long S32;
           =1 
           =1 typedef union UU16
           =1 {
           =1    U16 U16;
           =1    S16 S16;
           =1    U8 U8[2];
           =1    S8 S8[2];
           =1 } UU16;
           =1 
           =1 typedef union UU32
           =1 {
           =1    U32 U32;
           =1    S32 S32;
           =1    UU16 UU16[2];
           =1    U16 U16[2];
           =1    S16 S16[2];
           =1    U8 U8[4];
           =1    S8 S8[4];
           =1 } UU32;
           =1 
           =1 // NOP () macro support
           =1 #define NOP() _asm NOP _endasm
           =1 
           =1 
           =1 //-----------------------------------------------------------------------------
           =1 
           =1 // Raisonance (must be placed before Keil C51)
           =1 // http://www.raisonance.com
           =1 
           =1 #elif defined __RC51__
           =1 
           =1 //#error Raisonance C51 detected.
           =1 
           =1 # define SEG_GENERIC generic     //SEG_GENERIC only applies to pointers in Raisonance, not variables.
           =1 # define SEG_FAR   xdata
           =1 # define SEG_DATA  data
           =1 # define SEG_NEAR  data
           =1 # define SEG_IDATA idata
           =1 # define SEG_XDATA xdata
           =1 # define SEG_PDATA pdata
           =1 # define SEG_CODE  code
           =1 # define SEG_BDATA bdata
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 5   

           =1 
           =1 # define SBIT(name, addr, bit)  at (addr+bit) sbit         name
           =1 # define SFR(name, addr)        sfr at addr                name
           =1 # define SFR16(name, addr)      sfr16 at addr              name
           =1 # define SFR16E(name, fulladdr) /* not supported */
           =1 # define SFR32(name, fulladdr)  /* not supported */
           =1 # define SFR32E(name, fulladdr) /* not supported */
           =1 
           =1 # define INTERRUPT(name, vector) void name (void) interrupt vector
           =1 # define INTERRUPT_USING(name, vector, regnum) void name (void) interrupt vector using regnum
           =1 # define INTERRUPT_PROTO(name, vector) void name (void)
           =1 # define INTERRUPT_PROTO_USING(name, vector, regnum) void name (void)
           =1 
           =1 # define FUNCTION_USING(name, return_value, parameter, regnum) return_value name (parameter) using regnum
           =1 # define FUNCTION_PROTO_USING(name, return_value, parameter, regnum) return_value name (parameter)
           =1 // Note: Parameter must be either 'void' or include a variable type and name. (Ex: char temp_variable)
           =1 
           =1 # define SEGMENT_VARIABLE(name, vartype, locsegment) vartype locsegment name
           =1 # define VARIABLE_SEGMENT_POINTER(name, vartype, targsegment) vartype targsegment * name
           =1 # define SEGMENT_VARIABLE_SEGMENT_POINTER(name, vartype, targsegment, locsegment) vartype targsegment * lo
             -csegment name
           =1 # define SEGMENT_POINTER(name, vartype, locsegment) vartype * locsegment name
           =1 # define LOCATED_VARIABLE(name, vartype, locsegment, addr, init) at addr locsegment vartype name
           =1 # define LOCATED_VARIABLE_NO_INIT(name, vartype, locsegment, addr) at addr locsegment vartype name
           =1 
           =1 
           =1 // used with UU16
           =1 # define LSB 1
           =1 # define MSB 0
           =1 
           =1 // used with UU32 (b0 is least-significant byte)
           =1 //# define b0 3
           =1 //# define b1 2
           =1 //# define b2 1
           =1 //# define b3 0
           =1 
           =1 typedef unsigned char U8;
           =1 typedef unsigned int U16;
           =1 typedef unsigned long U32;
           =1 
           =1 typedef signed char S8;
           =1 typedef signed int S16;
           =1 typedef signed long S32;
           =1 
           =1 typedef union UU16
           =1 {
           =1    U16 U16;
           =1    S16 S16;
           =1    U8 U8[2];
           =1    S8 S8[2];
           =1 } UU16;
           =1 
           =1 typedef union UU32
           =1 {
           =1    U32 U32;
           =1    S32 S32;
           =1    UU16 UU16[2];
           =1    U16 U16[2];
           =1    S16 S16[2];
           =1    U8 U8[4];
           =1    S8 S8[4];
           =1 } UU32;
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 6   

           =1 
           =1 // NOP () macro support -- NOP is opcode 0x00
           =1 #define NOP() asm { 0x00 }
           =1 
           =1 
           =1 //-----------------------------------------------------------------------------
           =1 
           =1 
           =1 // Keil C51
           =1 // http://www.keil.com
           =1 
           =1 #elif defined __C51__
 307      =1  
 308      =1  //#error Keil C51 detected.
 309      =1  
 310      =1  # define SEG_GENERIC
 311      =1  # define SEG_FAR   xdata
 312      =1  # define SEG_DATA  data
 313      =1  # define SEG_NEAR  data
 314      =1  # define SEG_IDATA idata
 315      =1  # define SEG_XDATA xdata
 316      =1  # define SEG_PDATA pdata
 317      =1  # define SEG_CODE  code
 318      =1  # define SEG_BDATA bdata
 319      =1  
 320      =1  # define SBIT(name, addr, bit)  sbit  name = addr^bit
 321      =1  # define SFR(name, addr)        sfr   name = addr
 322      =1  # define SFR16(name, addr)      sfr16 name = addr
 323      =1  # define SFR16E(name, fulladdr) /* not supported */
 324      =1  # define SFR32(name, fulladdr)  /* not supported */
 325      =1  # define SFR32E(name, fulladdr) /* not supported */
 326      =1  
 327      =1  # define INTERRUPT(name, vector) void name (void) interrupt vector
 328      =1  # define INTERRUPT_USING(name, vector, regnum) void name (void) interrupt vector using regnum
 329      =1  # define INTERRUPT_PROTO(name, vector) void name (void)
 330      =1  # define INTERRUPT_PROTO_USING(name, vector, regnum) void name (void)
 331      =1  
 332      =1  # define FUNCTION_USING(name, return_value, parameter, regnum) return_value name (parameter) using regnum
 333      =1  # define FUNCTION_PROTO_USING(name, return_value, parameter, regnum) return_value name (parameter)
 334      =1  // Note: Parameter must be either 'void' or include a variable type and name. (Ex: char temp_variable)
 335      =1  
 336      =1  # define SEGMENT_VARIABLE(name, vartype, locsegment) vartype locsegment name
 337      =1  # define VARIABLE_SEGMENT_POINTER(name, vartype, targsegment) vartype targsegment * name
 338      =1  # define SEGMENT_VARIABLE_SEGMENT_POINTER(name, vartype, targsegment, locsegment) vartype targsegment * lo
             -csegment name
 339      =1  # define SEGMENT_POINTER(name, vartype, locsegment) vartype * locsegment name
 340      =1  # define LOCATED_VARIABLE_NO_INIT(name, vartype, locsegment, addr) vartype locsegment name _at_ addr
 341      =1  
 342      =1  // used with UU16
 343      =1  # define LSB 1
 344      =1  # define MSB 0
 345      =1  
 346      =1  // used with UU32 (b0 is least-significant byte)
 347      =1  //# define b0 3
 348      =1  // define b1 2
 349      =1  //# define b2 1
 350      =1  //# define b3 0
 351      =1  
 352      =1  typedef unsigned char U8;
 353      =1  typedef unsigned int U16;
 354      =1  typedef unsigned long U32;
 355      =1  
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 7   

 356      =1  typedef signed char S8;
 357      =1  typedef signed int S16;
 358      =1  typedef signed long S32;
 359      =1  
 360      =1  typedef union UU16
 361      =1  {
 362      =1     U16 U16;
 363      =1     S16 S16;
 364      =1     U8 U8[2];
 365      =1     S8 S8[2];
 366      =1  } UU16;
 367      =1  
 368      =1  typedef union UU32
 369      =1  {
 370      =1     U32 U32;
 371      =1     S32 S32;
 372      =1     UU16 UU16[2];
 373      =1     U16 U16[2];
 374      =1     S16 S16[2];
 375      =1     U8 U8[4];
 376      =1     S8 S8[4];
 377      =1  } UU32;
 378      =1  
 379      =1  // NOP () macro support
 380      =1  extern void _nop_ (void);
 381      =1  #define NOP() _nop_()
 382      =1  
 383      =1  //-----------------------------------------------------------------------------
 384      =1  
 385      =1  // Hi-Tech 8051
 386      =1  // http://www.htsoft.com
 387      =1  
 388      =1  #elif defined HI_TECH_C
           =1 
           =1 # define SEG_GENERIC
           =1 # define SEG_FAR   far
           =1 # define SEG_DATA  data
           =1 # define SEG_NEAR  near
           =1 # define SEG_IDATA idata
           =1 # define SEG_XDATA xdata
           =1 # define SEG_PDATA pdata
           =1 # define SEG_CODE  code
           =1 # define SEG_BDATA bdata
           =1 
           =1 
           =1 # define SBIT(name, addr, thebit) static volatile bit name @ (addr + thebit)
           =1 # define SFR(name, addr)          static volatile unsigned char name @ addr
           =1 # define SFR16(name, addr)        static volatile unsigned int name @ addr
           =1 # define SFR16E(name, fulladdr) /* not supported */
           =1 # define SFR32(name, fulladdr)  /* not supported */
           =1 # define SFR32E(name, fulladdr) /* not supported */
           =1 
           =1 # define INTERRUPT(name, vector)       void name (void) interrupt vector
           =1 # define INTERRUPT_PROTO(name, vector)
           =1 # define INTERRUPT_USING(name, vector, regnum) void name (void) interrupt vector using regnum
           =1 # define INTERRUPT_PROTO_USING(name, vector, regnum)
           =1 
           =1 # define FUNCTION_USING(name, return_value, parameter, regnum) /* not supported */
           =1 # define FUNCTION_PROTO_USING(name, return_value, parameter, regnum) /* not supported */
           =1 // Note: Hi-Tech does not support functions using different register banks. Register
           =1 //       banks can only be specified in interrupts. If a function is called from
           =1 //       inside an interrupt, it will use the same register bank as the interrupt.
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 8   

           =1 
           =1 # define SEGMENT_VARIABLE(name, vartype, locsegment) locsegment vartype name
           =1 # define VARIABLE_SEGMENT_POINTER(name, vartype, targsegment) targsegment vartype * name
           =1 # define SEGMENT_VARIABLE_SEGMENT_POINTER(name, vartype, targsegment, locsegment) targsegment vartype * lo
             -csegment name
           =1 # define LOCATED_VARIABLE(name, vartype, locsegment, addr, init) locsegment vartype name @ addr
           =1 
           =1 // used with UU16
           =1 # define LSB 0
           =1 # define MSB 1
           =1 
           =1 // used with UU32 (b0 is least-significant byte)
           =1 # define b0 0
           =1 # define b1 1
           =1 # define b2 2
           =1 # define b3 3
           =1 
           =1 typedef unsigned char U8;
           =1 typedef unsigned int U16;
           =1 typedef unsigned long U32;
           =1 
           =1 typedef signed char S8;
           =1 typedef signed int S16;
           =1 typedef signed long S32;
           =1 
           =1 typedef union UU16
           =1 {
           =1    U16 U16;
           =1    S16 S16;
           =1    U8 U8[2];
           =1    S8 S8[2];
           =1 } UU16;
           =1 
           =1 typedef union UU32
           =1 {
           =1    U32 U32;
           =1    S32 S32;
           =1    UU16 UU16[2];
           =1    U16 U16[2];
           =1    S16 S16[2];
           =1    U8 U8[4];
           =1    S8 S8[4];
           =1 } UU32;
           =1 
           =1 // NOP () macro support
           =1 #define NOP() asm(" nop ")
           =1 
           =1 //-----------------------------------------------------------------------------
           =1 
           =1 // Tasking / Altium
           =1 // http://www.altium.com/tasking
           =1 
           =1 
           =1 #elif defined _CC51
           =1 
           =1 # define SEG_GENERIC
           =1 # define SEG_FAR   _xdat
           =1 # define SEG_DATA  _data
           =1 # define SEG_NEAR  _data
           =1 # define SEG_IDATA _idat
           =1 # define SEG_XDATA _xdat
           =1 # define SEG_PDATA _pdat
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 9   

           =1 # define SEG_CODE  _rom
           =1 # define SEG_BDATA _bdat
           =1 
           =1 # define SBIT(name, addr, bit)  _sfrbit  name _at(addr+bit)
           =1 # define SFR(name, addr)        _sfrbyte name _at(addr)
           =1 # define SFRX(name, addr)       _xdat volatile unsigned char name _at(addr)
           =1 #if _CC51 > 71
           =1 # define SFR16(name, addr)      _sfrword _little name _at(addr)
           =1 #else
           =1 # define SFR16(name, addr)      /* not supported */
           =1 #endif
           =1 # define SFR16E(name, fulladdr) /* not supported */
           =1 # define SFR32(name, fulladdr)  /* not supported */
           =1 # define SFR32E(name, fulladdr) /* not supported */
           =1 
           =1 # define INTERRUPT(name, vector) _interrupt (vector) void name (void)
           =1 # define INTERRUPT_USING(name, vector, regnum) _interrupt (vector) _using(regnum) void name (void)
           =1 # define INTERRUPT_PROTO(name, vector) _interrupt (vector) void name (void)
           =1 # define INTERRUPT_PROTO_USING(name, vector, regnum) _interrupt (vector) _using(regnum) void name (void)
           =1 
           =1 // When calling FUNCTION_USING in Tasking, the function must be called from an interrupt or Main which
           =1 // is also using the same register bank. If not, the compiler will generate an error.
           =1 # define FUNCTION_USING(name, return_value, parameter, regnum) _using(regnum) return_value name (parameter
             -)
           =1 # define FUNCTION_PROTO_USING(name, return_value, parameter, regnum) _using(regnum) return_value name (par
             -ameter)
           =1 // Note: Parameter must be either 'void' or include a variable type and name. (Ex: char temp_variable)
           =1 
           =1 # define SEGMENT_VARIABLE(name, vartype, locsegment) vartype locsegment name
           =1 # define VARIABLE_SEGMENT_POINTER(name, vartype, targsegment) vartype targsegment * name
           =1 # define SEGMENT_VARIABLE_SEGMENT_POINTER(name, vartype, targsegment, locsegment) vartype targsegment * lo
             -csegment name
           =1 # define LOCATED_VARIABLE(name, vartype, locsegment, addr, init) vartype locsegment name _at( addr )
           =1 
           =1 // used with UU16
           =1 # define LSB 1
           =1 # define MSB 0
           =1 
           =1 // used with UU32 (b0 is least-significant byte)
           =1 //# define b0 3
           =1 //# define b1 2
           =1 //# define b2 1
           =1 //# define b3 0
           =1 
           =1 typedef unsigned char U8;
           =1 typedef unsigned int U16;
           =1 typedef unsigned long U32;
           =1 
           =1 typedef signed char S8;
           =1 typedef signed int S16;
           =1 typedef signed long S32;
           =1 
           =1 typedef union UU16
           =1 {
           =1    U16 U16;
           =1    S16 S16;
           =1    U8 U8[2];
           =1    S8 S8[2];
           =1 } UU16;
           =1 
           =1 typedef union UU32
           =1 {
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 10  

           =1    U32 U32;
           =1    S32 S32;
           =1    UU16 UU16[2];
           =1    U16 U16[2];
           =1    S16 S16[2];
           =1    U8 U8[4];
           =1    S8 S8[4];
           =1 } UU32;
           =1 
           =1 // NOP () macro support
           =1 extern void _nop (void);
           =1 #define NOP() _nop()
           =1 
           =1 //-----------------------------------------------------------------------------
           =1 
           =1 
           =1 // IAR 8051
           =1 // http://www.iar.com
           =1 
           =1 #elif defined __ICC8051__
           =1 
           =1 #include <stdbool.h>
           =1 #include <intrinsics.h>
           =1 
           =1 # define SBIT(name, addr, bit)  __bit __no_init volatile bool name @ (addr+bit)
           =1 # define SFR(name, addr)        __sfr __no_init volatile unsigned char name @ addr
           =1 # define SFRX(name, addr)       __xdata __no_init volatile unsigned char name @ addr
           =1 # define SFR16(name, addr)      __sfr __no_init volatile unsigned int  name @ addr
           =1 # define SFR16E(name, fulladdr) /* not supported */
           =1 # define SFR32(name, fulladdr) /* not supported */
           =1 # define SFR32E(name, fulladdr) /* not supported */
           =1 
           =1 # define SEG_GENERIC __generic
           =1 # define SEG_FAR  __xdata
           =1 # define SEG_DATA __data
           =1 # define SEG_NEAR __data
           =1 # define SEG_IDATA __idata
           =1 # define SEG_XDATA __xdata
           =1 # define SEG_PDATA __pdata
           =1 # define SEG_CODE  __code
           =1 # define SEG_BDATA __bdata
           =1 
           =1 #define bit bool
           =1 
           =1 # define _PPTOSTR_(x) #x
           =1 # define _PPARAM_(address) _PPTOSTR_(vector=address * 8 + 3)
           =1 # define _PPARAM2_(regbank) _PPTOSTR_(register_bank=regbank)
           =1 # define INTERRUPT(name, vector) _Pragma(_PPARAM_(vector)) __interrupt void name(void)
           =1 # define INTERRUPT_PROTO(name, vector)  __interrupt void name(void)
           =1 # define INTERRUPT_USING(name, vector, regnum) _Pragma(_PPARAM2_(regnum)) _Pragma(_PPARAM_(vector)) __inte
             -rrupt void name(void)
           =1 # define INTERRUPT_PROTO_USING(name, vector, regnum) __interrupt void name(void)
           =1 
           =1 # define FUNCTION_USING(name, return_value, parameter, regnum) /* not supported */
           =1 # define FUNCTION_PROTO_USING(name, return_value, parameter, regnum) /* not supported */
           =1 // Note: IAR does not support functions using different register banks. Register
           =1 //       banks can only be specified in interrupts. If a function is called from
           =1 //       inside an interrupt, it will use the same register bank as the interrupt.
           =1 
           =1 # define SEGMENT_VARIABLE(name, vartype, locsegment)  locsegment vartype name
           =1 # define VARIABLE_SEGMENT_POINTER(name, vartype, targsegment) vartype targsegment  * name
           =1 # define SEGMENT_VARIABLE_SEGMENT_POINTER(name, vartype, targsegment, locsegment) vartype targsegment * lo
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 11  

             -csegment name
           =1 
           =1 # define LOCATED_VARIABLE(name, vartype, locsegment, addr, init) locsegment __no_init vartype name @ addr
           =1 
           =1 // used with UU16
           =1 # define LSB 0
           =1 # define MSB 1
           =1 
           =1 // used with UU32 (b0 is least-significant byte)
           =1 //# define b0 0
           =1 //# define b1 1
           =1 //# define b2 2
           =1 //# define b3 3
           =1 
           =1 typedef unsigned char U8;
           =1 typedef unsigned int U16;
           =1 typedef unsigned long U32;
           =1 
           =1 typedef signed char S8;
           =1 typedef signed int S16;
           =1 typedef signed long S32;
           =1 
           =1 typedef union UU16
           =1 {
           =1    U16 U16;
           =1    S16 S16;
           =1    U8 U8[2];
           =1    S8 S8[2];
           =1 } UU16;
           =1 
           =1 typedef union UU32
           =1 {
           =1    U32 U32;
           =1    S32 S32;
           =1    UU16 UU16[2];
           =1    U16 U16[2];
           =1    S16 S16[2];
           =1    U8 U8[4];
           =1    S8 S8[4];
           =1 } UU32;
           =1 
           =1 
           =1 #define NOP() __no_operation();
           =1 //-----------------------------------------------------------------------------
           =1 
           =1 // Crossware
           =1 // http://www.crossware.com
           =1 
           =1 #elif defined _XC51_VER
           =1 # define SBIT(name, addr, bit)  _sfrbit  name = (addr+bit)
           =1 # define SFR(name, addr)        _sfr     name = addr
           =1 # define SFR16(name, addr)      _sfrword name = addr
           =1 # define SFR16E(name, fulladdr) /* not supported */
           =1 # define SFR32(name, fulladdr)  /* not supported */
           =1 # define SFR32E(name, fulladdr) /* not supported */
           =1 
           =1 //-----------------------------------------------------------------------------
           =1 
           =1 // Wickenhäuser
           =1 // http://www.wickenhaeuser.de
           =1 
           =1 #elif defined __UC__
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 12  

           =1 # define SBIT(name, addr, bit)  unsigned char bit  name @ (addr+bit)
           =1 # define SFR(name, addr)        near unsigned char name @ addr
           =1 # define SFR16(name, addr)      /* not supported */
           =1 # define SFR16E(name, fulladdr) /* not supported */
           =1 # define SFR32(name, fulladdr)  /* not supported */
           =1 # define SFR32E(name, fulladdr) /* not supported */
           =1 
           =1 //-----------------------------------------------------------------------------
           =1 
           =1 // Default
           =1 // Unknown compiler
           =1 
           =1 #else
           =1 # warning unrecognized compiler
           =1 # define SBIT(name, addr, bit)  volatile bool           name
           =1 # define SFR(name, addr)        volatile unsigned char  name
           =1 # define SFRX(name, addr)       volatile unsigned char  name
           =1 # define SFR16(name, addr)      volatile unsigned short name
           =1 # define SFR16E(name, fulladdr) volatile unsigned short name
           =1 # define SFR32(name, fulladdr)  volatile unsigned long  name
           =1 # define SFR32E(name, fulladdr) volatile unsigned long  name
           =1 
           =1 #endif
 683      =1  
 684      =1  //-----------------------------------------------------------------------------
 685      =1  // Header File PreProcessor Directive
 686      =1  //-----------------------------------------------------------------------------
 687      =1  
 688      =1  #endif                                 // #define COMPILER_DEFS_H
 689      =1  
 690      =1  //-----------------------------------------------------------------------------
 691      =1  // End Of File
 692      =1  //-----------------------------------------------------------------------------
   3          #include "C8051F580_defs.h"
   1      =1  //-----------------------------------------------------------------------------
   2      =1  // C8051F580_defs.h
   3      =1  //-----------------------------------------------------------------------------
   4      =1  // Copyright 2008, Silicon Laboratories, Inc.
   5      =1  // http://www.silabs.com
   6      =1  //
   7      =1  // Program Description:
   8      =1  //
   9      =1  // Register/bit definitions for the C8051F58x family.
  10      =1  // **Important Note**: The compiler_defs.h header file should be included
  11      =1  // before including this header file.
  12      =1  //
  13      =1  // Target:         C8051F580/1/2/3/4/5/6/7,8/9-F590/1
  14      =1  // Tool chain:     Generic
  15      =1  // Command Line:   None
  16      =1  //
  17      =1  // Release 0.6 - 20 AUG 2012 (TP)
  18      =1  //    -Added #define for _XPAGE to provide support for SDCC memory paging
  19      =1  //     (pdata)
  20      =1  //
  21      =1  // Release 0.5 - 10 SEP 2011 (GP)
  22      =1  //    - Fixed SFR16 definition for CAN0IF2MC
  23      =1  //
  24      =1  // Release 0.4 - 08 OCT 2010 (TP)
  25      =1  //    - Fixed bit definitions for SCON0
  26      =1  //
  27      =1  // Release 0.3 - 01 APR 2009 (GP)
  28      =1  //    - Added SN0-SN3
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 13  

  29      =1  //
  30      =1  // Release 0.2 - 29 JUL 2008 (ADT)
  31      =1  //    - Added Timer 4 bit definitions
  32      =1  //
  33      =1  // Release 0.1 - 09 JUL 2008 (GP)
  34      =1  //    - Initial Revision
  35      =1  //
  36      =1  //-----------------------------------------------------------------------------
  37      =1  // Header File Preprocessor Directive
  38      =1  //-----------------------------------------------------------------------------
  39      =1  
  40      =1  #ifndef C8051F580_DEFS_H
  41      =1  #define C8051F580_DEFS_H
  42      =1  
  43      =1  //-----------------------------------------------------------------------------
  44      =1  // Page 0, Page 1 and Page F Registers
  45      =1  //-----------------------------------------------------------------------------
  46      =1  
  47      =1  SFR (P0, 0x80);                        // Port 0 Latch
  48      =1  SFR (SP, 0x81);                        // Stack Pointer
  49      =1  SFR (DPL, 0x82);                       // Data Pointer Low
  50      =1  SFR (DPH, 0x83);                       // Data Pointer High
  51      =1  SFR (SFR0CN, 0x84);                    // SFR Page Control
  52      =1  SFR (SFRNEXT, 0x85);                   // SFR stack next page
  53      =1  SFR (SFRLAST, 0x86);                   // SFR stack last page
  54      =1  SFR (PCON, 0x87);                      // Power Control
  55      =1  SFR (TCON, 0x88);                      // Timer/Counter Control
  56      =1  SFR (TMOD, 0x89);                      // Timer/Counter Mode
  57      =1  SFR (TL0, 0x8A);                       // Timer/Counter 0 Low
  58      =1  SFR (TL1, 0x8B);                       // Timer/Counter 1 Low
  59      =1  SFR (TH0, 0x8C);                       // Timer/Counter 0 High
  60      =1  SFR (TH1, 0x8D);                       // Timer/Counter 1 High
  61      =1  SFR (CKCON, 0x8E);                     // Clock Control
  62      =1  SFR (PSCTL, 0x8F);                     // Program Store R/W Control
  63      =1  SFR (CLKSEL, 0x8F);                    // System clock select
  64      =1  SFR (P1, 0x90);                        // Port 1 Latch
  65      =1  SFR (TMR3CN, 0x91);                    // Timer/Counter 3 Control
  66      =1  SFR (TMR5CN, 0x91);                    // Timer/Counter 5 Control
  67      =1  SFR (TMR3RLL, 0x92);                   // Timer/Counter 3 Reload Low
  68      =1  SFR (TMR5CAPL, 0x92);                  // Timer/Counter 5 Capture Low
  69      =1  SFR (TMR3RLH, 0x93);                   // Timer/Counter 3 Reload High
  70      =1  SFR (TMR5CAPH, 0x93);                  // Timer/Counter 5 Capture High
  71      =1  SFR (TMR3L, 0x94);                     // Timer/Counter 3 Low
  72      =1  SFR (TMR5L, 0x94);                     // Timer/Counter 5 Low
  73      =1  SFR (TMR3H, 0x95);                     // Timer/Counter 3 High
  74      =1  SFR (TMR5H, 0x95);                     // Timer/Counter 5 High
  75      =1  SFR (TMR5CF, 0x96);                    // Timer/Counter 5 Configuration
  76      =1  SFR (CLKMUL, 0x97);                    // Clock Multiplier
  77      =1  SFR (SCON0, 0x98);                     // UART0 Control
  78      =1  SFR (SCON1, 0x98);                     // UART1 Control
  79      =1  SFR (SBUF0, 0x99);                     // UART0 Data Buffer
  80      =1  SFR (SBUF1, 0x99);                     // UART1 Data Buffer
  81      =1  SFR (CPT0CN, 0x9A);                    // Comparator 0 Control
  82      =1  SFR (CPT2CN, 0x9A);                    // Comparator 2 Control
  83      =1  SFR (CPT0MD, 0x9B);                    // Comparator 0 Mode
  84      =1  SFR (CPT2MD, 0x9B);                    // Comparator 2 Mode
  85      =1  SFR (CPT0MX, 0x9C);                    // Comparator 0 Mux
  86      =1  SFR (CPT2MX, 0x9C);                    // Comparator 2 Mux
  87      =1  SFR (CPT1CN, 0x9D);                    // Comparator 1 Control
  88      =1  SFR (CPT1MD, 0x9E);                    // Comparator 0 Mode
  89      =1  SFR (OSCIFIN, 0x9E);                   // Internal Oscillator Fine Control
  90      =1  SFR (CPT1MX, 0x9F);                    // Comparator 1 Mux
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 14  

  91      =1  SFR (OSCXCN, 0x9F);                    // External Oscillator Control
  92      =1  SFR (P2, 0xA0);                        // Port 2 Latch
  93      =1  SFR (SPI0CFG, 0xA1);                   // SPI0 Configuration
  94      =1  SFR (OSCICN, 0xA1);                    // Internal Oscillator Control
  95      =1  SFR (SPI0CKR, 0xA2);                   // SPI0 Clock rate control
  96      =1  SFR (OSCICRS, 0xA2);                   // Internal Oscillator Coarse Control
  97      =1  SFR (SPI0DAT, 0xA3);                   // SPI0 Data Buffer
  98      =1  SFR (P0MDOUT, 0xA4);                   // Port 0 Output Mode
  99      =1  SFR (P1MDOUT, 0xA5);                   // Port 1 Output Mode
 100      =1  SFR (P2MDOUT, 0xA6);                   // Port 2 Output Mode
 101      =1  SFR (SFRPAGE, 0xA7);                   // SFR Page Select
 102      =1  SFR (IE, 0xA8);                        // Interrupt Enable
 103      =1  SFR (SMOD0, 0xA9);                     // Serial Port 0 Control
 104      =1  SFR (EMI0CN, 0xAA);                    // EMIF Control
 105      =1  SFR (EMI0TC, 0xAA);                    // EMIF Timing control
 106      =1  SFR (SBCON0, 0xAB);                    // UART0 Baud Rate Generator Control
 107      =1  SFR (SBRLL0, 0xAC);                    // UART0 Baud Rate Generator Low
 108      =1  SFR (SBRLH0, 0xAD);                    // UART0 Baud Rate Generator High
 109      =1  SFR (P3MAT, 0xAE);                     // Port 3 Match
 110      =1  SFR (P3MDOUT, 0xAE);                   // Port 3 Mode
 111      =1  SFR (P3MASK, 0xAF);                    // Port 3 Mask
 112      =1  SFR (P4MDOUT, 0xAF);                   // Port 4 Mode
 113      =1  SFR (P3, 0xB0);                        // Port 3 Latch
 114      =1  SFR (P2MAT, 0xB1);                     // Port 2 Match
 115      =1  SFR (P2MASK, 0xB2);                    // Port 2 Mask
 116      =1  SFR (EMI0CF, 0xB2);                    // EMIF Configuration
 117      =1  SFR (P4, 0xB5);                        // Port 4 Latch
 118      =1  SFR (FLSCL, 0xB6);                     // Flash Scale
 119      =1  SFR (FLKEY, 0xB7);                     // Flash access limit
 120      =1  SFR (IP, 0xB8);                        // Interrupt Priority
 121      =1  SFR (SMB0ADR, 0xB9);                   // SMBus0 Slave address
 122      =1  SFR (ADC0TK, 0xBA);                    // ADC0 Tracking Mode Select
 123      =1  SFR (SMB0ADM, 0xBA);                   // SMBus0 Address Mask
 124      =1  SFR (ADC0MX, 0xBB);                    // AMUX0 Channel select
 125      =1  SFR (ADC0CF, 0xBC);                    // AMUX0 Channel configuration
 126      =1  SFR (ADC0L, 0xBD);                     // ADC0 Data Low
 127      =1  SFR (ADC0H, 0xBE);                     // ADC0 Data High
 128      =1  SFR (SMB0CN, 0xC0);                    // SMBus0 Control
 129      =1  SFR (SMB0CF, 0xC1);                    // SMBus0 Configuration
 130      =1  SFR (SMB0DAT, 0xC2);                   // SMBus0 Data
 131      =1  SFR (ADC0GTL, 0xC3);                   // ADC0 Greater-Than Compare Low
 132      =1  SFR (ADC0GTH, 0xC4);                   // ADC0 Greater-Than Compare High
 133      =1  SFR (ADC0LTL, 0xC5);                   // ADC0 Less-Than Compare Word Low
 134      =1  SFR (ADC0LTH, 0xC6);                   // ADC0 Less-Than Compare Word High
 135      =1  SFR (XBR3, 0xC6);                      // Port I/O Crossbar Control 3
 136      =1  SFR (XBR2, 0xC7);                      // Port I/O Crossbar Control 2
 137      =1  SFR (TMR2CN, 0xC8);                    // Timer/Counter 2 Control
 138      =1  SFR (TMR4CN, 0xC8);                    // Timer/Counter 4 Control
 139      =1  SFR (REG0CN, 0xC9);                    // Regulator Control
 140      =1  SFR (LIN0CF, 0xC9);                    // LIN 0 Configuration
 141      =1  SFR (TMR4CF, 0xC9);                    // Timer/Counter 4 Configuration
 142      =1  SFR (TMR2RLL, 0xCA);                   // Timer/Counter 2 Reload Low
 143      =1  SFR (TMR4CAPL, 0xCA);                  // Timer/Counter 4 Capture Low
 144      =1  SFR (TMR2RLH, 0xCB);                   // Timer/Counter 2 Reload High
 145      =1  SFR (TMR4CAPH, 0xCB);                  // Timer/Counter 4 Capture High
 146      =1  SFR (TMR2L, 0xCC);                     // Timer/Counter 2 Low
 147      =1  SFR (TMR4L, 0xCC);                     // Timer/Counter 4 Low
 148      =1  SFR (TMR2H, 0xCD);                     // Timer/Counter 2 High
 149      =1  SFR (TMR4H, 0xCD);                     // Timer/Counter 4 High
 150      =1  SFR (PCA0CPL5, 0xCE);                  // PCA0 Capture 5 Low
 151      =1  SFR (PCA1CPL11, 0xCE);                 // PCA1 Capture 11 Low
 152      =1  SFR (PCA0CPH5, 0xCF);                  // PCA0 Capture 5 High
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 15  

 153      =1  SFR (PCA1CPH11, 0xCF);                 // PCA1 Capture 11 High
 154      =1  SFR (PSW, 0xD0);                       // Program Status Word
 155      =1  SFR (REF0CN, 0xD1);                    // Voltage Reference Control
 156      =1  SFR (LIN0DAT, 0xD2);                   // LIN0 Data
 157      =1  SFR (LIN0ADR, 0xD3);                   // LIN0 Address
 158      =1  SFR (P0SKIP, 0xD4);                    // Port 0 Skip
 159      =1  SFR (P1SKIP, 0xD5);                    // Port 1 Skip
 160      =1  SFR (P2SKIP, 0xD6);                    // Port 2 Skip
 161      =1  SFR (P3SKIP, 0xD7);                    // Port 3 Skip
 162      =1  SFR (PCA0CN, 0xD8);                    // PCA0 Control
 163      =1  SFR (PCA1CN, 0xD8);                    // PCA1 Control
 164      =1  SFR (PCA0MD, 0xD9);                    // PCA0 Mode
 165      =1  SFR (PCA1MD, 0xD9);                    // PCA1 Mode
 166      =1  SFR (PCA0PWM, 0xD9);                   // PCA0 PWM Control
 167      =1  SFR (PCA0CPM0, 0xDA);                  // PCA0 Module 0 Mode
 168      =1  SFR (PCA1CPM6, 0xDA);                  // PCA1 Module 6 Mode
 169      =1  SFR (PCA1PWM, 0xDA);                   // PCA1 PWM Control
 170      =1  SFR (PCA0CPM1, 0xDB);                  // PCA0 Module 1  Mode
 171      =1  SFR (PCA1CPM7, 0xDB);                  // PCA1 Module 7  Mode
 172      =1  SFR (PCA0CPM2, 0xDC);                  // PCA0 Module 2  Mode
 173      =1  SFR (PCA1CPM8, 0xDC);                  // PCA1 Module 8  Mode
 174      =1  SFR (PCA0CPM3, 0xDD);                  // PCA0 Module 3  Mode
 175      =1  SFR (PCA1CPM9, 0xDD);                  // PCA1 Module 9  Mode
 176      =1  SFR (PCA0CPM4, 0xDE);                  // PCA0 Module 4  Mode
 177      =1  SFR (PCA1CPM10, 0xDE);                  // PCA1 Module 10 Mode
 178      =1  SFR (PCA0CPM5, 0xDF);                  // PCA0 Module 5  Mode
 179      =1  SFR (PCA1CPM11, 0xDF);                  // PCA1 Module 11 Mode
 180      =1  SFR (ACC, 0xE0);                       // Accumulator
 181      =1  SFR (XBR0, 0xE1);                      // Port I/O Crossbar Control 0
 182      =1  SFR (XBR1, 0xE2);                      // Port I/O Crossbar Control 1
 183      =1  SFR (CCH0CN, 0xE3);                    // Cache control
 184      =1  SFR (IT01CF, 0xE4);                    // INT0/INT1 Configuration
 185      =1  SFR (EIE1, 0xE6);                      // Extended Interrupt Enable 2
 186      =1  SFR (EIE2, 0xE7);                      // Extended Interrupt Enable 2
 187      =1  SFR (ADC0CN, 0xE8);                    // ADC0 Control
 188      =1  SFR (PCA0CPL1, 0xE9);                  // PCA0 Capture 1 Low
 189      =1  SFR (PCA1CPL1, 0xE9);                  // PCA1 Capture 7 Low
 190      =1  SFR (PCA0CPH1, 0xEA);                  // PCA0 Capture 1 High
 191      =1  SFR (PCA1CPH1, 0xEA);                  // PCA1 Capture 7 High
 192      =1  SFR (PCA0CPL2, 0xEB);                  // PCA0 Capture 2 Low
 193      =1  SFR (PCA1CPL2, 0xEB);                  // PCA1 Capture 8 Low
 194      =1  SFR (PCA0CPH2, 0xEC);                  // PCA0 Capture 2 High
 195      =1  SFR (PCA1CPH2, 0xEC);                  // PCA1 Capture 8 High
 196      =1  SFR (PCA0CPL3, 0xED);                  // PCA0 Capture 3 Low
 197      =1  SFR (PCA1CPL3, 0xED);                  // PCA1 Capture 9 Low
 198      =1  SFR (PCA0CPH3, 0xEE);                  // PCA0 Capture 3 High
 199      =1  SFR (PCA1CPH3, 0xEE);                  // PCA1 Capture 9 High
 200      =1  SFR (RSTSRC, 0xEF);                    // Reset Source Configuration/Status
 201      =1  SFR (B, 0xF0);                         // B Register
 202      =1  SFR (P0MAT, 0xF1);                     // Port 0 Match
 203      =1  SFR (P0MDIN, 0xF1);                    // Port 0 Input Mode
 204      =1  SFR (P0MASK, 0xF2);                    // Port 0 Mask
 205      =1  SFR (P1MDIN, 0xF2);                    // Port 1 Input Mode
 206      =1  SFR (P1MAT, 0xF3);                     // Port 1 Match
 207      =1  SFR (P2MDIN, 0xF3);                    // Port 2 Input Mode
 208      =1  SFR (P1MASK, 0xF4);                    // Port 1 Mask
 209      =1  SFR (P3MDIN, 0xF4);                    // Port 3 Input Mode
 210      =1  SFR (PSBANK, 0xF5);                    // Program Space Bank Select
 211      =1  SFR (EIP1, 0xF6);                      // External Interrupt Priority 1
 212      =1  SFR (EIP2, 0xF7);                      // External Interrupt Priority 2
 213      =1  SFR (SPI0CN, 0xF8);                    // SPI0 Control
 214      =1  SFR (PCA0L, 0xF9);                     // PCA0 Counter Low
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 16  

 215      =1  SFR (PCA1L, 0xF9);                     // PCA1 Counter Low
 216      =1  SFR (SN0, 0xF9);                       // Serial Number 0
 217      =1  SFR (PCA0H, 0xFA);                     // PCA0 Counter High
 218      =1  SFR (PCA1H, 0xFA);                     // PCA1 Counter High
 219      =1  SFR (SN1, 0xFA);                       // Serial Number 1
 220      =1  SFR (PCA0CPL0, 0xFB);                  // PCA0 Capture 0 Low
 221      =1  SFR (PCA1CPL6, 0xFB);                  // PCA1 Capture 6 Low
 222      =1  SFR (SN2, 0xFB);                       // Serial Number 2
 223      =1  SFR (PCA0CPH0, 0xFC);                  // PCA0 Capture 0 High
 224      =1  SFR (PCA1CPH6, 0xFC);                  // PCA1 Capture 6 High
 225      =1  SFR (SN3, 0xFC);                       // Serial Number 3
 226      =1  SFR (PCA0CPL4, 0xFD);                  // PCA0 Capture 4 Low
 227      =1  SFR (PCA1CPL10, 0xFD);                 // PCA1 Capture 10 Low
 228      =1  SFR (PCA0CPH4, 0xFE);                  // PCA0 Capture 4 High
 229      =1  SFR (PCA1CPH10, 0xFE);                 // PCA1 Capture 10 High
 230      =1  SFR (VDM0CN, 0xFF);                    // VDD Monitor Control
 231      =1  
 232      =1  //-----------------------------------------------------------------------------
 233      =1  // Page C (CAN0) Registers
 234      =1  //-----------------------------------------------------------------------------
 235      =1  
 236      =1  SFR (CAN0CFG, 0x92);                   // CAN0 Clock Configuration
 237      =1  SFR (CAN0STAT, 0x94);                  // Status Register Low Byte
 238      =1  SFR (CAN0ERRL, 0x96);                  // Error Counter Low Byte
 239      =1  SFR (CAN0ERRH, 0x97);                  // Error Counter High Byte
 240      =1  SFR (CAN0BTL, 0x9A);                   // Bit Timing Register Low Byte
 241      =1  SFR (CAN0BTH, 0x9B);                   // Bit Timing Register High Byte
 242      =1  SFR (CAN0IIDL, 0x9C);                  // Interrupt Register Low Byte
 243      =1  SFR (CAN0IIDH, 0x9D);                  // Interrupt Register High Byte
 244      =1  SFR (CAN0TST, 0x9E);                   // Test Register Low Byte
 245      =1  SFR (CAN0BRPE, 0xA1);                  // BRP Extension Register Low Byte
 246      =1  SFR (CAN0TR1L, 0xA2);                  // Transmission Request 1 Low Byte
 247      =1  SFR (CAN0TR1H, 0xA3);                  // Transmission Request 1 High Byte
 248      =1  SFR (CAN0TR2L, 0xA4);                  // Transmission Request 2 Low Byte
 249      =1  SFR (CAN0TR2H, 0xA5);                  // Transmission Request 2 High Byte
 250      =1  SFR (CAN0ND1L, 0xAA);                  // New Data 1 Low Byte
 251      =1  SFR (CAN0ND1H, 0xAB);                  // New Data 1 High Byte
 252      =1  SFR (CAN0ND2L, 0xAC);                  // New Data 2 Low Byte
 253      =1  SFR (CAN0ND2H, 0xAD);                  // New Data 2 High Byte
 254      =1  SFR (CAN0IP1L, 0xAE);                  // Interrupt Pending 1 Low Byte
 255      =1  SFR (CAN0IP1H, 0xAF);                  // Interrupt Pending 1 High Byte
 256      =1  SFR (CAN0IP2L, 0xB2);                  // Interrupt Pending 2 Low Byte
 257      =1  SFR (CAN0IP2H, 0xB3);                  // Interrupt Pending 2 High Byte
 258      =1  SFR (CAN0MV1L, 0xBA);                  // Message Valid 1 Low Byte
 259      =1  SFR (CAN0MV1H, 0xBB);                  // Message Valid 1 High Byte
 260      =1  SFR (CAN0MV2L, 0xBC);                  // Message Valid 2 Low Byte
 261      =1  SFR (CAN0MV2H, 0xBD);                  // Message Valid 2 High Byte
 262      =1  SFR (CAN0IF1CRL, 0xBE);                // IF1 Command Request Low Byte
 263      =1  SFR (CAN0IF1CRH, 0xBF);                // IF1 Command Request High Byte
 264      =1  SFR (CAN0CN, 0xC0);                    // CAN Control Register Low Byte
 265      =1  SFR (CAN0IF1CML, 0xC2);                // IF1 Command Mask Low Byte
 266      =1  SFR (CAN0IF1CMH, 0xC3);                // IF1 Command Mask High Byte
 267      =1  SFR (CAN0IF1M1L, 0xC4);                // IF1 Mask 1 Low Byte
 268      =1  SFR (CAN0IF1M1H, 0xC5);                // IF1 Mask 1 High Byte
 269      =1  SFR (CAN0IF1M2L, 0xC6);                // IF1 Mask 2 Low Byte
 270      =1  SFR (CAN0IF1M2H, 0xC7);                // IF1 Mask 2 High Byte
 271      =1  SFR (CAN0IF1A1L, 0xCA);                // IF1 Arbitration 1 Low Byte
 272      =1  SFR (CAN0IF1A1H, 0xCB);                // IF1 Arbitration 1 High Byte
 273      =1  SFR (CAN0IF1A2L, 0xCC);                // IF1 Arbitration 2 Low Byte
 274      =1  SFR (CAN0IF1A2H, 0xCD);                // IF1 Arbitration 2 High Byte
 275      =1  SFR (CAN0IF2MCL, 0xCE);                // IF2 Message Control Low Byte
 276      =1  SFR (CAN0IF2MCH, 0xCF);                // IF2 Message Control High Byte
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 17  

 277      =1  SFR (CAN0IF1MCL, 0xD2);                // IF1 Message Control Low Byte
 278      =1  SFR (CAN0IF1MCH, 0xD3);                // IF1 Message Control High Byte
 279      =1  SFR (CAN0IF1DA1L, 0xD4);               // IF1 Data A 1 Low Byte
 280      =1  SFR (CAN0IF1DA1H, 0xD5);               // IF1 Data A 1 High Byte
 281      =1  SFR (CAN0IF1DA2L, 0xD6);               // IF1 Data A 2 Low Byte
 282      =1  SFR (CAN0IF1DA2H, 0xD7);               // IF1 Data A 2 High Byte
 283      =1  SFR (CAN0IF1DB1L, 0xDA);               // IF1 Data B 1 Low Byte
 284      =1  SFR (CAN0IF1DB1H, 0xDB);               // IF1 Data B 1 High Byte
 285      =1  SFR (CAN0IF1DB2L, 0xDC);               // IF1 Data B 2 Low Byte
 286      =1  SFR (CAN0IF1DB2H, 0xDD);               // IF1 Data B 2 High Byte
 287      =1  SFR (CAN0IF2CRL, 0xDE);                // IF2 Command Request Low Byte
 288      =1  SFR (CAN0IF2CRH, 0xDF);                // IF2 Command Request High Byte
 289      =1  SFR (CAN0IF2CML, 0xE2);                // IF2 Command Mask Low Byte
 290      =1  SFR (CAN0IF2CMH, 0xE3);                // IF2 Command Mask High Byte
 291      =1  SFR (CAN0IF2M1L, 0xEA);                // IF2 Mask 1 Low Byte
 292      =1  SFR (CAN0IF2M1H, 0xEB);                // IF2 Mask 1 High Byte
 293      =1  SFR (CAN0IF2M2L, 0xEC);                // IF2 Mask 2 Low Byte
 294      =1  SFR (CAN0IF2M2H, 0xED);                // IF2 Mask 2 High Byte
 295      =1  SFR (CAN0IF2A1L, 0xEE);                // IF2 Arbitration 1 Low Byte
 296      =1  SFR (CAN0IF2A1H, 0xEF);                // IF2 Arbitration 1 High Byte
 297      =1  SFR (CAN0IF2A2L, 0xF2);                // IF2 Arbitration 2 Low Byte
 298      =1  SFR (CAN0IF2A2H, 0xF3);                // IF2 Arbitration 2 High Byte
 299      =1  SFR (CAN0IF2DA1L, 0xF6);               // IF2 Data A 1 Low Byte
 300      =1  SFR (CAN0IF2DA1H, 0xF7);               // IF2 Data A 1 High Byte
 301      =1  SFR (CAN0IF2DA2L, 0xFA);               // IF2 Data A 2 Low Byte
 302      =1  SFR (CAN0IF2DA2H, 0xFB);               // IF2 Data A 2 High Byte
 303      =1  SFR (CAN0IF2DB1L, 0xFC);               // IF2 Data B 1 Low Byte
 304      =1  SFR (CAN0IF2DB1H, 0xFD);               // IF2 Data B 1 High Byte
 305      =1  SFR (CAN0IF2DB2L, 0xFE);               // IF2 Data B 2 Low Byte
 306      =1  SFR (CAN0IF2DB2H, 0xFF);               // IF2 Data B 2 High Byte
 307      =1  
 308      =1  
 309      =1  //-----------------------------------------------------------------------------
 310      =1  // 16-bit Register Definitions (might not be supported by all compilers)
 311      =1  //-----------------------------------------------------------------------------
 312      =1  
 313      =1  SFR16 (DP, 0x82);                      // Data Pointer
 314      =1  SFR16 (TMR3RL, 0x92);                  // Timer 3 Reload
 315      =1  SFR16 (TMR5CAP, 0x92);                 // Timer 5 Capture
 316      =1  SFR16 (TMR3, 0x94);                    // Timer 3 Capture / Reload
 317      =1  SFR16 (TMR5, 0x94);                    // Timer 5
 318      =1  SFR16 (SBRL0, 0xAC);                   // UART0 Reload
 319      =1  SFR16 (ADC0, 0xBD);                    // ADC0 data
 320      =1  SFR16 (ADC0GT, 0xC3);                  // ADC0 Greater Than Window
 321      =1  SFR16 (ADC0LT, 0xC5);                  // ADC0 Less Than Window
 322      =1  SFR16 (TMR2RL, 0xCA);                  // Timer 2 Reload
 323      =1  SFR16 (TMR4CAP, 0xCA);                 // Timer 4 Capture
 324      =1  SFR16 (TMR2, 0xCC);                    // Timer 2 Capture / Reload
 325      =1  SFR16 (TMR4, 0xCC);                    // Timer 4
 326      =1  SFR16 (PCA0CP5, 0xCE);                 // PCA0 Module 5 Capture
 327      =1  SFR16 (PCA1CP11, 0xCE);                // PCA1 Module 11 Capture
 328      =1  SFR16 (PCA0CP1, 0xE9);                 // PCA0 Module 1 Capture
 329      =1  SFR16 (PCA1CP7, 0xE9);                 // PCA1 Module 7 Capture
 330      =1  SFR16 (PCA0CP2, 0xEB);                 // PCA0 Module 2 Capture
 331      =1  SFR16 (PCA1CP8, 0xEB);                 // PCA1 Module 8 Capture
 332      =1  SFR16 (PCA0CP3, 0xED);                 // PCA0 Module 3 Capture
 333      =1  SFR16 (PCA1CP9, 0xED);                 // PCA1 Module 9 Capture
 334      =1  SFR16 (PCA0, 0xF9);                    // PCA0 Counter
 335      =1  SFR16 (PCA1, 0xF9);                    // PCA1 Counter
 336      =1  SFR16 (PCA0CP0, 0xFB);                 // PCA0 Module 0 Capture
 337      =1  SFR16 (PCA1CP6, 0xFB);                 // PCA1 Module 6 Capture
 338      =1  SFR16 (PCA0CP4, 0xFD);                 // PCA0 Module 4 Capture
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 18  

 339      =1  SFR16 (PCA1CP10, 0xFD);                 // PCA1 Module 10 Capture
 340      =1  
 341      =1  SFR16 (CAN0ERR, 0x96);                 // Error Counter
 342      =1  SFR16 (CAN0BT, 0x9A);                  // Bit Timing Register
 343      =1  SFR16 (CAN0IID, 0x9C);                 // Interrupt Register
 344      =1  SFR16 (CAN0TR1, 0xA2);                 // Transmission Request 1
 345      =1  SFR16 (CAN0TR2, 0xA4);                 // Transmission Request 2
 346      =1  SFR16 (CAN0ND1, 0xAA);                 // New Data 1
 347      =1  SFR16 (CAN0ND2, 0xAC);                 // New Data 2
 348      =1  SFR16 (CAN0IP1, 0xAE);                 // Interrupt Pending 1
 349      =1  SFR16 (CAN0IP2, 0xB2);                 // Interrupt Pending 2
 350      =1  SFR16 (CAN0MV1, 0xBA);                 // Message Valid 1
 351      =1  SFR16 (CAN0MV2, 0xBC);                 // Message Valid 2
 352      =1  SFR16 (CAN0IF1CR, 0xBE);               // IF1 Command Request
 353      =1  SFR16 (CAN0IF1CM, 0xC2);               // IF1 Command Mask
 354      =1  SFR16 (CAN0IF1M1, 0xC4);               // IF1 Mask 1
 355      =1  SFR16 (CAN0IF1M2, 0xC6);               // IF1 Mask 2
 356      =1  SFR16 (CAN0IF1A1, 0xCA);               // IF1 Arbitration 1
 357      =1  SFR16 (CAN0IF1A2, 0xCC);               // IF1 Arbitration 2
 358      =1  SFR16 (CAN0IF1MC, 0xD2);               // IF1 Message Control
 359      =1  SFR16 (CAN0IF1DA1, 0xD4);              // IF1 Data A 1
 360      =1  SFR16 (CAN0IF1DA2, 0xD6);              // IF1 Data A 2
 361      =1  SFR16 (CAN0IF1DB1, 0xDA);              // IF1 Data B 1
 362      =1  SFR16 (CAN0IF1DB2, 0xDC);              // IF1 Data B 2
 363      =1  SFR16 (CAN0IF2CR, 0xDE);               // IF2 Command Request
 364      =1  SFR16 (CAN0IF2CM, 0xE2);               // IF2 Command Mask
 365      =1  SFR16 (CAN0IF2M1, 0xEA);               // IF2 Mask 1
 366      =1  SFR16 (CAN0IF2M2, 0xEC);               // IF2 Mask 2
 367      =1  SFR16 (CAN0IF2A1, 0xEE);               // IF2 Arbitration 1
 368      =1  SFR16 (CAN0IF2A2, 0xF2);               // IF2 Arbitration 2
 369      =1  SFR16 (CAN0IF2MC, 0xCE);               // IF2 Message Control
 370      =1  SFR16 (CAN0IF2DA1, 0xF6);              // IF2 Data A 1
 371      =1  SFR16 (CAN0IF2DA2, 0xFA);              // IF2 Data A 2
 372      =1  SFR16 (CAN0IF2DB1, 0xFC);              // IF2 Data B 1
 373      =1  SFR16 (CAN0IF2DB2, 0xFE);              // IF2 Data B 2
 374      =1  
 375      =1  //-----------------------------------------------------------------------------
 376      =1  // LIN0 Indirect Registers
 377      =1  //-----------------------------------------------------------------------------
 378      =1  
 379      =1  #define  LIN0DT1   0x00                // LIN0 Data Byte 1
 380      =1  #define  LIN0DT2   0x01                // LIN0 Data Byte 2
 381      =1  #define  LIN0DT3   0x02                // LIN0 Data Byte 3
 382      =1  #define  LIN0DT4   0x03                // LIN0 Data Byte 4
 383      =1  #define  LIN0DT5   0x04                // LIN0 Data Byte 5
 384      =1  #define  LIN0DT6   0x05                // LIN0 Data Byte 6
 385      =1  #define  LIN0DT7   0x06                // LIN0 Data Byte 7
 386      =1  #define  LIN0DT8   0x07                // LIN0 Data Byte 8
 387      =1  #define  LIN0CTRL  0x08                // LIN0 Control
 388      =1  #define  LIN0ST    0x09                // LIN0 Status
 389      =1  #define  LIN0ERR   0x0A                // LIN0 Error
 390      =1  #define  LIN0SIZE  0x0B                // LIN0 Message Size
 391      =1  #define  LIN0DIV   0x0C                // LIN0 Divider
 392      =1  #define  LIN0MUL   0x0D                // LIN0 Multiplier
 393      =1  #define  LIN0ID    0x0E                // LIN0 Identifier
 394      =1  
 395      =1  //-----------------------------------------------------------------------------
 396      =1  // Address Definitions for Bit-addressable Registers
 397      =1  //-----------------------------------------------------------------------------
 398      =1  
 399      =1  #define SFR_P0       0x80
 400      =1  #define SFR_TCON     0x88
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 19  

 401      =1  #define SFR_P1       0x90
 402      =1  #define SFR_SCON0    0x98
 403      =1  #define SFR_SCON1    0x98
 404      =1  #define SFR_P2       0xA0
 405      =1  #define SFR_IE       0xA8
 406      =1  #define SFR_P3       0xB0
 407      =1  #define SFR_IP       0xB8
 408      =1  #define SFR_SMB0CN   0xC0
 409      =1  #define SFR_TMR2CN   0xC8
 410      =1  #define SFR_TMR4CN   0xC8
 411      =1  #define SFR_PSW      0xD0
 412      =1  #define SFR_PCA0CN   0xD8
 413      =1  #define SFR_PCA1CN   0xD8
 414      =1  #define SFR_ACC      0xE0
 415      =1  #define SFR_ADC0CN   0xE8
 416      =1  #define SFR_B        0xF0
 417      =1  #define SFR_SPI0CN   0xF8
 418      =1  
 419      =1  //-----------------------------------------------------------------------------
 420      =1  // Bit Definitions
 421      =1  //-----------------------------------------------------------------------------
 422      =1  
 423      =1  // TCON 0x88
 424      =1  SBIT (TF1, SFR_TCON, 7);               // Timer 1 Overflow Flag
 425      =1  SBIT (TR1, SFR_TCON, 6);               // Timer 1 On/Off Control
 426      =1  SBIT (TF0, SFR_TCON, 5);               // Timer 0 Overflow Flag
 427      =1  SBIT (TR0, SFR_TCON, 4);               // Timer 0 On/Off Control
 428      =1  SBIT (IE1, SFR_TCON, 3);               // Ext. Interrupt 1 Edge Flag
 429      =1  SBIT (IT1, SFR_TCON, 2);               // Ext. Interrupt 1 Type
 430      =1  SBIT (IE0, SFR_TCON, 1);               // Ext. Interrupt 0 Edge Flag
 431      =1  SBIT (IT0, SFR_TCON, 0);               // Ext. Interrupt 0 Type
 432      =1  
 433      =1  // SCON0 0x98
 434      =1  SBIT (OVR0, SFR_SCON0, 7);             // UART0 Receive FIFO Overrun Flag
 435      =1  SBIT (PERR0, SFR_SCON0, 6);            // UART0 Parity Error Flag
 436      =1  SBIT (THRE0, SFR_SCON0, 5);            // UART0 Transmit Register Empty Flag
 437      =1  SBIT (REN0, SFR_SCON0, 4);             // UART0 RX Enable
 438      =1  SBIT (TBX0, SFR_SCON0, 3);             // UART0 Extra Transmission Bit
 439      =1  SBIT (RBX0, SFR_SCON0, 2);             // UART0 Extra Receive Bit
 440      =1  SBIT (TI0, SFR_SCON0, 1);              // UART0 TX Interrupt Flag
 441      =1  SBIT (RI0, SFR_SCON0, 0);              // UART0 RX Interrupt Flag
 442      =1  
 443      =1  // SCON1 0x98
 444      =1  SBIT (S1MODE, SFR_SCON1, 7);           // UART1 Mode 0
 445      =1                                         // Bit 6 UNUSED
 446      =1  SBIT (MCE1, SFR_SCON1, 5);             // UART1 Multiprocessor enable
 447      =1  SBIT (REN1, SFR_SCON1, 4);             // UART1 RX Enable
 448      =1  SBIT (TB81, SFR_SCON1, 3);             // UART1 TX Bit 8
 449      =1  SBIT (RB81, SFR_SCON1, 2);             // UART1 RX Bit 8
 450      =1  SBIT (TI1, SFR_SCON1, 1);              // UART1 TX Interrupt Flag
 451      =1  SBIT (RI1, SFR_SCON1, 0);              // UART1 RX Interrupt Flag
 452      =1  
 453      =1  // IE 0xA8
 454      =1  SBIT (EA, SFR_IE, 7);                  // Global Interrupt Enable
 455      =1  SBIT (ESPI0, SFR_IE, 6);               // SPI0 Interrupt Enable
 456      =1  SBIT (ET2, SFR_IE, 5);                 // Timer 2 Interrupt Enable
 457      =1  SBIT (ES0, SFR_IE, 4);                 // UART0 Interrupt Enable
 458      =1  SBIT (ET1, SFR_IE, 3);                 // Timer 1 Interrupt Enable
 459      =1  SBIT (EX1, SFR_IE, 2);                 // External Interrupt 1 Enable
 460      =1  SBIT (ET0, SFR_IE, 1);                 // Timer 0 Interrupt Enable
 461      =1  SBIT (EX0, SFR_IE, 0);                 // External Interrupt 0 Enable
 462      =1  
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 20  

 463      =1  // IP 0xB8
 464      =1                                         // Bit 7 unused
 465      =1  SBIT (PSPI0, SFR_IP, 6);               // SPI0 Interrupt Priority
 466      =1  SBIT (PT2, SFR_IP, 5);                 // Timer 2 Priority
 467      =1  SBIT (PS0, SFR_IP, 4);                 // UART0 Priority
 468      =1  SBIT (PS, SFR_IP, 4);                  // UART0 Priority
 469      =1  SBIT (PT1, SFR_IP, 3);                 // Timer 1 Priority
 470      =1  SBIT (PX1, SFR_IP, 2);                 // External Interrupt 1 Priority
 471      =1  SBIT (PT0, SFR_IP, 1);                 // Timer 0 Priority
 472      =1  SBIT (PX0, SFR_IP, 0);                 // External Interrupt 0 Priority
 473      =1  
 474      =1  // SMB0CN 0xC0
 475      =1  SBIT (MASTER, SFR_SMB0CN, 7);          // SMBus0 Master/Slave Indicator
 476      =1  SBIT (TXMODE, SFR_SMB0CN, 6);          // SMBus0 Transmit Mode Indicator
 477      =1  SBIT (STA, SFR_SMB0CN, 5);             // SMBus0 Start Flag
 478      =1  SBIT (STO, SFR_SMB0CN, 4);             // SMBus0 Stop Flag
 479      =1  SBIT (ACKRQ, SFR_SMB0CN, 3);           // SMBus0 Acknowledge Request
 480      =1  SBIT (ARBLOST, SFR_SMB0CN, 2);         // SMBus0 Arbitration Lost Indicator
 481      =1  SBIT (ACK, SFR_SMB0CN, 1);             // SMBus0 Acknowledge
 482      =1  SBIT (SI, SFR_SMB0CN, 0);              // SMBus0 Interrupt Flag
 483      =1  
 484      =1  // TMR2CN 0xC8
 485      =1  SBIT (TF2H, SFR_TMR2CN, 7);            // Timer 2 High-Byte Overflow Flag
 486      =1  SBIT (TF2L, SFR_TMR2CN, 6);            // Timer 2 Low-Byte  Overflow Flag
 487      =1  SBIT (TF2LEN, SFR_TMR2CN, 5);          // Timer 2 Low-Byte Flag Enable
 488      =1  SBIT (TF2CEN, SFR_TMR2CN, 4);          // Timer 2 Capture Enable
 489      =1  SBIT (T2SPLIT, SFR_TMR2CN, 3);         // Timer 2 Split-Mode Enable
 490      =1  SBIT (TR2, SFR_TMR2CN, 2);             // Timer 2 Run Enable
 491      =1  SBIT (T2RCLK, SFR_TMR2CN, 1);          // Timer 2 Xclk/Rclk Select
 492      =1  SBIT (T2XCLK, SFR_TMR2CN, 0);          // Timer 2 Clk/8 Clock Source
 493      =1  
 494      =1  // TMR4CN 0xC8
 495      =1  SBIT (TF4, SFR_TMR4CN, 7);             // Timer 4 Overflow/Underflow Flag
 496      =1  SBIT (EXF4, SFR_TMR4CN, 6);            // Timer 4 External Flag
 497      =1                                         // Bit 5 unused
 498      =1                                         // Bit 4 unused
 499      =1  SBIT (EXE4, SFR_TMR4CN, 3);            // Timer 4 External Enable
 500      =1  SBIT (TR4, SFR_TMR4CN, 2);             // Timer 4 Run Enable
 501      =1  SBIT (CT4, SFR_TMR4CN, 1);             // Timer 4 Counter/Timer Select
 502      =1  SBIT (CPRL4, SFR_TMR4CN, 0);           // Timer 4 Capture/Reload Select
 503      =1  
 504      =1  // PSW 0xD0
 505      =1  SBIT (CY, SFR_PSW, 7);                 // Carry Flag
 506      =1  SBIT (AC, SFR_PSW, 6);                 // Auxiliary Carry Flag
 507      =1  SBIT (F0, SFR_PSW, 5);                 // User Flag 0
 508      =1  SBIT (RS1, SFR_PSW, 4);                // Register Bank Select 1
 509      =1  SBIT (RS0, SFR_PSW, 3);                // Register Bank Select 0
 510      =1  SBIT (OV, SFR_PSW, 2);                 // Overflow Flag
 511      =1  SBIT (F1, SFR_PSW, 1);                 // User Flag 1
 512      =1  SBIT (P, SFR_PSW, 0);                  // Accumulator Parity Flag
 513      =1  
 514      =1  // PCA0CN 0xD8
 515      =1  SBIT (CF, SFR_PCA0CN, 7);              // PCA0 Counter Overflow Flag
 516      =1  SBIT (CR, SFR_PCA0CN, 6);              // PCA0 Counter Run Control Bit
 517      =1  SBIT (CCF5, SFR_PCA0CN, 5);            // PCA0 Module 5 Interrupt Flag
 518      =1  SBIT (CCF4, SFR_PCA0CN, 4);            // PCA0 Module 4 Interrupt Flag
 519      =1  SBIT (CCF3, SFR_PCA0CN, 3);            // PCA0 Module 3 Interrupt Flag
 520      =1  SBIT (CCF2, SFR_PCA0CN, 2);            // PCA0 Module 2 Interrupt Flag
 521      =1  SBIT (CCF1, SFR_PCA0CN, 1);            // PCA0 Module 1 Interrupt Flag
 522      =1  SBIT (CCF0, SFR_PCA0CN, 0);            // PCA0 Module 0 Interrupt Flag
 523      =1  
 524      =1  // PCA1CN 0xD8
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 21  

 525      =1  SBIT (CF1, SFR_PCA1CN, 7);             // PCA1 Counter Overflow Flag
 526      =1  SBIT (CR1, SFR_PCA1CN, 6);             // PCA1 Counter Run Control Bit
 527      =1  SBIT (CCF11, SFR_PCA1CN, 5);           // PCA1 Module 11 Interrupt Flag
 528      =1  SBIT (CCF10, SFR_PCA1CN, 4);           // PCA1 Module 10 Interrupt Flag
 529      =1  SBIT (CCF9, SFR_PCA1CN, 3);            // PCA1 Module 9 Interrupt Flag
 530      =1  SBIT (CCF8, SFR_PCA1CN, 2);            // PCA1 Module 8 Interrupt Flag
 531      =1  SBIT (CCF7, SFR_PCA1CN, 1);            // PCA1 Module 7 Interrupt Flag
 532      =1  SBIT (CCF6, SFR_PCA1CN, 0);            // PCA1 Module 6 Interrupt Flag
 533      =1  
 534      =1  // ADC0CN 0xE8
 535      =1  SBIT (AD0EN, SFR_ADC0CN, 7);           // ADC0 Enable
 536      =1  SBIT (BURSTEN, SFR_ADC0CN, 6);         // ADC0 Burst Enable
 537      =1  SBIT (AD0INT, SFR_ADC0CN, 5);          // ADC0 EOC Interrupt Flag
 538      =1  SBIT (AD0BUSY, SFR_ADC0CN, 4);         // ADC0 Busy Flag
 539      =1  SBIT (AD0WINT, SFR_ADC0CN, 3);         // ADC0 Window Compare Interrupt Flag
 540      =1  SBIT (AD0LJST, SFR_ADC0CN, 2);         // ADC0 Left Justified
 541      =1  SBIT (AD0CM1, SFR_ADC0CN, 1);          // ADC0 Start Of Conversion Mode Bit 1
 542      =1  SBIT (AD0CM0, SFR_ADC0CN, 0);          // ADC0 Start Of Conversion Mode Bit 0
 543      =1  
 544      =1  // SPI0CN 0xF8
 545      =1  SBIT (SPIF, SFR_SPI0CN, 7);            // SPI0 Interrupt Flag
 546      =1  SBIT (WCOL, SFR_SPI0CN, 6);            // SPI0 Write Collision Flag
 547      =1  SBIT (MODF, SFR_SPI0CN, 5);            // SPI0 Mode Fault Flag
 548      =1  SBIT (RXOVRN, SFR_SPI0CN, 4);          // SPI0 RX Overrun Flag
 549      =1  SBIT (NSSMD1, SFR_SPI0CN, 3);          // SPI0 Slave Select Mode 1
 550      =1  SBIT (NSSMD0, SFR_SPI0CN, 2);          // SPI0 Slave Select Mode 0
 551      =1  SBIT (TXBMT, SFR_SPI0CN, 1);           // SPI0 TX Buffer Empty Flag
 552      =1  SBIT (SPIEN, SFR_SPI0CN, 0);           // SPI0 Enable
 553      =1  
 554      =1  //-----------------------------------------------------------------------------
 555      =1  // Interrupt Priorities
 556      =1  //-----------------------------------------------------------------------------
 557      =1  
 558      =1  #define INTERRUPT_INT0             0   // External Interrupt 0
 559      =1  #define INTERRUPT_TIMER0           1   // Timer 0 Overflow
 560      =1  #define INTERRUPT_INT1             2   // External Interrupt 1
 561      =1  #define INTERRUPT_TIMER1           3   // Timer 1 Overflow
 562      =1  #define INTERRUPT_UART0            4   // UART0
 563      =1  #define INTERRUPT_TIMER2           5   // Timer 2 Overflow
 564      =1  #define INTERRUPT_SPI0             6   // SPI0
 565      =1  #define INTERRUPT_SMBUS0           7   // SMBus0 Interface
 566      =1  #define INTERRUPT_ADC0_WINDOW      8   // ADC0 Window Comparison
 567      =1  #define INTERRUPT_ADC0_EOC         9   // ADC0 End Of Conversion
 568      =1  #define INTERRUPT_PCA0            10   // PCA0 Peripheral
 569      =1  #define INTERRUPT_COMPARATOR0     11   // Comparator 0 Comparison
 570      =1  #define INTERRUPT_COMPARATOR1     12   // Comparator 1 Comparison
 571      =1  #define INTERRUPT_TIMER3          13   // Timer 3 Overflow
 572      =1  #define INTERRUPT_LIN0            14   // LIN Bus Interrupt
 573      =1  #define INTERRUPT_VREG            15   // Voltage Regulator
 574      =1  #define INTERRUPT_CAN0            16   // CAN Bus Interrupt
 575      =1  #define INTERRUPT_PORT_MATCH      17   // Port Match
 576      =1  #define INTERRUPT_UART1           18   // UART1
 577      =1  #define INTERRUPT_PCA1            19   // PCA1 Peripheral
 578      =1  #define INTERRUPT_COMPARATOR2     20   // Comparator 2 Comparison
 579      =1  #define INTERRUPT_TIMER4          21   // Timer 4 Overflow
 580      =1  #define INTERRUPT_TIMER5          22   // Timer 5 Overflow
 581      =1  
 582      =1  
 583      =1  //-----------------------------------------------------------------------------
 584      =1  // SFR Page Definitions
 585      =1  //-----------------------------------------------------------------------------
 586      =1  
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 22  

 587      =1  #define  CONFIG_PAGE       0x0F        // System and Port Configuration Page
 588      =1  #define  ACTIVE_PAGE       0x00        // Active Use Page
 589      =1  #define  ACTIVE2_PAGE      0x10        // Active Use Page 2
 590      =1  #define  CAN0_PAGE         0x0C        // CAN0 Registers
 591      =1  
 592      =1  //-----------------------------------------------------------------------------
 593      =1  // SDCC PDATA External Memory Paging Support
 594      =1  //-----------------------------------------------------------------------------
 595      =1  
 596      =1  #if defined SDCC
           =1 
           =1 SFR(_XPAGE, 0xAA); // Point to the EMI0CN register
           =1 
           =1 #endif
 601      =1  
 602      =1  //-----------------------------------------------------------------------------
 603      =1  // Header File PreProcessor Directive
 604      =1  //-----------------------------------------------------------------------------
 605      =1  
 606      =1  #endif                                 // #define C8051F580_DEFS_H
 607      =1  
 608      =1  //-----------------------------------------------------------------------------
 609      =1  // End Of File
 610      =1  //-----------------------------------------------------------------------------
   4          #include "global_define.h"
   1      =1  /*----------TYPE-------------------*/
   2      =1  
   3      =1  #define CAMERA
   4      =1  #define SYSCLK 24000000
   5      =1  /*----------SENSOR-----------------*/
   6      =1  
   7      =1  //      #define APTINA_126
   8      =1  //      #define APTINA_128
   9      =1          #define APTINA_AP0100                   0x03U
  10      =1          #define APTINA_ASX344                   0x04U
  11      =1  //      #define APTINA_ASX350AT
  12      =1  
  13      =1  
  14      =1  /*----------EEPROM-----------------*/
  15      =1  #define MXIC
  16      =1  //#define WINBOND
  17      =1  
  18      =1  /*----------DEVICE-----------------*/
  19      =1  //#define UART
  20      =1  #define SPI
  21      =1  #define I2C                                                     
  22      =1  #define ADC
  23      =1  #define WATCHDOG
  24      =1  #define PCA
  25      =1  #define CAN
  26      =1  
  27      =1  #define EXINTERRUPT
  28      =1  
  29      =1  /*----------I2C---------------*/        // Use Timer1
  30      =1  //#define I2C_SPEED_100KHZ                      
  31      =1  #define I2C_SPEED_400KHZ                
  32      =1  
  33      =1  /*----------WATCHDOG---------------*/
  34      =1  #define WATCHDOG_ENABLE
  35      =1  //#define WATCHDOG_32MS
  36      =1  #define WATCHDOG_400MS
  37      =1  
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 23  

  38      =1  /*----------VDDMONITOR-------------*/
  39      =1  #define VDDMONITOR_ENABLE
  40      =1  //#define VDDMONITOR_HIGH
  41      =1  #define VDDMONITOR_LOW
  42      =1  
  43      =1  /*----------TIMER-------------*/
  44      =1  //#define TIMER0                                        //Use Wait_ms()
  45      =1  #define TIMER1                                          //Use SMBUS0
  46      =1  #define TIMER2                                          //1ms interrupt1
  47      =1  #define TIMER3                                          //Use SMBUS0 low time out
  48      =1  //#define TIMER4                                        //1ms interrupt2
  49      =1  #define TIMER5                                          //Use PCA0 (Watchdog)
  50      =1  
  51      =1  /*----------ETC..-----------------*/
  52      =1  #define TRUE    (U8)1
  53      =1  #define FALSE   (U8)0
  54      =1  
  55      =1  #define HIGH    (U8)1
  56      =1  #define LOW     (U8)0
  57      =1  
  58      =1  //CAN DATA
  59      =1  //#define MDPS11                                
  60      =1  //#define LANGUAGEINFO          
  61      =1  //#define HUTYPE                                
  62      =1  //#define GATEWAY                               
  63      =1  //#define NAVIONOFF                     
  64      =1  //#define G_SEL_DISP                
  65      =1  //#define CAM_REARCAMERA_REQ    
  66      =1  
  67      =1  //Operate Mode---------------------
  68      =1  #define OPERATE_STANDBY         (U8)1
  69      =1  #define OPERATE_INTERINIT       (U8)2
  70      =1  #define OPERATE_IDLE            (U8)3
  71      =1  #define OPERATE_RUNNING         (U8)4
  72      =1  
  73      =1  #define DTC_RECORD_WRITE
  74      =1  #define DTC_RECORD_CLEAR
  75      =1  
  76      =1  //Define Error
  77      =1  #define NO_ERROR                        (U8)0x00
  78      =1  #define ERROR_RX_COMM           (U8)0x01        //RX Error
  79      =1  #define ERROR_TX_COMM           (U8)0x02        //TX Error
  80      =1  
  81      =1  //#define ERROR_TX_COMM         (U8)0x02        //RX Error
  82      =1  
  83      =1  //BANK SET
  84      =1  #define BANK0                           (U8)0x00
  85      =1  #define BANK1                           (U8)0x10
  86      =1  #define BANK2                           (U8)0x20
  87      =1  #define BANK3                           (U8)0x30
  88      =1  
  89      =1  //DIAGNOSTIC TEST
  90      =1  //#define DIAG_TEST_MCU_WD_ERR
  91      =1  //#define DIAG_TEST_MCU_MC_ERR
  92      =1  //#define DIAG_TEST_ISP_FV_ERR
  93      =1  //#define DIAG_TEST_ISP_FC_ERR
  94      =1  //#define DIAG_TEST_ISP_IS_ERR
  95      =1  //#define DIAG_TEST_ISP_CM_ERR
  96      =1  //#define DIAG_TEST_ISP_IT_ERR
  97      =1  //#define DIAG_TEST_VID_OC_ERR
  98      =1  //#define DIAG_TEST_VID_VO_ERR
  99      =1  
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 24  

   5          #include "drv_mcu.h"
   1      =1  #ifndef DRV_MCU_H
   2      =1  #define DRV_MCU_H
   3      =1  /* ----- Global Define -------------------------------*/
   4      =1  //#define  SYSCLK                                               (24000000)      // System clock frequency in Hz
   5      =1  
   6      =1  #define FRAME_SYNC_COUNT        ((g_FrameSync)++)
   7      =1  #define FRAME_SYNC_GET          (g_FrameSync)
   8      =1  #define FRAME_SYNC_CLEAR        ((g_FrameSync) = (0))
   9      =1  /*----------------------------------------------------*/
  10      =1  
  11      =1  /* ----- Global Value --------------------------------*/
  12      =1  /* Pin Name Set */
  13      =1  //-----------------------------------------------------------------------------
  14      =1  // Macros and Macrodefinitions
  15      =1  //-----------------------------------------------------------------------------
  16      =1  SBIT (MCU_F_ENABLE,                     SFR_P1, 4);
  17      =1  SBIT (MCU_FRAME_SYNC,           SFR_P1, 6);
  18      =1  SBIT (AMP_V_STB,                        SFR_P2, 2);
  19      =1  SBIT (AMP_VIDEO_SIG,            SFR_P2, 3);
  20      =1  SBIT (MCU_SENSOR_RESET,         SFR_P2, 4);
  21      =1  SBIT (MCU_MCLK_ENABLE,          SFR_P2, 5);
  22      =1  SBIT (MCU_18V_ENABLE,           SFR_P2, 7);
  23      =1  
  24      =1  SBIT (SDA, SFR_P2, 0);
  25      =1  SBIT (SCL, SFR_P2, 1);
  26      =1  /*----------------------------------------------------*/
  27      =1  
  28      =1  /* ----- Function ------------------------------------*/
  29      =1  void Vdd_Monitor_Init(void);
  30      =1  void Osc_Init(void);
  31      =1  void Port_Init(void);
  32      =1  void Rstsrc_Init(void);
  33      =1  void Exinterrupt_Init(void);
  34      =1  void MCU_Reset(void);
  35      =1  void Device_Init(U8 Device);
  36      =1  U8 Frame_Sync_Status(void);
  37      =1  
  38      =1  #ifndef __PST_PolySpace__
  39      =1  #else
           =1 void INT1_ISR(void);
           =1 #endif
  42      =1  /*----------------------------------------------------*/
  43      =1  
  44      =1  /* ----- Extern Function -----------------------------*/
  45      =1  
  46      =1  /*----------------------------------------------------*/
  47      =1  #endif
  48      =1  
  49      =1  
  50      =1  
  51      =1  
  52      =1  
  53      =1  
  54      =1  
  55      =1  
  56      =1  
  57      =1  
   6          #include "drv_timer.h"
   1      =1  #ifndef DRV_TIMER_H
   2      =1  #define DRV_TIMER_H
   3      =1  
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 25  

   4      =1  /* ----- Global Define -------------------------------*/
   5      =1  
   6      =1  #define TID_FRAME_VALIDE                        0x01U
   7      =1  #define TID_FRAME_COUNT                         0x02U
   8      =1  #define TID_OVERLAY_GUIDELINE           0x03U
   9      =1  #define TID_SENSOR_IDLE_PERIOD          0x04U
  10      =1  #define TID_I2C_COMM_CHECK                      0x05U
  11      =1  #define TID_VCAN                                        0x06U
  12      =1  #define TID_DTC_WRITE                   0x07U
  13      =1  #define TID_DIAG_ECU_RESET                      0x08U
  14      =1  #define TID_FIRME_UPDATE                        0x09U
  15      =1  #define TID_SENSOR_RESET                        0x0AU
  16      =1  #define TID_CHECKSTATUS_LOOP            0x0BU
  17      =1  #define TID_ADC_CHANGE_TIMER            0x0CU
  18      =1  #define TID_I2C_BUSY_CHECK                      0x0DU
  19      =1  #define TID_DOORBELL_CHECK                      0x0EU
  20      =1  #define TID_GEAR_CHATTERING                     0x0FU
  21      =1  #define TID_TEMP_TIMEOUT                        0x10U
  22      =1  #define TID_COUNT                                       0x11U
  23      =1  
  24      =1  /*----------TIMER DELAY-------------*/
  25      =1  #define DT_FRAME_VALIDE                         100U
  26      =1  #define DT_FRAME_COUNT                          100U
  27      =1  #define DT_VCAN                                          10U
  28      =1  #define DT_OVERLAY_GUIDELINE         50U
  29      =1  #define DT_DTC_WRITE                    100U
  30      =1  #define DT_DIAG_ECU_RESET                   100U
  31      =1  #define DT_FIRME_UPDATE                          30U
  32      =1  #define DT_SENSOR_RESET                         500U
  33      =1  #define DT_SENSOR_IDLE_PERIOD           300U
  34      =1  #define DT_CHECKSTATUS_LOOP                      30U
  35      =1  #define DT_ADC_CHANGE_TIMER                  10U
  36      =1  #define DT_I2C_COMM_CHECK                   100U
  37      =1  #define DT_I2C_BUSY_CHECK                        10U
  38      =1  #define DT_DOORBELL_CHECK                        10U
  39      =1  #define DT_GEAR_CHATTERING                       50U
  40      =1  #define DT_TEMP_TIMEOUT                         100U
  41      =1  /*----------------------------------------------------*/
  42      =1  typedef struct {
  43      =1          U8      Set;
  44      =1          U32 Delay_Time;
  45      =1          U32 Cur_Time;
  46      =1          U32 End_Time;
  47      =1  }tMsg_Time_s;
  48      =1  
  49      =1  typedef struct {
  50      =1          U32 Tick_1ms;
  51      =1          U32     Limit;
  52      =1          U8      Over_Set;
  53      =1  }tMsg_Global_Tick;
  54      =1  
  55      =1  /* ----- Function ------------------------------------*/
  56      =1  void Timer0_Init(void);
  57      =1  void Timer1_Init(void);
  58      =1  #if defined(TIMER2)
  59      =1  void Timer2_Init(void);
  60      =1  #endif
  61      =1  void Timer3_Init(void);
  62      =1  void Timer4_Init(void);
  63      =1  void Timer5_Init(void);
  64      =1  void TIMER1__Init (void);
  65      =1  void Wait_ms (U16 ms);
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 26  

  66      =1  void Global_Timer_Init(void);
  67      =1  void Delay_Time_Set(U8 ID, U16 Delay_Time);
  68      =1  U8   Delay_Time_Get(U8 ID);
  69      =1  void Delay_Time_Expire(U8 ID);
  70      =1  U16 Get_Time(void);
  71      =1  /*----------------------------------------------------*/
  72      =1  
  73      =1  /* ----- Extern Function -----------------------------*/
  74      =1  extern SEG_XDATA tMsg_Global_Tick g_Global_Tick_Msg;
  75      =1  extern SEG_XDATA tMsg_Time_s    ga_tCAN_Time_Msg[TID_COUNT];
  76      =1  /*----------------------------------------------------*/
  77      =1  
  78      =1  /* ----- Global Value --------------------------------*/
  79      =1  /*----------------------------------------------------*/
  80      =1  
  81      =1  #endif
   7          #include "drv_pca.h"
   1      =1  #ifndef DRV_PCA_H
   2      =1  #define DRV_PCA_H
   3      =1  #include "compiler_defs.h"
   1      =2  //-----------------------------------------------------------------------------
   2      =2  // compiler_defs.h
   3      =2  //-----------------------------------------------------------------------------
   4      =2  // Portions of this file are copyright Maarten Brock
   5      =2  // http://sdcc.sourceforge.net
   6      =2  // Portions of this file are copyright 2010, Silicon Laboratories, Inc.
   7      =2  // http://www.silabs.com
   8      =2  //
   9      =2  // GNU LGPL boilerplate:
  10      =2  /** This library is free software; you can redistribute it and/or
  11      =2    * modify it under the terms of the GNU Lesser General Public
  12      =2    * License as published by the Free Software Foundation; either
  13      =2    * version 2.1 of the License, or (at your option) any later version.
  14      =2    *
  15      =2    * This library is distributed in the hope that it will be useful,
  16      =2    * but WITHOUT ANY WARRANTY; without even the implied warranty of
  17      =2    * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
  18      =2    * Lesser General Public License for more details.
  19      =2    *
  20      =2    * You should have received a copy of the GNU Lesser General Public
  21      =2    * License along with this library; if not, write to the Free Software
  22      =2    * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
  23      =2    *
  24      =2    * In other words, you are welcome to use, share and improve this program.
  25      =2    * You are forbidden to forbid anyone else to use, share and improve
  26      =2    * what you give them. Help stamp out software-hoarding!
  27      =2  **/
  28      =2  // Program Description:
  29      =2  //
  30      =2  // **Important Note**: This header file should be included before including
  31      =2  // a device-specific header file such as C8051F300_defs.h.
  32      =2  //
  33      =2  // Macro definitions to accomodate 8051 compiler differences in specifying
  34      =2  // special function registers and other 8051-specific features such as NOP
  35      =2  // generation, and locating variables in memory-specific segments.  The
  36      =2  // compilers are identified by their unique predefined macros. See also:
  37      =2  // http://predef.sourceforge.net/precomp.html
  38      =2  //
  39      =2  // SBIT and SFR define special bit and special function registers at the given
  40      =2  // address. SFR16 and SFR32 define sfr combinations at adjacent addresses in
  41      =2  // little-endian format. SFR16E and SFR32E define sfr combinations without
  42      =2  // prerequisite byte order or adjacency. None of these multi-byte sfr
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 27  

  43      =2  // combinations will guarantee the order in which they are accessed when read
  44      =2  // or written.
  45      =2  //
  46      =2  // SFR16X and SFR32X for 16 bit and 32 bit xdata registers are not defined
  47      =2  // to avoid portability issues because of compiler endianness.
  48      =2  //
  49      =2  // Example:
  50      =2  // // my_mcu.c: main 'c' file for my mcu
  51      =2  // #include <compiler_defs.h>  // this file
  52      =2  // #include <C8051xxxx_defs.h> // SFR definitions for specific MCU target
  53      =2  //
  54      =2  // SBIT  (P0_1, 0x80, 1);      // Port 0 pin 1
  55      =2  // SFR   (P0, 0x80);           // Port 0
  56      =2  // SFRX  (CPUCS, 0xE600);      // Cypress FX2 Control and Status register in
  57      =2  //                             // xdata memory at 0xE600
  58      =2  // SFR16 (TMR2, 0xCC);         // Timer 2, lsb at 0xCC, msb at 0xCD
  59      =2  // SFR16E(TMR0, 0x8C8A);       // Timer 0, lsb at 0x8A, msb at 0x8C
  60      =2  // SFR32 (MAC0ACC, 0x93);      // SiLabs C8051F120 32 bits MAC0 Accumulator,
  61      =2  //                             // lsb at 0x93, msb at 0x96
  62      =2  // SFR32E(SUMR, 0xE5E4E3E2);   // TI MSC1210 SUMR 32 bits Summation register,
  63      =2  //                             // lsb at 0xE2, msb at 0xE5
  64      =2  //
  65      =2  // Target:         C8051xxxx
  66      =2  // Tool chain:     Generic
  67      =2  // Command Line:   None
  68      =2  // 
  69      =2  // Release 2.6 - 14 DEC 2012 (GO)
  70      =2  //        -Added define for deprecated SDCC keyword 'at'
  71      =2  // Release 2.5 - 12 SEP 2012 (TP)
  72      =2  //    -Added defines for deprecated SDCC keywords bit and code
  73      =2  // Release 2.4 - 27 AUG 2012 (TP)
  74      =2  //    -Added defines for deprecated SDCC keywords interrupt, _asm, and _endasm
  75      =2  // Release 2.3 - 27 MAY 2010 (DM)
  76      =2  //    -Removed 'LOCATED_VARIABLE' pragma from Keil because it is not supported
  77      =2  // Release 2.2 - 06 APR 2010 (ES)
  78      =2  //    -Removed 'PATHINCLUDE' pragma from Raisonance section
  79      =2  // Release 2.1 - 16 JUL 2009 (ES)
  80      =2  //    -Added SEGMENT_POINTER macro definitions for SDCC, Keil, and Raisonance
  81      =2  //    -Added LOCATED_VARIABLE_NO_INIT macro definitions for Raisonance
  82      =2  // Release 2.0 - 19 MAY 2009 (ES)
  83      =2  //    -Added LOCATED_VARIABLE_NO_INIT macro definitions for SDCC and Keil
  84      =2  // Release 1.9 - 23 OCT 2008 (ES)
  85      =2  //    -Updated Hi-Tech INTERRUPT and INTERRUPT_USING macro definitions
  86      =2  //    -Added SFR16 macro defintion for Hi-Tech
  87      =2  // Release 1.8 - 31 JUL 2008 (ES)
  88      =2  //    -Added INTERRUPT_USING and FUNCTION_USING macro's
  89      =2  //    -Added macro's for IAR
  90      =2  //    -Corrected Union definitions for Hi-Tech and added SFR16 macro defintion
  91      =2  // Release 1.7 - 11 SEP 2007 (BW)
  92      =2  //    -Added support for Raisonance EVAL 03.03.42 and Tasking Eval 7.2r1
  93      =2  // Release 1.6 - 27 AUG 2007 (BW)
  94      =2  //    -Updated copyright notice per agreement with Maartin Brock
  95      =2  //    -Added SDCC 2.7.0 "compiler.h" bug fixes
  96      =2  //    -Added memory segment defines (SEG_XDATA, for example)
  97      =2  // Release 1.5 - 24 AUG 2007 (BW)
  98      =2  //    -Added support for NOP () macro
  99      =2  //    -Added support for Hi-Tech ver 9.01
 100      =2  // Release 1.4 - 07 AUG 2007 (PKC)
 101      =2  //    -Removed FID and fixed formatting.
 102      =2  // Release 1.3 - 30 SEP 2007 (TP)
 103      =2  //    -Added INTERRUPT_PROTO_USING to properly support ISR context switching
 104      =2  //     under SDCC.
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 28  

 105      =2  // Release 1.2 - (BW)
 106      =2  //    -Added support for U8,U16,U32,S8,S16,S32,UU16,UU32 data types
 107      =2  // Release 1.1 - (BW)
 108      =2  //    -Added support for INTERRUPT, INTERRUPT_USING, INTERRUPT_PROTO,
 109      =2  //     SEGMENT_VARIABLE, VARIABLE_SEGMENT_POINTER,
 110      =2  //     SEGMENT_VARIABLE_SEGMENT_POINTER, and LOCATED_VARIABLE
 111      =2  // Release 1.0 - 29 SEP 2006 (PKC)
 112      =2  //    -Initial revision
 113      =2  
 114      =2  //-----------------------------------------------------------------------------
 115      =2  // Header File Preprocessor Directive
 116      =2  //-----------------------------------------------------------------------------
 117      =2  
 118      =2  #ifndef COMPILER_DEFS_H
           =2 #define COMPILER_DEFS_H
           =2 
           =2 //-----------------------------------------------------------------------------
           =2 // Macro definitions
           =2 //-----------------------------------------------------------------------------
           =2 
           =2 // SDCC - Small Device C Compiler
           =2 // http://sdcc.sourceforge.net
           =2 
           =2 #if defined SDCC
           =2 
           =2 #if (SDCC >= 300)
           =2 
           =2 #define interrupt __interrupt
           =2 #define _asm __asm
           =2 #define _endasm __endasm
           =2 #define bit __bit
           =2 #define code __code
           =2 #define at __at
           =2 
           =2 #endif
           =2 
           =2 # define SEG_GENERIC
           =2 # define SEG_FAR   __xdata
           =2 # define SEG_DATA  __data
           =2 # define SEG_NEAR  __data
           =2 # define SEG_IDATA __idata
           =2 # define SEG_XDATA __xdata
           =2 # define SEG_PDATA __pdata
           =2 # define SEG_CODE  __code
           =2 # define SEG_BDATA __bdata
           =2 
           =2 # define SBIT(name, addr, bit)  __sbit  __at(addr+bit)                  name
           =2 # define SFR(name, addr)        __sfr   __at(addr)                      name
           =2 # define SFRX(name, addr)       xdata volatile unsigned char __at(addr) name
           =2 # define SFR16(name, addr)      __sfr16 __at(((addr+1U)<<8) | addr)     name
           =2 # define SFR16E(name, fulladdr) __sfr16 __at(fulladdr)                  name
           =2 # define SFR32(name, addr)      __sfr32 __at(((addr+3UL)<<24) | ((addr+2UL)<<16) | ((addr+1UL)<<8) | addr)
             - name
           =2 # define SFR32E(name, fulladdr) __sfr32 __at(fulladdr)                  name
           =2 
           =2 # define INTERRUPT(name, vector) void name (void) interrupt (vector)
           =2 # define INTERRUPT_USING(name, vector, regnum) void name (void) interrupt (vector) using (regnum)
           =2 # define INTERRUPT_PROTO(name, vector) void name (void) interrupt (vector)
           =2 # define INTERRUPT_PROTO_USING(name, vector, regnum) void name (void) interrupt (vector) using (regnum)
           =2 
           =2 # define FUNCTION_USING(name, return_value, parameter, regnum) return_value name (parameter) using (regnum
             -)
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 29  

           =2 # define FUNCTION_PROTO_USING(name, return_value, parameter, regnum) return_value name (parameter) using (
             -regnum)
           =2 // Note: Parameter must be either 'void' or include a variable type and name. (Ex: char temp_variable)
           =2 
           =2 # define SEGMENT_VARIABLE(name, vartype, locsegment) locsegment vartype name
           =2 # define VARIABLE_SEGMENT_POINTER(name, vartype, targsegment) targsegment vartype * name
           =2 # define SEGMENT_VARIABLE_SEGMENT_POINTER(name, vartype, targsegment, locsegment) targsegment vartype * lo
             -csegment name
           =2 # define SEGMENT_POINTER(name, vartype, locsegment) vartype * locsegment name
           =2 # define LOCATED_VARIABLE(name, vartype, locsegment, addr, init) locsegment at (addr) vartype name = init
           =2 # define LOCATED_VARIABLE_NO_INIT(name, vartype, locsegment, addr) locsegment at (addr) vartype name
           =2 
           =2 // used with UU16
           =2 # define LSB 0
           =2 # define MSB 1
           =2 
           =2 // used with UU32 (b0 is least-significant byte)
           =2 //# define b0 0
           =2 //# define b1 1
           =2 //# define b2 2
           =2 //# define b3 3
           =2 
           =2 typedef unsigned char U8;
           =2 typedef unsigned int U16;
           =2 typedef unsigned long U32;
           =2 
           =2 typedef signed char S8;
           =2 typedef signed int S16;
           =2 typedef signed long S32;
           =2 
           =2 typedef union UU16
           =2 {
           =2    U16 U16;
           =2    S16 S16;
           =2    U8 U8[2];
           =2    S8 S8[2];
           =2 } UU16;
           =2 
           =2 typedef union UU32
           =2 {
           =2    U32 U32;
           =2    S32 S32;
           =2    UU16 UU16[2];
           =2    U16 U16[2];
           =2    S16 S16[2];
           =2    U8 U8[4];
           =2    S8 S8[4];
           =2 } UU32;
           =2 
           =2 // NOP () macro support
           =2 #define NOP() _asm NOP _endasm
           =2 
           =2 
           =2 //-----------------------------------------------------------------------------
           =2 
           =2 // Raisonance (must be placed before Keil C51)
           =2 // http://www.raisonance.com
           =2 
           =2 #elif defined __RC51__
           =2 
           =2 //#error Raisonance C51 detected.
           =2 
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 30  

           =2 # define SEG_GENERIC generic     //SEG_GENERIC only applies to pointers in Raisonance, not variables.
           =2 # define SEG_FAR   xdata
           =2 # define SEG_DATA  data
           =2 # define SEG_NEAR  data
           =2 # define SEG_IDATA idata
           =2 # define SEG_XDATA xdata
           =2 # define SEG_PDATA pdata
           =2 # define SEG_CODE  code
           =2 # define SEG_BDATA bdata
           =2 
           =2 # define SBIT(name, addr, bit)  at (addr+bit) sbit         name
           =2 # define SFR(name, addr)        sfr at addr                name
           =2 # define SFR16(name, addr)      sfr16 at addr              name
           =2 # define SFR16E(name, fulladdr) /* not supported */
           =2 # define SFR32(name, fulladdr)  /* not supported */
           =2 # define SFR32E(name, fulladdr) /* not supported */
           =2 
           =2 # define INTERRUPT(name, vector) void name (void) interrupt vector
           =2 # define INTERRUPT_USING(name, vector, regnum) void name (void) interrupt vector using regnum
           =2 # define INTERRUPT_PROTO(name, vector) void name (void)
           =2 # define INTERRUPT_PROTO_USING(name, vector, regnum) void name (void)
           =2 
           =2 # define FUNCTION_USING(name, return_value, parameter, regnum) return_value name (parameter) using regnum
           =2 # define FUNCTION_PROTO_USING(name, return_value, parameter, regnum) return_value name (parameter)
           =2 // Note: Parameter must be either 'void' or include a variable type and name. (Ex: char temp_variable)
           =2 
           =2 # define SEGMENT_VARIABLE(name, vartype, locsegment) vartype locsegment name
           =2 # define VARIABLE_SEGMENT_POINTER(name, vartype, targsegment) vartype targsegment * name
           =2 # define SEGMENT_VARIABLE_SEGMENT_POINTER(name, vartype, targsegment, locsegment) vartype targsegment * lo
             -csegment name
           =2 # define SEGMENT_POINTER(name, vartype, locsegment) vartype * locsegment name
           =2 # define LOCATED_VARIABLE(name, vartype, locsegment, addr, init) at addr locsegment vartype name
           =2 # define LOCATED_VARIABLE_NO_INIT(name, vartype, locsegment, addr) at addr locsegment vartype name
           =2 
           =2 
           =2 // used with UU16
           =2 # define LSB 1
           =2 # define MSB 0
           =2 
           =2 // used with UU32 (b0 is least-significant byte)
           =2 //# define b0 3
           =2 //# define b1 2
           =2 //# define b2 1
           =2 //# define b3 0
           =2 
           =2 typedef unsigned char U8;
           =2 typedef unsigned int U16;
           =2 typedef unsigned long U32;
           =2 
           =2 typedef signed char S8;
           =2 typedef signed int S16;
           =2 typedef signed long S32;
           =2 
           =2 typedef union UU16
           =2 {
           =2    U16 U16;
           =2    S16 S16;
           =2    U8 U8[2];
           =2    S8 S8[2];
           =2 } UU16;
           =2 
           =2 typedef union UU32
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 31  

           =2 {
           =2    U32 U32;
           =2    S32 S32;
           =2    UU16 UU16[2];
           =2    U16 U16[2];
           =2    S16 S16[2];
           =2    U8 U8[4];
           =2    S8 S8[4];
           =2 } UU32;
           =2 
           =2 // NOP () macro support -- NOP is opcode 0x00
           =2 #define NOP() asm { 0x00 }
           =2 
           =2 
           =2 //-----------------------------------------------------------------------------
           =2 
           =2 
           =2 // Keil C51
           =2 // http://www.keil.com
           =2 
           =2 #elif defined __C51__
           =2 
           =2 //#error Keil C51 detected.
           =2 
           =2 # define SEG_GENERIC
           =2 # define SEG_FAR   xdata
           =2 # define SEG_DATA  data
           =2 # define SEG_NEAR  data
           =2 # define SEG_IDATA idata
           =2 # define SEG_XDATA xdata
           =2 # define SEG_PDATA pdata
           =2 # define SEG_CODE  code
           =2 # define SEG_BDATA bdata
           =2 
           =2 # define SBIT(name, addr, bit)  sbit  name = addr^bit
           =2 # define SFR(name, addr)        sfr   name = addr
           =2 # define SFR16(name, addr)      sfr16 name = addr
           =2 # define SFR16E(name, fulladdr) /* not supported */
           =2 # define SFR32(name, fulladdr)  /* not supported */
           =2 # define SFR32E(name, fulladdr) /* not supported */
           =2 
           =2 # define INTERRUPT(name, vector) void name (void) interrupt vector
           =2 # define INTERRUPT_USING(name, vector, regnum) void name (void) interrupt vector using regnum
           =2 # define INTERRUPT_PROTO(name, vector) void name (void)
           =2 # define INTERRUPT_PROTO_USING(name, vector, regnum) void name (void)
           =2 
           =2 # define FUNCTION_USING(name, return_value, parameter, regnum) return_value name (parameter) using regnum
           =2 # define FUNCTION_PROTO_USING(name, return_value, parameter, regnum) return_value name (parameter)
           =2 // Note: Parameter must be either 'void' or include a variable type and name. (Ex: char temp_variable)
           =2 
           =2 # define SEGMENT_VARIABLE(name, vartype, locsegment) vartype locsegment name
           =2 # define VARIABLE_SEGMENT_POINTER(name, vartype, targsegment) vartype targsegment * name
           =2 # define SEGMENT_VARIABLE_SEGMENT_POINTER(name, vartype, targsegment, locsegment) vartype targsegment * lo
             -csegment name
           =2 # define SEGMENT_POINTER(name, vartype, locsegment) vartype * locsegment name
           =2 # define LOCATED_VARIABLE_NO_INIT(name, vartype, locsegment, addr) vartype locsegment name _at_ addr
           =2 
           =2 // used with UU16
           =2 # define LSB 1
           =2 # define MSB 0
           =2 
           =2 // used with UU32 (b0 is least-significant byte)
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 32  

           =2 //# define b0 3
           =2 // define b1 2
           =2 //# define b2 1
           =2 //# define b3 0
           =2 
           =2 typedef unsigned char U8;
           =2 typedef unsigned int U16;
           =2 typedef unsigned long U32;
           =2 
           =2 typedef signed char S8;
           =2 typedef signed int S16;
           =2 typedef signed long S32;
           =2 
           =2 typedef union UU16
           =2 {
           =2    U16 U16;
           =2    S16 S16;
           =2    U8 U8[2];
           =2    S8 S8[2];
           =2 } UU16;
           =2 
           =2 typedef union UU32
           =2 {
           =2    U32 U32;
           =2    S32 S32;
           =2    UU16 UU16[2];
           =2    U16 U16[2];
           =2    S16 S16[2];
           =2    U8 U8[4];
           =2    S8 S8[4];
           =2 } UU32;
           =2 
           =2 // NOP () macro support
           =2 extern void _nop_ (void);
           =2 #define NOP() _nop_()
           =2 
           =2 //-----------------------------------------------------------------------------
           =2 
           =2 // Hi-Tech 8051
           =2 // http://www.htsoft.com
           =2 
           =2 #elif defined HI_TECH_C
           =2 
           =2 # define SEG_GENERIC
           =2 # define SEG_FAR   far
           =2 # define SEG_DATA  data
           =2 # define SEG_NEAR  near
           =2 # define SEG_IDATA idata
           =2 # define SEG_XDATA xdata
           =2 # define SEG_PDATA pdata
           =2 # define SEG_CODE  code
           =2 # define SEG_BDATA bdata
           =2 
           =2 
           =2 # define SBIT(name, addr, thebit) static volatile bit name @ (addr + thebit)
           =2 # define SFR(name, addr)          static volatile unsigned char name @ addr
           =2 # define SFR16(name, addr)        static volatile unsigned int name @ addr
           =2 # define SFR16E(name, fulladdr) /* not supported */
           =2 # define SFR32(name, fulladdr)  /* not supported */
           =2 # define SFR32E(name, fulladdr) /* not supported */
           =2 
           =2 # define INTERRUPT(name, vector)       void name (void) interrupt vector
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 33  

           =2 # define INTERRUPT_PROTO(name, vector)
           =2 # define INTERRUPT_USING(name, vector, regnum) void name (void) interrupt vector using regnum
           =2 # define INTERRUPT_PROTO_USING(name, vector, regnum)
           =2 
           =2 # define FUNCTION_USING(name, return_value, parameter, regnum) /* not supported */
           =2 # define FUNCTION_PROTO_USING(name, return_value, parameter, regnum) /* not supported */
           =2 // Note: Hi-Tech does not support functions using different register banks. Register
           =2 //       banks can only be specified in interrupts. If a function is called from
           =2 //       inside an interrupt, it will use the same register bank as the interrupt.
           =2 
           =2 # define SEGMENT_VARIABLE(name, vartype, locsegment) locsegment vartype name
           =2 # define VARIABLE_SEGMENT_POINTER(name, vartype, targsegment) targsegment vartype * name
           =2 # define SEGMENT_VARIABLE_SEGMENT_POINTER(name, vartype, targsegment, locsegment) targsegment vartype * lo
             -csegment name
           =2 # define LOCATED_VARIABLE(name, vartype, locsegment, addr, init) locsegment vartype name @ addr
           =2 
           =2 // used with UU16
           =2 # define LSB 0
           =2 # define MSB 1
           =2 
           =2 // used with UU32 (b0 is least-significant byte)
           =2 # define b0 0
           =2 # define b1 1
           =2 # define b2 2
           =2 # define b3 3
           =2 
           =2 typedef unsigned char U8;
           =2 typedef unsigned int U16;
           =2 typedef unsigned long U32;
           =2 
           =2 typedef signed char S8;
           =2 typedef signed int S16;
           =2 typedef signed long S32;
           =2 
           =2 typedef union UU16
           =2 {
           =2    U16 U16;
           =2    S16 S16;
           =2    U8 U8[2];
           =2    S8 S8[2];
           =2 } UU16;
           =2 
           =2 typedef union UU32
           =2 {
           =2    U32 U32;
           =2    S32 S32;
           =2    UU16 UU16[2];
           =2    U16 U16[2];
           =2    S16 S16[2];
           =2    U8 U8[4];
           =2    S8 S8[4];
           =2 } UU32;
           =2 
           =2 // NOP () macro support
           =2 #define NOP() asm(" nop ")
           =2 
           =2 //-----------------------------------------------------------------------------
           =2 
           =2 // Tasking / Altium
           =2 // http://www.altium.com/tasking
           =2 
           =2 
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 34  

           =2 #elif defined _CC51
           =2 
           =2 # define SEG_GENERIC
           =2 # define SEG_FAR   _xdat
           =2 # define SEG_DATA  _data
           =2 # define SEG_NEAR  _data
           =2 # define SEG_IDATA _idat
           =2 # define SEG_XDATA _xdat
           =2 # define SEG_PDATA _pdat
           =2 # define SEG_CODE  _rom
           =2 # define SEG_BDATA _bdat
           =2 
           =2 # define SBIT(name, addr, bit)  _sfrbit  name _at(addr+bit)
           =2 # define SFR(name, addr)        _sfrbyte name _at(addr)
           =2 # define SFRX(name, addr)       _xdat volatile unsigned char name _at(addr)
           =2 #if _CC51 > 71
           =2 # define SFR16(name, addr)      _sfrword _little name _at(addr)
           =2 #else
           =2 # define SFR16(name, addr)      /* not supported */
           =2 #endif
           =2 # define SFR16E(name, fulladdr) /* not supported */
           =2 # define SFR32(name, fulladdr)  /* not supported */
           =2 # define SFR32E(name, fulladdr) /* not supported */
           =2 
           =2 # define INTERRUPT(name, vector) _interrupt (vector) void name (void)
           =2 # define INTERRUPT_USING(name, vector, regnum) _interrupt (vector) _using(regnum) void name (void)
           =2 # define INTERRUPT_PROTO(name, vector) _interrupt (vector) void name (void)
           =2 # define INTERRUPT_PROTO_USING(name, vector, regnum) _interrupt (vector) _using(regnum) void name (void)
           =2 
           =2 // When calling FUNCTION_USING in Tasking, the function must be called from an interrupt or Main which
           =2 // is also using the same register bank. If not, the compiler will generate an error.
           =2 # define FUNCTION_USING(name, return_value, parameter, regnum) _using(regnum) return_value name (parameter
             -)
           =2 # define FUNCTION_PROTO_USING(name, return_value, parameter, regnum) _using(regnum) return_value name (par
             -ameter)
           =2 // Note: Parameter must be either 'void' or include a variable type and name. (Ex: char temp_variable)
           =2 
           =2 # define SEGMENT_VARIABLE(name, vartype, locsegment) vartype locsegment name
           =2 # define VARIABLE_SEGMENT_POINTER(name, vartype, targsegment) vartype targsegment * name
           =2 # define SEGMENT_VARIABLE_SEGMENT_POINTER(name, vartype, targsegment, locsegment) vartype targsegment * lo
             -csegment name
           =2 # define LOCATED_VARIABLE(name, vartype, locsegment, addr, init) vartype locsegment name _at( addr )
           =2 
           =2 // used with UU16
           =2 # define LSB 1
           =2 # define MSB 0
           =2 
           =2 // used with UU32 (b0 is least-significant byte)
           =2 //# define b0 3
           =2 //# define b1 2
           =2 //# define b2 1
           =2 //# define b3 0
           =2 
           =2 typedef unsigned char U8;
           =2 typedef unsigned int U16;
           =2 typedef unsigned long U32;
           =2 
           =2 typedef signed char S8;
           =2 typedef signed int S16;
           =2 typedef signed long S32;
           =2 
           =2 typedef union UU16
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 35  

           =2 {
           =2    U16 U16;
           =2    S16 S16;
           =2    U8 U8[2];
           =2    S8 S8[2];
           =2 } UU16;
           =2 
           =2 typedef union UU32
           =2 {
           =2    U32 U32;
           =2    S32 S32;
           =2    UU16 UU16[2];
           =2    U16 U16[2];
           =2    S16 S16[2];
           =2    U8 U8[4];
           =2    S8 S8[4];
           =2 } UU32;
           =2 
           =2 // NOP () macro support
           =2 extern void _nop (void);
           =2 #define NOP() _nop()
           =2 
           =2 //-----------------------------------------------------------------------------
           =2 
           =2 
           =2 // IAR 8051
           =2 // http://www.iar.com
           =2 
           =2 #elif defined __ICC8051__
           =2 
           =2 #include <stdbool.h>
           =2 #include <intrinsics.h>
           =2 
           =2 # define SBIT(name, addr, bit)  __bit __no_init volatile bool name @ (addr+bit)
           =2 # define SFR(name, addr)        __sfr __no_init volatile unsigned char name @ addr
           =2 # define SFRX(name, addr)       __xdata __no_init volatile unsigned char name @ addr
           =2 # define SFR16(name, addr)      __sfr __no_init volatile unsigned int  name @ addr
           =2 # define SFR16E(name, fulladdr) /* not supported */
           =2 # define SFR32(name, fulladdr) /* not supported */
           =2 # define SFR32E(name, fulladdr) /* not supported */
           =2 
           =2 # define SEG_GENERIC __generic
           =2 # define SEG_FAR  __xdata
           =2 # define SEG_DATA __data
           =2 # define SEG_NEAR __data
           =2 # define SEG_IDATA __idata
           =2 # define SEG_XDATA __xdata
           =2 # define SEG_PDATA __pdata
           =2 # define SEG_CODE  __code
           =2 # define SEG_BDATA __bdata
           =2 
           =2 #define bit bool
           =2 
           =2 # define _PPTOSTR_(x) #x
           =2 # define _PPARAM_(address) _PPTOSTR_(vector=address * 8 + 3)
           =2 # define _PPARAM2_(regbank) _PPTOSTR_(register_bank=regbank)
           =2 # define INTERRUPT(name, vector) _Pragma(_PPARAM_(vector)) __interrupt void name(void)
           =2 # define INTERRUPT_PROTO(name, vector)  __interrupt void name(void)
           =2 # define INTERRUPT_USING(name, vector, regnum) _Pragma(_PPARAM2_(regnum)) _Pragma(_PPARAM_(vector)) __inte
             -rrupt void name(void)
           =2 # define INTERRUPT_PROTO_USING(name, vector, regnum) __interrupt void name(void)
           =2 
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 36  

           =2 # define FUNCTION_USING(name, return_value, parameter, regnum) /* not supported */
           =2 # define FUNCTION_PROTO_USING(name, return_value, parameter, regnum) /* not supported */
           =2 // Note: IAR does not support functions using different register banks. Register
           =2 //       banks can only be specified in interrupts. If a function is called from
           =2 //       inside an interrupt, it will use the same register bank as the interrupt.
           =2 
           =2 # define SEGMENT_VARIABLE(name, vartype, locsegment)  locsegment vartype name
           =2 # define VARIABLE_SEGMENT_POINTER(name, vartype, targsegment) vartype targsegment  * name
           =2 # define SEGMENT_VARIABLE_SEGMENT_POINTER(name, vartype, targsegment, locsegment) vartype targsegment * lo
             -csegment name
           =2 
           =2 # define LOCATED_VARIABLE(name, vartype, locsegment, addr, init) locsegment __no_init vartype name @ addr
           =2 
           =2 // used with UU16
           =2 # define LSB 0
           =2 # define MSB 1
           =2 
           =2 // used with UU32 (b0 is least-significant byte)
           =2 //# define b0 0
           =2 //# define b1 1
           =2 //# define b2 2
           =2 //# define b3 3
           =2 
           =2 typedef unsigned char U8;
           =2 typedef unsigned int U16;
           =2 typedef unsigned long U32;
           =2 
           =2 typedef signed char S8;
           =2 typedef signed int S16;
           =2 typedef signed long S32;
           =2 
           =2 typedef union UU16
           =2 {
           =2    U16 U16;
           =2    S16 S16;
           =2    U8 U8[2];
           =2    S8 S8[2];
           =2 } UU16;
           =2 
           =2 typedef union UU32
           =2 {
           =2    U32 U32;
           =2    S32 S32;
           =2    UU16 UU16[2];
           =2    U16 U16[2];
           =2    S16 S16[2];
           =2    U8 U8[4];
           =2    S8 S8[4];
           =2 } UU32;
           =2 
           =2 
           =2 #define NOP() __no_operation();
           =2 //-----------------------------------------------------------------------------
           =2 
           =2 // Crossware
           =2 // http://www.crossware.com
           =2 
           =2 #elif defined _XC51_VER
           =2 # define SBIT(name, addr, bit)  _sfrbit  name = (addr+bit)
           =2 # define SFR(name, addr)        _sfr     name = addr
           =2 # define SFR16(name, addr)      _sfrword name = addr
           =2 # define SFR16E(name, fulladdr) /* not supported */
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 37  

           =2 # define SFR32(name, fulladdr)  /* not supported */
           =2 # define SFR32E(name, fulladdr) /* not supported */
           =2 
           =2 //-----------------------------------------------------------------------------
           =2 
           =2 // Wickenhäuser
           =2 // http://www.wickenhaeuser.de
           =2 
           =2 #elif defined __UC__
           =2 # define SBIT(name, addr, bit)  unsigned char bit  name @ (addr+bit)
           =2 # define SFR(name, addr)        near unsigned char name @ addr
           =2 # define SFR16(name, addr)      /* not supported */
           =2 # define SFR16E(name, fulladdr) /* not supported */
           =2 # define SFR32(name, fulladdr)  /* not supported */
           =2 # define SFR32E(name, fulladdr) /* not supported */
           =2 
           =2 //-----------------------------------------------------------------------------
           =2 
           =2 // Default
           =2 // Unknown compiler
           =2 
           =2 #else
           =2 # warning unrecognized compiler
           =2 # define SBIT(name, addr, bit)  volatile bool           name
           =2 # define SFR(name, addr)        volatile unsigned char  name
           =2 # define SFRX(name, addr)       volatile unsigned char  name
           =2 # define SFR16(name, addr)      volatile unsigned short name
           =2 # define SFR16E(name, fulladdr) volatile unsigned short name
           =2 # define SFR32(name, fulladdr)  volatile unsigned long  name
           =2 # define SFR32E(name, fulladdr) volatile unsigned long  name
           =2 
           =2 #endif
           =2 
           =2 //-----------------------------------------------------------------------------
           =2 // Header File PreProcessor Directive
           =2 //-----------------------------------------------------------------------------
           =2 
           =2 #endif                                 // #define COMPILER_DEFS_H
 689      =2  
 690      =2  //-----------------------------------------------------------------------------
 691      =2  // End Of File
 692      =2  //-----------------------------------------------------------------------------
   4      =1  #include "C8051F580_defs.h"
   1      =2  //-----------------------------------------------------------------------------
   2      =2  // C8051F580_defs.h
   3      =2  //-----------------------------------------------------------------------------
   4      =2  // Copyright 2008, Silicon Laboratories, Inc.
   5      =2  // http://www.silabs.com
   6      =2  //
   7      =2  // Program Description:
   8      =2  //
   9      =2  // Register/bit definitions for the C8051F58x family.
  10      =2  // **Important Note**: The compiler_defs.h header file should be included
  11      =2  // before including this header file.
  12      =2  //
  13      =2  // Target:         C8051F580/1/2/3/4/5/6/7,8/9-F590/1
  14      =2  // Tool chain:     Generic
  15      =2  // Command Line:   None
  16      =2  //
  17      =2  // Release 0.6 - 20 AUG 2012 (TP)
  18      =2  //    -Added #define for _XPAGE to provide support for SDCC memory paging
  19      =2  //     (pdata)
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 38  

  20      =2  //
  21      =2  // Release 0.5 - 10 SEP 2011 (GP)
  22      =2  //    - Fixed SFR16 definition for CAN0IF2MC
  23      =2  //
  24      =2  // Release 0.4 - 08 OCT 2010 (TP)
  25      =2  //    - Fixed bit definitions for SCON0
  26      =2  //
  27      =2  // Release 0.3 - 01 APR 2009 (GP)
  28      =2  //    - Added SN0-SN3
  29      =2  //
  30      =2  // Release 0.2 - 29 JUL 2008 (ADT)
  31      =2  //    - Added Timer 4 bit definitions
  32      =2  //
  33      =2  // Release 0.1 - 09 JUL 2008 (GP)
  34      =2  //    - Initial Revision
  35      =2  //
  36      =2  //-----------------------------------------------------------------------------
  37      =2  // Header File Preprocessor Directive
  38      =2  //-----------------------------------------------------------------------------
  39      =2  
  40      =2  #ifndef C8051F580_DEFS_H
           =2 #define C8051F580_DEFS_H
           =2 
           =2 //-----------------------------------------------------------------------------
           =2 // Page 0, Page 1 and Page F Registers
           =2 //-----------------------------------------------------------------------------
           =2 
           =2 SFR (P0, 0x80);                        // Port 0 Latch
           =2 SFR (SP, 0x81);                        // Stack Pointer
           =2 SFR (DPL, 0x82);                       // Data Pointer Low
           =2 SFR (DPH, 0x83);                       // Data Pointer High
           =2 SFR (SFR0CN, 0x84);                    // SFR Page Control
           =2 SFR (SFRNEXT, 0x85);                   // SFR stack next page
           =2 SFR (SFRLAST, 0x86);                   // SFR stack last page
           =2 SFR (PCON, 0x87);                      // Power Control
           =2 SFR (TCON, 0x88);                      // Timer/Counter Control
           =2 SFR (TMOD, 0x89);                      // Timer/Counter Mode
           =2 SFR (TL0, 0x8A);                       // Timer/Counter 0 Low
           =2 SFR (TL1, 0x8B);                       // Timer/Counter 1 Low
           =2 SFR (TH0, 0x8C);                       // Timer/Counter 0 High
           =2 SFR (TH1, 0x8D);                       // Timer/Counter 1 High
           =2 SFR (CKCON, 0x8E);                     // Clock Control
           =2 SFR (PSCTL, 0x8F);                     // Program Store R/W Control
           =2 SFR (CLKSEL, 0x8F);                    // System clock select
           =2 SFR (P1, 0x90);                        // Port 1 Latch
           =2 SFR (TMR3CN, 0x91);                    // Timer/Counter 3 Control
           =2 SFR (TMR5CN, 0x91);                    // Timer/Counter 5 Control
           =2 SFR (TMR3RLL, 0x92);                   // Timer/Counter 3 Reload Low
           =2 SFR (TMR5CAPL, 0x92);                  // Timer/Counter 5 Capture Low
           =2 SFR (TMR3RLH, 0x93);                   // Timer/Counter 3 Reload High
           =2 SFR (TMR5CAPH, 0x93);                  // Timer/Counter 5 Capture High
           =2 SFR (TMR3L, 0x94);                     // Timer/Counter 3 Low
           =2 SFR (TMR5L, 0x94);                     // Timer/Counter 5 Low
           =2 SFR (TMR3H, 0x95);                     // Timer/Counter 3 High
           =2 SFR (TMR5H, 0x95);                     // Timer/Counter 5 High
           =2 SFR (TMR5CF, 0x96);                    // Timer/Counter 5 Configuration
           =2 SFR (CLKMUL, 0x97);                    // Clock Multiplier
           =2 SFR (SCON0, 0x98);                     // UART0 Control
           =2 SFR (SCON1, 0x98);                     // UART1 Control
           =2 SFR (SBUF0, 0x99);                     // UART0 Data Buffer
           =2 SFR (SBUF1, 0x99);                     // UART1 Data Buffer
           =2 SFR (CPT0CN, 0x9A);                    // Comparator 0 Control
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 39  

           =2 SFR (CPT2CN, 0x9A);                    // Comparator 2 Control
           =2 SFR (CPT0MD, 0x9B);                    // Comparator 0 Mode
           =2 SFR (CPT2MD, 0x9B);                    // Comparator 2 Mode
           =2 SFR (CPT0MX, 0x9C);                    // Comparator 0 Mux
           =2 SFR (CPT2MX, 0x9C);                    // Comparator 2 Mux
           =2 SFR (CPT1CN, 0x9D);                    // Comparator 1 Control
           =2 SFR (CPT1MD, 0x9E);                    // Comparator 0 Mode
           =2 SFR (OSCIFIN, 0x9E);                   // Internal Oscillator Fine Control
           =2 SFR (CPT1MX, 0x9F);                    // Comparator 1 Mux
           =2 SFR (OSCXCN, 0x9F);                    // External Oscillator Control
           =2 SFR (P2, 0xA0);                        // Port 2 Latch
           =2 SFR (SPI0CFG, 0xA1);                   // SPI0 Configuration
           =2 SFR (OSCICN, 0xA1);                    // Internal Oscillator Control
           =2 SFR (SPI0CKR, 0xA2);                   // SPI0 Clock rate control
           =2 SFR (OSCICRS, 0xA2);                   // Internal Oscillator Coarse Control
           =2 SFR (SPI0DAT, 0xA3);                   // SPI0 Data Buffer
           =2 SFR (P0MDOUT, 0xA4);                   // Port 0 Output Mode
           =2 SFR (P1MDOUT, 0xA5);                   // Port 1 Output Mode
           =2 SFR (P2MDOUT, 0xA6);                   // Port 2 Output Mode
           =2 SFR (SFRPAGE, 0xA7);                   // SFR Page Select
           =2 SFR (IE, 0xA8);                        // Interrupt Enable
           =2 SFR (SMOD0, 0xA9);                     // Serial Port 0 Control
           =2 SFR (EMI0CN, 0xAA);                    // EMIF Control
           =2 SFR (EMI0TC, 0xAA);                    // EMIF Timing control
           =2 SFR (SBCON0, 0xAB);                    // UART0 Baud Rate Generator Control
           =2 SFR (SBRLL0, 0xAC);                    // UART0 Baud Rate Generator Low
           =2 SFR (SBRLH0, 0xAD);                    // UART0 Baud Rate Generator High
           =2 SFR (P3MAT, 0xAE);                     // Port 3 Match
           =2 SFR (P3MDOUT, 0xAE);                   // Port 3 Mode
           =2 SFR (P3MASK, 0xAF);                    // Port 3 Mask
           =2 SFR (P4MDOUT, 0xAF);                   // Port 4 Mode
           =2 SFR (P3, 0xB0);                        // Port 3 Latch
           =2 SFR (P2MAT, 0xB1);                     // Port 2 Match
           =2 SFR (P2MASK, 0xB2);                    // Port 2 Mask
           =2 SFR (EMI0CF, 0xB2);                    // EMIF Configuration
           =2 SFR (P4, 0xB5);                        // Port 4 Latch
           =2 SFR (FLSCL, 0xB6);                     // Flash Scale
           =2 SFR (FLKEY, 0xB7);                     // Flash access limit
           =2 SFR (IP, 0xB8);                        // Interrupt Priority
           =2 SFR (SMB0ADR, 0xB9);                   // SMBus0 Slave address
           =2 SFR (ADC0TK, 0xBA);                    // ADC0 Tracking Mode Select
           =2 SFR (SMB0ADM, 0xBA);                   // SMBus0 Address Mask
           =2 SFR (ADC0MX, 0xBB);                    // AMUX0 Channel select
           =2 SFR (ADC0CF, 0xBC);                    // AMUX0 Channel configuration
           =2 SFR (ADC0L, 0xBD);                     // ADC0 Data Low
           =2 SFR (ADC0H, 0xBE);                     // ADC0 Data High
           =2 SFR (SMB0CN, 0xC0);                    // SMBus0 Control
           =2 SFR (SMB0CF, 0xC1);                    // SMBus0 Configuration
           =2 SFR (SMB0DAT, 0xC2);                   // SMBus0 Data
           =2 SFR (ADC0GTL, 0xC3);                   // ADC0 Greater-Than Compare Low
           =2 SFR (ADC0GTH, 0xC4);                   // ADC0 Greater-Than Compare High
           =2 SFR (ADC0LTL, 0xC5);                   // ADC0 Less-Than Compare Word Low
           =2 SFR (ADC0LTH, 0xC6);                   // ADC0 Less-Than Compare Word High
           =2 SFR (XBR3, 0xC6);                      // Port I/O Crossbar Control 3
           =2 SFR (XBR2, 0xC7);                      // Port I/O Crossbar Control 2
           =2 SFR (TMR2CN, 0xC8);                    // Timer/Counter 2 Control
           =2 SFR (TMR4CN, 0xC8);                    // Timer/Counter 4 Control
           =2 SFR (REG0CN, 0xC9);                    // Regulator Control
           =2 SFR (LIN0CF, 0xC9);                    // LIN 0 Configuration
           =2 SFR (TMR4CF, 0xC9);                    // Timer/Counter 4 Configuration
           =2 SFR (TMR2RLL, 0xCA);                   // Timer/Counter 2 Reload Low
           =2 SFR (TMR4CAPL, 0xCA);                  // Timer/Counter 4 Capture Low
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 40  

           =2 SFR (TMR2RLH, 0xCB);                   // Timer/Counter 2 Reload High
           =2 SFR (TMR4CAPH, 0xCB);                  // Timer/Counter 4 Capture High
           =2 SFR (TMR2L, 0xCC);                     // Timer/Counter 2 Low
           =2 SFR (TMR4L, 0xCC);                     // Timer/Counter 4 Low
           =2 SFR (TMR2H, 0xCD);                     // Timer/Counter 2 High
           =2 SFR (TMR4H, 0xCD);                     // Timer/Counter 4 High
           =2 SFR (PCA0CPL5, 0xCE);                  // PCA0 Capture 5 Low
           =2 SFR (PCA1CPL11, 0xCE);                 // PCA1 Capture 11 Low
           =2 SFR (PCA0CPH5, 0xCF);                  // PCA0 Capture 5 High
           =2 SFR (PCA1CPH11, 0xCF);                 // PCA1 Capture 11 High
           =2 SFR (PSW, 0xD0);                       // Program Status Word
           =2 SFR (REF0CN, 0xD1);                    // Voltage Reference Control
           =2 SFR (LIN0DAT, 0xD2);                   // LIN0 Data
           =2 SFR (LIN0ADR, 0xD3);                   // LIN0 Address
           =2 SFR (P0SKIP, 0xD4);                    // Port 0 Skip
           =2 SFR (P1SKIP, 0xD5);                    // Port 1 Skip
           =2 SFR (P2SKIP, 0xD6);                    // Port 2 Skip
           =2 SFR (P3SKIP, 0xD7);                    // Port 3 Skip
           =2 SFR (PCA0CN, 0xD8);                    // PCA0 Control
           =2 SFR (PCA1CN, 0xD8);                    // PCA1 Control
           =2 SFR (PCA0MD, 0xD9);                    // PCA0 Mode
           =2 SFR (PCA1MD, 0xD9);                    // PCA1 Mode
           =2 SFR (PCA0PWM, 0xD9);                   // PCA0 PWM Control
           =2 SFR (PCA0CPM0, 0xDA);                  // PCA0 Module 0 Mode
           =2 SFR (PCA1CPM6, 0xDA);                  // PCA1 Module 6 Mode
           =2 SFR (PCA1PWM, 0xDA);                   // PCA1 PWM Control
           =2 SFR (PCA0CPM1, 0xDB);                  // PCA0 Module 1  Mode
           =2 SFR (PCA1CPM7, 0xDB);                  // PCA1 Module 7  Mode
           =2 SFR (PCA0CPM2, 0xDC);                  // PCA0 Module 2  Mode
           =2 SFR (PCA1CPM8, 0xDC);                  // PCA1 Module 8  Mode
           =2 SFR (PCA0CPM3, 0xDD);                  // PCA0 Module 3  Mode
           =2 SFR (PCA1CPM9, 0xDD);                  // PCA1 Module 9  Mode
           =2 SFR (PCA0CPM4, 0xDE);                  // PCA0 Module 4  Mode
           =2 SFR (PCA1CPM10, 0xDE);                  // PCA1 Module 10 Mode
           =2 SFR (PCA0CPM5, 0xDF);                  // PCA0 Module 5  Mode
           =2 SFR (PCA1CPM11, 0xDF);                  // PCA1 Module 11 Mode
           =2 SFR (ACC, 0xE0);                       // Accumulator
           =2 SFR (XBR0, 0xE1);                      // Port I/O Crossbar Control 0
           =2 SFR (XBR1, 0xE2);                      // Port I/O Crossbar Control 1
           =2 SFR (CCH0CN, 0xE3);                    // Cache control
           =2 SFR (IT01CF, 0xE4);                    // INT0/INT1 Configuration
           =2 SFR (EIE1, 0xE6);                      // Extended Interrupt Enable 2
           =2 SFR (EIE2, 0xE7);                      // Extended Interrupt Enable 2
           =2 SFR (ADC0CN, 0xE8);                    // ADC0 Control
           =2 SFR (PCA0CPL1, 0xE9);                  // PCA0 Capture 1 Low
           =2 SFR (PCA1CPL1, 0xE9);                  // PCA1 Capture 7 Low
           =2 SFR (PCA0CPH1, 0xEA);                  // PCA0 Capture 1 High
           =2 SFR (PCA1CPH1, 0xEA);                  // PCA1 Capture 7 High
           =2 SFR (PCA0CPL2, 0xEB);                  // PCA0 Capture 2 Low
           =2 SFR (PCA1CPL2, 0xEB);                  // PCA1 Capture 8 Low
           =2 SFR (PCA0CPH2, 0xEC);                  // PCA0 Capture 2 High
           =2 SFR (PCA1CPH2, 0xEC);                  // PCA1 Capture 8 High
           =2 SFR (PCA0CPL3, 0xED);                  // PCA0 Capture 3 Low
           =2 SFR (PCA1CPL3, 0xED);                  // PCA1 Capture 9 Low
           =2 SFR (PCA0CPH3, 0xEE);                  // PCA0 Capture 3 High
           =2 SFR (PCA1CPH3, 0xEE);                  // PCA1 Capture 9 High
           =2 SFR (RSTSRC, 0xEF);                    // Reset Source Configuration/Status
           =2 SFR (B, 0xF0);                         // B Register
           =2 SFR (P0MAT, 0xF1);                     // Port 0 Match
           =2 SFR (P0MDIN, 0xF1);                    // Port 0 Input Mode
           =2 SFR (P0MASK, 0xF2);                    // Port 0 Mask
           =2 SFR (P1MDIN, 0xF2);                    // Port 1 Input Mode
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 41  

           =2 SFR (P1MAT, 0xF3);                     // Port 1 Match
           =2 SFR (P2MDIN, 0xF3);                    // Port 2 Input Mode
           =2 SFR (P1MASK, 0xF4);                    // Port 1 Mask
           =2 SFR (P3MDIN, 0xF4);                    // Port 3 Input Mode
           =2 SFR (PSBANK, 0xF5);                    // Program Space Bank Select
           =2 SFR (EIP1, 0xF6);                      // External Interrupt Priority 1
           =2 SFR (EIP2, 0xF7);                      // External Interrupt Priority 2
           =2 SFR (SPI0CN, 0xF8);                    // SPI0 Control
           =2 SFR (PCA0L, 0xF9);                     // PCA0 Counter Low
           =2 SFR (PCA1L, 0xF9);                     // PCA1 Counter Low
           =2 SFR (SN0, 0xF9);                       // Serial Number 0
           =2 SFR (PCA0H, 0xFA);                     // PCA0 Counter High
           =2 SFR (PCA1H, 0xFA);                     // PCA1 Counter High
           =2 SFR (SN1, 0xFA);                       // Serial Number 1
           =2 SFR (PCA0CPL0, 0xFB);                  // PCA0 Capture 0 Low
           =2 SFR (PCA1CPL6, 0xFB);                  // PCA1 Capture 6 Low
           =2 SFR (SN2, 0xFB);                       // Serial Number 2
           =2 SFR (PCA0CPH0, 0xFC);                  // PCA0 Capture 0 High
           =2 SFR (PCA1CPH6, 0xFC);                  // PCA1 Capture 6 High
           =2 SFR (SN3, 0xFC);                       // Serial Number 3
           =2 SFR (PCA0CPL4, 0xFD);                  // PCA0 Capture 4 Low
           =2 SFR (PCA1CPL10, 0xFD);                 // PCA1 Capture 10 Low
           =2 SFR (PCA0CPH4, 0xFE);                  // PCA0 Capture 4 High
           =2 SFR (PCA1CPH10, 0xFE);                 // PCA1 Capture 10 High
           =2 SFR (VDM0CN, 0xFF);                    // VDD Monitor Control
           =2 
           =2 //-----------------------------------------------------------------------------
           =2 // Page C (CAN0) Registers
           =2 //-----------------------------------------------------------------------------
           =2 
           =2 SFR (CAN0CFG, 0x92);                   // CAN0 Clock Configuration
           =2 SFR (CAN0STAT, 0x94);                  // Status Register Low Byte
           =2 SFR (CAN0ERRL, 0x96);                  // Error Counter Low Byte
           =2 SFR (CAN0ERRH, 0x97);                  // Error Counter High Byte
           =2 SFR (CAN0BTL, 0x9A);                   // Bit Timing Register Low Byte
           =2 SFR (CAN0BTH, 0x9B);                   // Bit Timing Register High Byte
           =2 SFR (CAN0IIDL, 0x9C);                  // Interrupt Register Low Byte
           =2 SFR (CAN0IIDH, 0x9D);                  // Interrupt Register High Byte
           =2 SFR (CAN0TST, 0x9E);                   // Test Register Low Byte
           =2 SFR (CAN0BRPE, 0xA1);                  // BRP Extension Register Low Byte
           =2 SFR (CAN0TR1L, 0xA2);                  // Transmission Request 1 Low Byte
           =2 SFR (CAN0TR1H, 0xA3);                  // Transmission Request 1 High Byte
           =2 SFR (CAN0TR2L, 0xA4);                  // Transmission Request 2 Low Byte
           =2 SFR (CAN0TR2H, 0xA5);                  // Transmission Request 2 High Byte
           =2 SFR (CAN0ND1L, 0xAA);                  // New Data 1 Low Byte
           =2 SFR (CAN0ND1H, 0xAB);                  // New Data 1 High Byte
           =2 SFR (CAN0ND2L, 0xAC);                  // New Data 2 Low Byte
           =2 SFR (CAN0ND2H, 0xAD);                  // New Data 2 High Byte
           =2 SFR (CAN0IP1L, 0xAE);                  // Interrupt Pending 1 Low Byte
           =2 SFR (CAN0IP1H, 0xAF);                  // Interrupt Pending 1 High Byte
           =2 SFR (CAN0IP2L, 0xB2);                  // Interrupt Pending 2 Low Byte
           =2 SFR (CAN0IP2H, 0xB3);                  // Interrupt Pending 2 High Byte
           =2 SFR (CAN0MV1L, 0xBA);                  // Message Valid 1 Low Byte
           =2 SFR (CAN0MV1H, 0xBB);                  // Message Valid 1 High Byte
           =2 SFR (CAN0MV2L, 0xBC);                  // Message Valid 2 Low Byte
           =2 SFR (CAN0MV2H, 0xBD);                  // Message Valid 2 High Byte
           =2 SFR (CAN0IF1CRL, 0xBE);                // IF1 Command Request Low Byte
           =2 SFR (CAN0IF1CRH, 0xBF);                // IF1 Command Request High Byte
           =2 SFR (CAN0CN, 0xC0);                    // CAN Control Register Low Byte
           =2 SFR (CAN0IF1CML, 0xC2);                // IF1 Command Mask Low Byte
           =2 SFR (CAN0IF1CMH, 0xC3);                // IF1 Command Mask High Byte
           =2 SFR (CAN0IF1M1L, 0xC4);                // IF1 Mask 1 Low Byte
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 42  

           =2 SFR (CAN0IF1M1H, 0xC5);                // IF1 Mask 1 High Byte
           =2 SFR (CAN0IF1M2L, 0xC6);                // IF1 Mask 2 Low Byte
           =2 SFR (CAN0IF1M2H, 0xC7);                // IF1 Mask 2 High Byte
           =2 SFR (CAN0IF1A1L, 0xCA);                // IF1 Arbitration 1 Low Byte
           =2 SFR (CAN0IF1A1H, 0xCB);                // IF1 Arbitration 1 High Byte
           =2 SFR (CAN0IF1A2L, 0xCC);                // IF1 Arbitration 2 Low Byte
           =2 SFR (CAN0IF1A2H, 0xCD);                // IF1 Arbitration 2 High Byte
           =2 SFR (CAN0IF2MCL, 0xCE);                // IF2 Message Control Low Byte
           =2 SFR (CAN0IF2MCH, 0xCF);                // IF2 Message Control High Byte
           =2 SFR (CAN0IF1MCL, 0xD2);                // IF1 Message Control Low Byte
           =2 SFR (CAN0IF1MCH, 0xD3);                // IF1 Message Control High Byte
           =2 SFR (CAN0IF1DA1L, 0xD4);               // IF1 Data A 1 Low Byte
           =2 SFR (CAN0IF1DA1H, 0xD5);               // IF1 Data A 1 High Byte
           =2 SFR (CAN0IF1DA2L, 0xD6);               // IF1 Data A 2 Low Byte
           =2 SFR (CAN0IF1DA2H, 0xD7);               // IF1 Data A 2 High Byte
           =2 SFR (CAN0IF1DB1L, 0xDA);               // IF1 Data B 1 Low Byte
           =2 SFR (CAN0IF1DB1H, 0xDB);               // IF1 Data B 1 High Byte
           =2 SFR (CAN0IF1DB2L, 0xDC);               // IF1 Data B 2 Low Byte
           =2 SFR (CAN0IF1DB2H, 0xDD);               // IF1 Data B 2 High Byte
           =2 SFR (CAN0IF2CRL, 0xDE);                // IF2 Command Request Low Byte
           =2 SFR (CAN0IF2CRH, 0xDF);                // IF2 Command Request High Byte
           =2 SFR (CAN0IF2CML, 0xE2);                // IF2 Command Mask Low Byte
           =2 SFR (CAN0IF2CMH, 0xE3);                // IF2 Command Mask High Byte
           =2 SFR (CAN0IF2M1L, 0xEA);                // IF2 Mask 1 Low Byte
           =2 SFR (CAN0IF2M1H, 0xEB);                // IF2 Mask 1 High Byte
           =2 SFR (CAN0IF2M2L, 0xEC);                // IF2 Mask 2 Low Byte
           =2 SFR (CAN0IF2M2H, 0xED);                // IF2 Mask 2 High Byte
           =2 SFR (CAN0IF2A1L, 0xEE);                // IF2 Arbitration 1 Low Byte
           =2 SFR (CAN0IF2A1H, 0xEF);                // IF2 Arbitration 1 High Byte
           =2 SFR (CAN0IF2A2L, 0xF2);                // IF2 Arbitration 2 Low Byte
           =2 SFR (CAN0IF2A2H, 0xF3);                // IF2 Arbitration 2 High Byte
           =2 SFR (CAN0IF2DA1L, 0xF6);               // IF2 Data A 1 Low Byte
           =2 SFR (CAN0IF2DA1H, 0xF7);               // IF2 Data A 1 High Byte
           =2 SFR (CAN0IF2DA2L, 0xFA);               // IF2 Data A 2 Low Byte
           =2 SFR (CAN0IF2DA2H, 0xFB);               // IF2 Data A 2 High Byte
           =2 SFR (CAN0IF2DB1L, 0xFC);               // IF2 Data B 1 Low Byte
           =2 SFR (CAN0IF2DB1H, 0xFD);               // IF2 Data B 1 High Byte
           =2 SFR (CAN0IF2DB2L, 0xFE);               // IF2 Data B 2 Low Byte
           =2 SFR (CAN0IF2DB2H, 0xFF);               // IF2 Data B 2 High Byte
           =2 
           =2 
           =2 //-----------------------------------------------------------------------------
           =2 // 16-bit Register Definitions (might not be supported by all compilers)
           =2 //-----------------------------------------------------------------------------
           =2 
           =2 SFR16 (DP, 0x82);                      // Data Pointer
           =2 SFR16 (TMR3RL, 0x92);                  // Timer 3 Reload
           =2 SFR16 (TMR5CAP, 0x92);                 // Timer 5 Capture
           =2 SFR16 (TMR3, 0x94);                    // Timer 3 Capture / Reload
           =2 SFR16 (TMR5, 0x94);                    // Timer 5
           =2 SFR16 (SBRL0, 0xAC);                   // UART0 Reload
           =2 SFR16 (ADC0, 0xBD);                    // ADC0 data
           =2 SFR16 (ADC0GT, 0xC3);                  // ADC0 Greater Than Window
           =2 SFR16 (ADC0LT, 0xC5);                  // ADC0 Less Than Window
           =2 SFR16 (TMR2RL, 0xCA);                  // Timer 2 Reload
           =2 SFR16 (TMR4CAP, 0xCA);                 // Timer 4 Capture
           =2 SFR16 (TMR2, 0xCC);                    // Timer 2 Capture / Reload
           =2 SFR16 (TMR4, 0xCC);                    // Timer 4
           =2 SFR16 (PCA0CP5, 0xCE);                 // PCA0 Module 5 Capture
           =2 SFR16 (PCA1CP11, 0xCE);                // PCA1 Module 11 Capture
           =2 SFR16 (PCA0CP1, 0xE9);                 // PCA0 Module 1 Capture
           =2 SFR16 (PCA1CP7, 0xE9);                 // PCA1 Module 7 Capture
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 43  

           =2 SFR16 (PCA0CP2, 0xEB);                 // PCA0 Module 2 Capture
           =2 SFR16 (PCA1CP8, 0xEB);                 // PCA1 Module 8 Capture
           =2 SFR16 (PCA0CP3, 0xED);                 // PCA0 Module 3 Capture
           =2 SFR16 (PCA1CP9, 0xED);                 // PCA1 Module 9 Capture
           =2 SFR16 (PCA0, 0xF9);                    // PCA0 Counter
           =2 SFR16 (PCA1, 0xF9);                    // PCA1 Counter
           =2 SFR16 (PCA0CP0, 0xFB);                 // PCA0 Module 0 Capture
           =2 SFR16 (PCA1CP6, 0xFB);                 // PCA1 Module 6 Capture
           =2 SFR16 (PCA0CP4, 0xFD);                 // PCA0 Module 4 Capture
           =2 SFR16 (PCA1CP10, 0xFD);                 // PCA1 Module 10 Capture
           =2 
           =2 SFR16 (CAN0ERR, 0x96);                 // Error Counter
           =2 SFR16 (CAN0BT, 0x9A);                  // Bit Timing Register
           =2 SFR16 (CAN0IID, 0x9C);                 // Interrupt Register
           =2 SFR16 (CAN0TR1, 0xA2);                 // Transmission Request 1
           =2 SFR16 (CAN0TR2, 0xA4);                 // Transmission Request 2
           =2 SFR16 (CAN0ND1, 0xAA);                 // New Data 1
           =2 SFR16 (CAN0ND2, 0xAC);                 // New Data 2
           =2 SFR16 (CAN0IP1, 0xAE);                 // Interrupt Pending 1
           =2 SFR16 (CAN0IP2, 0xB2);                 // Interrupt Pending 2
           =2 SFR16 (CAN0MV1, 0xBA);                 // Message Valid 1
           =2 SFR16 (CAN0MV2, 0xBC);                 // Message Valid 2
           =2 SFR16 (CAN0IF1CR, 0xBE);               // IF1 Command Request
           =2 SFR16 (CAN0IF1CM, 0xC2);               // IF1 Command Mask
           =2 SFR16 (CAN0IF1M1, 0xC4);               // IF1 Mask 1
           =2 SFR16 (CAN0IF1M2, 0xC6);               // IF1 Mask 2
           =2 SFR16 (CAN0IF1A1, 0xCA);               // IF1 Arbitration 1
           =2 SFR16 (CAN0IF1A2, 0xCC);               // IF1 Arbitration 2
           =2 SFR16 (CAN0IF1MC, 0xD2);               // IF1 Message Control
           =2 SFR16 (CAN0IF1DA1, 0xD4);              // IF1 Data A 1
           =2 SFR16 (CAN0IF1DA2, 0xD6);              // IF1 Data A 2
           =2 SFR16 (CAN0IF1DB1, 0xDA);              // IF1 Data B 1
           =2 SFR16 (CAN0IF1DB2, 0xDC);              // IF1 Data B 2
           =2 SFR16 (CAN0IF2CR, 0xDE);               // IF2 Command Request
           =2 SFR16 (CAN0IF2CM, 0xE2);               // IF2 Command Mask
           =2 SFR16 (CAN0IF2M1, 0xEA);               // IF2 Mask 1
           =2 SFR16 (CAN0IF2M2, 0xEC);               // IF2 Mask 2
           =2 SFR16 (CAN0IF2A1, 0xEE);               // IF2 Arbitration 1
           =2 SFR16 (CAN0IF2A2, 0xF2);               // IF2 Arbitration 2
           =2 SFR16 (CAN0IF2MC, 0xCE);               // IF2 Message Control
           =2 SFR16 (CAN0IF2DA1, 0xF6);              // IF2 Data A 1
           =2 SFR16 (CAN0IF2DA2, 0xFA);              // IF2 Data A 2
           =2 SFR16 (CAN0IF2DB1, 0xFC);              // IF2 Data B 1
           =2 SFR16 (CAN0IF2DB2, 0xFE);              // IF2 Data B 2
           =2 
           =2 //-----------------------------------------------------------------------------
           =2 // LIN0 Indirect Registers
           =2 //-----------------------------------------------------------------------------
           =2 
           =2 #define  LIN0DT1   0x00                // LIN0 Data Byte 1
           =2 #define  LIN0DT2   0x01                // LIN0 Data Byte 2
           =2 #define  LIN0DT3   0x02                // LIN0 Data Byte 3
           =2 #define  LIN0DT4   0x03                // LIN0 Data Byte 4
           =2 #define  LIN0DT5   0x04                // LIN0 Data Byte 5
           =2 #define  LIN0DT6   0x05                // LIN0 Data Byte 6
           =2 #define  LIN0DT7   0x06                // LIN0 Data Byte 7
           =2 #define  LIN0DT8   0x07                // LIN0 Data Byte 8
           =2 #define  LIN0CTRL  0x08                // LIN0 Control
           =2 #define  LIN0ST    0x09                // LIN0 Status
           =2 #define  LIN0ERR   0x0A                // LIN0 Error
           =2 #define  LIN0SIZE  0x0B                // LIN0 Message Size
           =2 #define  LIN0DIV   0x0C                // LIN0 Divider
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 44  

           =2 #define  LIN0MUL   0x0D                // LIN0 Multiplier
           =2 #define  LIN0ID    0x0E                // LIN0 Identifier
           =2 
           =2 //-----------------------------------------------------------------------------
           =2 // Address Definitions for Bit-addressable Registers
           =2 //-----------------------------------------------------------------------------
           =2 
           =2 #define SFR_P0       0x80
           =2 #define SFR_TCON     0x88
           =2 #define SFR_P1       0x90
           =2 #define SFR_SCON0    0x98
           =2 #define SFR_SCON1    0x98
           =2 #define SFR_P2       0xA0
           =2 #define SFR_IE       0xA8
           =2 #define SFR_P3       0xB0
           =2 #define SFR_IP       0xB8
           =2 #define SFR_SMB0CN   0xC0
           =2 #define SFR_TMR2CN   0xC8
           =2 #define SFR_TMR4CN   0xC8
           =2 #define SFR_PSW      0xD0
           =2 #define SFR_PCA0CN   0xD8
           =2 #define SFR_PCA1CN   0xD8
           =2 #define SFR_ACC      0xE0
           =2 #define SFR_ADC0CN   0xE8
           =2 #define SFR_B        0xF0
           =2 #define SFR_SPI0CN   0xF8
           =2 
           =2 //-----------------------------------------------------------------------------
           =2 // Bit Definitions
           =2 //-----------------------------------------------------------------------------
           =2 
           =2 // TCON 0x88
           =2 SBIT (TF1, SFR_TCON, 7);               // Timer 1 Overflow Flag
           =2 SBIT (TR1, SFR_TCON, 6);               // Timer 1 On/Off Control
           =2 SBIT (TF0, SFR_TCON, 5);               // Timer 0 Overflow Flag
           =2 SBIT (TR0, SFR_TCON, 4);               // Timer 0 On/Off Control
           =2 SBIT (IE1, SFR_TCON, 3);               // Ext. Interrupt 1 Edge Flag
           =2 SBIT (IT1, SFR_TCON, 2);               // Ext. Interrupt 1 Type
           =2 SBIT (IE0, SFR_TCON, 1);               // Ext. Interrupt 0 Edge Flag
           =2 SBIT (IT0, SFR_TCON, 0);               // Ext. Interrupt 0 Type
           =2 
           =2 // SCON0 0x98
           =2 SBIT (OVR0, SFR_SCON0, 7);             // UART0 Receive FIFO Overrun Flag
           =2 SBIT (PERR0, SFR_SCON0, 6);            // UART0 Parity Error Flag
           =2 SBIT (THRE0, SFR_SCON0, 5);            // UART0 Transmit Register Empty Flag
           =2 SBIT (REN0, SFR_SCON0, 4);             // UART0 RX Enable
           =2 SBIT (TBX0, SFR_SCON0, 3);             // UART0 Extra Transmission Bit
           =2 SBIT (RBX0, SFR_SCON0, 2);             // UART0 Extra Receive Bit
           =2 SBIT (TI0, SFR_SCON0, 1);              // UART0 TX Interrupt Flag
           =2 SBIT (RI0, SFR_SCON0, 0);              // UART0 RX Interrupt Flag
           =2 
           =2 // SCON1 0x98
           =2 SBIT (S1MODE, SFR_SCON1, 7);           // UART1 Mode 0
           =2                                        // Bit 6 UNUSED
           =2 SBIT (MCE1, SFR_SCON1, 5);             // UART1 Multiprocessor enable
           =2 SBIT (REN1, SFR_SCON1, 4);             // UART1 RX Enable
           =2 SBIT (TB81, SFR_SCON1, 3);             // UART1 TX Bit 8
           =2 SBIT (RB81, SFR_SCON1, 2);             // UART1 RX Bit 8
           =2 SBIT (TI1, SFR_SCON1, 1);              // UART1 TX Interrupt Flag
           =2 SBIT (RI1, SFR_SCON1, 0);              // UART1 RX Interrupt Flag
           =2 
           =2 // IE 0xA8
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 45  

           =2 SBIT (EA, SFR_IE, 7);                  // Global Interrupt Enable
           =2 SBIT (ESPI0, SFR_IE, 6);               // SPI0 Interrupt Enable
           =2 SBIT (ET2, SFR_IE, 5);                 // Timer 2 Interrupt Enable
           =2 SBIT (ES0, SFR_IE, 4);                 // UART0 Interrupt Enable
           =2 SBIT (ET1, SFR_IE, 3);                 // Timer 1 Interrupt Enable
           =2 SBIT (EX1, SFR_IE, 2);                 // External Interrupt 1 Enable
           =2 SBIT (ET0, SFR_IE, 1);                 // Timer 0 Interrupt Enable
           =2 SBIT (EX0, SFR_IE, 0);                 // External Interrupt 0 Enable
           =2 
           =2 // IP 0xB8
           =2                                        // Bit 7 unused
           =2 SBIT (PSPI0, SFR_IP, 6);               // SPI0 Interrupt Priority
           =2 SBIT (PT2, SFR_IP, 5);                 // Timer 2 Priority
           =2 SBIT (PS0, SFR_IP, 4);                 // UART0 Priority
           =2 SBIT (PS, SFR_IP, 4);                  // UART0 Priority
           =2 SBIT (PT1, SFR_IP, 3);                 // Timer 1 Priority
           =2 SBIT (PX1, SFR_IP, 2);                 // External Interrupt 1 Priority
           =2 SBIT (PT0, SFR_IP, 1);                 // Timer 0 Priority
           =2 SBIT (PX0, SFR_IP, 0);                 // External Interrupt 0 Priority
           =2 
           =2 // SMB0CN 0xC0
           =2 SBIT (MASTER, SFR_SMB0CN, 7);          // SMBus0 Master/Slave Indicator
           =2 SBIT (TXMODE, SFR_SMB0CN, 6);          // SMBus0 Transmit Mode Indicator
           =2 SBIT (STA, SFR_SMB0CN, 5);             // SMBus0 Start Flag
           =2 SBIT (STO, SFR_SMB0CN, 4);             // SMBus0 Stop Flag
           =2 SBIT (ACKRQ, SFR_SMB0CN, 3);           // SMBus0 Acknowledge Request
           =2 SBIT (ARBLOST, SFR_SMB0CN, 2);         // SMBus0 Arbitration Lost Indicator
           =2 SBIT (ACK, SFR_SMB0CN, 1);             // SMBus0 Acknowledge
           =2 SBIT (SI, SFR_SMB0CN, 0);              // SMBus0 Interrupt Flag
           =2 
           =2 // TMR2CN 0xC8
           =2 SBIT (TF2H, SFR_TMR2CN, 7);            // Timer 2 High-Byte Overflow Flag
           =2 SBIT (TF2L, SFR_TMR2CN, 6);            // Timer 2 Low-Byte  Overflow Flag
           =2 SBIT (TF2LEN, SFR_TMR2CN, 5);          // Timer 2 Low-Byte Flag Enable
           =2 SBIT (TF2CEN, SFR_TMR2CN, 4);          // Timer 2 Capture Enable
           =2 SBIT (T2SPLIT, SFR_TMR2CN, 3);         // Timer 2 Split-Mode Enable
           =2 SBIT (TR2, SFR_TMR2CN, 2);             // Timer 2 Run Enable
           =2 SBIT (T2RCLK, SFR_TMR2CN, 1);          // Timer 2 Xclk/Rclk Select
           =2 SBIT (T2XCLK, SFR_TMR2CN, 0);          // Timer 2 Clk/8 Clock Source
           =2 
           =2 // TMR4CN 0xC8
           =2 SBIT (TF4, SFR_TMR4CN, 7);             // Timer 4 Overflow/Underflow Flag
           =2 SBIT (EXF4, SFR_TMR4CN, 6);            // Timer 4 External Flag
           =2                                        // Bit 5 unused
           =2                                        // Bit 4 unused
           =2 SBIT (EXE4, SFR_TMR4CN, 3);            // Timer 4 External Enable
           =2 SBIT (TR4, SFR_TMR4CN, 2);             // Timer 4 Run Enable
           =2 SBIT (CT4, SFR_TMR4CN, 1);             // Timer 4 Counter/Timer Select
           =2 SBIT (CPRL4, SFR_TMR4CN, 0);           // Timer 4 Capture/Reload Select
           =2 
           =2 // PSW 0xD0
           =2 SBIT (CY, SFR_PSW, 7);                 // Carry Flag
           =2 SBIT (AC, SFR_PSW, 6);                 // Auxiliary Carry Flag
           =2 SBIT (F0, SFR_PSW, 5);                 // User Flag 0
           =2 SBIT (RS1, SFR_PSW, 4);                // Register Bank Select 1
           =2 SBIT (RS0, SFR_PSW, 3);                // Register Bank Select 0
           =2 SBIT (OV, SFR_PSW, 2);                 // Overflow Flag
           =2 SBIT (F1, SFR_PSW, 1);                 // User Flag 1
           =2 SBIT (P, SFR_PSW, 0);                  // Accumulator Parity Flag
           =2 
           =2 // PCA0CN 0xD8
           =2 SBIT (CF, SFR_PCA0CN, 7);              // PCA0 Counter Overflow Flag
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 46  

           =2 SBIT (CR, SFR_PCA0CN, 6);              // PCA0 Counter Run Control Bit
           =2 SBIT (CCF5, SFR_PCA0CN, 5);            // PCA0 Module 5 Interrupt Flag
           =2 SBIT (CCF4, SFR_PCA0CN, 4);            // PCA0 Module 4 Interrupt Flag
           =2 SBIT (CCF3, SFR_PCA0CN, 3);            // PCA0 Module 3 Interrupt Flag
           =2 SBIT (CCF2, SFR_PCA0CN, 2);            // PCA0 Module 2 Interrupt Flag
           =2 SBIT (CCF1, SFR_PCA0CN, 1);            // PCA0 Module 1 Interrupt Flag
           =2 SBIT (CCF0, SFR_PCA0CN, 0);            // PCA0 Module 0 Interrupt Flag
           =2 
           =2 // PCA1CN 0xD8
           =2 SBIT (CF1, SFR_PCA1CN, 7);             // PCA1 Counter Overflow Flag
           =2 SBIT (CR1, SFR_PCA1CN, 6);             // PCA1 Counter Run Control Bit
           =2 SBIT (CCF11, SFR_PCA1CN, 5);           // PCA1 Module 11 Interrupt Flag
           =2 SBIT (CCF10, SFR_PCA1CN, 4);           // PCA1 Module 10 Interrupt Flag
           =2 SBIT (CCF9, SFR_PCA1CN, 3);            // PCA1 Module 9 Interrupt Flag
           =2 SBIT (CCF8, SFR_PCA1CN, 2);            // PCA1 Module 8 Interrupt Flag
           =2 SBIT (CCF7, SFR_PCA1CN, 1);            // PCA1 Module 7 Interrupt Flag
           =2 SBIT (CCF6, SFR_PCA1CN, 0);            // PCA1 Module 6 Interrupt Flag
           =2 
           =2 // ADC0CN 0xE8
           =2 SBIT (AD0EN, SFR_ADC0CN, 7);           // ADC0 Enable
           =2 SBIT (BURSTEN, SFR_ADC0CN, 6);         // ADC0 Burst Enable
           =2 SBIT (AD0INT, SFR_ADC0CN, 5);          // ADC0 EOC Interrupt Flag
           =2 SBIT (AD0BUSY, SFR_ADC0CN, 4);         // ADC0 Busy Flag
           =2 SBIT (AD0WINT, SFR_ADC0CN, 3);         // ADC0 Window Compare Interrupt Flag
           =2 SBIT (AD0LJST, SFR_ADC0CN, 2);         // ADC0 Left Justified
           =2 SBIT (AD0CM1, SFR_ADC0CN, 1);          // ADC0 Start Of Conversion Mode Bit 1
           =2 SBIT (AD0CM0, SFR_ADC0CN, 0);          // ADC0 Start Of Conversion Mode Bit 0
           =2 
           =2 // SPI0CN 0xF8
           =2 SBIT (SPIF, SFR_SPI0CN, 7);            // SPI0 Interrupt Flag
           =2 SBIT (WCOL, SFR_SPI0CN, 6);            // SPI0 Write Collision Flag
           =2 SBIT (MODF, SFR_SPI0CN, 5);            // SPI0 Mode Fault Flag
           =2 SBIT (RXOVRN, SFR_SPI0CN, 4);          // SPI0 RX Overrun Flag
           =2 SBIT (NSSMD1, SFR_SPI0CN, 3);          // SPI0 Slave Select Mode 1
           =2 SBIT (NSSMD0, SFR_SPI0CN, 2);          // SPI0 Slave Select Mode 0
           =2 SBIT (TXBMT, SFR_SPI0CN, 1);           // SPI0 TX Buffer Empty Flag
           =2 SBIT (SPIEN, SFR_SPI0CN, 0);           // SPI0 Enable
           =2 
           =2 //-----------------------------------------------------------------------------
           =2 // Interrupt Priorities
           =2 //-----------------------------------------------------------------------------
           =2 
           =2 #define INTERRUPT_INT0             0   // External Interrupt 0
           =2 #define INTERRUPT_TIMER0           1   // Timer 0 Overflow
           =2 #define INTERRUPT_INT1             2   // External Interrupt 1
           =2 #define INTERRUPT_TIMER1           3   // Timer 1 Overflow
           =2 #define INTERRUPT_UART0            4   // UART0
           =2 #define INTERRUPT_TIMER2           5   // Timer 2 Overflow
           =2 #define INTERRUPT_SPI0             6   // SPI0
           =2 #define INTERRUPT_SMBUS0           7   // SMBus0 Interface
           =2 #define INTERRUPT_ADC0_WINDOW      8   // ADC0 Window Comparison
           =2 #define INTERRUPT_ADC0_EOC         9   // ADC0 End Of Conversion
           =2 #define INTERRUPT_PCA0            10   // PCA0 Peripheral
           =2 #define INTERRUPT_COMPARATOR0     11   // Comparator 0 Comparison
           =2 #define INTERRUPT_COMPARATOR1     12   // Comparator 1 Comparison
           =2 #define INTERRUPT_TIMER3          13   // Timer 3 Overflow
           =2 #define INTERRUPT_LIN0            14   // LIN Bus Interrupt
           =2 #define INTERRUPT_VREG            15   // Voltage Regulator
           =2 #define INTERRUPT_CAN0            16   // CAN Bus Interrupt
           =2 #define INTERRUPT_PORT_MATCH      17   // Port Match
           =2 #define INTERRUPT_UART1           18   // UART1
           =2 #define INTERRUPT_PCA1            19   // PCA1 Peripheral
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 47  

           =2 #define INTERRUPT_COMPARATOR2     20   // Comparator 2 Comparison
           =2 #define INTERRUPT_TIMER4          21   // Timer 4 Overflow
           =2 #define INTERRUPT_TIMER5          22   // Timer 5 Overflow
           =2 
           =2 
           =2 //-----------------------------------------------------------------------------
           =2 // SFR Page Definitions
           =2 //-----------------------------------------------------------------------------
           =2 
           =2 #define  CONFIG_PAGE       0x0F        // System and Port Configuration Page
           =2 #define  ACTIVE_PAGE       0x00        // Active Use Page
           =2 #define  ACTIVE2_PAGE      0x10        // Active Use Page 2
           =2 #define  CAN0_PAGE         0x0C        // CAN0 Registers
           =2 
           =2 //-----------------------------------------------------------------------------
           =2 // SDCC PDATA External Memory Paging Support
           =2 //-----------------------------------------------------------------------------
           =2 
           =2 #if defined SDCC
           =2 
           =2 SFR(_XPAGE, 0xAA); // Point to the EMI0CN register
           =2 
           =2 #endif
           =2 
           =2 //-----------------------------------------------------------------------------
           =2 // Header File PreProcessor Directive
           =2 //-----------------------------------------------------------------------------
           =2 
           =2 #endif                                 // #define C8051F580_DEFS_H
 607      =2  
 608      =2  //-----------------------------------------------------------------------------
 609      =2  // End Of File
 610      =2  //-----------------------------------------------------------------------------
   5      =1  /* ----- Global Define -------------------------------*/
   6      =1  
   7      =1  /*----------------------------------------------------*/
   8      =1  
   9      =1  /* ----- Global Value --------------------------------*/
  10      =1  
  11      =1  /*----------------------------------------------------*/
  12      =1  
  13      =1  /* ----- Function ------------------------------------*/
  14      =1  
  15      =1  void Watchdog_Init(void);
  16      =1  void WDT_Clear(void);
  17      =1  void PCA_Init(void);
  18      =1  /*----------------------------------------------------*/
  19      =1  
  20      =1  /* ----- Extern Function -----------------------------*/
  21      =1  
  22      =1  /*----------------------------------------------------*/
  23      =1  #endif
   8          #include "drv_spi.h"
   1      =1  #ifndef DRV_SPI_H
   2      =1  #define DRV_SPI_H
   3      =1  
   4      =1  // Target MCU Commands
   5      =1  #define TGT_CMD_ENTER_BL_MODE    (0x90U)
   6      =1  #define TGT_CMD_GET_INFO         (0x91U)
   7      =1  #define TGT_CMD_SET_FLASH_KEYS   (0x92U)
   8      =1  #define TGT_CMD_SET_ADDR         (0x93U)
   9      =1  #define TGT_CMD_ERASE_PAGE       (0x94U)
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 48  

  10      =1  #define TGT_CMD_WRITE_FLASH      (0x95U)
  11      =1  #define TGT_CMD_GET_PAGE_CRC     (0x96U)
  12      =1  #define TGT_CMD_WRITE_SIGNATURE  (0x97U)
  13      =1  #define TGT_CMD_SW_RESET         (0x98U)
  14      =1  #define TGT_CMD_SW_INFO          (0x9FU)
  15      =1  
  16      =1  // EEPROM
  17      =1  #define  EEPROM_CAPACITY                        (1048576)       // EEPROM Capacity (bytes)
  18      =1  #define  EEPROM_PAGE_SIZE                       (256)           // EEPROM Page Size (bytes)
  19      =1  #define  EEPROM_SECTOR_SIZE                     (4096)          // EEPROM Sector Size (bytes)
  20      =1  #define  EEPROM_BLOCK_SIZE                      (65536)         // EEPROM Block Size (bytes)
  21      =1  #define  EEPROM_CMD_WREN                        (0x06U)         // write enable
  22      =1  #define  EEPROM_CMD_RDDT                        (0x03U)         // read data
  23      =1  #define  EEPROM_CMD_WRDI                        (0x04U)         // write disable
  24      =1  #define  EEPROM_CMD_RDSR                        (0x05U)         // status register read
  25      =1  #define  EEPROM_CMD_FAST_READ           (0x0BU)         // +AD1,AD2,AD3+Dummy fast read data
  26      =1  #define  EEPROM_CMD_REMS                        (0x90U)         // +Dummy,Dummy,ADD read electronic manufacturer & device ID)
  27      =1  #define  EEPROM_CMD_SE                          (0x20U)         // +AD1,AD2,AD3 sector erase (4KB) 0~255 sector
  28      =1  #define  EEPROM_CMD_PP                          (0x02U)         // +AD1,AD2,AD3 page program (256 byte)
  29      =1  #define  EEPROM_STATUS_WIP                      (0x01U)         // write in progress bit
  30      =1  
  31      =1  // Reserved space first byte
  32      =1  #define RESERVED_SPACE_ADDR                     (31*1024)       // 0x7C00U
  33      =1  
  34      =1  void Flash_Wait(void);
  35      =1  void Flash_DataSet(U8 flash_data);
  36      =1  void Flash_Slave_Select(void);
  37      =1  void Flash_Slave_Command(U8 flash_cmd);
  38      =1  void Update_Flash_Proc(U8 Mode, U8 Buf);
  39      =1  void Flash_EraseSector( U32 Addr );
  40      =1  void Spi_Init (void);
  41      =1  U8      Check_Flash_ID( void );
  42      =1  U8 spi_master_read(U8 addr);
  43      =1  void spi_master_write(U8 addr, U8 dat);
  44      =1  void    Flash_Write( U32 Addr,U8 *Data, U16 Len );
  45      =1  U8      Read_Guide_Value( U8 *Value );
  46      =1  #endif
  47      =1  
  48      =1  
   9          #include "drv_i2c.h"
   1      =1  #ifndef DRV_I2C_H
   2      =1  #define DRV_I2C_H
   3      =1  
   4      =1  
   5      =1  /* ----- Global Define -------------------------------*/
   6      =1  #define  WRITE          0x00           // SMBus WRITE command
   7      =1  #define  READ           0x01U           // SMBus READ command
   8      =1  #define  SMB_MTSTA      0xE0U           // (MT) start transmitted
   9      =1  #define  SMB_MTDB       0xC0U           // (MT) data byte transmitted
  10      =1  #define  SMB_MRDB       0x80U           // (MR) data byte received
  11      =1  
  12      =1  #define  I2C_1BYTE_RW   0x01U           // (MR) data byte received
  13      =1  #define  I2C_2BYTE_RW   0x02U           // (MR) data byte received
  14      =1  
  15      =1  #if defined(APTINA_AP0100)
  16      =1  #define ISP_SLAVE_ADDRESS       0x90U
  17      =1  #endif
  18      =1  
  19      =1  #if defined(APTINA_AP0100)
  20      =1  #define ISP_SLAVE_ADDRESS       0x90U
  21      =1  #endif
  22      =1  /*----------------------------------------------------*/
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 49  

  23      =1  
  24      =1  
  25      =1  /* ----- Global Value --------------------------------*/
  26      =1  
  27      =1  /*----------------------------------------------------*/
  28      =1  
  29      =1  
  30      =1  /* ----- Function ------------------------------------*/
  31      =1  void SMBUS0_Init (void);
  32      =1  void SMB_Write (void);
  33      =1  void SMB_Read (void);
  34      =1  U16      i2c_master_read(U8 slave_addr, U16 addr, U8 Byte_Length);
  35      =1  void i2c_master_write(U8 slave_addr, U16 addr, U16 dat, U8 Byte_Length);
  36      =1  
  37      =1  /*----------------------------------------------------*/
  38      =1  
  39      =1  
  40      =1  /* ----- INTERRUPT -----------------------------------*/
  41      =1  INTERRUPT_PROTO (TIMER3_ISR, INTERRUPT_TIMER3);
  42      =1  INTERRUPT_PROTO (SMBUS0_ISR, INTERRUPT_SMBUS0);
  43      =1  /*----------------------------------------------------*/
  44      =1  
  45      =1  /* ----- Extern Function -----------------------------*/
  46      =1  extern SEG_XDATA volatile U8 g_I2C_Err_Cnt;
  47      =1  /*----------------------------------------------------*/
  48      =1  
  49      =1  #endif
  50      =1  
  51      =1  
  10          #include "drv_adc.h"
   1      =1  #ifndef DRV_ADC_H
   2      =1  #define DRV_ADC_H
   3      =1  
   4      =1  
   5      =1  /* ----- Global Define -------------------------------*/
   6      =1  
   7      =1  /*----------------------------------------------------*/
   8      =1  
   9      =1  /* ----- Global Value --------------------------------*/
  10      =1  
  11      =1  /*----------------------------------------------------*/
  12      =1  
  13      =1  
  14      =1  /* ----- Function ------------------------------------*/
  15      =1  void ADC_Init(void);
  16      =1  U8 Get_Video_Signal(void);
  17      =1  U8 Get_Temperature(void);
  18      =1  /*----------------------------------------------------*/
  19      =1  
  20      =1  
  21      =1  /* ----- INTERRUPT -----------------------------------*/
  22      =1  
  23      =1  /*----------------------------------------------------*/
  24      =1  
  25      =1  /* ----- Extern Function -----------------------------*/
  26      =1  extern SEG_XDATA U16 RESULT;
  27      =1  /*----------------------------------------------------*/
  28      =1  
  29      =1  #endif
  30      =1  
  11          #include "drv_mem.h"
   1      =1  /* ----- Global Define -------------------------------*/
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 50  

   2      =1  
   3      =1  /*----------------------------------------------------*/
   4      =1  
   5      =1  /* ----- Global Value --------------------------------*/
   6      =1  
   7      =1  /*----------------------------------------------------*/
   8      =1  
   9      =1  /* ----- Function ------------------------------------*/
  10      =1  
  11      =1  /*----------------------------------------------------*/
  12      =1  
  13      =1  /* ----- Extern Function -----------------------------*/
  14      =1  
  15      =1  /*----------------------------------------------------*/
  16      =1  #ifndef DRV_MEM_H_
  17      =1  #define DRV_MEM_H_
  18      =1  
  19      =1  #include "compiler_defs.h"
   1      =2  //-----------------------------------------------------------------------------
   2      =2  // compiler_defs.h
   3      =2  //-----------------------------------------------------------------------------
   4      =2  // Portions of this file are copyright Maarten Brock
   5      =2  // http://sdcc.sourceforge.net
   6      =2  // Portions of this file are copyright 2010, Silicon Laboratories, Inc.
   7      =2  // http://www.silabs.com
   8      =2  //
   9      =2  // GNU LGPL boilerplate:
  10      =2  /** This library is free software; you can redistribute it and/or
  11      =2    * modify it under the terms of the GNU Lesser General Public
  12      =2    * License as published by the Free Software Foundation; either
  13      =2    * version 2.1 of the License, or (at your option) any later version.
  14      =2    *
  15      =2    * This library is distributed in the hope that it will be useful,
  16      =2    * but WITHOUT ANY WARRANTY; without even the implied warranty of
  17      =2    * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
  18      =2    * Lesser General Public License for more details.
  19      =2    *
  20      =2    * You should have received a copy of the GNU Lesser General Public
  21      =2    * License along with this library; if not, write to the Free Software
  22      =2    * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
  23      =2    *
  24      =2    * In other words, you are welcome to use, share and improve this program.
  25      =2    * You are forbidden to forbid anyone else to use, share and improve
  26      =2    * what you give them. Help stamp out software-hoarding!
  27      =2  **/
  28      =2  // Program Description:
  29      =2  //
  30      =2  // **Important Note**: This header file should be included before including
  31      =2  // a device-specific header file such as C8051F300_defs.h.
  32      =2  //
  33      =2  // Macro definitions to accomodate 8051 compiler differences in specifying
  34      =2  // special function registers and other 8051-specific features such as NOP
  35      =2  // generation, and locating variables in memory-specific segments.  The
  36      =2  // compilers are identified by their unique predefined macros. See also:
  37      =2  // http://predef.sourceforge.net/precomp.html
  38      =2  //
  39      =2  // SBIT and SFR define special bit and special function registers at the given
  40      =2  // address. SFR16 and SFR32 define sfr combinations at adjacent addresses in
  41      =2  // little-endian format. SFR16E and SFR32E define sfr combinations without
  42      =2  // prerequisite byte order or adjacency. None of these multi-byte sfr
  43      =2  // combinations will guarantee the order in which they are accessed when read
  44      =2  // or written.
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 51  

  45      =2  //
  46      =2  // SFR16X and SFR32X for 16 bit and 32 bit xdata registers are not defined
  47      =2  // to avoid portability issues because of compiler endianness.
  48      =2  //
  49      =2  // Example:
  50      =2  // // my_mcu.c: main 'c' file for my mcu
  51      =2  // #include <compiler_defs.h>  // this file
  52      =2  // #include <C8051xxxx_defs.h> // SFR definitions for specific MCU target
  53      =2  //
  54      =2  // SBIT  (P0_1, 0x80, 1);      // Port 0 pin 1
  55      =2  // SFR   (P0, 0x80);           // Port 0
  56      =2  // SFRX  (CPUCS, 0xE600);      // Cypress FX2 Control and Status register in
  57      =2  //                             // xdata memory at 0xE600
  58      =2  // SFR16 (TMR2, 0xCC);         // Timer 2, lsb at 0xCC, msb at 0xCD
  59      =2  // SFR16E(TMR0, 0x8C8A);       // Timer 0, lsb at 0x8A, msb at 0x8C
  60      =2  // SFR32 (MAC0ACC, 0x93);      // SiLabs C8051F120 32 bits MAC0 Accumulator,
  61      =2  //                             // lsb at 0x93, msb at 0x96
  62      =2  // SFR32E(SUMR, 0xE5E4E3E2);   // TI MSC1210 SUMR 32 bits Summation register,
  63      =2  //                             // lsb at 0xE2, msb at 0xE5
  64      =2  //
  65      =2  // Target:         C8051xxxx
  66      =2  // Tool chain:     Generic
  67      =2  // Command Line:   None
  68      =2  // 
  69      =2  // Release 2.6 - 14 DEC 2012 (GO)
  70      =2  //        -Added define for deprecated SDCC keyword 'at'
  71      =2  // Release 2.5 - 12 SEP 2012 (TP)
  72      =2  //    -Added defines for deprecated SDCC keywords bit and code
  73      =2  // Release 2.4 - 27 AUG 2012 (TP)
  74      =2  //    -Added defines for deprecated SDCC keywords interrupt, _asm, and _endasm
  75      =2  // Release 2.3 - 27 MAY 2010 (DM)
  76      =2  //    -Removed 'LOCATED_VARIABLE' pragma from Keil because it is not supported
  77      =2  // Release 2.2 - 06 APR 2010 (ES)
  78      =2  //    -Removed 'PATHINCLUDE' pragma from Raisonance section
  79      =2  // Release 2.1 - 16 JUL 2009 (ES)
  80      =2  //    -Added SEGMENT_POINTER macro definitions for SDCC, Keil, and Raisonance
  81      =2  //    -Added LOCATED_VARIABLE_NO_INIT macro definitions for Raisonance
  82      =2  // Release 2.0 - 19 MAY 2009 (ES)
  83      =2  //    -Added LOCATED_VARIABLE_NO_INIT macro definitions for SDCC and Keil
  84      =2  // Release 1.9 - 23 OCT 2008 (ES)
  85      =2  //    -Updated Hi-Tech INTERRUPT and INTERRUPT_USING macro definitions
  86      =2  //    -Added SFR16 macro defintion for Hi-Tech
  87      =2  // Release 1.8 - 31 JUL 2008 (ES)
  88      =2  //    -Added INTERRUPT_USING and FUNCTION_USING macro's
  89      =2  //    -Added macro's for IAR
  90      =2  //    -Corrected Union definitions for Hi-Tech and added SFR16 macro defintion
  91      =2  // Release 1.7 - 11 SEP 2007 (BW)
  92      =2  //    -Added support for Raisonance EVAL 03.03.42 and Tasking Eval 7.2r1
  93      =2  // Release 1.6 - 27 AUG 2007 (BW)
  94      =2  //    -Updated copyright notice per agreement with Maartin Brock
  95      =2  //    -Added SDCC 2.7.0 "compiler.h" bug fixes
  96      =2  //    -Added memory segment defines (SEG_XDATA, for example)
  97      =2  // Release 1.5 - 24 AUG 2007 (BW)
  98      =2  //    -Added support for NOP () macro
  99      =2  //    -Added support for Hi-Tech ver 9.01
 100      =2  // Release 1.4 - 07 AUG 2007 (PKC)
 101      =2  //    -Removed FID and fixed formatting.
 102      =2  // Release 1.3 - 30 SEP 2007 (TP)
 103      =2  //    -Added INTERRUPT_PROTO_USING to properly support ISR context switching
 104      =2  //     under SDCC.
 105      =2  // Release 1.2 - (BW)
 106      =2  //    -Added support for U8,U16,U32,S8,S16,S32,UU16,UU32 data types
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 52  

 107      =2  // Release 1.1 - (BW)
 108      =2  //    -Added support for INTERRUPT, INTERRUPT_USING, INTERRUPT_PROTO,
 109      =2  //     SEGMENT_VARIABLE, VARIABLE_SEGMENT_POINTER,
 110      =2  //     SEGMENT_VARIABLE_SEGMENT_POINTER, and LOCATED_VARIABLE
 111      =2  // Release 1.0 - 29 SEP 2006 (PKC)
 112      =2  //    -Initial revision
 113      =2  
 114      =2  //-----------------------------------------------------------------------------
 115      =2  // Header File Preprocessor Directive
 116      =2  //-----------------------------------------------------------------------------
 117      =2  
 118      =2  #ifndef COMPILER_DEFS_H
           =2 #define COMPILER_DEFS_H
           =2 
           =2 //-----------------------------------------------------------------------------
           =2 // Macro definitions
           =2 //-----------------------------------------------------------------------------
           =2 
           =2 // SDCC - Small Device C Compiler
           =2 // http://sdcc.sourceforge.net
           =2 
           =2 #if defined SDCC
           =2 
           =2 #if (SDCC >= 300)
           =2 
           =2 #define interrupt __interrupt
           =2 #define _asm __asm
           =2 #define _endasm __endasm
           =2 #define bit __bit
           =2 #define code __code
           =2 #define at __at
           =2 
           =2 #endif
           =2 
           =2 # define SEG_GENERIC
           =2 # define SEG_FAR   __xdata
           =2 # define SEG_DATA  __data
           =2 # define SEG_NEAR  __data
           =2 # define SEG_IDATA __idata
           =2 # define SEG_XDATA __xdata
           =2 # define SEG_PDATA __pdata
           =2 # define SEG_CODE  __code
           =2 # define SEG_BDATA __bdata
           =2 
           =2 # define SBIT(name, addr, bit)  __sbit  __at(addr+bit)                  name
           =2 # define SFR(name, addr)        __sfr   __at(addr)                      name
           =2 # define SFRX(name, addr)       xdata volatile unsigned char __at(addr) name
           =2 # define SFR16(name, addr)      __sfr16 __at(((addr+1U)<<8) | addr)     name
           =2 # define SFR16E(name, fulladdr) __sfr16 __at(fulladdr)                  name
           =2 # define SFR32(name, addr)      __sfr32 __at(((addr+3UL)<<24) | ((addr+2UL)<<16) | ((addr+1UL)<<8) | addr)
             - name
           =2 # define SFR32E(name, fulladdr) __sfr32 __at(fulladdr)                  name
           =2 
           =2 # define INTERRUPT(name, vector) void name (void) interrupt (vector)
           =2 # define INTERRUPT_USING(name, vector, regnum) void name (void) interrupt (vector) using (regnum)
           =2 # define INTERRUPT_PROTO(name, vector) void name (void) interrupt (vector)
           =2 # define INTERRUPT_PROTO_USING(name, vector, regnum) void name (void) interrupt (vector) using (regnum)
           =2 
           =2 # define FUNCTION_USING(name, return_value, parameter, regnum) return_value name (parameter) using (regnum
             -)
           =2 # define FUNCTION_PROTO_USING(name, return_value, parameter, regnum) return_value name (parameter) using (
             -regnum)
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 53  

           =2 // Note: Parameter must be either 'void' or include a variable type and name. (Ex: char temp_variable)
           =2 
           =2 # define SEGMENT_VARIABLE(name, vartype, locsegment) locsegment vartype name
           =2 # define VARIABLE_SEGMENT_POINTER(name, vartype, targsegment) targsegment vartype * name
           =2 # define SEGMENT_VARIABLE_SEGMENT_POINTER(name, vartype, targsegment, locsegment) targsegment vartype * lo
             -csegment name
           =2 # define SEGMENT_POINTER(name, vartype, locsegment) vartype * locsegment name
           =2 # define LOCATED_VARIABLE(name, vartype, locsegment, addr, init) locsegment at (addr) vartype name = init
           =2 # define LOCATED_VARIABLE_NO_INIT(name, vartype, locsegment, addr) locsegment at (addr) vartype name
           =2 
           =2 // used with UU16
           =2 # define LSB 0
           =2 # define MSB 1
           =2 
           =2 // used with UU32 (b0 is least-significant byte)
           =2 //# define b0 0
           =2 //# define b1 1
           =2 //# define b2 2
           =2 //# define b3 3
           =2 
           =2 typedef unsigned char U8;
           =2 typedef unsigned int U16;
           =2 typedef unsigned long U32;
           =2 
           =2 typedef signed char S8;
           =2 typedef signed int S16;
           =2 typedef signed long S32;
           =2 
           =2 typedef union UU16
           =2 {
           =2    U16 U16;
           =2    S16 S16;
           =2    U8 U8[2];
           =2    S8 S8[2];
           =2 } UU16;
           =2 
           =2 typedef union UU32
           =2 {
           =2    U32 U32;
           =2    S32 S32;
           =2    UU16 UU16[2];
           =2    U16 U16[2];
           =2    S16 S16[2];
           =2    U8 U8[4];
           =2    S8 S8[4];
           =2 } UU32;
           =2 
           =2 // NOP () macro support
           =2 #define NOP() _asm NOP _endasm
           =2 
           =2 
           =2 //-----------------------------------------------------------------------------
           =2 
           =2 // Raisonance (must be placed before Keil C51)
           =2 // http://www.raisonance.com
           =2 
           =2 #elif defined __RC51__
           =2 
           =2 //#error Raisonance C51 detected.
           =2 
           =2 # define SEG_GENERIC generic     //SEG_GENERIC only applies to pointers in Raisonance, not variables.
           =2 # define SEG_FAR   xdata
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 54  

           =2 # define SEG_DATA  data
           =2 # define SEG_NEAR  data
           =2 # define SEG_IDATA idata
           =2 # define SEG_XDATA xdata
           =2 # define SEG_PDATA pdata
           =2 # define SEG_CODE  code
           =2 # define SEG_BDATA bdata
           =2 
           =2 # define SBIT(name, addr, bit)  at (addr+bit) sbit         name
           =2 # define SFR(name, addr)        sfr at addr                name
           =2 # define SFR16(name, addr)      sfr16 at addr              name
           =2 # define SFR16E(name, fulladdr) /* not supported */
           =2 # define SFR32(name, fulladdr)  /* not supported */
           =2 # define SFR32E(name, fulladdr) /* not supported */
           =2 
           =2 # define INTERRUPT(name, vector) void name (void) interrupt vector
           =2 # define INTERRUPT_USING(name, vector, regnum) void name (void) interrupt vector using regnum
           =2 # define INTERRUPT_PROTO(name, vector) void name (void)
           =2 # define INTERRUPT_PROTO_USING(name, vector, regnum) void name (void)
           =2 
           =2 # define FUNCTION_USING(name, return_value, parameter, regnum) return_value name (parameter) using regnum
           =2 # define FUNCTION_PROTO_USING(name, return_value, parameter, regnum) return_value name (parameter)
           =2 // Note: Parameter must be either 'void' or include a variable type and name. (Ex: char temp_variable)
           =2 
           =2 # define SEGMENT_VARIABLE(name, vartype, locsegment) vartype locsegment name
           =2 # define VARIABLE_SEGMENT_POINTER(name, vartype, targsegment) vartype targsegment * name
           =2 # define SEGMENT_VARIABLE_SEGMENT_POINTER(name, vartype, targsegment, locsegment) vartype targsegment * lo
             -csegment name
           =2 # define SEGMENT_POINTER(name, vartype, locsegment) vartype * locsegment name
           =2 # define LOCATED_VARIABLE(name, vartype, locsegment, addr, init) at addr locsegment vartype name
           =2 # define LOCATED_VARIABLE_NO_INIT(name, vartype, locsegment, addr) at addr locsegment vartype name
           =2 
           =2 
           =2 // used with UU16
           =2 # define LSB 1
           =2 # define MSB 0
           =2 
           =2 // used with UU32 (b0 is least-significant byte)
           =2 //# define b0 3
           =2 //# define b1 2
           =2 //# define b2 1
           =2 //# define b3 0
           =2 
           =2 typedef unsigned char U8;
           =2 typedef unsigned int U16;
           =2 typedef unsigned long U32;
           =2 
           =2 typedef signed char S8;
           =2 typedef signed int S16;
           =2 typedef signed long S32;
           =2 
           =2 typedef union UU16
           =2 {
           =2    U16 U16;
           =2    S16 S16;
           =2    U8 U8[2];
           =2    S8 S8[2];
           =2 } UU16;
           =2 
           =2 typedef union UU32
           =2 {
           =2    U32 U32;
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 55  

           =2    S32 S32;
           =2    UU16 UU16[2];
           =2    U16 U16[2];
           =2    S16 S16[2];
           =2    U8 U8[4];
           =2    S8 S8[4];
           =2 } UU32;
           =2 
           =2 // NOP () macro support -- NOP is opcode 0x00
           =2 #define NOP() asm { 0x00 }
           =2 
           =2 
           =2 //-----------------------------------------------------------------------------
           =2 
           =2 
           =2 // Keil C51
           =2 // http://www.keil.com
           =2 
           =2 #elif defined __C51__
           =2 
           =2 //#error Keil C51 detected.
           =2 
           =2 # define SEG_GENERIC
           =2 # define SEG_FAR   xdata
           =2 # define SEG_DATA  data
           =2 # define SEG_NEAR  data
           =2 # define SEG_IDATA idata
           =2 # define SEG_XDATA xdata
           =2 # define SEG_PDATA pdata
           =2 # define SEG_CODE  code
           =2 # define SEG_BDATA bdata
           =2 
           =2 # define SBIT(name, addr, bit)  sbit  name = addr^bit
           =2 # define SFR(name, addr)        sfr   name = addr
           =2 # define SFR16(name, addr)      sfr16 name = addr
           =2 # define SFR16E(name, fulladdr) /* not supported */
           =2 # define SFR32(name, fulladdr)  /* not supported */
           =2 # define SFR32E(name, fulladdr) /* not supported */
           =2 
           =2 # define INTERRUPT(name, vector) void name (void) interrupt vector
           =2 # define INTERRUPT_USING(name, vector, regnum) void name (void) interrupt vector using regnum
           =2 # define INTERRUPT_PROTO(name, vector) void name (void)
           =2 # define INTERRUPT_PROTO_USING(name, vector, regnum) void name (void)
           =2 
           =2 # define FUNCTION_USING(name, return_value, parameter, regnum) return_value name (parameter) using regnum
           =2 # define FUNCTION_PROTO_USING(name, return_value, parameter, regnum) return_value name (parameter)
           =2 // Note: Parameter must be either 'void' or include a variable type and name. (Ex: char temp_variable)
           =2 
           =2 # define SEGMENT_VARIABLE(name, vartype, locsegment) vartype locsegment name
           =2 # define VARIABLE_SEGMENT_POINTER(name, vartype, targsegment) vartype targsegment * name
           =2 # define SEGMENT_VARIABLE_SEGMENT_POINTER(name, vartype, targsegment, locsegment) vartype targsegment * lo
             -csegment name
           =2 # define SEGMENT_POINTER(name, vartype, locsegment) vartype * locsegment name
           =2 # define LOCATED_VARIABLE_NO_INIT(name, vartype, locsegment, addr) vartype locsegment name _at_ addr
           =2 
           =2 // used with UU16
           =2 # define LSB 1
           =2 # define MSB 0
           =2 
           =2 // used with UU32 (b0 is least-significant byte)
           =2 //# define b0 3
           =2 // define b1 2
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 56  

           =2 //# define b2 1
           =2 //# define b3 0
           =2 
           =2 typedef unsigned char U8;
           =2 typedef unsigned int U16;
           =2 typedef unsigned long U32;
           =2 
           =2 typedef signed char S8;
           =2 typedef signed int S16;
           =2 typedef signed long S32;
           =2 
           =2 typedef union UU16
           =2 {
           =2    U16 U16;
           =2    S16 S16;
           =2    U8 U8[2];
           =2    S8 S8[2];
           =2 } UU16;
           =2 
           =2 typedef union UU32
           =2 {
           =2    U32 U32;
           =2    S32 S32;
           =2    UU16 UU16[2];
           =2    U16 U16[2];
           =2    S16 S16[2];
           =2    U8 U8[4];
           =2    S8 S8[4];
           =2 } UU32;
           =2 
           =2 // NOP () macro support
           =2 extern void _nop_ (void);
           =2 #define NOP() _nop_()
           =2 
           =2 //-----------------------------------------------------------------------------
           =2 
           =2 // Hi-Tech 8051
           =2 // http://www.htsoft.com
           =2 
           =2 #elif defined HI_TECH_C
           =2 
           =2 # define SEG_GENERIC
           =2 # define SEG_FAR   far
           =2 # define SEG_DATA  data
           =2 # define SEG_NEAR  near
           =2 # define SEG_IDATA idata
           =2 # define SEG_XDATA xdata
           =2 # define SEG_PDATA pdata
           =2 # define SEG_CODE  code
           =2 # define SEG_BDATA bdata
           =2 
           =2 
           =2 # define SBIT(name, addr, thebit) static volatile bit name @ (addr + thebit)
           =2 # define SFR(name, addr)          static volatile unsigned char name @ addr
           =2 # define SFR16(name, addr)        static volatile unsigned int name @ addr
           =2 # define SFR16E(name, fulladdr) /* not supported */
           =2 # define SFR32(name, fulladdr)  /* not supported */
           =2 # define SFR32E(name, fulladdr) /* not supported */
           =2 
           =2 # define INTERRUPT(name, vector)       void name (void) interrupt vector
           =2 # define INTERRUPT_PROTO(name, vector)
           =2 # define INTERRUPT_USING(name, vector, regnum) void name (void) interrupt vector using regnum
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 57  

           =2 # define INTERRUPT_PROTO_USING(name, vector, regnum)
           =2 
           =2 # define FUNCTION_USING(name, return_value, parameter, regnum) /* not supported */
           =2 # define FUNCTION_PROTO_USING(name, return_value, parameter, regnum) /* not supported */
           =2 // Note: Hi-Tech does not support functions using different register banks. Register
           =2 //       banks can only be specified in interrupts. If a function is called from
           =2 //       inside an interrupt, it will use the same register bank as the interrupt.
           =2 
           =2 # define SEGMENT_VARIABLE(name, vartype, locsegment) locsegment vartype name
           =2 # define VARIABLE_SEGMENT_POINTER(name, vartype, targsegment) targsegment vartype * name
           =2 # define SEGMENT_VARIABLE_SEGMENT_POINTER(name, vartype, targsegment, locsegment) targsegment vartype * lo
             -csegment name
           =2 # define LOCATED_VARIABLE(name, vartype, locsegment, addr, init) locsegment vartype name @ addr
           =2 
           =2 // used with UU16
           =2 # define LSB 0
           =2 # define MSB 1
           =2 
           =2 // used with UU32 (b0 is least-significant byte)
           =2 # define b0 0
           =2 # define b1 1
           =2 # define b2 2
           =2 # define b3 3
           =2 
           =2 typedef unsigned char U8;
           =2 typedef unsigned int U16;
           =2 typedef unsigned long U32;
           =2 
           =2 typedef signed char S8;
           =2 typedef signed int S16;
           =2 typedef signed long S32;
           =2 
           =2 typedef union UU16
           =2 {
           =2    U16 U16;
           =2    S16 S16;
           =2    U8 U8[2];
           =2    S8 S8[2];
           =2 } UU16;
           =2 
           =2 typedef union UU32
           =2 {
           =2    U32 U32;
           =2    S32 S32;
           =2    UU16 UU16[2];
           =2    U16 U16[2];
           =2    S16 S16[2];
           =2    U8 U8[4];
           =2    S8 S8[4];
           =2 } UU32;
           =2 
           =2 // NOP () macro support
           =2 #define NOP() asm(" nop ")
           =2 
           =2 //-----------------------------------------------------------------------------
           =2 
           =2 // Tasking / Altium
           =2 // http://www.altium.com/tasking
           =2 
           =2 
           =2 #elif defined _CC51
           =2 
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 58  

           =2 # define SEG_GENERIC
           =2 # define SEG_FAR   _xdat
           =2 # define SEG_DATA  _data
           =2 # define SEG_NEAR  _data
           =2 # define SEG_IDATA _idat
           =2 # define SEG_XDATA _xdat
           =2 # define SEG_PDATA _pdat
           =2 # define SEG_CODE  _rom
           =2 # define SEG_BDATA _bdat
           =2 
           =2 # define SBIT(name, addr, bit)  _sfrbit  name _at(addr+bit)
           =2 # define SFR(name, addr)        _sfrbyte name _at(addr)
           =2 # define SFRX(name, addr)       _xdat volatile unsigned char name _at(addr)
           =2 #if _CC51 > 71
           =2 # define SFR16(name, addr)      _sfrword _little name _at(addr)
           =2 #else
           =2 # define SFR16(name, addr)      /* not supported */
           =2 #endif
           =2 # define SFR16E(name, fulladdr) /* not supported */
           =2 # define SFR32(name, fulladdr)  /* not supported */
           =2 # define SFR32E(name, fulladdr) /* not supported */
           =2 
           =2 # define INTERRUPT(name, vector) _interrupt (vector) void name (void)
           =2 # define INTERRUPT_USING(name, vector, regnum) _interrupt (vector) _using(regnum) void name (void)
           =2 # define INTERRUPT_PROTO(name, vector) _interrupt (vector) void name (void)
           =2 # define INTERRUPT_PROTO_USING(name, vector, regnum) _interrupt (vector) _using(regnum) void name (void)
           =2 
           =2 // When calling FUNCTION_USING in Tasking, the function must be called from an interrupt or Main which
           =2 // is also using the same register bank. If not, the compiler will generate an error.
           =2 # define FUNCTION_USING(name, return_value, parameter, regnum) _using(regnum) return_value name (parameter
             -)
           =2 # define FUNCTION_PROTO_USING(name, return_value, parameter, regnum) _using(regnum) return_value name (par
             -ameter)
           =2 // Note: Parameter must be either 'void' or include a variable type and name. (Ex: char temp_variable)
           =2 
           =2 # define SEGMENT_VARIABLE(name, vartype, locsegment) vartype locsegment name
           =2 # define VARIABLE_SEGMENT_POINTER(name, vartype, targsegment) vartype targsegment * name
           =2 # define SEGMENT_VARIABLE_SEGMENT_POINTER(name, vartype, targsegment, locsegment) vartype targsegment * lo
             -csegment name
           =2 # define LOCATED_VARIABLE(name, vartype, locsegment, addr, init) vartype locsegment name _at( addr )
           =2 
           =2 // used with UU16
           =2 # define LSB 1
           =2 # define MSB 0
           =2 
           =2 // used with UU32 (b0 is least-significant byte)
           =2 //# define b0 3
           =2 //# define b1 2
           =2 //# define b2 1
           =2 //# define b3 0
           =2 
           =2 typedef unsigned char U8;
           =2 typedef unsigned int U16;
           =2 typedef unsigned long U32;
           =2 
           =2 typedef signed char S8;
           =2 typedef signed int S16;
           =2 typedef signed long S32;
           =2 
           =2 typedef union UU16
           =2 {
           =2    U16 U16;
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 59  

           =2    S16 S16;
           =2    U8 U8[2];
           =2    S8 S8[2];
           =2 } UU16;
           =2 
           =2 typedef union UU32
           =2 {
           =2    U32 U32;
           =2    S32 S32;
           =2    UU16 UU16[2];
           =2    U16 U16[2];
           =2    S16 S16[2];
           =2    U8 U8[4];
           =2    S8 S8[4];
           =2 } UU32;
           =2 
           =2 // NOP () macro support
           =2 extern void _nop (void);
           =2 #define NOP() _nop()
           =2 
           =2 //-----------------------------------------------------------------------------
           =2 
           =2 
           =2 // IAR 8051
           =2 // http://www.iar.com
           =2 
           =2 #elif defined __ICC8051__
           =2 
           =2 #include <stdbool.h>
           =2 #include <intrinsics.h>
           =2 
           =2 # define SBIT(name, addr, bit)  __bit __no_init volatile bool name @ (addr+bit)
           =2 # define SFR(name, addr)        __sfr __no_init volatile unsigned char name @ addr
           =2 # define SFRX(name, addr)       __xdata __no_init volatile unsigned char name @ addr
           =2 # define SFR16(name, addr)      __sfr __no_init volatile unsigned int  name @ addr
           =2 # define SFR16E(name, fulladdr) /* not supported */
           =2 # define SFR32(name, fulladdr) /* not supported */
           =2 # define SFR32E(name, fulladdr) /* not supported */
           =2 
           =2 # define SEG_GENERIC __generic
           =2 # define SEG_FAR  __xdata
           =2 # define SEG_DATA __data
           =2 # define SEG_NEAR __data
           =2 # define SEG_IDATA __idata
           =2 # define SEG_XDATA __xdata
           =2 # define SEG_PDATA __pdata
           =2 # define SEG_CODE  __code
           =2 # define SEG_BDATA __bdata
           =2 
           =2 #define bit bool
           =2 
           =2 # define _PPTOSTR_(x) #x
           =2 # define _PPARAM_(address) _PPTOSTR_(vector=address * 8 + 3)
           =2 # define _PPARAM2_(regbank) _PPTOSTR_(register_bank=regbank)
           =2 # define INTERRUPT(name, vector) _Pragma(_PPARAM_(vector)) __interrupt void name(void)
           =2 # define INTERRUPT_PROTO(name, vector)  __interrupt void name(void)
           =2 # define INTERRUPT_USING(name, vector, regnum) _Pragma(_PPARAM2_(regnum)) _Pragma(_PPARAM_(vector)) __inte
             -rrupt void name(void)
           =2 # define INTERRUPT_PROTO_USING(name, vector, regnum) __interrupt void name(void)
           =2 
           =2 # define FUNCTION_USING(name, return_value, parameter, regnum) /* not supported */
           =2 # define FUNCTION_PROTO_USING(name, return_value, parameter, regnum) /* not supported */
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 60  

           =2 // Note: IAR does not support functions using different register banks. Register
           =2 //       banks can only be specified in interrupts. If a function is called from
           =2 //       inside an interrupt, it will use the same register bank as the interrupt.
           =2 
           =2 # define SEGMENT_VARIABLE(name, vartype, locsegment)  locsegment vartype name
           =2 # define VARIABLE_SEGMENT_POINTER(name, vartype, targsegment) vartype targsegment  * name
           =2 # define SEGMENT_VARIABLE_SEGMENT_POINTER(name, vartype, targsegment, locsegment) vartype targsegment * lo
             -csegment name
           =2 
           =2 # define LOCATED_VARIABLE(name, vartype, locsegment, addr, init) locsegment __no_init vartype name @ addr
           =2 
           =2 // used with UU16
           =2 # define LSB 0
           =2 # define MSB 1
           =2 
           =2 // used with UU32 (b0 is least-significant byte)
           =2 //# define b0 0
           =2 //# define b1 1
           =2 //# define b2 2
           =2 //# define b3 3
           =2 
           =2 typedef unsigned char U8;
           =2 typedef unsigned int U16;
           =2 typedef unsigned long U32;
           =2 
           =2 typedef signed char S8;
           =2 typedef signed int S16;
           =2 typedef signed long S32;
           =2 
           =2 typedef union UU16
           =2 {
           =2    U16 U16;
           =2    S16 S16;
           =2    U8 U8[2];
           =2    S8 S8[2];
           =2 } UU16;
           =2 
           =2 typedef union UU32
           =2 {
           =2    U32 U32;
           =2    S32 S32;
           =2    UU16 UU16[2];
           =2    U16 U16[2];
           =2    S16 S16[2];
           =2    U8 U8[4];
           =2    S8 S8[4];
           =2 } UU32;
           =2 
           =2 
           =2 #define NOP() __no_operation();
           =2 //-----------------------------------------------------------------------------
           =2 
           =2 // Crossware
           =2 // http://www.crossware.com
           =2 
           =2 #elif defined _XC51_VER
           =2 # define SBIT(name, addr, bit)  _sfrbit  name = (addr+bit)
           =2 # define SFR(name, addr)        _sfr     name = addr
           =2 # define SFR16(name, addr)      _sfrword name = addr
           =2 # define SFR16E(name, fulladdr) /* not supported */
           =2 # define SFR32(name, fulladdr)  /* not supported */
           =2 # define SFR32E(name, fulladdr) /* not supported */
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 61  

           =2 
           =2 //-----------------------------------------------------------------------------
           =2 
           =2 // Wickenhäuser
           =2 // http://www.wickenhaeuser.de
           =2 
           =2 #elif defined __UC__
           =2 # define SBIT(name, addr, bit)  unsigned char bit  name @ (addr+bit)
           =2 # define SFR(name, addr)        near unsigned char name @ addr
           =2 # define SFR16(name, addr)      /* not supported */
           =2 # define SFR16E(name, fulladdr) /* not supported */
           =2 # define SFR32(name, fulladdr)  /* not supported */
           =2 # define SFR32E(name, fulladdr) /* not supported */
           =2 
           =2 //-----------------------------------------------------------------------------
           =2 
           =2 // Default
           =2 // Unknown compiler
           =2 
           =2 #else
           =2 # warning unrecognized compiler
           =2 # define SBIT(name, addr, bit)  volatile bool           name
           =2 # define SFR(name, addr)        volatile unsigned char  name
           =2 # define SFRX(name, addr)       volatile unsigned char  name
           =2 # define SFR16(name, addr)      volatile unsigned short name
           =2 # define SFR16E(name, fulladdr) volatile unsigned short name
           =2 # define SFR32(name, fulladdr)  volatile unsigned long  name
           =2 # define SFR32E(name, fulladdr) volatile unsigned long  name
           =2 
           =2 #endif
           =2 
           =2 //-----------------------------------------------------------------------------
           =2 // Header File PreProcessor Directive
           =2 //-----------------------------------------------------------------------------
           =2 
           =2 #endif                                 // #define COMPILER_DEFS_H
 689      =2  
 690      =2  //-----------------------------------------------------------------------------
 691      =2  // End Of File
 692      =2  //-----------------------------------------------------------------------------
  20      =1  #include "mgr_diag.h"
   1      =2  //#include "drv_i2c.h"
   2      =2  
   3      =2  #ifndef MGR_DIAG_H
   4      =2  #define MGR_DIAG_H
   5      =2  
   6      =2  #include "mgr_comm.h"
   1      =3  #ifndef MGR_COMM_H
   2      =3  #define MGR_COMM_H
   3      =3  
   4      =3  #include "compiler_defs.h"
   1      =4  //-----------------------------------------------------------------------------
   2      =4  // compiler_defs.h
   3      =4  //-----------------------------------------------------------------------------
   4      =4  // Portions of this file are copyright Maarten Brock
   5      =4  // http://sdcc.sourceforge.net
   6      =4  // Portions of this file are copyright 2010, Silicon Laboratories, Inc.
   7      =4  // http://www.silabs.com
   8      =4  //
   9      =4  // GNU LGPL boilerplate:
  10      =4  /** This library is free software; you can redistribute it and/or
  11      =4    * modify it under the terms of the GNU Lesser General Public
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 62  

  12      =4    * License as published by the Free Software Foundation; either
  13      =4    * version 2.1 of the License, or (at your option) any later version.
  14      =4    *
  15      =4    * This library is distributed in the hope that it will be useful,
  16      =4    * but WITHOUT ANY WARRANTY; without even the implied warranty of
  17      =4    * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
  18      =4    * Lesser General Public License for more details.
  19      =4    *
  20      =4    * You should have received a copy of the GNU Lesser General Public
  21      =4    * License along with this library; if not, write to the Free Software
  22      =4    * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
  23      =4    *
  24      =4    * In other words, you are welcome to use, share and improve this program.
  25      =4    * You are forbidden to forbid anyone else to use, share and improve
  26      =4    * what you give them. Help stamp out software-hoarding!
  27      =4  **/
  28      =4  // Program Description:
  29      =4  //
  30      =4  // **Important Note**: This header file should be included before including
  31      =4  // a device-specific header file such as C8051F300_defs.h.
  32      =4  //
  33      =4  // Macro definitions to accomodate 8051 compiler differences in specifying
  34      =4  // special function registers and other 8051-specific features such as NOP
  35      =4  // generation, and locating variables in memory-specific segments.  The
  36      =4  // compilers are identified by their unique predefined macros. See also:
  37      =4  // http://predef.sourceforge.net/precomp.html
  38      =4  //
  39      =4  // SBIT and SFR define special bit and special function registers at the given
  40      =4  // address. SFR16 and SFR32 define sfr combinations at adjacent addresses in
  41      =4  // little-endian format. SFR16E and SFR32E define sfr combinations without
  42      =4  // prerequisite byte order or adjacency. None of these multi-byte sfr
  43      =4  // combinations will guarantee the order in which they are accessed when read
  44      =4  // or written.
  45      =4  //
  46      =4  // SFR16X and SFR32X for 16 bit and 32 bit xdata registers are not defined
  47      =4  // to avoid portability issues because of compiler endianness.
  48      =4  //
  49      =4  // Example:
  50      =4  // // my_mcu.c: main 'c' file for my mcu
  51      =4  // #include <compiler_defs.h>  // this file
  52      =4  // #include <C8051xxxx_defs.h> // SFR definitions for specific MCU target
  53      =4  //
  54      =4  // SBIT  (P0_1, 0x80, 1);      // Port 0 pin 1
  55      =4  // SFR   (P0, 0x80);           // Port 0
  56      =4  // SFRX  (CPUCS, 0xE600);      // Cypress FX2 Control and Status register in
  57      =4  //                             // xdata memory at 0xE600
  58      =4  // SFR16 (TMR2, 0xCC);         // Timer 2, lsb at 0xCC, msb at 0xCD
  59      =4  // SFR16E(TMR0, 0x8C8A);       // Timer 0, lsb at 0x8A, msb at 0x8C
  60      =4  // SFR32 (MAC0ACC, 0x93);      // SiLabs C8051F120 32 bits MAC0 Accumulator,
  61      =4  //                             // lsb at 0x93, msb at 0x96
  62      =4  // SFR32E(SUMR, 0xE5E4E3E2);   // TI MSC1210 SUMR 32 bits Summation register,
  63      =4  //                             // lsb at 0xE2, msb at 0xE5
  64      =4  //
  65      =4  // Target:         C8051xxxx
  66      =4  // Tool chain:     Generic
  67      =4  // Command Line:   None
  68      =4  // 
  69      =4  // Release 2.6 - 14 DEC 2012 (GO)
  70      =4  //        -Added define for deprecated SDCC keyword 'at'
  71      =4  // Release 2.5 - 12 SEP 2012 (TP)
  72      =4  //    -Added defines for deprecated SDCC keywords bit and code
  73      =4  // Release 2.4 - 27 AUG 2012 (TP)
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 63  

  74      =4  //    -Added defines for deprecated SDCC keywords interrupt, _asm, and _endasm
  75      =4  // Release 2.3 - 27 MAY 2010 (DM)
  76      =4  //    -Removed 'LOCATED_VARIABLE' pragma from Keil because it is not supported
  77      =4  // Release 2.2 - 06 APR 2010 (ES)
  78      =4  //    -Removed 'PATHINCLUDE' pragma from Raisonance section
  79      =4  // Release 2.1 - 16 JUL 2009 (ES)
  80      =4  //    -Added SEGMENT_POINTER macro definitions for SDCC, Keil, and Raisonance
  81      =4  //    -Added LOCATED_VARIABLE_NO_INIT macro definitions for Raisonance
  82      =4  // Release 2.0 - 19 MAY 2009 (ES)
  83      =4  //    -Added LOCATED_VARIABLE_NO_INIT macro definitions for SDCC and Keil
  84      =4  // Release 1.9 - 23 OCT 2008 (ES)
  85      =4  //    -Updated Hi-Tech INTERRUPT and INTERRUPT_USING macro definitions
  86      =4  //    -Added SFR16 macro defintion for Hi-Tech
  87      =4  // Release 1.8 - 31 JUL 2008 (ES)
  88      =4  //    -Added INTERRUPT_USING and FUNCTION_USING macro's
  89      =4  //    -Added macro's for IAR
  90      =4  //    -Corrected Union definitions for Hi-Tech and added SFR16 macro defintion
  91      =4  // Release 1.7 - 11 SEP 2007 (BW)
  92      =4  //    -Added support for Raisonance EVAL 03.03.42 and Tasking Eval 7.2r1
  93      =4  // Release 1.6 - 27 AUG 2007 (BW)
  94      =4  //    -Updated copyright notice per agreement with Maartin Brock
  95      =4  //    -Added SDCC 2.7.0 "compiler.h" bug fixes
  96      =4  //    -Added memory segment defines (SEG_XDATA, for example)
  97      =4  // Release 1.5 - 24 AUG 2007 (BW)
  98      =4  //    -Added support for NOP () macro
  99      =4  //    -Added support for Hi-Tech ver 9.01
 100      =4  // Release 1.4 - 07 AUG 2007 (PKC)
 101      =4  //    -Removed FID and fixed formatting.
 102      =4  // Release 1.3 - 30 SEP 2007 (TP)
 103      =4  //    -Added INTERRUPT_PROTO_USING to properly support ISR context switching
 104      =4  //     under SDCC.
 105      =4  // Release 1.2 - (BW)
 106      =4  //    -Added support for U8,U16,U32,S8,S16,S32,UU16,UU32 data types
 107      =4  // Release 1.1 - (BW)
 108      =4  //    -Added support for INTERRUPT, INTERRUPT_USING, INTERRUPT_PROTO,
 109      =4  //     SEGMENT_VARIABLE, VARIABLE_SEGMENT_POINTER,
 110      =4  //     SEGMENT_VARIABLE_SEGMENT_POINTER, and LOCATED_VARIABLE
 111      =4  // Release 1.0 - 29 SEP 2006 (PKC)
 112      =4  //    -Initial revision
 113      =4  
 114      =4  //-----------------------------------------------------------------------------
 115      =4  // Header File Preprocessor Directive
 116      =4  //-----------------------------------------------------------------------------
 117      =4  
 118      =4  #ifndef COMPILER_DEFS_H
           =4 #define COMPILER_DEFS_H
           =4 
           =4 //-----------------------------------------------------------------------------
           =4 // Macro definitions
           =4 //-----------------------------------------------------------------------------
           =4 
           =4 // SDCC - Small Device C Compiler
           =4 // http://sdcc.sourceforge.net
           =4 
           =4 #if defined SDCC
           =4 
           =4 #if (SDCC >= 300)
           =4 
           =4 #define interrupt __interrupt
           =4 #define _asm __asm
           =4 #define _endasm __endasm
           =4 #define bit __bit
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 64  

           =4 #define code __code
           =4 #define at __at
           =4 
           =4 #endif
           =4 
           =4 # define SEG_GENERIC
           =4 # define SEG_FAR   __xdata
           =4 # define SEG_DATA  __data
           =4 # define SEG_NEAR  __data
           =4 # define SEG_IDATA __idata
           =4 # define SEG_XDATA __xdata
           =4 # define SEG_PDATA __pdata
           =4 # define SEG_CODE  __code
           =4 # define SEG_BDATA __bdata
           =4 
           =4 # define SBIT(name, addr, bit)  __sbit  __at(addr+bit)                  name
           =4 # define SFR(name, addr)        __sfr   __at(addr)                      name
           =4 # define SFRX(name, addr)       xdata volatile unsigned char __at(addr) name
           =4 # define SFR16(name, addr)      __sfr16 __at(((addr+1U)<<8) | addr)     name
           =4 # define SFR16E(name, fulladdr) __sfr16 __at(fulladdr)                  name
           =4 # define SFR32(name, addr)      __sfr32 __at(((addr+3UL)<<24) | ((addr+2UL)<<16) | ((addr+1UL)<<8) | addr)
             - name
           =4 # define SFR32E(name, fulladdr) __sfr32 __at(fulladdr)                  name
           =4 
           =4 # define INTERRUPT(name, vector) void name (void) interrupt (vector)
           =4 # define INTERRUPT_USING(name, vector, regnum) void name (void) interrupt (vector) using (regnum)
           =4 # define INTERRUPT_PROTO(name, vector) void name (void) interrupt (vector)
           =4 # define INTERRUPT_PROTO_USING(name, vector, regnum) void name (void) interrupt (vector) using (regnum)
           =4 
           =4 # define FUNCTION_USING(name, return_value, parameter, regnum) return_value name (parameter) using (regnum
             -)
           =4 # define FUNCTION_PROTO_USING(name, return_value, parameter, regnum) return_value name (parameter) using (
             -regnum)
           =4 // Note: Parameter must be either 'void' or include a variable type and name. (Ex: char temp_variable)
           =4 
           =4 # define SEGMENT_VARIABLE(name, vartype, locsegment) locsegment vartype name
           =4 # define VARIABLE_SEGMENT_POINTER(name, vartype, targsegment) targsegment vartype * name
           =4 # define SEGMENT_VARIABLE_SEGMENT_POINTER(name, vartype, targsegment, locsegment) targsegment vartype * lo
             -csegment name
           =4 # define SEGMENT_POINTER(name, vartype, locsegment) vartype * locsegment name
           =4 # define LOCATED_VARIABLE(name, vartype, locsegment, addr, init) locsegment at (addr) vartype name = init
           =4 # define LOCATED_VARIABLE_NO_INIT(name, vartype, locsegment, addr) locsegment at (addr) vartype name
           =4 
           =4 // used with UU16
           =4 # define LSB 0
           =4 # define MSB 1
           =4 
           =4 // used with UU32 (b0 is least-significant byte)
           =4 //# define b0 0
           =4 //# define b1 1
           =4 //# define b2 2
           =4 //# define b3 3
           =4 
           =4 typedef unsigned char U8;
           =4 typedef unsigned int U16;
           =4 typedef unsigned long U32;
           =4 
           =4 typedef signed char S8;
           =4 typedef signed int S16;
           =4 typedef signed long S32;
           =4 
           =4 typedef union UU16
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 65  

           =4 {
           =4    U16 U16;
           =4    S16 S16;
           =4    U8 U8[2];
           =4    S8 S8[2];
           =4 } UU16;
           =4 
           =4 typedef union UU32
           =4 {
           =4    U32 U32;
           =4    S32 S32;
           =4    UU16 UU16[2];
           =4    U16 U16[2];
           =4    S16 S16[2];
           =4    U8 U8[4];
           =4    S8 S8[4];
           =4 } UU32;
           =4 
           =4 // NOP () macro support
           =4 #define NOP() _asm NOP _endasm
           =4 
           =4 
           =4 //-----------------------------------------------------------------------------
           =4 
           =4 // Raisonance (must be placed before Keil C51)
           =4 // http://www.raisonance.com
           =4 
           =4 #elif defined __RC51__
           =4 
           =4 //#error Raisonance C51 detected.
           =4 
           =4 # define SEG_GENERIC generic     //SEG_GENERIC only applies to pointers in Raisonance, not variables.
           =4 # define SEG_FAR   xdata
           =4 # define SEG_DATA  data
           =4 # define SEG_NEAR  data
           =4 # define SEG_IDATA idata
           =4 # define SEG_XDATA xdata
           =4 # define SEG_PDATA pdata
           =4 # define SEG_CODE  code
           =4 # define SEG_BDATA bdata
           =4 
           =4 # define SBIT(name, addr, bit)  at (addr+bit) sbit         name
           =4 # define SFR(name, addr)        sfr at addr                name
           =4 # define SFR16(name, addr)      sfr16 at addr              name
           =4 # define SFR16E(name, fulladdr) /* not supported */
           =4 # define SFR32(name, fulladdr)  /* not supported */
           =4 # define SFR32E(name, fulladdr) /* not supported */
           =4 
           =4 # define INTERRUPT(name, vector) void name (void) interrupt vector
           =4 # define INTERRUPT_USING(name, vector, regnum) void name (void) interrupt vector using regnum
           =4 # define INTERRUPT_PROTO(name, vector) void name (void)
           =4 # define INTERRUPT_PROTO_USING(name, vector, regnum) void name (void)
           =4 
           =4 # define FUNCTION_USING(name, return_value, parameter, regnum) return_value name (parameter) using regnum
           =4 # define FUNCTION_PROTO_USING(name, return_value, parameter, regnum) return_value name (parameter)
           =4 // Note: Parameter must be either 'void' or include a variable type and name. (Ex: char temp_variable)
           =4 
           =4 # define SEGMENT_VARIABLE(name, vartype, locsegment) vartype locsegment name
           =4 # define VARIABLE_SEGMENT_POINTER(name, vartype, targsegment) vartype targsegment * name
           =4 # define SEGMENT_VARIABLE_SEGMENT_POINTER(name, vartype, targsegment, locsegment) vartype targsegment * lo
             -csegment name
           =4 # define SEGMENT_POINTER(name, vartype, locsegment) vartype * locsegment name
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 66  

           =4 # define LOCATED_VARIABLE(name, vartype, locsegment, addr, init) at addr locsegment vartype name
           =4 # define LOCATED_VARIABLE_NO_INIT(name, vartype, locsegment, addr) at addr locsegment vartype name
           =4 
           =4 
           =4 // used with UU16
           =4 # define LSB 1
           =4 # define MSB 0
           =4 
           =4 // used with UU32 (b0 is least-significant byte)
           =4 //# define b0 3
           =4 //# define b1 2
           =4 //# define b2 1
           =4 //# define b3 0
           =4 
           =4 typedef unsigned char U8;
           =4 typedef unsigned int U16;
           =4 typedef unsigned long U32;
           =4 
           =4 typedef signed char S8;
           =4 typedef signed int S16;
           =4 typedef signed long S32;
           =4 
           =4 typedef union UU16
           =4 {
           =4    U16 U16;
           =4    S16 S16;
           =4    U8 U8[2];
           =4    S8 S8[2];
           =4 } UU16;
           =4 
           =4 typedef union UU32
           =4 {
           =4    U32 U32;
           =4    S32 S32;
           =4    UU16 UU16[2];
           =4    U16 U16[2];
           =4    S16 S16[2];
           =4    U8 U8[4];
           =4    S8 S8[4];
           =4 } UU32;
           =4 
           =4 // NOP () macro support -- NOP is opcode 0x00
           =4 #define NOP() asm { 0x00 }
           =4 
           =4 
           =4 //-----------------------------------------------------------------------------
           =4 
           =4 
           =4 // Keil C51
           =4 // http://www.keil.com
           =4 
           =4 #elif defined __C51__
           =4 
           =4 //#error Keil C51 detected.
           =4 
           =4 # define SEG_GENERIC
           =4 # define SEG_FAR   xdata
           =4 # define SEG_DATA  data
           =4 # define SEG_NEAR  data
           =4 # define SEG_IDATA idata
           =4 # define SEG_XDATA xdata
           =4 # define SEG_PDATA pdata
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 67  

           =4 # define SEG_CODE  code
           =4 # define SEG_BDATA bdata
           =4 
           =4 # define SBIT(name, addr, bit)  sbit  name = addr^bit
           =4 # define SFR(name, addr)        sfr   name = addr
           =4 # define SFR16(name, addr)      sfr16 name = addr
           =4 # define SFR16E(name, fulladdr) /* not supported */
           =4 # define SFR32(name, fulladdr)  /* not supported */
           =4 # define SFR32E(name, fulladdr) /* not supported */
           =4 
           =4 # define INTERRUPT(name, vector) void name (void) interrupt vector
           =4 # define INTERRUPT_USING(name, vector, regnum) void name (void) interrupt vector using regnum
           =4 # define INTERRUPT_PROTO(name, vector) void name (void)
           =4 # define INTERRUPT_PROTO_USING(name, vector, regnum) void name (void)
           =4 
           =4 # define FUNCTION_USING(name, return_value, parameter, regnum) return_value name (parameter) using regnum
           =4 # define FUNCTION_PROTO_USING(name, return_value, parameter, regnum) return_value name (parameter)
           =4 // Note: Parameter must be either 'void' or include a variable type and name. (Ex: char temp_variable)
           =4 
           =4 # define SEGMENT_VARIABLE(name, vartype, locsegment) vartype locsegment name
           =4 # define VARIABLE_SEGMENT_POINTER(name, vartype, targsegment) vartype targsegment * name
           =4 # define SEGMENT_VARIABLE_SEGMENT_POINTER(name, vartype, targsegment, locsegment) vartype targsegment * lo
             -csegment name
           =4 # define SEGMENT_POINTER(name, vartype, locsegment) vartype * locsegment name
           =4 # define LOCATED_VARIABLE_NO_INIT(name, vartype, locsegment, addr) vartype locsegment name _at_ addr
           =4 
           =4 // used with UU16
           =4 # define LSB 1
           =4 # define MSB 0
           =4 
           =4 // used with UU32 (b0 is least-significant byte)
           =4 //# define b0 3
           =4 // define b1 2
           =4 //# define b2 1
           =4 //# define b3 0
           =4 
           =4 typedef unsigned char U8;
           =4 typedef unsigned int U16;
           =4 typedef unsigned long U32;
           =4 
           =4 typedef signed char S8;
           =4 typedef signed int S16;
           =4 typedef signed long S32;
           =4 
           =4 typedef union UU16
           =4 {
           =4    U16 U16;
           =4    S16 S16;
           =4    U8 U8[2];
           =4    S8 S8[2];
           =4 } UU16;
           =4 
           =4 typedef union UU32
           =4 {
           =4    U32 U32;
           =4    S32 S32;
           =4    UU16 UU16[2];
           =4    U16 U16[2];
           =4    S16 S16[2];
           =4    U8 U8[4];
           =4    S8 S8[4];
           =4 } UU32;
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 68  

           =4 
           =4 // NOP () macro support
           =4 extern void _nop_ (void);
           =4 #define NOP() _nop_()
           =4 
           =4 //-----------------------------------------------------------------------------
           =4 
           =4 // Hi-Tech 8051
           =4 // http://www.htsoft.com
           =4 
           =4 #elif defined HI_TECH_C
           =4 
           =4 # define SEG_GENERIC
           =4 # define SEG_FAR   far
           =4 # define SEG_DATA  data
           =4 # define SEG_NEAR  near
           =4 # define SEG_IDATA idata
           =4 # define SEG_XDATA xdata
           =4 # define SEG_PDATA pdata
           =4 # define SEG_CODE  code
           =4 # define SEG_BDATA bdata
           =4 
           =4 
           =4 # define SBIT(name, addr, thebit) static volatile bit name @ (addr + thebit)
           =4 # define SFR(name, addr)          static volatile unsigned char name @ addr
           =4 # define SFR16(name, addr)        static volatile unsigned int name @ addr
           =4 # define SFR16E(name, fulladdr) /* not supported */
           =4 # define SFR32(name, fulladdr)  /* not supported */
           =4 # define SFR32E(name, fulladdr) /* not supported */
           =4 
           =4 # define INTERRUPT(name, vector)       void name (void) interrupt vector
           =4 # define INTERRUPT_PROTO(name, vector)
           =4 # define INTERRUPT_USING(name, vector, regnum) void name (void) interrupt vector using regnum
           =4 # define INTERRUPT_PROTO_USING(name, vector, regnum)
           =4 
           =4 # define FUNCTION_USING(name, return_value, parameter, regnum) /* not supported */
           =4 # define FUNCTION_PROTO_USING(name, return_value, parameter, regnum) /* not supported */
           =4 // Note: Hi-Tech does not support functions using different register banks. Register
           =4 //       banks can only be specified in interrupts. If a function is called from
           =4 //       inside an interrupt, it will use the same register bank as the interrupt.
           =4 
           =4 # define SEGMENT_VARIABLE(name, vartype, locsegment) locsegment vartype name
           =4 # define VARIABLE_SEGMENT_POINTER(name, vartype, targsegment) targsegment vartype * name
           =4 # define SEGMENT_VARIABLE_SEGMENT_POINTER(name, vartype, targsegment, locsegment) targsegment vartype * lo
             -csegment name
           =4 # define LOCATED_VARIABLE(name, vartype, locsegment, addr, init) locsegment vartype name @ addr
           =4 
           =4 // used with UU16
           =4 # define LSB 0
           =4 # define MSB 1
           =4 
           =4 // used with UU32 (b0 is least-significant byte)
           =4 # define b0 0
           =4 # define b1 1
           =4 # define b2 2
           =4 # define b3 3
           =4 
           =4 typedef unsigned char U8;
           =4 typedef unsigned int U16;
           =4 typedef unsigned long U32;
           =4 
           =4 typedef signed char S8;
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 69  

           =4 typedef signed int S16;
           =4 typedef signed long S32;
           =4 
           =4 typedef union UU16
           =4 {
           =4    U16 U16;
           =4    S16 S16;
           =4    U8 U8[2];
           =4    S8 S8[2];
           =4 } UU16;
           =4 
           =4 typedef union UU32
           =4 {
           =4    U32 U32;
           =4    S32 S32;
           =4    UU16 UU16[2];
           =4    U16 U16[2];
           =4    S16 S16[2];
           =4    U8 U8[4];
           =4    S8 S8[4];
           =4 } UU32;
           =4 
           =4 // NOP () macro support
           =4 #define NOP() asm(" nop ")
           =4 
           =4 //-----------------------------------------------------------------------------
           =4 
           =4 // Tasking / Altium
           =4 // http://www.altium.com/tasking
           =4 
           =4 
           =4 #elif defined _CC51
           =4 
           =4 # define SEG_GENERIC
           =4 # define SEG_FAR   _xdat
           =4 # define SEG_DATA  _data
           =4 # define SEG_NEAR  _data
           =4 # define SEG_IDATA _idat
           =4 # define SEG_XDATA _xdat
           =4 # define SEG_PDATA _pdat
           =4 # define SEG_CODE  _rom
           =4 # define SEG_BDATA _bdat
           =4 
           =4 # define SBIT(name, addr, bit)  _sfrbit  name _at(addr+bit)
           =4 # define SFR(name, addr)        _sfrbyte name _at(addr)
           =4 # define SFRX(name, addr)       _xdat volatile unsigned char name _at(addr)
           =4 #if _CC51 > 71
           =4 # define SFR16(name, addr)      _sfrword _little name _at(addr)
           =4 #else
           =4 # define SFR16(name, addr)      /* not supported */
           =4 #endif
           =4 # define SFR16E(name, fulladdr) /* not supported */
           =4 # define SFR32(name, fulladdr)  /* not supported */
           =4 # define SFR32E(name, fulladdr) /* not supported */
           =4 
           =4 # define INTERRUPT(name, vector) _interrupt (vector) void name (void)
           =4 # define INTERRUPT_USING(name, vector, regnum) _interrupt (vector) _using(regnum) void name (void)
           =4 # define INTERRUPT_PROTO(name, vector) _interrupt (vector) void name (void)
           =4 # define INTERRUPT_PROTO_USING(name, vector, regnum) _interrupt (vector) _using(regnum) void name (void)
           =4 
           =4 // When calling FUNCTION_USING in Tasking, the function must be called from an interrupt or Main which
           =4 // is also using the same register bank. If not, the compiler will generate an error.
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 70  

           =4 # define FUNCTION_USING(name, return_value, parameter, regnum) _using(regnum) return_value name (parameter
             -)
           =4 # define FUNCTION_PROTO_USING(name, return_value, parameter, regnum) _using(regnum) return_value name (par
             -ameter)
           =4 // Note: Parameter must be either 'void' or include a variable type and name. (Ex: char temp_variable)
           =4 
           =4 # define SEGMENT_VARIABLE(name, vartype, locsegment) vartype locsegment name
           =4 # define VARIABLE_SEGMENT_POINTER(name, vartype, targsegment) vartype targsegment * name
           =4 # define SEGMENT_VARIABLE_SEGMENT_POINTER(name, vartype, targsegment, locsegment) vartype targsegment * lo
             -csegment name
           =4 # define LOCATED_VARIABLE(name, vartype, locsegment, addr, init) vartype locsegment name _at( addr )
           =4 
           =4 // used with UU16
           =4 # define LSB 1
           =4 # define MSB 0
           =4 
           =4 // used with UU32 (b0 is least-significant byte)
           =4 //# define b0 3
           =4 //# define b1 2
           =4 //# define b2 1
           =4 //# define b3 0
           =4 
           =4 typedef unsigned char U8;
           =4 typedef unsigned int U16;
           =4 typedef unsigned long U32;
           =4 
           =4 typedef signed char S8;
           =4 typedef signed int S16;
           =4 typedef signed long S32;
           =4 
           =4 typedef union UU16
           =4 {
           =4    U16 U16;
           =4    S16 S16;
           =4    U8 U8[2];
           =4    S8 S8[2];
           =4 } UU16;
           =4 
           =4 typedef union UU32
           =4 {
           =4    U32 U32;
           =4    S32 S32;
           =4    UU16 UU16[2];
           =4    U16 U16[2];
           =4    S16 S16[2];
           =4    U8 U8[4];
           =4    S8 S8[4];
           =4 } UU32;
           =4 
           =4 // NOP () macro support
           =4 extern void _nop (void);
           =4 #define NOP() _nop()
           =4 
           =4 //-----------------------------------------------------------------------------
           =4 
           =4 
           =4 // IAR 8051
           =4 // http://www.iar.com
           =4 
           =4 #elif defined __ICC8051__
           =4 
           =4 #include <stdbool.h>
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 71  

           =4 #include <intrinsics.h>
           =4 
           =4 # define SBIT(name, addr, bit)  __bit __no_init volatile bool name @ (addr+bit)
           =4 # define SFR(name, addr)        __sfr __no_init volatile unsigned char name @ addr
           =4 # define SFRX(name, addr)       __xdata __no_init volatile unsigned char name @ addr
           =4 # define SFR16(name, addr)      __sfr __no_init volatile unsigned int  name @ addr
           =4 # define SFR16E(name, fulladdr) /* not supported */
           =4 # define SFR32(name, fulladdr) /* not supported */
           =4 # define SFR32E(name, fulladdr) /* not supported */
           =4 
           =4 # define SEG_GENERIC __generic
           =4 # define SEG_FAR  __xdata
           =4 # define SEG_DATA __data
           =4 # define SEG_NEAR __data
           =4 # define SEG_IDATA __idata
           =4 # define SEG_XDATA __xdata
           =4 # define SEG_PDATA __pdata
           =4 # define SEG_CODE  __code
           =4 # define SEG_BDATA __bdata
           =4 
           =4 #define bit bool
           =4 
           =4 # define _PPTOSTR_(x) #x
           =4 # define _PPARAM_(address) _PPTOSTR_(vector=address * 8 + 3)
           =4 # define _PPARAM2_(regbank) _PPTOSTR_(register_bank=regbank)
           =4 # define INTERRUPT(name, vector) _Pragma(_PPARAM_(vector)) __interrupt void name(void)
           =4 # define INTERRUPT_PROTO(name, vector)  __interrupt void name(void)
           =4 # define INTERRUPT_USING(name, vector, regnum) _Pragma(_PPARAM2_(regnum)) _Pragma(_PPARAM_(vector)) __inte
             -rrupt void name(void)
           =4 # define INTERRUPT_PROTO_USING(name, vector, regnum) __interrupt void name(void)
           =4 
           =4 # define FUNCTION_USING(name, return_value, parameter, regnum) /* not supported */
           =4 # define FUNCTION_PROTO_USING(name, return_value, parameter, regnum) /* not supported */
           =4 // Note: IAR does not support functions using different register banks. Register
           =4 //       banks can only be specified in interrupts. If a function is called from
           =4 //       inside an interrupt, it will use the same register bank as the interrupt.
           =4 
           =4 # define SEGMENT_VARIABLE(name, vartype, locsegment)  locsegment vartype name
           =4 # define VARIABLE_SEGMENT_POINTER(name, vartype, targsegment) vartype targsegment  * name
           =4 # define SEGMENT_VARIABLE_SEGMENT_POINTER(name, vartype, targsegment, locsegment) vartype targsegment * lo
             -csegment name
           =4 
           =4 # define LOCATED_VARIABLE(name, vartype, locsegment, addr, init) locsegment __no_init vartype name @ addr
           =4 
           =4 // used with UU16
           =4 # define LSB 0
           =4 # define MSB 1
           =4 
           =4 // used with UU32 (b0 is least-significant byte)
           =4 //# define b0 0
           =4 //# define b1 1
           =4 //# define b2 2
           =4 //# define b3 3
           =4 
           =4 typedef unsigned char U8;
           =4 typedef unsigned int U16;
           =4 typedef unsigned long U32;
           =4 
           =4 typedef signed char S8;
           =4 typedef signed int S16;
           =4 typedef signed long S32;
           =4 
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 72  

           =4 typedef union UU16
           =4 {
           =4    U16 U16;
           =4    S16 S16;
           =4    U8 U8[2];
           =4    S8 S8[2];
           =4 } UU16;
           =4 
           =4 typedef union UU32
           =4 {
           =4    U32 U32;
           =4    S32 S32;
           =4    UU16 UU16[2];
           =4    U16 U16[2];
           =4    S16 S16[2];
           =4    U8 U8[4];
           =4    S8 S8[4];
           =4 } UU32;
           =4 
           =4 
           =4 #define NOP() __no_operation();
           =4 //-----------------------------------------------------------------------------
           =4 
           =4 // Crossware
           =4 // http://www.crossware.com
           =4 
           =4 #elif defined _XC51_VER
           =4 # define SBIT(name, addr, bit)  _sfrbit  name = (addr+bit)
           =4 # define SFR(name, addr)        _sfr     name = addr
           =4 # define SFR16(name, addr)      _sfrword name = addr
           =4 # define SFR16E(name, fulladdr) /* not supported */
           =4 # define SFR32(name, fulladdr)  /* not supported */
           =4 # define SFR32E(name, fulladdr) /* not supported */
           =4 
           =4 //-----------------------------------------------------------------------------
           =4 
           =4 // Wickenhäuser
           =4 // http://www.wickenhaeuser.de
           =4 
           =4 #elif defined __UC__
           =4 # define SBIT(name, addr, bit)  unsigned char bit  name @ (addr+bit)
           =4 # define SFR(name, addr)        near unsigned char name @ addr
           =4 # define SFR16(name, addr)      /* not supported */
           =4 # define SFR16E(name, fulladdr) /* not supported */
           =4 # define SFR32(name, fulladdr)  /* not supported */
           =4 # define SFR32E(name, fulladdr) /* not supported */
           =4 
           =4 //-----------------------------------------------------------------------------
           =4 
           =4 // Default
           =4 // Unknown compiler
           =4 
           =4 #else
           =4 # warning unrecognized compiler
           =4 # define SBIT(name, addr, bit)  volatile bool           name
           =4 # define SFR(name, addr)        volatile unsigned char  name
           =4 # define SFRX(name, addr)       volatile unsigned char  name
           =4 # define SFR16(name, addr)      volatile unsigned short name
           =4 # define SFR16E(name, fulladdr) volatile unsigned short name
           =4 # define SFR32(name, fulladdr)  volatile unsigned long  name
           =4 # define SFR32E(name, fulladdr) volatile unsigned long  name
           =4 
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 73  

           =4 #endif
           =4 
           =4 //-----------------------------------------------------------------------------
           =4 // Header File PreProcessor Directive
           =4 //-----------------------------------------------------------------------------
           =4 
           =4 #endif                                 // #define COMPILER_DEFS_H
 689      =4  
 690      =4  //-----------------------------------------------------------------------------
 691      =4  // End Of File
 692      =4  //-----------------------------------------------------------------------------
   5      =3  #include "C8051F580_defs.h"
   1      =4  //-----------------------------------------------------------------------------
   2      =4  // C8051F580_defs.h
   3      =4  //-----------------------------------------------------------------------------
   4      =4  // Copyright 2008, Silicon Laboratories, Inc.
   5      =4  // http://www.silabs.com
   6      =4  //
   7      =4  // Program Description:
   8      =4  //
   9      =4  // Register/bit definitions for the C8051F58x family.
  10      =4  // **Important Note**: The compiler_defs.h header file should be included
  11      =4  // before including this header file.
  12      =4  //
  13      =4  // Target:         C8051F580/1/2/3/4/5/6/7,8/9-F590/1
  14      =4  // Tool chain:     Generic
  15      =4  // Command Line:   None
  16      =4  //
  17      =4  // Release 0.6 - 20 AUG 2012 (TP)
  18      =4  //    -Added #define for _XPAGE to provide support for SDCC memory paging
  19      =4  //     (pdata)
  20      =4  //
  21      =4  // Release 0.5 - 10 SEP 2011 (GP)
  22      =4  //    - Fixed SFR16 definition for CAN0IF2MC
  23      =4  //
  24      =4  // Release 0.4 - 08 OCT 2010 (TP)
  25      =4  //    - Fixed bit definitions for SCON0
  26      =4  //
  27      =4  // Release 0.3 - 01 APR 2009 (GP)
  28      =4  //    - Added SN0-SN3
  29      =4  //
  30      =4  // Release 0.2 - 29 JUL 2008 (ADT)
  31      =4  //    - Added Timer 4 bit definitions
  32      =4  //
  33      =4  // Release 0.1 - 09 JUL 2008 (GP)
  34      =4  //    - Initial Revision
  35      =4  //
  36      =4  //-----------------------------------------------------------------------------
  37      =4  // Header File Preprocessor Directive
  38      =4  //-----------------------------------------------------------------------------
  39      =4  
  40      =4  #ifndef C8051F580_DEFS_H
           =4 #define C8051F580_DEFS_H
           =4 
           =4 //-----------------------------------------------------------------------------
           =4 // Page 0, Page 1 and Page F Registers
           =4 //-----------------------------------------------------------------------------
           =4 
           =4 SFR (P0, 0x80);                        // Port 0 Latch
           =4 SFR (SP, 0x81);                        // Stack Pointer
           =4 SFR (DPL, 0x82);                       // Data Pointer Low
           =4 SFR (DPH, 0x83);                       // Data Pointer High
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 74  

           =4 SFR (SFR0CN, 0x84);                    // SFR Page Control
           =4 SFR (SFRNEXT, 0x85);                   // SFR stack next page
           =4 SFR (SFRLAST, 0x86);                   // SFR stack last page
           =4 SFR (PCON, 0x87);                      // Power Control
           =4 SFR (TCON, 0x88);                      // Timer/Counter Control
           =4 SFR (TMOD, 0x89);                      // Timer/Counter Mode
           =4 SFR (TL0, 0x8A);                       // Timer/Counter 0 Low
           =4 SFR (TL1, 0x8B);                       // Timer/Counter 1 Low
           =4 SFR (TH0, 0x8C);                       // Timer/Counter 0 High
           =4 SFR (TH1, 0x8D);                       // Timer/Counter 1 High
           =4 SFR (CKCON, 0x8E);                     // Clock Control
           =4 SFR (PSCTL, 0x8F);                     // Program Store R/W Control
           =4 SFR (CLKSEL, 0x8F);                    // System clock select
           =4 SFR (P1, 0x90);                        // Port 1 Latch
           =4 SFR (TMR3CN, 0x91);                    // Timer/Counter 3 Control
           =4 SFR (TMR5CN, 0x91);                    // Timer/Counter 5 Control
           =4 SFR (TMR3RLL, 0x92);                   // Timer/Counter 3 Reload Low
           =4 SFR (TMR5CAPL, 0x92);                  // Timer/Counter 5 Capture Low
           =4 SFR (TMR3RLH, 0x93);                   // Timer/Counter 3 Reload High
           =4 SFR (TMR5CAPH, 0x93);                  // Timer/Counter 5 Capture High
           =4 SFR (TMR3L, 0x94);                     // Timer/Counter 3 Low
           =4 SFR (TMR5L, 0x94);                     // Timer/Counter 5 Low
           =4 SFR (TMR3H, 0x95);                     // Timer/Counter 3 High
           =4 SFR (TMR5H, 0x95);                     // Timer/Counter 5 High
           =4 SFR (TMR5CF, 0x96);                    // Timer/Counter 5 Configuration
           =4 SFR (CLKMUL, 0x97);                    // Clock Multiplier
           =4 SFR (SCON0, 0x98);                     // UART0 Control
           =4 SFR (SCON1, 0x98);                     // UART1 Control
           =4 SFR (SBUF0, 0x99);                     // UART0 Data Buffer
           =4 SFR (SBUF1, 0x99);                     // UART1 Data Buffer
           =4 SFR (CPT0CN, 0x9A);                    // Comparator 0 Control
           =4 SFR (CPT2CN, 0x9A);                    // Comparator 2 Control
           =4 SFR (CPT0MD, 0x9B);                    // Comparator 0 Mode
           =4 SFR (CPT2MD, 0x9B);                    // Comparator 2 Mode
           =4 SFR (CPT0MX, 0x9C);                    // Comparator 0 Mux
           =4 SFR (CPT2MX, 0x9C);                    // Comparator 2 Mux
           =4 SFR (CPT1CN, 0x9D);                    // Comparator 1 Control
           =4 SFR (CPT1MD, 0x9E);                    // Comparator 0 Mode
           =4 SFR (OSCIFIN, 0x9E);                   // Internal Oscillator Fine Control
           =4 SFR (CPT1MX, 0x9F);                    // Comparator 1 Mux
           =4 SFR (OSCXCN, 0x9F);                    // External Oscillator Control
           =4 SFR (P2, 0xA0);                        // Port 2 Latch
           =4 SFR (SPI0CFG, 0xA1);                   // SPI0 Configuration
           =4 SFR (OSCICN, 0xA1);                    // Internal Oscillator Control
           =4 SFR (SPI0CKR, 0xA2);                   // SPI0 Clock rate control
           =4 SFR (OSCICRS, 0xA2);                   // Internal Oscillator Coarse Control
           =4 SFR (SPI0DAT, 0xA3);                   // SPI0 Data Buffer
           =4 SFR (P0MDOUT, 0xA4);                   // Port 0 Output Mode
           =4 SFR (P1MDOUT, 0xA5);                   // Port 1 Output Mode
           =4 SFR (P2MDOUT, 0xA6);                   // Port 2 Output Mode
           =4 SFR (SFRPAGE, 0xA7);                   // SFR Page Select
           =4 SFR (IE, 0xA8);                        // Interrupt Enable
           =4 SFR (SMOD0, 0xA9);                     // Serial Port 0 Control
           =4 SFR (EMI0CN, 0xAA);                    // EMIF Control
           =4 SFR (EMI0TC, 0xAA);                    // EMIF Timing control
           =4 SFR (SBCON0, 0xAB);                    // UART0 Baud Rate Generator Control
           =4 SFR (SBRLL0, 0xAC);                    // UART0 Baud Rate Generator Low
           =4 SFR (SBRLH0, 0xAD);                    // UART0 Baud Rate Generator High
           =4 SFR (P3MAT, 0xAE);                     // Port 3 Match
           =4 SFR (P3MDOUT, 0xAE);                   // Port 3 Mode
           =4 SFR (P3MASK, 0xAF);                    // Port 3 Mask
           =4 SFR (P4MDOUT, 0xAF);                   // Port 4 Mode
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 75  

           =4 SFR (P3, 0xB0);                        // Port 3 Latch
           =4 SFR (P2MAT, 0xB1);                     // Port 2 Match
           =4 SFR (P2MASK, 0xB2);                    // Port 2 Mask
           =4 SFR (EMI0CF, 0xB2);                    // EMIF Configuration
           =4 SFR (P4, 0xB5);                        // Port 4 Latch
           =4 SFR (FLSCL, 0xB6);                     // Flash Scale
           =4 SFR (FLKEY, 0xB7);                     // Flash access limit
           =4 SFR (IP, 0xB8);                        // Interrupt Priority
           =4 SFR (SMB0ADR, 0xB9);                   // SMBus0 Slave address
           =4 SFR (ADC0TK, 0xBA);                    // ADC0 Tracking Mode Select
           =4 SFR (SMB0ADM, 0xBA);                   // SMBus0 Address Mask
           =4 SFR (ADC0MX, 0xBB);                    // AMUX0 Channel select
           =4 SFR (ADC0CF, 0xBC);                    // AMUX0 Channel configuration
           =4 SFR (ADC0L, 0xBD);                     // ADC0 Data Low
           =4 SFR (ADC0H, 0xBE);                     // ADC0 Data High
           =4 SFR (SMB0CN, 0xC0);                    // SMBus0 Control
           =4 SFR (SMB0CF, 0xC1);                    // SMBus0 Configuration
           =4 SFR (SMB0DAT, 0xC2);                   // SMBus0 Data
           =4 SFR (ADC0GTL, 0xC3);                   // ADC0 Greater-Than Compare Low
           =4 SFR (ADC0GTH, 0xC4);                   // ADC0 Greater-Than Compare High
           =4 SFR (ADC0LTL, 0xC5);                   // ADC0 Less-Than Compare Word Low
           =4 SFR (ADC0LTH, 0xC6);                   // ADC0 Less-Than Compare Word High
           =4 SFR (XBR3, 0xC6);                      // Port I/O Crossbar Control 3
           =4 SFR (XBR2, 0xC7);                      // Port I/O Crossbar Control 2
           =4 SFR (TMR2CN, 0xC8);                    // Timer/Counter 2 Control
           =4 SFR (TMR4CN, 0xC8);                    // Timer/Counter 4 Control
           =4 SFR (REG0CN, 0xC9);                    // Regulator Control
           =4 SFR (LIN0CF, 0xC9);                    // LIN 0 Configuration
           =4 SFR (TMR4CF, 0xC9);                    // Timer/Counter 4 Configuration
           =4 SFR (TMR2RLL, 0xCA);                   // Timer/Counter 2 Reload Low
           =4 SFR (TMR4CAPL, 0xCA);                  // Timer/Counter 4 Capture Low
           =4 SFR (TMR2RLH, 0xCB);                   // Timer/Counter 2 Reload High
           =4 SFR (TMR4CAPH, 0xCB);                  // Timer/Counter 4 Capture High
           =4 SFR (TMR2L, 0xCC);                     // Timer/Counter 2 Low
           =4 SFR (TMR4L, 0xCC);                     // Timer/Counter 4 Low
           =4 SFR (TMR2H, 0xCD);                     // Timer/Counter 2 High
           =4 SFR (TMR4H, 0xCD);                     // Timer/Counter 4 High
           =4 SFR (PCA0CPL5, 0xCE);                  // PCA0 Capture 5 Low
           =4 SFR (PCA1CPL11, 0xCE);                 // PCA1 Capture 11 Low
           =4 SFR (PCA0CPH5, 0xCF);                  // PCA0 Capture 5 High
           =4 SFR (PCA1CPH11, 0xCF);                 // PCA1 Capture 11 High
           =4 SFR (PSW, 0xD0);                       // Program Status Word
           =4 SFR (REF0CN, 0xD1);                    // Voltage Reference Control
           =4 SFR (LIN0DAT, 0xD2);                   // LIN0 Data
           =4 SFR (LIN0ADR, 0xD3);                   // LIN0 Address
           =4 SFR (P0SKIP, 0xD4);                    // Port 0 Skip
           =4 SFR (P1SKIP, 0xD5);                    // Port 1 Skip
           =4 SFR (P2SKIP, 0xD6);                    // Port 2 Skip
           =4 SFR (P3SKIP, 0xD7);                    // Port 3 Skip
           =4 SFR (PCA0CN, 0xD8);                    // PCA0 Control
           =4 SFR (PCA1CN, 0xD8);                    // PCA1 Control
           =4 SFR (PCA0MD, 0xD9);                    // PCA0 Mode
           =4 SFR (PCA1MD, 0xD9);                    // PCA1 Mode
           =4 SFR (PCA0PWM, 0xD9);                   // PCA0 PWM Control
           =4 SFR (PCA0CPM0, 0xDA);                  // PCA0 Module 0 Mode
           =4 SFR (PCA1CPM6, 0xDA);                  // PCA1 Module 6 Mode
           =4 SFR (PCA1PWM, 0xDA);                   // PCA1 PWM Control
           =4 SFR (PCA0CPM1, 0xDB);                  // PCA0 Module 1  Mode
           =4 SFR (PCA1CPM7, 0xDB);                  // PCA1 Module 7  Mode
           =4 SFR (PCA0CPM2, 0xDC);                  // PCA0 Module 2  Mode
           =4 SFR (PCA1CPM8, 0xDC);                  // PCA1 Module 8  Mode
           =4 SFR (PCA0CPM3, 0xDD);                  // PCA0 Module 3  Mode
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 76  

           =4 SFR (PCA1CPM9, 0xDD);                  // PCA1 Module 9  Mode
           =4 SFR (PCA0CPM4, 0xDE);                  // PCA0 Module 4  Mode
           =4 SFR (PCA1CPM10, 0xDE);                  // PCA1 Module 10 Mode
           =4 SFR (PCA0CPM5, 0xDF);                  // PCA0 Module 5  Mode
           =4 SFR (PCA1CPM11, 0xDF);                  // PCA1 Module 11 Mode
           =4 SFR (ACC, 0xE0);                       // Accumulator
           =4 SFR (XBR0, 0xE1);                      // Port I/O Crossbar Control 0
           =4 SFR (XBR1, 0xE2);                      // Port I/O Crossbar Control 1
           =4 SFR (CCH0CN, 0xE3);                    // Cache control
           =4 SFR (IT01CF, 0xE4);                    // INT0/INT1 Configuration
           =4 SFR (EIE1, 0xE6);                      // Extended Interrupt Enable 2
           =4 SFR (EIE2, 0xE7);                      // Extended Interrupt Enable 2
           =4 SFR (ADC0CN, 0xE8);                    // ADC0 Control
           =4 SFR (PCA0CPL1, 0xE9);                  // PCA0 Capture 1 Low
           =4 SFR (PCA1CPL1, 0xE9);                  // PCA1 Capture 7 Low
           =4 SFR (PCA0CPH1, 0xEA);                  // PCA0 Capture 1 High
           =4 SFR (PCA1CPH1, 0xEA);                  // PCA1 Capture 7 High
           =4 SFR (PCA0CPL2, 0xEB);                  // PCA0 Capture 2 Low
           =4 SFR (PCA1CPL2, 0xEB);                  // PCA1 Capture 8 Low
           =4 SFR (PCA0CPH2, 0xEC);                  // PCA0 Capture 2 High
           =4 SFR (PCA1CPH2, 0xEC);                  // PCA1 Capture 8 High
           =4 SFR (PCA0CPL3, 0xED);                  // PCA0 Capture 3 Low
           =4 SFR (PCA1CPL3, 0xED);                  // PCA1 Capture 9 Low
           =4 SFR (PCA0CPH3, 0xEE);                  // PCA0 Capture 3 High
           =4 SFR (PCA1CPH3, 0xEE);                  // PCA1 Capture 9 High
           =4 SFR (RSTSRC, 0xEF);                    // Reset Source Configuration/Status
           =4 SFR (B, 0xF0);                         // B Register
           =4 SFR (P0MAT, 0xF1);                     // Port 0 Match
           =4 SFR (P0MDIN, 0xF1);                    // Port 0 Input Mode
           =4 SFR (P0MASK, 0xF2);                    // Port 0 Mask
           =4 SFR (P1MDIN, 0xF2);                    // Port 1 Input Mode
           =4 SFR (P1MAT, 0xF3);                     // Port 1 Match
           =4 SFR (P2MDIN, 0xF3);                    // Port 2 Input Mode
           =4 SFR (P1MASK, 0xF4);                    // Port 1 Mask
           =4 SFR (P3MDIN, 0xF4);                    // Port 3 Input Mode
           =4 SFR (PSBANK, 0xF5);                    // Program Space Bank Select
           =4 SFR (EIP1, 0xF6);                      // External Interrupt Priority 1
           =4 SFR (EIP2, 0xF7);                      // External Interrupt Priority 2
           =4 SFR (SPI0CN, 0xF8);                    // SPI0 Control
           =4 SFR (PCA0L, 0xF9);                     // PCA0 Counter Low
           =4 SFR (PCA1L, 0xF9);                     // PCA1 Counter Low
           =4 SFR (SN0, 0xF9);                       // Serial Number 0
           =4 SFR (PCA0H, 0xFA);                     // PCA0 Counter High
           =4 SFR (PCA1H, 0xFA);                     // PCA1 Counter High
           =4 SFR (SN1, 0xFA);                       // Serial Number 1
           =4 SFR (PCA0CPL0, 0xFB);                  // PCA0 Capture 0 Low
           =4 SFR (PCA1CPL6, 0xFB);                  // PCA1 Capture 6 Low
           =4 SFR (SN2, 0xFB);                       // Serial Number 2
           =4 SFR (PCA0CPH0, 0xFC);                  // PCA0 Capture 0 High
           =4 SFR (PCA1CPH6, 0xFC);                  // PCA1 Capture 6 High
           =4 SFR (SN3, 0xFC);                       // Serial Number 3
           =4 SFR (PCA0CPL4, 0xFD);                  // PCA0 Capture 4 Low
           =4 SFR (PCA1CPL10, 0xFD);                 // PCA1 Capture 10 Low
           =4 SFR (PCA0CPH4, 0xFE);                  // PCA0 Capture 4 High
           =4 SFR (PCA1CPH10, 0xFE);                 // PCA1 Capture 10 High
           =4 SFR (VDM0CN, 0xFF);                    // VDD Monitor Control
           =4 
           =4 //-----------------------------------------------------------------------------
           =4 // Page C (CAN0) Registers
           =4 //-----------------------------------------------------------------------------
           =4 
           =4 SFR (CAN0CFG, 0x92);                   // CAN0 Clock Configuration
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 77  

           =4 SFR (CAN0STAT, 0x94);                  // Status Register Low Byte
           =4 SFR (CAN0ERRL, 0x96);                  // Error Counter Low Byte
           =4 SFR (CAN0ERRH, 0x97);                  // Error Counter High Byte
           =4 SFR (CAN0BTL, 0x9A);                   // Bit Timing Register Low Byte
           =4 SFR (CAN0BTH, 0x9B);                   // Bit Timing Register High Byte
           =4 SFR (CAN0IIDL, 0x9C);                  // Interrupt Register Low Byte
           =4 SFR (CAN0IIDH, 0x9D);                  // Interrupt Register High Byte
           =4 SFR (CAN0TST, 0x9E);                   // Test Register Low Byte
           =4 SFR (CAN0BRPE, 0xA1);                  // BRP Extension Register Low Byte
           =4 SFR (CAN0TR1L, 0xA2);                  // Transmission Request 1 Low Byte
           =4 SFR (CAN0TR1H, 0xA3);                  // Transmission Request 1 High Byte
           =4 SFR (CAN0TR2L, 0xA4);                  // Transmission Request 2 Low Byte
           =4 SFR (CAN0TR2H, 0xA5);                  // Transmission Request 2 High Byte
           =4 SFR (CAN0ND1L, 0xAA);                  // New Data 1 Low Byte
           =4 SFR (CAN0ND1H, 0xAB);                  // New Data 1 High Byte
           =4 SFR (CAN0ND2L, 0xAC);                  // New Data 2 Low Byte
           =4 SFR (CAN0ND2H, 0xAD);                  // New Data 2 High Byte
           =4 SFR (CAN0IP1L, 0xAE);                  // Interrupt Pending 1 Low Byte
           =4 SFR (CAN0IP1H, 0xAF);                  // Interrupt Pending 1 High Byte
           =4 SFR (CAN0IP2L, 0xB2);                  // Interrupt Pending 2 Low Byte
           =4 SFR (CAN0IP2H, 0xB3);                  // Interrupt Pending 2 High Byte
           =4 SFR (CAN0MV1L, 0xBA);                  // Message Valid 1 Low Byte
           =4 SFR (CAN0MV1H, 0xBB);                  // Message Valid 1 High Byte
           =4 SFR (CAN0MV2L, 0xBC);                  // Message Valid 2 Low Byte
           =4 SFR (CAN0MV2H, 0xBD);                  // Message Valid 2 High Byte
           =4 SFR (CAN0IF1CRL, 0xBE);                // IF1 Command Request Low Byte
           =4 SFR (CAN0IF1CRH, 0xBF);                // IF1 Command Request High Byte
           =4 SFR (CAN0CN, 0xC0);                    // CAN Control Register Low Byte
           =4 SFR (CAN0IF1CML, 0xC2);                // IF1 Command Mask Low Byte
           =4 SFR (CAN0IF1CMH, 0xC3);                // IF1 Command Mask High Byte
           =4 SFR (CAN0IF1M1L, 0xC4);                // IF1 Mask 1 Low Byte
           =4 SFR (CAN0IF1M1H, 0xC5);                // IF1 Mask 1 High Byte
           =4 SFR (CAN0IF1M2L, 0xC6);                // IF1 Mask 2 Low Byte
           =4 SFR (CAN0IF1M2H, 0xC7);                // IF1 Mask 2 High Byte
           =4 SFR (CAN0IF1A1L, 0xCA);                // IF1 Arbitration 1 Low Byte
           =4 SFR (CAN0IF1A1H, 0xCB);                // IF1 Arbitration 1 High Byte
           =4 SFR (CAN0IF1A2L, 0xCC);                // IF1 Arbitration 2 Low Byte
           =4 SFR (CAN0IF1A2H, 0xCD);                // IF1 Arbitration 2 High Byte
           =4 SFR (CAN0IF2MCL, 0xCE);                // IF2 Message Control Low Byte
           =4 SFR (CAN0IF2MCH, 0xCF);                // IF2 Message Control High Byte
           =4 SFR (CAN0IF1MCL, 0xD2);                // IF1 Message Control Low Byte
           =4 SFR (CAN0IF1MCH, 0xD3);                // IF1 Message Control High Byte
           =4 SFR (CAN0IF1DA1L, 0xD4);               // IF1 Data A 1 Low Byte
           =4 SFR (CAN0IF1DA1H, 0xD5);               // IF1 Data A 1 High Byte
           =4 SFR (CAN0IF1DA2L, 0xD6);               // IF1 Data A 2 Low Byte
           =4 SFR (CAN0IF1DA2H, 0xD7);               // IF1 Data A 2 High Byte
           =4 SFR (CAN0IF1DB1L, 0xDA);               // IF1 Data B 1 Low Byte
           =4 SFR (CAN0IF1DB1H, 0xDB);               // IF1 Data B 1 High Byte
           =4 SFR (CAN0IF1DB2L, 0xDC);               // IF1 Data B 2 Low Byte
           =4 SFR (CAN0IF1DB2H, 0xDD);               // IF1 Data B 2 High Byte
           =4 SFR (CAN0IF2CRL, 0xDE);                // IF2 Command Request Low Byte
           =4 SFR (CAN0IF2CRH, 0xDF);                // IF2 Command Request High Byte
           =4 SFR (CAN0IF2CML, 0xE2);                // IF2 Command Mask Low Byte
           =4 SFR (CAN0IF2CMH, 0xE3);                // IF2 Command Mask High Byte
           =4 SFR (CAN0IF2M1L, 0xEA);                // IF2 Mask 1 Low Byte
           =4 SFR (CAN0IF2M1H, 0xEB);                // IF2 Mask 1 High Byte
           =4 SFR (CAN0IF2M2L, 0xEC);                // IF2 Mask 2 Low Byte
           =4 SFR (CAN0IF2M2H, 0xED);                // IF2 Mask 2 High Byte
           =4 SFR (CAN0IF2A1L, 0xEE);                // IF2 Arbitration 1 Low Byte
           =4 SFR (CAN0IF2A1H, 0xEF);                // IF2 Arbitration 1 High Byte
           =4 SFR (CAN0IF2A2L, 0xF2);                // IF2 Arbitration 2 Low Byte
           =4 SFR (CAN0IF2A2H, 0xF3);                // IF2 Arbitration 2 High Byte
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 78  

           =4 SFR (CAN0IF2DA1L, 0xF6);               // IF2 Data A 1 Low Byte
           =4 SFR (CAN0IF2DA1H, 0xF7);               // IF2 Data A 1 High Byte
           =4 SFR (CAN0IF2DA2L, 0xFA);               // IF2 Data A 2 Low Byte
           =4 SFR (CAN0IF2DA2H, 0xFB);               // IF2 Data A 2 High Byte
           =4 SFR (CAN0IF2DB1L, 0xFC);               // IF2 Data B 1 Low Byte
           =4 SFR (CAN0IF2DB1H, 0xFD);               // IF2 Data B 1 High Byte
           =4 SFR (CAN0IF2DB2L, 0xFE);               // IF2 Data B 2 Low Byte
           =4 SFR (CAN0IF2DB2H, 0xFF);               // IF2 Data B 2 High Byte
           =4 
           =4 
           =4 //-----------------------------------------------------------------------------
           =4 // 16-bit Register Definitions (might not be supported by all compilers)
           =4 //-----------------------------------------------------------------------------
           =4 
           =4 SFR16 (DP, 0x82);                      // Data Pointer
           =4 SFR16 (TMR3RL, 0x92);                  // Timer 3 Reload
           =4 SFR16 (TMR5CAP, 0x92);                 // Timer 5 Capture
           =4 SFR16 (TMR3, 0x94);                    // Timer 3 Capture / Reload
           =4 SFR16 (TMR5, 0x94);                    // Timer 5
           =4 SFR16 (SBRL0, 0xAC);                   // UART0 Reload
           =4 SFR16 (ADC0, 0xBD);                    // ADC0 data
           =4 SFR16 (ADC0GT, 0xC3);                  // ADC0 Greater Than Window
           =4 SFR16 (ADC0LT, 0xC5);                  // ADC0 Less Than Window
           =4 SFR16 (TMR2RL, 0xCA);                  // Timer 2 Reload
           =4 SFR16 (TMR4CAP, 0xCA);                 // Timer 4 Capture
           =4 SFR16 (TMR2, 0xCC);                    // Timer 2 Capture / Reload
           =4 SFR16 (TMR4, 0xCC);                    // Timer 4
           =4 SFR16 (PCA0CP5, 0xCE);                 // PCA0 Module 5 Capture
           =4 SFR16 (PCA1CP11, 0xCE);                // PCA1 Module 11 Capture
           =4 SFR16 (PCA0CP1, 0xE9);                 // PCA0 Module 1 Capture
           =4 SFR16 (PCA1CP7, 0xE9);                 // PCA1 Module 7 Capture
           =4 SFR16 (PCA0CP2, 0xEB);                 // PCA0 Module 2 Capture
           =4 SFR16 (PCA1CP8, 0xEB);                 // PCA1 Module 8 Capture
           =4 SFR16 (PCA0CP3, 0xED);                 // PCA0 Module 3 Capture
           =4 SFR16 (PCA1CP9, 0xED);                 // PCA1 Module 9 Capture
           =4 SFR16 (PCA0, 0xF9);                    // PCA0 Counter
           =4 SFR16 (PCA1, 0xF9);                    // PCA1 Counter
           =4 SFR16 (PCA0CP0, 0xFB);                 // PCA0 Module 0 Capture
           =4 SFR16 (PCA1CP6, 0xFB);                 // PCA1 Module 6 Capture
           =4 SFR16 (PCA0CP4, 0xFD);                 // PCA0 Module 4 Capture
           =4 SFR16 (PCA1CP10, 0xFD);                 // PCA1 Module 10 Capture
           =4 
           =4 SFR16 (CAN0ERR, 0x96);                 // Error Counter
           =4 SFR16 (CAN0BT, 0x9A);                  // Bit Timing Register
           =4 SFR16 (CAN0IID, 0x9C);                 // Interrupt Register
           =4 SFR16 (CAN0TR1, 0xA2);                 // Transmission Request 1
           =4 SFR16 (CAN0TR2, 0xA4);                 // Transmission Request 2
           =4 SFR16 (CAN0ND1, 0xAA);                 // New Data 1
           =4 SFR16 (CAN0ND2, 0xAC);                 // New Data 2
           =4 SFR16 (CAN0IP1, 0xAE);                 // Interrupt Pending 1
           =4 SFR16 (CAN0IP2, 0xB2);                 // Interrupt Pending 2
           =4 SFR16 (CAN0MV1, 0xBA);                 // Message Valid 1
           =4 SFR16 (CAN0MV2, 0xBC);                 // Message Valid 2
           =4 SFR16 (CAN0IF1CR, 0xBE);               // IF1 Command Request
           =4 SFR16 (CAN0IF1CM, 0xC2);               // IF1 Command Mask
           =4 SFR16 (CAN0IF1M1, 0xC4);               // IF1 Mask 1
           =4 SFR16 (CAN0IF1M2, 0xC6);               // IF1 Mask 2
           =4 SFR16 (CAN0IF1A1, 0xCA);               // IF1 Arbitration 1
           =4 SFR16 (CAN0IF1A2, 0xCC);               // IF1 Arbitration 2
           =4 SFR16 (CAN0IF1MC, 0xD2);               // IF1 Message Control
           =4 SFR16 (CAN0IF1DA1, 0xD4);              // IF1 Data A 1
           =4 SFR16 (CAN0IF1DA2, 0xD6);              // IF1 Data A 2
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 79  

           =4 SFR16 (CAN0IF1DB1, 0xDA);              // IF1 Data B 1
           =4 SFR16 (CAN0IF1DB2, 0xDC);              // IF1 Data B 2
           =4 SFR16 (CAN0IF2CR, 0xDE);               // IF2 Command Request
           =4 SFR16 (CAN0IF2CM, 0xE2);               // IF2 Command Mask
           =4 SFR16 (CAN0IF2M1, 0xEA);               // IF2 Mask 1
           =4 SFR16 (CAN0IF2M2, 0xEC);               // IF2 Mask 2
           =4 SFR16 (CAN0IF2A1, 0xEE);               // IF2 Arbitration 1
           =4 SFR16 (CAN0IF2A2, 0xF2);               // IF2 Arbitration 2
           =4 SFR16 (CAN0IF2MC, 0xCE);               // IF2 Message Control
           =4 SFR16 (CAN0IF2DA1, 0xF6);              // IF2 Data A 1
           =4 SFR16 (CAN0IF2DA2, 0xFA);              // IF2 Data A 2
           =4 SFR16 (CAN0IF2DB1, 0xFC);              // IF2 Data B 1
           =4 SFR16 (CAN0IF2DB2, 0xFE);              // IF2 Data B 2
           =4 
           =4 //-----------------------------------------------------------------------------
           =4 // LIN0 Indirect Registers
           =4 //-----------------------------------------------------------------------------
           =4 
           =4 #define  LIN0DT1   0x00                // LIN0 Data Byte 1
           =4 #define  LIN0DT2   0x01                // LIN0 Data Byte 2
           =4 #define  LIN0DT3   0x02                // LIN0 Data Byte 3
           =4 #define  LIN0DT4   0x03                // LIN0 Data Byte 4
           =4 #define  LIN0DT5   0x04                // LIN0 Data Byte 5
           =4 #define  LIN0DT6   0x05                // LIN0 Data Byte 6
           =4 #define  LIN0DT7   0x06                // LIN0 Data Byte 7
           =4 #define  LIN0DT8   0x07                // LIN0 Data Byte 8
           =4 #define  LIN0CTRL  0x08                // LIN0 Control
           =4 #define  LIN0ST    0x09                // LIN0 Status
           =4 #define  LIN0ERR   0x0A                // LIN0 Error
           =4 #define  LIN0SIZE  0x0B                // LIN0 Message Size
           =4 #define  LIN0DIV   0x0C                // LIN0 Divider
           =4 #define  LIN0MUL   0x0D                // LIN0 Multiplier
           =4 #define  LIN0ID    0x0E                // LIN0 Identifier
           =4 
           =4 //-----------------------------------------------------------------------------
           =4 // Address Definitions for Bit-addressable Registers
           =4 //-----------------------------------------------------------------------------
           =4 
           =4 #define SFR_P0       0x80
           =4 #define SFR_TCON     0x88
           =4 #define SFR_P1       0x90
           =4 #define SFR_SCON0    0x98
           =4 #define SFR_SCON1    0x98
           =4 #define SFR_P2       0xA0
           =4 #define SFR_IE       0xA8
           =4 #define SFR_P3       0xB0
           =4 #define SFR_IP       0xB8
           =4 #define SFR_SMB0CN   0xC0
           =4 #define SFR_TMR2CN   0xC8
           =4 #define SFR_TMR4CN   0xC8
           =4 #define SFR_PSW      0xD0
           =4 #define SFR_PCA0CN   0xD8
           =4 #define SFR_PCA1CN   0xD8
           =4 #define SFR_ACC      0xE0
           =4 #define SFR_ADC0CN   0xE8
           =4 #define SFR_B        0xF0
           =4 #define SFR_SPI0CN   0xF8
           =4 
           =4 //-----------------------------------------------------------------------------
           =4 // Bit Definitions
           =4 //-----------------------------------------------------------------------------
           =4 
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 80  

           =4 // TCON 0x88
           =4 SBIT (TF1, SFR_TCON, 7);               // Timer 1 Overflow Flag
           =4 SBIT (TR1, SFR_TCON, 6);               // Timer 1 On/Off Control
           =4 SBIT (TF0, SFR_TCON, 5);               // Timer 0 Overflow Flag
           =4 SBIT (TR0, SFR_TCON, 4);               // Timer 0 On/Off Control
           =4 SBIT (IE1, SFR_TCON, 3);               // Ext. Interrupt 1 Edge Flag
           =4 SBIT (IT1, SFR_TCON, 2);               // Ext. Interrupt 1 Type
           =4 SBIT (IE0, SFR_TCON, 1);               // Ext. Interrupt 0 Edge Flag
           =4 SBIT (IT0, SFR_TCON, 0);               // Ext. Interrupt 0 Type
           =4 
           =4 // SCON0 0x98
           =4 SBIT (OVR0, SFR_SCON0, 7);             // UART0 Receive FIFO Overrun Flag
           =4 SBIT (PERR0, SFR_SCON0, 6);            // UART0 Parity Error Flag
           =4 SBIT (THRE0, SFR_SCON0, 5);            // UART0 Transmit Register Empty Flag
           =4 SBIT (REN0, SFR_SCON0, 4);             // UART0 RX Enable
           =4 SBIT (TBX0, SFR_SCON0, 3);             // UART0 Extra Transmission Bit
           =4 SBIT (RBX0, SFR_SCON0, 2);             // UART0 Extra Receive Bit
           =4 SBIT (TI0, SFR_SCON0, 1);              // UART0 TX Interrupt Flag
           =4 SBIT (RI0, SFR_SCON0, 0);              // UART0 RX Interrupt Flag
           =4 
           =4 // SCON1 0x98
           =4 SBIT (S1MODE, SFR_SCON1, 7);           // UART1 Mode 0
           =4                                        // Bit 6 UNUSED
           =4 SBIT (MCE1, SFR_SCON1, 5);             // UART1 Multiprocessor enable
           =4 SBIT (REN1, SFR_SCON1, 4);             // UART1 RX Enable
           =4 SBIT (TB81, SFR_SCON1, 3);             // UART1 TX Bit 8
           =4 SBIT (RB81, SFR_SCON1, 2);             // UART1 RX Bit 8
           =4 SBIT (TI1, SFR_SCON1, 1);              // UART1 TX Interrupt Flag
           =4 SBIT (RI1, SFR_SCON1, 0);              // UART1 RX Interrupt Flag
           =4 
           =4 // IE 0xA8
           =4 SBIT (EA, SFR_IE, 7);                  // Global Interrupt Enable
           =4 SBIT (ESPI0, SFR_IE, 6);               // SPI0 Interrupt Enable
           =4 SBIT (ET2, SFR_IE, 5);                 // Timer 2 Interrupt Enable
           =4 SBIT (ES0, SFR_IE, 4);                 // UART0 Interrupt Enable
           =4 SBIT (ET1, SFR_IE, 3);                 // Timer 1 Interrupt Enable
           =4 SBIT (EX1, SFR_IE, 2);                 // External Interrupt 1 Enable
           =4 SBIT (ET0, SFR_IE, 1);                 // Timer 0 Interrupt Enable
           =4 SBIT (EX0, SFR_IE, 0);                 // External Interrupt 0 Enable
           =4 
           =4 // IP 0xB8
           =4                                        // Bit 7 unused
           =4 SBIT (PSPI0, SFR_IP, 6);               // SPI0 Interrupt Priority
           =4 SBIT (PT2, SFR_IP, 5);                 // Timer 2 Priority
           =4 SBIT (PS0, SFR_IP, 4);                 // UART0 Priority
           =4 SBIT (PS, SFR_IP, 4);                  // UART0 Priority
           =4 SBIT (PT1, SFR_IP, 3);                 // Timer 1 Priority
           =4 SBIT (PX1, SFR_IP, 2);                 // External Interrupt 1 Priority
           =4 SBIT (PT0, SFR_IP, 1);                 // Timer 0 Priority
           =4 SBIT (PX0, SFR_IP, 0);                 // External Interrupt 0 Priority
           =4 
           =4 // SMB0CN 0xC0
           =4 SBIT (MASTER, SFR_SMB0CN, 7);          // SMBus0 Master/Slave Indicator
           =4 SBIT (TXMODE, SFR_SMB0CN, 6);          // SMBus0 Transmit Mode Indicator
           =4 SBIT (STA, SFR_SMB0CN, 5);             // SMBus0 Start Flag
           =4 SBIT (STO, SFR_SMB0CN, 4);             // SMBus0 Stop Flag
           =4 SBIT (ACKRQ, SFR_SMB0CN, 3);           // SMBus0 Acknowledge Request
           =4 SBIT (ARBLOST, SFR_SMB0CN, 2);         // SMBus0 Arbitration Lost Indicator
           =4 SBIT (ACK, SFR_SMB0CN, 1);             // SMBus0 Acknowledge
           =4 SBIT (SI, SFR_SMB0CN, 0);              // SMBus0 Interrupt Flag
           =4 
           =4 // TMR2CN 0xC8
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 81  

           =4 SBIT (TF2H, SFR_TMR2CN, 7);            // Timer 2 High-Byte Overflow Flag
           =4 SBIT (TF2L, SFR_TMR2CN, 6);            // Timer 2 Low-Byte  Overflow Flag
           =4 SBIT (TF2LEN, SFR_TMR2CN, 5);          // Timer 2 Low-Byte Flag Enable
           =4 SBIT (TF2CEN, SFR_TMR2CN, 4);          // Timer 2 Capture Enable
           =4 SBIT (T2SPLIT, SFR_TMR2CN, 3);         // Timer 2 Split-Mode Enable
           =4 SBIT (TR2, SFR_TMR2CN, 2);             // Timer 2 Run Enable
           =4 SBIT (T2RCLK, SFR_TMR2CN, 1);          // Timer 2 Xclk/Rclk Select
           =4 SBIT (T2XCLK, SFR_TMR2CN, 0);          // Timer 2 Clk/8 Clock Source
           =4 
           =4 // TMR4CN 0xC8
           =4 SBIT (TF4, SFR_TMR4CN, 7);             // Timer 4 Overflow/Underflow Flag
           =4 SBIT (EXF4, SFR_TMR4CN, 6);            // Timer 4 External Flag
           =4                                        // Bit 5 unused
           =4                                        // Bit 4 unused
           =4 SBIT (EXE4, SFR_TMR4CN, 3);            // Timer 4 External Enable
           =4 SBIT (TR4, SFR_TMR4CN, 2);             // Timer 4 Run Enable
           =4 SBIT (CT4, SFR_TMR4CN, 1);             // Timer 4 Counter/Timer Select
           =4 SBIT (CPRL4, SFR_TMR4CN, 0);           // Timer 4 Capture/Reload Select
           =4 
           =4 // PSW 0xD0
           =4 SBIT (CY, SFR_PSW, 7);                 // Carry Flag
           =4 SBIT (AC, SFR_PSW, 6);                 // Auxiliary Carry Flag
           =4 SBIT (F0, SFR_PSW, 5);                 // User Flag 0
           =4 SBIT (RS1, SFR_PSW, 4);                // Register Bank Select 1
           =4 SBIT (RS0, SFR_PSW, 3);                // Register Bank Select 0
           =4 SBIT (OV, SFR_PSW, 2);                 // Overflow Flag
           =4 SBIT (F1, SFR_PSW, 1);                 // User Flag 1
           =4 SBIT (P, SFR_PSW, 0);                  // Accumulator Parity Flag
           =4 
           =4 // PCA0CN 0xD8
           =4 SBIT (CF, SFR_PCA0CN, 7);              // PCA0 Counter Overflow Flag
           =4 SBIT (CR, SFR_PCA0CN, 6);              // PCA0 Counter Run Control Bit
           =4 SBIT (CCF5, SFR_PCA0CN, 5);            // PCA0 Module 5 Interrupt Flag
           =4 SBIT (CCF4, SFR_PCA0CN, 4);            // PCA0 Module 4 Interrupt Flag
           =4 SBIT (CCF3, SFR_PCA0CN, 3);            // PCA0 Module 3 Interrupt Flag
           =4 SBIT (CCF2, SFR_PCA0CN, 2);            // PCA0 Module 2 Interrupt Flag
           =4 SBIT (CCF1, SFR_PCA0CN, 1);            // PCA0 Module 1 Interrupt Flag
           =4 SBIT (CCF0, SFR_PCA0CN, 0);            // PCA0 Module 0 Interrupt Flag
           =4 
           =4 // PCA1CN 0xD8
           =4 SBIT (CF1, SFR_PCA1CN, 7);             // PCA1 Counter Overflow Flag
           =4 SBIT (CR1, SFR_PCA1CN, 6);             // PCA1 Counter Run Control Bit
           =4 SBIT (CCF11, SFR_PCA1CN, 5);           // PCA1 Module 11 Interrupt Flag
           =4 SBIT (CCF10, SFR_PCA1CN, 4);           // PCA1 Module 10 Interrupt Flag
           =4 SBIT (CCF9, SFR_PCA1CN, 3);            // PCA1 Module 9 Interrupt Flag
           =4 SBIT (CCF8, SFR_PCA1CN, 2);            // PCA1 Module 8 Interrupt Flag
           =4 SBIT (CCF7, SFR_PCA1CN, 1);            // PCA1 Module 7 Interrupt Flag
           =4 SBIT (CCF6, SFR_PCA1CN, 0);            // PCA1 Module 6 Interrupt Flag
           =4 
           =4 // ADC0CN 0xE8
           =4 SBIT (AD0EN, SFR_ADC0CN, 7);           // ADC0 Enable
           =4 SBIT (BURSTEN, SFR_ADC0CN, 6);         // ADC0 Burst Enable
           =4 SBIT (AD0INT, SFR_ADC0CN, 5);          // ADC0 EOC Interrupt Flag
           =4 SBIT (AD0BUSY, SFR_ADC0CN, 4);         // ADC0 Busy Flag
           =4 SBIT (AD0WINT, SFR_ADC0CN, 3);         // ADC0 Window Compare Interrupt Flag
           =4 SBIT (AD0LJST, SFR_ADC0CN, 2);         // ADC0 Left Justified
           =4 SBIT (AD0CM1, SFR_ADC0CN, 1);          // ADC0 Start Of Conversion Mode Bit 1
           =4 SBIT (AD0CM0, SFR_ADC0CN, 0);          // ADC0 Start Of Conversion Mode Bit 0
           =4 
           =4 // SPI0CN 0xF8
           =4 SBIT (SPIF, SFR_SPI0CN, 7);            // SPI0 Interrupt Flag
           =4 SBIT (WCOL, SFR_SPI0CN, 6);            // SPI0 Write Collision Flag
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 82  

           =4 SBIT (MODF, SFR_SPI0CN, 5);            // SPI0 Mode Fault Flag
           =4 SBIT (RXOVRN, SFR_SPI0CN, 4);          // SPI0 RX Overrun Flag
           =4 SBIT (NSSMD1, SFR_SPI0CN, 3);          // SPI0 Slave Select Mode 1
           =4 SBIT (NSSMD0, SFR_SPI0CN, 2);          // SPI0 Slave Select Mode 0
           =4 SBIT (TXBMT, SFR_SPI0CN, 1);           // SPI0 TX Buffer Empty Flag
           =4 SBIT (SPIEN, SFR_SPI0CN, 0);           // SPI0 Enable
           =4 
           =4 //-----------------------------------------------------------------------------
           =4 // Interrupt Priorities
           =4 //-----------------------------------------------------------------------------
           =4 
           =4 #define INTERRUPT_INT0             0   // External Interrupt 0
           =4 #define INTERRUPT_TIMER0           1   // Timer 0 Overflow
           =4 #define INTERRUPT_INT1             2   // External Interrupt 1
           =4 #define INTERRUPT_TIMER1           3   // Timer 1 Overflow
           =4 #define INTERRUPT_UART0            4   // UART0
           =4 #define INTERRUPT_TIMER2           5   // Timer 2 Overflow
           =4 #define INTERRUPT_SPI0             6   // SPI0
           =4 #define INTERRUPT_SMBUS0           7   // SMBus0 Interface
           =4 #define INTERRUPT_ADC0_WINDOW      8   // ADC0 Window Comparison
           =4 #define INTERRUPT_ADC0_EOC         9   // ADC0 End Of Conversion
           =4 #define INTERRUPT_PCA0            10   // PCA0 Peripheral
           =4 #define INTERRUPT_COMPARATOR0     11   // Comparator 0 Comparison
           =4 #define INTERRUPT_COMPARATOR1     12   // Comparator 1 Comparison
           =4 #define INTERRUPT_TIMER3          13   // Timer 3 Overflow
           =4 #define INTERRUPT_LIN0            14   // LIN Bus Interrupt
           =4 #define INTERRUPT_VREG            15   // Voltage Regulator
           =4 #define INTERRUPT_CAN0            16   // CAN Bus Interrupt
           =4 #define INTERRUPT_PORT_MATCH      17   // Port Match
           =4 #define INTERRUPT_UART1           18   // UART1
           =4 #define INTERRUPT_PCA1            19   // PCA1 Peripheral
           =4 #define INTERRUPT_COMPARATOR2     20   // Comparator 2 Comparison
           =4 #define INTERRUPT_TIMER4          21   // Timer 4 Overflow
           =4 #define INTERRUPT_TIMER5          22   // Timer 5 Overflow
           =4 
           =4 
           =4 //-----------------------------------------------------------------------------
           =4 // SFR Page Definitions
           =4 //-----------------------------------------------------------------------------
           =4 
           =4 #define  CONFIG_PAGE       0x0F        // System and Port Configuration Page
           =4 #define  ACTIVE_PAGE       0x00        // Active Use Page
           =4 #define  ACTIVE2_PAGE      0x10        // Active Use Page 2
           =4 #define  CAN0_PAGE         0x0C        // CAN0 Registers
           =4 
           =4 //-----------------------------------------------------------------------------
           =4 // SDCC PDATA External Memory Paging Support
           =4 //-----------------------------------------------------------------------------
           =4 
           =4 #if defined SDCC
           =4 
           =4 SFR(_XPAGE, 0xAA); // Point to the EMI0CN register
           =4 
           =4 #endif
           =4 
           =4 //-----------------------------------------------------------------------------
           =4 // Header File PreProcessor Directive
           =4 //-----------------------------------------------------------------------------
           =4 
           =4 #endif                                 // #define C8051F580_DEFS_H
 607      =4  
 608      =4  //-----------------------------------------------------------------------------
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 83  

 609      =4  // End Of File
 610      =4  //-----------------------------------------------------------------------------
   6      =3  
   7      =3  /* ----- Global Define -------------------------------*/
   8      =3  /*
   9      =3  #define TW8836          0x00U
  10      =3  #define DESERIALIZE     0x01U
  11      =3  #define SERIALIZE       0x02U
  12      =3  */
  13      =3  #define  TW8836_SLAVE_ADDRESS   (U8)0x8A
  14      =3  #define  TW8836_ID_ADRESS           (U8)0x00
  15      =3  #define  TW8836_ID                              (U16)0x0036
  16      =3  
  17      =3  #define  INIT                           0x00U           // (MR) data byte received
  18      =3  #define  RX                                     0x01U           // (MR) data byte received
  19      =3  #define  TX                                     0x02U           // (MR) data byte received
  20      =3  
  21      =3  #define USE_MDPS11                              0x00U
  22      =3  #define USE_LANGUAGEINFO                0x01U
  23      =3  #define USE_HUTYPE                              0x02U
  24      =3  #define USE_GATEWAY                             0x03U
  25      =3  #define USE_NAVIONOFF                   0x04U
  26      =3  #define USE_G_SEL_DISP                  0x05U
  27      =3  #define USE_IGN_SW                              0x06U
  28      =3  #define USE_RVM_CAMERAOFF               0x07U
  29      =3  #define FCZC_RVM_SW                             0x08U
  30      =3  #define USE_4WDERR                              0x09U
  31      =3  #define USE_ENGVOL                              0x0AU
  32      =3  #define USE_CAN_COUNT                   0x0BU           
  33      =3  
  34      =3  #define TYPE_2WD                                0x00U
  35      =3  #define TYPE_4WD                                0x01U
  36      =3  
  37      =3  #define TYPE_ENGVOL20                   0x14U
  38      =3  #define TYPE_ENGVOL22                   0x16U
  39      =3  #define TYPE_ENGVOL33                   0x21U
  40      =3  /*----------------------------------------------------*/
  41      =3  
  42      =3  /* ----- Function ------------------------------------*/
  43      =3  void Init_CommTask(void);
  44      =3  void Operate_CommTask(void);
  45      =3  void Rx_Data_Process(void);
  46      =3  //void Comm_I2C_Tx_Data(void);
  47      =3  void Comm_I2C_Tx(U8 Slave_Addr,U8 Length,U16 Addr, U16 TData,U16 RData );
  48      =3  U16   Comm_I2C_Rx(U8 Slave_Addr,U8 Length,U16 Addr, U16 TData,U16 RData );
  49      =3  void Clear_I2C_Tx_Data(void);
  50      =3  void Clear_CAN_Tx_Data(void);
  51      =3  void Clear_Can_Data(void);
  52      =3  void Clear_Sas_Data(void);
  53      =3  
  54      =3  void Comm_RearView_Data(void);
  55      =3  void Comm_Tuning_Value_Type(U8 Type4WdErr, U8 TypeEngVol);
  56      =3  U8 Comm_Sas_Data(U8 *pa_Data);
  57      =3  U8 Comm_Hutype_Data(U8 *pa_Data);
  58      =3  U8 Comm_Language_Data(U8 *pa_Data);
  59      =3  U8 Comm_G_Sel_Disp_Data(U8 *Data);
  60      =3  U8 Comm_IGN_Sw_Data(U8 *Data);
  61      =3  U8 Comm_RVM_CameraOff_Data(U8 *Data);
  62      =3  U8 Comm_RVM_SW_Data(U8 *Data);
  63      =3  U8 Comm_ENG_Vol_Data(U8 *pa_Data);
  64      =3  U8 Comm_4WD_Err_Data(U8 *pa_Data);
  65      =3  void Comm_Tx_RVM_View(U8 sigData);
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 84  

  66      =3  void Comm_Tx_RVM_SW_IND(U8 sigData);
  67      =3  
  68      =3  void Flash_OneSpec_Write(void);
  69      =3  void Flash_OneSpec_Read(void);
  70      =3  void Comm_Error_Check(void);
  71      =3  
  72      =3  void IlPutTxRVM_View(U8 sigData);
  73      =3  
  74      =3  void IlPutTxRVM_SW_IND(U8 sigData);
  75      =3  /*----------------------------------------------------*/
  76      =3  
  77      =3  /* ----- Extern Function -----------------------------*/
  78      =3  /*----------------------------------------------------*/
  79      =3  
  80      =3  /* ----- Global Value --------------------------------*/
  81      =3  
  82      =3  typedef struct {
  83      =3          U8  Slave;
  84      =3          U8  Length;
  85      =3          U8  TRX_Flag;
  86      =3          U16 Addr;
  87      =3          U16 TxData;
  88      =3          U16 RxData;
  89      =3  }tMsg_I2C_Tx_Data_s;
  90      =3  
  91      =3  typedef struct {
  92      =3          U8  Slave;
  93      =3          U8  Length;
  94      =3          U8  TRX_Flag;
  95      =3          U16 Addr;
  96      =3          U16 TxData;
  97      =3          U16 RxData;
  98      =3  }tMsg_CAN_Tx_Data_s;
  99      =3  
 100      =3  typedef struct {
 101      =3          U8 Is_Change;
 102      =3          U8 Change_Count;
 103      =3          U8 Time_Out;
 104      =3          U8 Cur_Data;
 105      =3          U8 Mid_Data;
 106      =3          U8 Pre_Data;
 107      =3          U16 Chatter_Time;
 108      =3  }tMsg_CAN_Rx_Data_s;
 109      =3  
 110      =3  typedef struct {
 111      =3          U8  Is_Change;
 112      =3          U8  Pre_Sign;
 113      =3          U8  Angle;
 114      =3          U8  Angle_Pre_Sign;
 115      =3          U8  Time_Out;
 116      =3          U16 Pre_Data;
 117      =3          U8      Tuning_Type;
 118      =3  }tMsg_CAN_SAS_Data_s;
 119      =3  
 120      =3  typedef struct {
 121      =3          U8  Is_Change;
 122      =3          U8  Pre_Sign;
 123      =3          U8  Angle;
 124      =3          U16 Pre_Data;
 125      =3  }tMsg_CAN_State_s;
 126      =3  
 127      =3  
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 85  

 128      =3  /*
 129      =3  struct tCAN_Tx_Data_s {
 130      =3          U8 Flag;
 131      =3          U8 Dest;
 132      =3          U8 Length;
 133      =3          U8 *TxData;
 134      =3  }
 135      =3  
 136      =3  struct tCAN_Rx_Data_s {
 137      =3          U8 Flag;
 138      =3          U8 Src;
 139      =3          U8 Length;
 140      =3          U8 RxData;
 141      =3  }
 142      =3  */
 143      =3  /*----------------------------------------------------*/
 144      =3  
 145      =3  extern SEG_XDATA volatile tMsg_CAN_SAS_Data_s tCAN_Rx_SAS_Msg;
 146      =3  #endif
 147      =3  
   7      =2  #include "compiler_defs.h"
   1      =3  //-----------------------------------------------------------------------------
   2      =3  // compiler_defs.h
   3      =3  //-----------------------------------------------------------------------------
   4      =3  // Portions of this file are copyright Maarten Brock
   5      =3  // http://sdcc.sourceforge.net
   6      =3  // Portions of this file are copyright 2010, Silicon Laboratories, Inc.
   7      =3  // http://www.silabs.com
   8      =3  //
   9      =3  // GNU LGPL boilerplate:
  10      =3  /** This library is free software; you can redistribute it and/or
  11      =3    * modify it under the terms of the GNU Lesser General Public
  12      =3    * License as published by the Free Software Foundation; either
  13      =3    * version 2.1 of the License, or (at your option) any later version.
  14      =3    *
  15      =3    * This library is distributed in the hope that it will be useful,
  16      =3    * but WITHOUT ANY WARRANTY; without even the implied warranty of
  17      =3    * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
  18      =3    * Lesser General Public License for more details.
  19      =3    *
  20      =3    * You should have received a copy of the GNU Lesser General Public
  21      =3    * License along with this library; if not, write to the Free Software
  22      =3    * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
  23      =3    *
  24      =3    * In other words, you are welcome to use, share and improve this program.
  25      =3    * You are forbidden to forbid anyone else to use, share and improve
  26      =3    * what you give them. Help stamp out software-hoarding!
  27      =3  **/
  28      =3  // Program Description:
  29      =3  //
  30      =3  // **Important Note**: This header file should be included before including
  31      =3  // a device-specific header file such as C8051F300_defs.h.
  32      =3  //
  33      =3  // Macro definitions to accomodate 8051 compiler differences in specifying
  34      =3  // special function registers and other 8051-specific features such as NOP
  35      =3  // generation, and locating variables in memory-specific segments.  The
  36      =3  // compilers are identified by their unique predefined macros. See also:
  37      =3  // http://predef.sourceforge.net/precomp.html
  38      =3  //
  39      =3  // SBIT and SFR define special bit and special function registers at the given
  40      =3  // address. SFR16 and SFR32 define sfr combinations at adjacent addresses in
  41      =3  // little-endian format. SFR16E and SFR32E define sfr combinations without
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 86  

  42      =3  // prerequisite byte order or adjacency. None of these multi-byte sfr
  43      =3  // combinations will guarantee the order in which they are accessed when read
  44      =3  // or written.
  45      =3  //
  46      =3  // SFR16X and SFR32X for 16 bit and 32 bit xdata registers are not defined
  47      =3  // to avoid portability issues because of compiler endianness.
  48      =3  //
  49      =3  // Example:
  50      =3  // // my_mcu.c: main 'c' file for my mcu
  51      =3  // #include <compiler_defs.h>  // this file
  52      =3  // #include <C8051xxxx_defs.h> // SFR definitions for specific MCU target
  53      =3  //
  54      =3  // SBIT  (P0_1, 0x80, 1);      // Port 0 pin 1
  55      =3  // SFR   (P0, 0x80);           // Port 0
  56      =3  // SFRX  (CPUCS, 0xE600);      // Cypress FX2 Control and Status register in
  57      =3  //                             // xdata memory at 0xE600
  58      =3  // SFR16 (TMR2, 0xCC);         // Timer 2, lsb at 0xCC, msb at 0xCD
  59      =3  // SFR16E(TMR0, 0x8C8A);       // Timer 0, lsb at 0x8A, msb at 0x8C
  60      =3  // SFR32 (MAC0ACC, 0x93);      // SiLabs C8051F120 32 bits MAC0 Accumulator,
  61      =3  //                             // lsb at 0x93, msb at 0x96
  62      =3  // SFR32E(SUMR, 0xE5E4E3E2);   // TI MSC1210 SUMR 32 bits Summation register,
  63      =3  //                             // lsb at 0xE2, msb at 0xE5
  64      =3  //
  65      =3  // Target:         C8051xxxx
  66      =3  // Tool chain:     Generic
  67      =3  // Command Line:   None
  68      =3  // 
  69      =3  // Release 2.6 - 14 DEC 2012 (GO)
  70      =3  //        -Added define for deprecated SDCC keyword 'at'
  71      =3  // Release 2.5 - 12 SEP 2012 (TP)
  72      =3  //    -Added defines for deprecated SDCC keywords bit and code
  73      =3  // Release 2.4 - 27 AUG 2012 (TP)
  74      =3  //    -Added defines for deprecated SDCC keywords interrupt, _asm, and _endasm
  75      =3  // Release 2.3 - 27 MAY 2010 (DM)
  76      =3  //    -Removed 'LOCATED_VARIABLE' pragma from Keil because it is not supported
  77      =3  // Release 2.2 - 06 APR 2010 (ES)
  78      =3  //    -Removed 'PATHINCLUDE' pragma from Raisonance section
  79      =3  // Release 2.1 - 16 JUL 2009 (ES)
  80      =3  //    -Added SEGMENT_POINTER macro definitions for SDCC, Keil, and Raisonance
  81      =3  //    -Added LOCATED_VARIABLE_NO_INIT macro definitions for Raisonance
  82      =3  // Release 2.0 - 19 MAY 2009 (ES)
  83      =3  //    -Added LOCATED_VARIABLE_NO_INIT macro definitions for SDCC and Keil
  84      =3  // Release 1.9 - 23 OCT 2008 (ES)
  85      =3  //    -Updated Hi-Tech INTERRUPT and INTERRUPT_USING macro definitions
  86      =3  //    -Added SFR16 macro defintion for Hi-Tech
  87      =3  // Release 1.8 - 31 JUL 2008 (ES)
  88      =3  //    -Added INTERRUPT_USING and FUNCTION_USING macro's
  89      =3  //    -Added macro's for IAR
  90      =3  //    -Corrected Union definitions for Hi-Tech and added SFR16 macro defintion
  91      =3  // Release 1.7 - 11 SEP 2007 (BW)
  92      =3  //    -Added support for Raisonance EVAL 03.03.42 and Tasking Eval 7.2r1
  93      =3  // Release 1.6 - 27 AUG 2007 (BW)
  94      =3  //    -Updated copyright notice per agreement with Maartin Brock
  95      =3  //    -Added SDCC 2.7.0 "compiler.h" bug fixes
  96      =3  //    -Added memory segment defines (SEG_XDATA, for example)
  97      =3  // Release 1.5 - 24 AUG 2007 (BW)
  98      =3  //    -Added support for NOP () macro
  99      =3  //    -Added support for Hi-Tech ver 9.01
 100      =3  // Release 1.4 - 07 AUG 2007 (PKC)
 101      =3  //    -Removed FID and fixed formatting.
 102      =3  // Release 1.3 - 30 SEP 2007 (TP)
 103      =3  //    -Added INTERRUPT_PROTO_USING to properly support ISR context switching
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 87  

 104      =3  //     under SDCC.
 105      =3  // Release 1.2 - (BW)
 106      =3  //    -Added support for U8,U16,U32,S8,S16,S32,UU16,UU32 data types
 107      =3  // Release 1.1 - (BW)
 108      =3  //    -Added support for INTERRUPT, INTERRUPT_USING, INTERRUPT_PROTO,
 109      =3  //     SEGMENT_VARIABLE, VARIABLE_SEGMENT_POINTER,
 110      =3  //     SEGMENT_VARIABLE_SEGMENT_POINTER, and LOCATED_VARIABLE
 111      =3  // Release 1.0 - 29 SEP 2006 (PKC)
 112      =3  //    -Initial revision
 113      =3  
 114      =3  //-----------------------------------------------------------------------------
 115      =3  // Header File Preprocessor Directive
 116      =3  //-----------------------------------------------------------------------------
 117      =3  
 118      =3  #ifndef COMPILER_DEFS_H
           =3 #define COMPILER_DEFS_H
           =3 
           =3 //-----------------------------------------------------------------------------
           =3 // Macro definitions
           =3 //-----------------------------------------------------------------------------
           =3 
           =3 // SDCC - Small Device C Compiler
           =3 // http://sdcc.sourceforge.net
           =3 
           =3 #if defined SDCC
           =3 
           =3 #if (SDCC >= 300)
           =3 
           =3 #define interrupt __interrupt
           =3 #define _asm __asm
           =3 #define _endasm __endasm
           =3 #define bit __bit
           =3 #define code __code
           =3 #define at __at
           =3 
           =3 #endif
           =3 
           =3 # define SEG_GENERIC
           =3 # define SEG_FAR   __xdata
           =3 # define SEG_DATA  __data
           =3 # define SEG_NEAR  __data
           =3 # define SEG_IDATA __idata
           =3 # define SEG_XDATA __xdata
           =3 # define SEG_PDATA __pdata
           =3 # define SEG_CODE  __code
           =3 # define SEG_BDATA __bdata
           =3 
           =3 # define SBIT(name, addr, bit)  __sbit  __at(addr+bit)                  name
           =3 # define SFR(name, addr)        __sfr   __at(addr)                      name
           =3 # define SFRX(name, addr)       xdata volatile unsigned char __at(addr) name
           =3 # define SFR16(name, addr)      __sfr16 __at(((addr+1U)<<8) | addr)     name
           =3 # define SFR16E(name, fulladdr) __sfr16 __at(fulladdr)                  name
           =3 # define SFR32(name, addr)      __sfr32 __at(((addr+3UL)<<24) | ((addr+2UL)<<16) | ((addr+1UL)<<8) | addr)
             - name
           =3 # define SFR32E(name, fulladdr) __sfr32 __at(fulladdr)                  name
           =3 
           =3 # define INTERRUPT(name, vector) void name (void) interrupt (vector)
           =3 # define INTERRUPT_USING(name, vector, regnum) void name (void) interrupt (vector) using (regnum)
           =3 # define INTERRUPT_PROTO(name, vector) void name (void) interrupt (vector)
           =3 # define INTERRUPT_PROTO_USING(name, vector, regnum) void name (void) interrupt (vector) using (regnum)
           =3 
           =3 # define FUNCTION_USING(name, return_value, parameter, regnum) return_value name (parameter) using (regnum
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 88  

             -)
           =3 # define FUNCTION_PROTO_USING(name, return_value, parameter, regnum) return_value name (parameter) using (
             -regnum)
           =3 // Note: Parameter must be either 'void' or include a variable type and name. (Ex: char temp_variable)
           =3 
           =3 # define SEGMENT_VARIABLE(name, vartype, locsegment) locsegment vartype name
           =3 # define VARIABLE_SEGMENT_POINTER(name, vartype, targsegment) targsegment vartype * name
           =3 # define SEGMENT_VARIABLE_SEGMENT_POINTER(name, vartype, targsegment, locsegment) targsegment vartype * lo
             -csegment name
           =3 # define SEGMENT_POINTER(name, vartype, locsegment) vartype * locsegment name
           =3 # define LOCATED_VARIABLE(name, vartype, locsegment, addr, init) locsegment at (addr) vartype name = init
           =3 # define LOCATED_VARIABLE_NO_INIT(name, vartype, locsegment, addr) locsegment at (addr) vartype name
           =3 
           =3 // used with UU16
           =3 # define LSB 0
           =3 # define MSB 1
           =3 
           =3 // used with UU32 (b0 is least-significant byte)
           =3 //# define b0 0
           =3 //# define b1 1
           =3 //# define b2 2
           =3 //# define b3 3
           =3 
           =3 typedef unsigned char U8;
           =3 typedef unsigned int U16;
           =3 typedef unsigned long U32;
           =3 
           =3 typedef signed char S8;
           =3 typedef signed int S16;
           =3 typedef signed long S32;
           =3 
           =3 typedef union UU16
           =3 {
           =3    U16 U16;
           =3    S16 S16;
           =3    U8 U8[2];
           =3    S8 S8[2];
           =3 } UU16;
           =3 
           =3 typedef union UU32
           =3 {
           =3    U32 U32;
           =3    S32 S32;
           =3    UU16 UU16[2];
           =3    U16 U16[2];
           =3    S16 S16[2];
           =3    U8 U8[4];
           =3    S8 S8[4];
           =3 } UU32;
           =3 
           =3 // NOP () macro support
           =3 #define NOP() _asm NOP _endasm
           =3 
           =3 
           =3 //-----------------------------------------------------------------------------
           =3 
           =3 // Raisonance (must be placed before Keil C51)
           =3 // http://www.raisonance.com
           =3 
           =3 #elif defined __RC51__
           =3 
           =3 //#error Raisonance C51 detected.
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 89  

           =3 
           =3 # define SEG_GENERIC generic     //SEG_GENERIC only applies to pointers in Raisonance, not variables.
           =3 # define SEG_FAR   xdata
           =3 # define SEG_DATA  data
           =3 # define SEG_NEAR  data
           =3 # define SEG_IDATA idata
           =3 # define SEG_XDATA xdata
           =3 # define SEG_PDATA pdata
           =3 # define SEG_CODE  code
           =3 # define SEG_BDATA bdata
           =3 
           =3 # define SBIT(name, addr, bit)  at (addr+bit) sbit         name
           =3 # define SFR(name, addr)        sfr at addr                name
           =3 # define SFR16(name, addr)      sfr16 at addr              name
           =3 # define SFR16E(name, fulladdr) /* not supported */
           =3 # define SFR32(name, fulladdr)  /* not supported */
           =3 # define SFR32E(name, fulladdr) /* not supported */
           =3 
           =3 # define INTERRUPT(name, vector) void name (void) interrupt vector
           =3 # define INTERRUPT_USING(name, vector, regnum) void name (void) interrupt vector using regnum
           =3 # define INTERRUPT_PROTO(name, vector) void name (void)
           =3 # define INTERRUPT_PROTO_USING(name, vector, regnum) void name (void)
           =3 
           =3 # define FUNCTION_USING(name, return_value, parameter, regnum) return_value name (parameter) using regnum
           =3 # define FUNCTION_PROTO_USING(name, return_value, parameter, regnum) return_value name (parameter)
           =3 // Note: Parameter must be either 'void' or include a variable type and name. (Ex: char temp_variable)
           =3 
           =3 # define SEGMENT_VARIABLE(name, vartype, locsegment) vartype locsegment name
           =3 # define VARIABLE_SEGMENT_POINTER(name, vartype, targsegment) vartype targsegment * name
           =3 # define SEGMENT_VARIABLE_SEGMENT_POINTER(name, vartype, targsegment, locsegment) vartype targsegment * lo
             -csegment name
           =3 # define SEGMENT_POINTER(name, vartype, locsegment) vartype * locsegment name
           =3 # define LOCATED_VARIABLE(name, vartype, locsegment, addr, init) at addr locsegment vartype name
           =3 # define LOCATED_VARIABLE_NO_INIT(name, vartype, locsegment, addr) at addr locsegment vartype name
           =3 
           =3 
           =3 // used with UU16
           =3 # define LSB 1
           =3 # define MSB 0
           =3 
           =3 // used with UU32 (b0 is least-significant byte)
           =3 //# define b0 3
           =3 //# define b1 2
           =3 //# define b2 1
           =3 //# define b3 0
           =3 
           =3 typedef unsigned char U8;
           =3 typedef unsigned int U16;
           =3 typedef unsigned long U32;
           =3 
           =3 typedef signed char S8;
           =3 typedef signed int S16;
           =3 typedef signed long S32;
           =3 
           =3 typedef union UU16
           =3 {
           =3    U16 U16;
           =3    S16 S16;
           =3    U8 U8[2];
           =3    S8 S8[2];
           =3 } UU16;
           =3 
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 90  

           =3 typedef union UU32
           =3 {
           =3    U32 U32;
           =3    S32 S32;
           =3    UU16 UU16[2];
           =3    U16 U16[2];
           =3    S16 S16[2];
           =3    U8 U8[4];
           =3    S8 S8[4];
           =3 } UU32;
           =3 
           =3 // NOP () macro support -- NOP is opcode 0x00
           =3 #define NOP() asm { 0x00 }
           =3 
           =3 
           =3 //-----------------------------------------------------------------------------
           =3 
           =3 
           =3 // Keil C51
           =3 // http://www.keil.com
           =3 
           =3 #elif defined __C51__
           =3 
           =3 //#error Keil C51 detected.
           =3 
           =3 # define SEG_GENERIC
           =3 # define SEG_FAR   xdata
           =3 # define SEG_DATA  data
           =3 # define SEG_NEAR  data
           =3 # define SEG_IDATA idata
           =3 # define SEG_XDATA xdata
           =3 # define SEG_PDATA pdata
           =3 # define SEG_CODE  code
           =3 # define SEG_BDATA bdata
           =3 
           =3 # define SBIT(name, addr, bit)  sbit  name = addr^bit
           =3 # define SFR(name, addr)        sfr   name = addr
           =3 # define SFR16(name, addr)      sfr16 name = addr
           =3 # define SFR16E(name, fulladdr) /* not supported */
           =3 # define SFR32(name, fulladdr)  /* not supported */
           =3 # define SFR32E(name, fulladdr) /* not supported */
           =3 
           =3 # define INTERRUPT(name, vector) void name (void) interrupt vector
           =3 # define INTERRUPT_USING(name, vector, regnum) void name (void) interrupt vector using regnum
           =3 # define INTERRUPT_PROTO(name, vector) void name (void)
           =3 # define INTERRUPT_PROTO_USING(name, vector, regnum) void name (void)
           =3 
           =3 # define FUNCTION_USING(name, return_value, parameter, regnum) return_value name (parameter) using regnum
           =3 # define FUNCTION_PROTO_USING(name, return_value, parameter, regnum) return_value name (parameter)
           =3 // Note: Parameter must be either 'void' or include a variable type and name. (Ex: char temp_variable)
           =3 
           =3 # define SEGMENT_VARIABLE(name, vartype, locsegment) vartype locsegment name
           =3 # define VARIABLE_SEGMENT_POINTER(name, vartype, targsegment) vartype targsegment * name
           =3 # define SEGMENT_VARIABLE_SEGMENT_POINTER(name, vartype, targsegment, locsegment) vartype targsegment * lo
             -csegment name
           =3 # define SEGMENT_POINTER(name, vartype, locsegment) vartype * locsegment name
           =3 # define LOCATED_VARIABLE_NO_INIT(name, vartype, locsegment, addr) vartype locsegment name _at_ addr
           =3 
           =3 // used with UU16
           =3 # define LSB 1
           =3 # define MSB 0
           =3 
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 91  

           =3 // used with UU32 (b0 is least-significant byte)
           =3 //# define b0 3
           =3 // define b1 2
           =3 //# define b2 1
           =3 //# define b3 0
           =3 
           =3 typedef unsigned char U8;
           =3 typedef unsigned int U16;
           =3 typedef unsigned long U32;
           =3 
           =3 typedef signed char S8;
           =3 typedef signed int S16;
           =3 typedef signed long S32;
           =3 
           =3 typedef union UU16
           =3 {
           =3    U16 U16;
           =3    S16 S16;
           =3    U8 U8[2];
           =3    S8 S8[2];
           =3 } UU16;
           =3 
           =3 typedef union UU32
           =3 {
           =3    U32 U32;
           =3    S32 S32;
           =3    UU16 UU16[2];
           =3    U16 U16[2];
           =3    S16 S16[2];
           =3    U8 U8[4];
           =3    S8 S8[4];
           =3 } UU32;
           =3 
           =3 // NOP () macro support
           =3 extern void _nop_ (void);
           =3 #define NOP() _nop_()
           =3 
           =3 //-----------------------------------------------------------------------------
           =3 
           =3 // Hi-Tech 8051
           =3 // http://www.htsoft.com
           =3 
           =3 #elif defined HI_TECH_C
           =3 
           =3 # define SEG_GENERIC
           =3 # define SEG_FAR   far
           =3 # define SEG_DATA  data
           =3 # define SEG_NEAR  near
           =3 # define SEG_IDATA idata
           =3 # define SEG_XDATA xdata
           =3 # define SEG_PDATA pdata
           =3 # define SEG_CODE  code
           =3 # define SEG_BDATA bdata
           =3 
           =3 
           =3 # define SBIT(name, addr, thebit) static volatile bit name @ (addr + thebit)
           =3 # define SFR(name, addr)          static volatile unsigned char name @ addr
           =3 # define SFR16(name, addr)        static volatile unsigned int name @ addr
           =3 # define SFR16E(name, fulladdr) /* not supported */
           =3 # define SFR32(name, fulladdr)  /* not supported */
           =3 # define SFR32E(name, fulladdr) /* not supported */
           =3 
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 92  

           =3 # define INTERRUPT(name, vector)       void name (void) interrupt vector
           =3 # define INTERRUPT_PROTO(name, vector)
           =3 # define INTERRUPT_USING(name, vector, regnum) void name (void) interrupt vector using regnum
           =3 # define INTERRUPT_PROTO_USING(name, vector, regnum)
           =3 
           =3 # define FUNCTION_USING(name, return_value, parameter, regnum) /* not supported */
           =3 # define FUNCTION_PROTO_USING(name, return_value, parameter, regnum) /* not supported */
           =3 // Note: Hi-Tech does not support functions using different register banks. Register
           =3 //       banks can only be specified in interrupts. If a function is called from
           =3 //       inside an interrupt, it will use the same register bank as the interrupt.
           =3 
           =3 # define SEGMENT_VARIABLE(name, vartype, locsegment) locsegment vartype name
           =3 # define VARIABLE_SEGMENT_POINTER(name, vartype, targsegment) targsegment vartype * name
           =3 # define SEGMENT_VARIABLE_SEGMENT_POINTER(name, vartype, targsegment, locsegment) targsegment vartype * lo
             -csegment name
           =3 # define LOCATED_VARIABLE(name, vartype, locsegment, addr, init) locsegment vartype name @ addr
           =3 
           =3 // used with UU16
           =3 # define LSB 0
           =3 # define MSB 1
           =3 
           =3 // used with UU32 (b0 is least-significant byte)
           =3 # define b0 0
           =3 # define b1 1
           =3 # define b2 2
           =3 # define b3 3
           =3 
           =3 typedef unsigned char U8;
           =3 typedef unsigned int U16;
           =3 typedef unsigned long U32;
           =3 
           =3 typedef signed char S8;
           =3 typedef signed int S16;
           =3 typedef signed long S32;
           =3 
           =3 typedef union UU16
           =3 {
           =3    U16 U16;
           =3    S16 S16;
           =3    U8 U8[2];
           =3    S8 S8[2];
           =3 } UU16;
           =3 
           =3 typedef union UU32
           =3 {
           =3    U32 U32;
           =3    S32 S32;
           =3    UU16 UU16[2];
           =3    U16 U16[2];
           =3    S16 S16[2];
           =3    U8 U8[4];
           =3    S8 S8[4];
           =3 } UU32;
           =3 
           =3 // NOP () macro support
           =3 #define NOP() asm(" nop ")
           =3 
           =3 //-----------------------------------------------------------------------------
           =3 
           =3 // Tasking / Altium
           =3 // http://www.altium.com/tasking
           =3 
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 93  

           =3 
           =3 #elif defined _CC51
           =3 
           =3 # define SEG_GENERIC
           =3 # define SEG_FAR   _xdat
           =3 # define SEG_DATA  _data
           =3 # define SEG_NEAR  _data
           =3 # define SEG_IDATA _idat
           =3 # define SEG_XDATA _xdat
           =3 # define SEG_PDATA _pdat
           =3 # define SEG_CODE  _rom
           =3 # define SEG_BDATA _bdat
           =3 
           =3 # define SBIT(name, addr, bit)  _sfrbit  name _at(addr+bit)
           =3 # define SFR(name, addr)        _sfrbyte name _at(addr)
           =3 # define SFRX(name, addr)       _xdat volatile unsigned char name _at(addr)
           =3 #if _CC51 > 71
           =3 # define SFR16(name, addr)      _sfrword _little name _at(addr)
           =3 #else
           =3 # define SFR16(name, addr)      /* not supported */
           =3 #endif
           =3 # define SFR16E(name, fulladdr) /* not supported */
           =3 # define SFR32(name, fulladdr)  /* not supported */
           =3 # define SFR32E(name, fulladdr) /* not supported */
           =3 
           =3 # define INTERRUPT(name, vector) _interrupt (vector) void name (void)
           =3 # define INTERRUPT_USING(name, vector, regnum) _interrupt (vector) _using(regnum) void name (void)
           =3 # define INTERRUPT_PROTO(name, vector) _interrupt (vector) void name (void)
           =3 # define INTERRUPT_PROTO_USING(name, vector, regnum) _interrupt (vector) _using(regnum) void name (void)
           =3 
           =3 // When calling FUNCTION_USING in Tasking, the function must be called from an interrupt or Main which
           =3 // is also using the same register bank. If not, the compiler will generate an error.
           =3 # define FUNCTION_USING(name, return_value, parameter, regnum) _using(regnum) return_value name (parameter
             -)
           =3 # define FUNCTION_PROTO_USING(name, return_value, parameter, regnum) _using(regnum) return_value name (par
             -ameter)
           =3 // Note: Parameter must be either 'void' or include a variable type and name. (Ex: char temp_variable)
           =3 
           =3 # define SEGMENT_VARIABLE(name, vartype, locsegment) vartype locsegment name
           =3 # define VARIABLE_SEGMENT_POINTER(name, vartype, targsegment) vartype targsegment * name
           =3 # define SEGMENT_VARIABLE_SEGMENT_POINTER(name, vartype, targsegment, locsegment) vartype targsegment * lo
             -csegment name
           =3 # define LOCATED_VARIABLE(name, vartype, locsegment, addr, init) vartype locsegment name _at( addr )
           =3 
           =3 // used with UU16
           =3 # define LSB 1
           =3 # define MSB 0
           =3 
           =3 // used with UU32 (b0 is least-significant byte)
           =3 //# define b0 3
           =3 //# define b1 2
           =3 //# define b2 1
           =3 //# define b3 0
           =3 
           =3 typedef unsigned char U8;
           =3 typedef unsigned int U16;
           =3 typedef unsigned long U32;
           =3 
           =3 typedef signed char S8;
           =3 typedef signed int S16;
           =3 typedef signed long S32;
           =3 
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 94  

           =3 typedef union UU16
           =3 {
           =3    U16 U16;
           =3    S16 S16;
           =3    U8 U8[2];
           =3    S8 S8[2];
           =3 } UU16;
           =3 
           =3 typedef union UU32
           =3 {
           =3    U32 U32;
           =3    S32 S32;
           =3    UU16 UU16[2];
           =3    U16 U16[2];
           =3    S16 S16[2];
           =3    U8 U8[4];
           =3    S8 S8[4];
           =3 } UU32;
           =3 
           =3 // NOP () macro support
           =3 extern void _nop (void);
           =3 #define NOP() _nop()
           =3 
           =3 //-----------------------------------------------------------------------------
           =3 
           =3 
           =3 // IAR 8051
           =3 // http://www.iar.com
           =3 
           =3 #elif defined __ICC8051__
           =3 
           =3 #include <stdbool.h>
           =3 #include <intrinsics.h>
           =3 
           =3 # define SBIT(name, addr, bit)  __bit __no_init volatile bool name @ (addr+bit)
           =3 # define SFR(name, addr)        __sfr __no_init volatile unsigned char name @ addr
           =3 # define SFRX(name, addr)       __xdata __no_init volatile unsigned char name @ addr
           =3 # define SFR16(name, addr)      __sfr __no_init volatile unsigned int  name @ addr
           =3 # define SFR16E(name, fulladdr) /* not supported */
           =3 # define SFR32(name, fulladdr) /* not supported */
           =3 # define SFR32E(name, fulladdr) /* not supported */
           =3 
           =3 # define SEG_GENERIC __generic
           =3 # define SEG_FAR  __xdata
           =3 # define SEG_DATA __data
           =3 # define SEG_NEAR __data
           =3 # define SEG_IDATA __idata
           =3 # define SEG_XDATA __xdata
           =3 # define SEG_PDATA __pdata
           =3 # define SEG_CODE  __code
           =3 # define SEG_BDATA __bdata
           =3 
           =3 #define bit bool
           =3 
           =3 # define _PPTOSTR_(x) #x
           =3 # define _PPARAM_(address) _PPTOSTR_(vector=address * 8 + 3)
           =3 # define _PPARAM2_(regbank) _PPTOSTR_(register_bank=regbank)
           =3 # define INTERRUPT(name, vector) _Pragma(_PPARAM_(vector)) __interrupt void name(void)
           =3 # define INTERRUPT_PROTO(name, vector)  __interrupt void name(void)
           =3 # define INTERRUPT_USING(name, vector, regnum) _Pragma(_PPARAM2_(regnum)) _Pragma(_PPARAM_(vector)) __inte
             -rrupt void name(void)
           =3 # define INTERRUPT_PROTO_USING(name, vector, regnum) __interrupt void name(void)
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 95  

           =3 
           =3 # define FUNCTION_USING(name, return_value, parameter, regnum) /* not supported */
           =3 # define FUNCTION_PROTO_USING(name, return_value, parameter, regnum) /* not supported */
           =3 // Note: IAR does not support functions using different register banks. Register
           =3 //       banks can only be specified in interrupts. If a function is called from
           =3 //       inside an interrupt, it will use the same register bank as the interrupt.
           =3 
           =3 # define SEGMENT_VARIABLE(name, vartype, locsegment)  locsegment vartype name
           =3 # define VARIABLE_SEGMENT_POINTER(name, vartype, targsegment) vartype targsegment  * name
           =3 # define SEGMENT_VARIABLE_SEGMENT_POINTER(name, vartype, targsegment, locsegment) vartype targsegment * lo
             -csegment name
           =3 
           =3 # define LOCATED_VARIABLE(name, vartype, locsegment, addr, init) locsegment __no_init vartype name @ addr
           =3 
           =3 // used with UU16
           =3 # define LSB 0
           =3 # define MSB 1
           =3 
           =3 // used with UU32 (b0 is least-significant byte)
           =3 //# define b0 0
           =3 //# define b1 1
           =3 //# define b2 2
           =3 //# define b3 3
           =3 
           =3 typedef unsigned char U8;
           =3 typedef unsigned int U16;
           =3 typedef unsigned long U32;
           =3 
           =3 typedef signed char S8;
           =3 typedef signed int S16;
           =3 typedef signed long S32;
           =3 
           =3 typedef union UU16
           =3 {
           =3    U16 U16;
           =3    S16 S16;
           =3    U8 U8[2];
           =3    S8 S8[2];
           =3 } UU16;
           =3 
           =3 typedef union UU32
           =3 {
           =3    U32 U32;
           =3    S32 S32;
           =3    UU16 UU16[2];
           =3    U16 U16[2];
           =3    S16 S16[2];
           =3    U8 U8[4];
           =3    S8 S8[4];
           =3 } UU32;
           =3 
           =3 
           =3 #define NOP() __no_operation();
           =3 //-----------------------------------------------------------------------------
           =3 
           =3 // Crossware
           =3 // http://www.crossware.com
           =3 
           =3 #elif defined _XC51_VER
           =3 # define SBIT(name, addr, bit)  _sfrbit  name = (addr+bit)
           =3 # define SFR(name, addr)        _sfr     name = addr
           =3 # define SFR16(name, addr)      _sfrword name = addr
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 96  

           =3 # define SFR16E(name, fulladdr) /* not supported */
           =3 # define SFR32(name, fulladdr)  /* not supported */
           =3 # define SFR32E(name, fulladdr) /* not supported */
           =3 
           =3 //-----------------------------------------------------------------------------
           =3 
           =3 // Wickenhäuser
           =3 // http://www.wickenhaeuser.de
           =3 
           =3 #elif defined __UC__
           =3 # define SBIT(name, addr, bit)  unsigned char bit  name @ (addr+bit)
           =3 # define SFR(name, addr)        near unsigned char name @ addr
           =3 # define SFR16(name, addr)      /* not supported */
           =3 # define SFR16E(name, fulladdr) /* not supported */
           =3 # define SFR32(name, fulladdr)  /* not supported */
           =3 # define SFR32E(name, fulladdr) /* not supported */
           =3 
           =3 //-----------------------------------------------------------------------------
           =3 
           =3 // Default
           =3 // Unknown compiler
           =3 
           =3 #else
           =3 # warning unrecognized compiler
           =3 # define SBIT(name, addr, bit)  volatile bool           name
           =3 # define SFR(name, addr)        volatile unsigned char  name
           =3 # define SFRX(name, addr)       volatile unsigned char  name
           =3 # define SFR16(name, addr)      volatile unsigned short name
           =3 # define SFR16E(name, fulladdr) volatile unsigned short name
           =3 # define SFR32(name, fulladdr)  volatile unsigned long  name
           =3 # define SFR32E(name, fulladdr) volatile unsigned long  name
           =3 
           =3 #endif
           =3 
           =3 //-----------------------------------------------------------------------------
           =3 // Header File PreProcessor Directive
           =3 //-----------------------------------------------------------------------------
           =3 
           =3 #endif                                 // #define COMPILER_DEFS_H
 689      =3  
 690      =3  //-----------------------------------------------------------------------------
 691      =3  // End Of File
 692      =3  //-----------------------------------------------------------------------------
   8      =2  #include "C8051F580_defs.h"
   1      =3  //-----------------------------------------------------------------------------
   2      =3  // C8051F580_defs.h
   3      =3  //-----------------------------------------------------------------------------
   4      =3  // Copyright 2008, Silicon Laboratories, Inc.
   5      =3  // http://www.silabs.com
   6      =3  //
   7      =3  // Program Description:
   8      =3  //
   9      =3  // Register/bit definitions for the C8051F58x family.
  10      =3  // **Important Note**: The compiler_defs.h header file should be included
  11      =3  // before including this header file.
  12      =3  //
  13      =3  // Target:         C8051F580/1/2/3/4/5/6/7,8/9-F590/1
  14      =3  // Tool chain:     Generic
  15      =3  // Command Line:   None
  16      =3  //
  17      =3  // Release 0.6 - 20 AUG 2012 (TP)
  18      =3  //    -Added #define for _XPAGE to provide support for SDCC memory paging
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 97  

  19      =3  //     (pdata)
  20      =3  //
  21      =3  // Release 0.5 - 10 SEP 2011 (GP)
  22      =3  //    - Fixed SFR16 definition for CAN0IF2MC
  23      =3  //
  24      =3  // Release 0.4 - 08 OCT 2010 (TP)
  25      =3  //    - Fixed bit definitions for SCON0
  26      =3  //
  27      =3  // Release 0.3 - 01 APR 2009 (GP)
  28      =3  //    - Added SN0-SN3
  29      =3  //
  30      =3  // Release 0.2 - 29 JUL 2008 (ADT)
  31      =3  //    - Added Timer 4 bit definitions
  32      =3  //
  33      =3  // Release 0.1 - 09 JUL 2008 (GP)
  34      =3  //    - Initial Revision
  35      =3  //
  36      =3  //-----------------------------------------------------------------------------
  37      =3  // Header File Preprocessor Directive
  38      =3  //-----------------------------------------------------------------------------
  39      =3  
  40      =3  #ifndef C8051F580_DEFS_H
           =3 #define C8051F580_DEFS_H
           =3 
           =3 //-----------------------------------------------------------------------------
           =3 // Page 0, Page 1 and Page F Registers
           =3 //-----------------------------------------------------------------------------
           =3 
           =3 SFR (P0, 0x80);                        // Port 0 Latch
           =3 SFR (SP, 0x81);                        // Stack Pointer
           =3 SFR (DPL, 0x82);                       // Data Pointer Low
           =3 SFR (DPH, 0x83);                       // Data Pointer High
           =3 SFR (SFR0CN, 0x84);                    // SFR Page Control
           =3 SFR (SFRNEXT, 0x85);                   // SFR stack next page
           =3 SFR (SFRLAST, 0x86);                   // SFR stack last page
           =3 SFR (PCON, 0x87);                      // Power Control
           =3 SFR (TCON, 0x88);                      // Timer/Counter Control
           =3 SFR (TMOD, 0x89);                      // Timer/Counter Mode
           =3 SFR (TL0, 0x8A);                       // Timer/Counter 0 Low
           =3 SFR (TL1, 0x8B);                       // Timer/Counter 1 Low
           =3 SFR (TH0, 0x8C);                       // Timer/Counter 0 High
           =3 SFR (TH1, 0x8D);                       // Timer/Counter 1 High
           =3 SFR (CKCON, 0x8E);                     // Clock Control
           =3 SFR (PSCTL, 0x8F);                     // Program Store R/W Control
           =3 SFR (CLKSEL, 0x8F);                    // System clock select
           =3 SFR (P1, 0x90);                        // Port 1 Latch
           =3 SFR (TMR3CN, 0x91);                    // Timer/Counter 3 Control
           =3 SFR (TMR5CN, 0x91);                    // Timer/Counter 5 Control
           =3 SFR (TMR3RLL, 0x92);                   // Timer/Counter 3 Reload Low
           =3 SFR (TMR5CAPL, 0x92);                  // Timer/Counter 5 Capture Low
           =3 SFR (TMR3RLH, 0x93);                   // Timer/Counter 3 Reload High
           =3 SFR (TMR5CAPH, 0x93);                  // Timer/Counter 5 Capture High
           =3 SFR (TMR3L, 0x94);                     // Timer/Counter 3 Low
           =3 SFR (TMR5L, 0x94);                     // Timer/Counter 5 Low
           =3 SFR (TMR3H, 0x95);                     // Timer/Counter 3 High
           =3 SFR (TMR5H, 0x95);                     // Timer/Counter 5 High
           =3 SFR (TMR5CF, 0x96);                    // Timer/Counter 5 Configuration
           =3 SFR (CLKMUL, 0x97);                    // Clock Multiplier
           =3 SFR (SCON0, 0x98);                     // UART0 Control
           =3 SFR (SCON1, 0x98);                     // UART1 Control
           =3 SFR (SBUF0, 0x99);                     // UART0 Data Buffer
           =3 SFR (SBUF1, 0x99);                     // UART1 Data Buffer
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 98  

           =3 SFR (CPT0CN, 0x9A);                    // Comparator 0 Control
           =3 SFR (CPT2CN, 0x9A);                    // Comparator 2 Control
           =3 SFR (CPT0MD, 0x9B);                    // Comparator 0 Mode
           =3 SFR (CPT2MD, 0x9B);                    // Comparator 2 Mode
           =3 SFR (CPT0MX, 0x9C);                    // Comparator 0 Mux
           =3 SFR (CPT2MX, 0x9C);                    // Comparator 2 Mux
           =3 SFR (CPT1CN, 0x9D);                    // Comparator 1 Control
           =3 SFR (CPT1MD, 0x9E);                    // Comparator 0 Mode
           =3 SFR (OSCIFIN, 0x9E);                   // Internal Oscillator Fine Control
           =3 SFR (CPT1MX, 0x9F);                    // Comparator 1 Mux
           =3 SFR (OSCXCN, 0x9F);                    // External Oscillator Control
           =3 SFR (P2, 0xA0);                        // Port 2 Latch
           =3 SFR (SPI0CFG, 0xA1);                   // SPI0 Configuration
           =3 SFR (OSCICN, 0xA1);                    // Internal Oscillator Control
           =3 SFR (SPI0CKR, 0xA2);                   // SPI0 Clock rate control
           =3 SFR (OSCICRS, 0xA2);                   // Internal Oscillator Coarse Control
           =3 SFR (SPI0DAT, 0xA3);                   // SPI0 Data Buffer
           =3 SFR (P0MDOUT, 0xA4);                   // Port 0 Output Mode
           =3 SFR (P1MDOUT, 0xA5);                   // Port 1 Output Mode
           =3 SFR (P2MDOUT, 0xA6);                   // Port 2 Output Mode
           =3 SFR (SFRPAGE, 0xA7);                   // SFR Page Select
           =3 SFR (IE, 0xA8);                        // Interrupt Enable
           =3 SFR (SMOD0, 0xA9);                     // Serial Port 0 Control
           =3 SFR (EMI0CN, 0xAA);                    // EMIF Control
           =3 SFR (EMI0TC, 0xAA);                    // EMIF Timing control
           =3 SFR (SBCON0, 0xAB);                    // UART0 Baud Rate Generator Control
           =3 SFR (SBRLL0, 0xAC);                    // UART0 Baud Rate Generator Low
           =3 SFR (SBRLH0, 0xAD);                    // UART0 Baud Rate Generator High
           =3 SFR (P3MAT, 0xAE);                     // Port 3 Match
           =3 SFR (P3MDOUT, 0xAE);                   // Port 3 Mode
           =3 SFR (P3MASK, 0xAF);                    // Port 3 Mask
           =3 SFR (P4MDOUT, 0xAF);                   // Port 4 Mode
           =3 SFR (P3, 0xB0);                        // Port 3 Latch
           =3 SFR (P2MAT, 0xB1);                     // Port 2 Match
           =3 SFR (P2MASK, 0xB2);                    // Port 2 Mask
           =3 SFR (EMI0CF, 0xB2);                    // EMIF Configuration
           =3 SFR (P4, 0xB5);                        // Port 4 Latch
           =3 SFR (FLSCL, 0xB6);                     // Flash Scale
           =3 SFR (FLKEY, 0xB7);                     // Flash access limit
           =3 SFR (IP, 0xB8);                        // Interrupt Priority
           =3 SFR (SMB0ADR, 0xB9);                   // SMBus0 Slave address
           =3 SFR (ADC0TK, 0xBA);                    // ADC0 Tracking Mode Select
           =3 SFR (SMB0ADM, 0xBA);                   // SMBus0 Address Mask
           =3 SFR (ADC0MX, 0xBB);                    // AMUX0 Channel select
           =3 SFR (ADC0CF, 0xBC);                    // AMUX0 Channel configuration
           =3 SFR (ADC0L, 0xBD);                     // ADC0 Data Low
           =3 SFR (ADC0H, 0xBE);                     // ADC0 Data High
           =3 SFR (SMB0CN, 0xC0);                    // SMBus0 Control
           =3 SFR (SMB0CF, 0xC1);                    // SMBus0 Configuration
           =3 SFR (SMB0DAT, 0xC2);                   // SMBus0 Data
           =3 SFR (ADC0GTL, 0xC3);                   // ADC0 Greater-Than Compare Low
           =3 SFR (ADC0GTH, 0xC4);                   // ADC0 Greater-Than Compare High
           =3 SFR (ADC0LTL, 0xC5);                   // ADC0 Less-Than Compare Word Low
           =3 SFR (ADC0LTH, 0xC6);                   // ADC0 Less-Than Compare Word High
           =3 SFR (XBR3, 0xC6);                      // Port I/O Crossbar Control 3
           =3 SFR (XBR2, 0xC7);                      // Port I/O Crossbar Control 2
           =3 SFR (TMR2CN, 0xC8);                    // Timer/Counter 2 Control
           =3 SFR (TMR4CN, 0xC8);                    // Timer/Counter 4 Control
           =3 SFR (REG0CN, 0xC9);                    // Regulator Control
           =3 SFR (LIN0CF, 0xC9);                    // LIN 0 Configuration
           =3 SFR (TMR4CF, 0xC9);                    // Timer/Counter 4 Configuration
           =3 SFR (TMR2RLL, 0xCA);                   // Timer/Counter 2 Reload Low
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 99  

           =3 SFR (TMR4CAPL, 0xCA);                  // Timer/Counter 4 Capture Low
           =3 SFR (TMR2RLH, 0xCB);                   // Timer/Counter 2 Reload High
           =3 SFR (TMR4CAPH, 0xCB);                  // Timer/Counter 4 Capture High
           =3 SFR (TMR2L, 0xCC);                     // Timer/Counter 2 Low
           =3 SFR (TMR4L, 0xCC);                     // Timer/Counter 4 Low
           =3 SFR (TMR2H, 0xCD);                     // Timer/Counter 2 High
           =3 SFR (TMR4H, 0xCD);                     // Timer/Counter 4 High
           =3 SFR (PCA0CPL5, 0xCE);                  // PCA0 Capture 5 Low
           =3 SFR (PCA1CPL11, 0xCE);                 // PCA1 Capture 11 Low
           =3 SFR (PCA0CPH5, 0xCF);                  // PCA0 Capture 5 High
           =3 SFR (PCA1CPH11, 0xCF);                 // PCA1 Capture 11 High
           =3 SFR (PSW, 0xD0);                       // Program Status Word
           =3 SFR (REF0CN, 0xD1);                    // Voltage Reference Control
           =3 SFR (LIN0DAT, 0xD2);                   // LIN0 Data
           =3 SFR (LIN0ADR, 0xD3);                   // LIN0 Address
           =3 SFR (P0SKIP, 0xD4);                    // Port 0 Skip
           =3 SFR (P1SKIP, 0xD5);                    // Port 1 Skip
           =3 SFR (P2SKIP, 0xD6);                    // Port 2 Skip
           =3 SFR (P3SKIP, 0xD7);                    // Port 3 Skip
           =3 SFR (PCA0CN, 0xD8);                    // PCA0 Control
           =3 SFR (PCA1CN, 0xD8);                    // PCA1 Control
           =3 SFR (PCA0MD, 0xD9);                    // PCA0 Mode
           =3 SFR (PCA1MD, 0xD9);                    // PCA1 Mode
           =3 SFR (PCA0PWM, 0xD9);                   // PCA0 PWM Control
           =3 SFR (PCA0CPM0, 0xDA);                  // PCA0 Module 0 Mode
           =3 SFR (PCA1CPM6, 0xDA);                  // PCA1 Module 6 Mode
           =3 SFR (PCA1PWM, 0xDA);                   // PCA1 PWM Control
           =3 SFR (PCA0CPM1, 0xDB);                  // PCA0 Module 1  Mode
           =3 SFR (PCA1CPM7, 0xDB);                  // PCA1 Module 7  Mode
           =3 SFR (PCA0CPM2, 0xDC);                  // PCA0 Module 2  Mode
           =3 SFR (PCA1CPM8, 0xDC);                  // PCA1 Module 8  Mode
           =3 SFR (PCA0CPM3, 0xDD);                  // PCA0 Module 3  Mode
           =3 SFR (PCA1CPM9, 0xDD);                  // PCA1 Module 9  Mode
           =3 SFR (PCA0CPM4, 0xDE);                  // PCA0 Module 4  Mode
           =3 SFR (PCA1CPM10, 0xDE);                  // PCA1 Module 10 Mode
           =3 SFR (PCA0CPM5, 0xDF);                  // PCA0 Module 5  Mode
           =3 SFR (PCA1CPM11, 0xDF);                  // PCA1 Module 11 Mode
           =3 SFR (ACC, 0xE0);                       // Accumulator
           =3 SFR (XBR0, 0xE1);                      // Port I/O Crossbar Control 0
           =3 SFR (XBR1, 0xE2);                      // Port I/O Crossbar Control 1
           =3 SFR (CCH0CN, 0xE3);                    // Cache control
           =3 SFR (IT01CF, 0xE4);                    // INT0/INT1 Configuration
           =3 SFR (EIE1, 0xE6);                      // Extended Interrupt Enable 2
           =3 SFR (EIE2, 0xE7);                      // Extended Interrupt Enable 2
           =3 SFR (ADC0CN, 0xE8);                    // ADC0 Control
           =3 SFR (PCA0CPL1, 0xE9);                  // PCA0 Capture 1 Low
           =3 SFR (PCA1CPL1, 0xE9);                  // PCA1 Capture 7 Low
           =3 SFR (PCA0CPH1, 0xEA);                  // PCA0 Capture 1 High
           =3 SFR (PCA1CPH1, 0xEA);                  // PCA1 Capture 7 High
           =3 SFR (PCA0CPL2, 0xEB);                  // PCA0 Capture 2 Low
           =3 SFR (PCA1CPL2, 0xEB);                  // PCA1 Capture 8 Low
           =3 SFR (PCA0CPH2, 0xEC);                  // PCA0 Capture 2 High
           =3 SFR (PCA1CPH2, 0xEC);                  // PCA1 Capture 8 High
           =3 SFR (PCA0CPL3, 0xED);                  // PCA0 Capture 3 Low
           =3 SFR (PCA1CPL3, 0xED);                  // PCA1 Capture 9 Low
           =3 SFR (PCA0CPH3, 0xEE);                  // PCA0 Capture 3 High
           =3 SFR (PCA1CPH3, 0xEE);                  // PCA1 Capture 9 High
           =3 SFR (RSTSRC, 0xEF);                    // Reset Source Configuration/Status
           =3 SFR (B, 0xF0);                         // B Register
           =3 SFR (P0MAT, 0xF1);                     // Port 0 Match
           =3 SFR (P0MDIN, 0xF1);                    // Port 0 Input Mode
           =3 SFR (P0MASK, 0xF2);                    // Port 0 Mask
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 100 

           =3 SFR (P1MDIN, 0xF2);                    // Port 1 Input Mode
           =3 SFR (P1MAT, 0xF3);                     // Port 1 Match
           =3 SFR (P2MDIN, 0xF3);                    // Port 2 Input Mode
           =3 SFR (P1MASK, 0xF4);                    // Port 1 Mask
           =3 SFR (P3MDIN, 0xF4);                    // Port 3 Input Mode
           =3 SFR (PSBANK, 0xF5);                    // Program Space Bank Select
           =3 SFR (EIP1, 0xF6);                      // External Interrupt Priority 1
           =3 SFR (EIP2, 0xF7);                      // External Interrupt Priority 2
           =3 SFR (SPI0CN, 0xF8);                    // SPI0 Control
           =3 SFR (PCA0L, 0xF9);                     // PCA0 Counter Low
           =3 SFR (PCA1L, 0xF9);                     // PCA1 Counter Low
           =3 SFR (SN0, 0xF9);                       // Serial Number 0
           =3 SFR (PCA0H, 0xFA);                     // PCA0 Counter High
           =3 SFR (PCA1H, 0xFA);                     // PCA1 Counter High
           =3 SFR (SN1, 0xFA);                       // Serial Number 1
           =3 SFR (PCA0CPL0, 0xFB);                  // PCA0 Capture 0 Low
           =3 SFR (PCA1CPL6, 0xFB);                  // PCA1 Capture 6 Low
           =3 SFR (SN2, 0xFB);                       // Serial Number 2
           =3 SFR (PCA0CPH0, 0xFC);                  // PCA0 Capture 0 High
           =3 SFR (PCA1CPH6, 0xFC);                  // PCA1 Capture 6 High
           =3 SFR (SN3, 0xFC);                       // Serial Number 3
           =3 SFR (PCA0CPL4, 0xFD);                  // PCA0 Capture 4 Low
           =3 SFR (PCA1CPL10, 0xFD);                 // PCA1 Capture 10 Low
           =3 SFR (PCA0CPH4, 0xFE);                  // PCA0 Capture 4 High
           =3 SFR (PCA1CPH10, 0xFE);                 // PCA1 Capture 10 High
           =3 SFR (VDM0CN, 0xFF);                    // VDD Monitor Control
           =3 
           =3 //-----------------------------------------------------------------------------
           =3 // Page C (CAN0) Registers
           =3 //-----------------------------------------------------------------------------
           =3 
           =3 SFR (CAN0CFG, 0x92);                   // CAN0 Clock Configuration
           =3 SFR (CAN0STAT, 0x94);                  // Status Register Low Byte
           =3 SFR (CAN0ERRL, 0x96);                  // Error Counter Low Byte
           =3 SFR (CAN0ERRH, 0x97);                  // Error Counter High Byte
           =3 SFR (CAN0BTL, 0x9A);                   // Bit Timing Register Low Byte
           =3 SFR (CAN0BTH, 0x9B);                   // Bit Timing Register High Byte
           =3 SFR (CAN0IIDL, 0x9C);                  // Interrupt Register Low Byte
           =3 SFR (CAN0IIDH, 0x9D);                  // Interrupt Register High Byte
           =3 SFR (CAN0TST, 0x9E);                   // Test Register Low Byte
           =3 SFR (CAN0BRPE, 0xA1);                  // BRP Extension Register Low Byte
           =3 SFR (CAN0TR1L, 0xA2);                  // Transmission Request 1 Low Byte
           =3 SFR (CAN0TR1H, 0xA3);                  // Transmission Request 1 High Byte
           =3 SFR (CAN0TR2L, 0xA4);                  // Transmission Request 2 Low Byte
           =3 SFR (CAN0TR2H, 0xA5);                  // Transmission Request 2 High Byte
           =3 SFR (CAN0ND1L, 0xAA);                  // New Data 1 Low Byte
           =3 SFR (CAN0ND1H, 0xAB);                  // New Data 1 High Byte
           =3 SFR (CAN0ND2L, 0xAC);                  // New Data 2 Low Byte
           =3 SFR (CAN0ND2H, 0xAD);                  // New Data 2 High Byte
           =3 SFR (CAN0IP1L, 0xAE);                  // Interrupt Pending 1 Low Byte
           =3 SFR (CAN0IP1H, 0xAF);                  // Interrupt Pending 1 High Byte
           =3 SFR (CAN0IP2L, 0xB2);                  // Interrupt Pending 2 Low Byte
           =3 SFR (CAN0IP2H, 0xB3);                  // Interrupt Pending 2 High Byte
           =3 SFR (CAN0MV1L, 0xBA);                  // Message Valid 1 Low Byte
           =3 SFR (CAN0MV1H, 0xBB);                  // Message Valid 1 High Byte
           =3 SFR (CAN0MV2L, 0xBC);                  // Message Valid 2 Low Byte
           =3 SFR (CAN0MV2H, 0xBD);                  // Message Valid 2 High Byte
           =3 SFR (CAN0IF1CRL, 0xBE);                // IF1 Command Request Low Byte
           =3 SFR (CAN0IF1CRH, 0xBF);                // IF1 Command Request High Byte
           =3 SFR (CAN0CN, 0xC0);                    // CAN Control Register Low Byte
           =3 SFR (CAN0IF1CML, 0xC2);                // IF1 Command Mask Low Byte
           =3 SFR (CAN0IF1CMH, 0xC3);                // IF1 Command Mask High Byte
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 101 

           =3 SFR (CAN0IF1M1L, 0xC4);                // IF1 Mask 1 Low Byte
           =3 SFR (CAN0IF1M1H, 0xC5);                // IF1 Mask 1 High Byte
           =3 SFR (CAN0IF1M2L, 0xC6);                // IF1 Mask 2 Low Byte
           =3 SFR (CAN0IF1M2H, 0xC7);                // IF1 Mask 2 High Byte
           =3 SFR (CAN0IF1A1L, 0xCA);                // IF1 Arbitration 1 Low Byte
           =3 SFR (CAN0IF1A1H, 0xCB);                // IF1 Arbitration 1 High Byte
           =3 SFR (CAN0IF1A2L, 0xCC);                // IF1 Arbitration 2 Low Byte
           =3 SFR (CAN0IF1A2H, 0xCD);                // IF1 Arbitration 2 High Byte
           =3 SFR (CAN0IF2MCL, 0xCE);                // IF2 Message Control Low Byte
           =3 SFR (CAN0IF2MCH, 0xCF);                // IF2 Message Control High Byte
           =3 SFR (CAN0IF1MCL, 0xD2);                // IF1 Message Control Low Byte
           =3 SFR (CAN0IF1MCH, 0xD3);                // IF1 Message Control High Byte
           =3 SFR (CAN0IF1DA1L, 0xD4);               // IF1 Data A 1 Low Byte
           =3 SFR (CAN0IF1DA1H, 0xD5);               // IF1 Data A 1 High Byte
           =3 SFR (CAN0IF1DA2L, 0xD6);               // IF1 Data A 2 Low Byte
           =3 SFR (CAN0IF1DA2H, 0xD7);               // IF1 Data A 2 High Byte
           =3 SFR (CAN0IF1DB1L, 0xDA);               // IF1 Data B 1 Low Byte
           =3 SFR (CAN0IF1DB1H, 0xDB);               // IF1 Data B 1 High Byte
           =3 SFR (CAN0IF1DB2L, 0xDC);               // IF1 Data B 2 Low Byte
           =3 SFR (CAN0IF1DB2H, 0xDD);               // IF1 Data B 2 High Byte
           =3 SFR (CAN0IF2CRL, 0xDE);                // IF2 Command Request Low Byte
           =3 SFR (CAN0IF2CRH, 0xDF);                // IF2 Command Request High Byte
           =3 SFR (CAN0IF2CML, 0xE2);                // IF2 Command Mask Low Byte
           =3 SFR (CAN0IF2CMH, 0xE3);                // IF2 Command Mask High Byte
           =3 SFR (CAN0IF2M1L, 0xEA);                // IF2 Mask 1 Low Byte
           =3 SFR (CAN0IF2M1H, 0xEB);                // IF2 Mask 1 High Byte
           =3 SFR (CAN0IF2M2L, 0xEC);                // IF2 Mask 2 Low Byte
           =3 SFR (CAN0IF2M2H, 0xED);                // IF2 Mask 2 High Byte
           =3 SFR (CAN0IF2A1L, 0xEE);                // IF2 Arbitration 1 Low Byte
           =3 SFR (CAN0IF2A1H, 0xEF);                // IF2 Arbitration 1 High Byte
           =3 SFR (CAN0IF2A2L, 0xF2);                // IF2 Arbitration 2 Low Byte
           =3 SFR (CAN0IF2A2H, 0xF3);                // IF2 Arbitration 2 High Byte
           =3 SFR (CAN0IF2DA1L, 0xF6);               // IF2 Data A 1 Low Byte
           =3 SFR (CAN0IF2DA1H, 0xF7);               // IF2 Data A 1 High Byte
           =3 SFR (CAN0IF2DA2L, 0xFA);               // IF2 Data A 2 Low Byte
           =3 SFR (CAN0IF2DA2H, 0xFB);               // IF2 Data A 2 High Byte
           =3 SFR (CAN0IF2DB1L, 0xFC);               // IF2 Data B 1 Low Byte
           =3 SFR (CAN0IF2DB1H, 0xFD);               // IF2 Data B 1 High Byte
           =3 SFR (CAN0IF2DB2L, 0xFE);               // IF2 Data B 2 Low Byte
           =3 SFR (CAN0IF2DB2H, 0xFF);               // IF2 Data B 2 High Byte
           =3 
           =3 
           =3 //-----------------------------------------------------------------------------
           =3 // 16-bit Register Definitions (might not be supported by all compilers)
           =3 //-----------------------------------------------------------------------------
           =3 
           =3 SFR16 (DP, 0x82);                      // Data Pointer
           =3 SFR16 (TMR3RL, 0x92);                  // Timer 3 Reload
           =3 SFR16 (TMR5CAP, 0x92);                 // Timer 5 Capture
           =3 SFR16 (TMR3, 0x94);                    // Timer 3 Capture / Reload
           =3 SFR16 (TMR5, 0x94);                    // Timer 5
           =3 SFR16 (SBRL0, 0xAC);                   // UART0 Reload
           =3 SFR16 (ADC0, 0xBD);                    // ADC0 data
           =3 SFR16 (ADC0GT, 0xC3);                  // ADC0 Greater Than Window
           =3 SFR16 (ADC0LT, 0xC5);                  // ADC0 Less Than Window
           =3 SFR16 (TMR2RL, 0xCA);                  // Timer 2 Reload
           =3 SFR16 (TMR4CAP, 0xCA);                 // Timer 4 Capture
           =3 SFR16 (TMR2, 0xCC);                    // Timer 2 Capture / Reload
           =3 SFR16 (TMR4, 0xCC);                    // Timer 4
           =3 SFR16 (PCA0CP5, 0xCE);                 // PCA0 Module 5 Capture
           =3 SFR16 (PCA1CP11, 0xCE);                // PCA1 Module 11 Capture
           =3 SFR16 (PCA0CP1, 0xE9);                 // PCA0 Module 1 Capture
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 102 

           =3 SFR16 (PCA1CP7, 0xE9);                 // PCA1 Module 7 Capture
           =3 SFR16 (PCA0CP2, 0xEB);                 // PCA0 Module 2 Capture
           =3 SFR16 (PCA1CP8, 0xEB);                 // PCA1 Module 8 Capture
           =3 SFR16 (PCA0CP3, 0xED);                 // PCA0 Module 3 Capture
           =3 SFR16 (PCA1CP9, 0xED);                 // PCA1 Module 9 Capture
           =3 SFR16 (PCA0, 0xF9);                    // PCA0 Counter
           =3 SFR16 (PCA1, 0xF9);                    // PCA1 Counter
           =3 SFR16 (PCA0CP0, 0xFB);                 // PCA0 Module 0 Capture
           =3 SFR16 (PCA1CP6, 0xFB);                 // PCA1 Module 6 Capture
           =3 SFR16 (PCA0CP4, 0xFD);                 // PCA0 Module 4 Capture
           =3 SFR16 (PCA1CP10, 0xFD);                 // PCA1 Module 10 Capture
           =3 
           =3 SFR16 (CAN0ERR, 0x96);                 // Error Counter
           =3 SFR16 (CAN0BT, 0x9A);                  // Bit Timing Register
           =3 SFR16 (CAN0IID, 0x9C);                 // Interrupt Register
           =3 SFR16 (CAN0TR1, 0xA2);                 // Transmission Request 1
           =3 SFR16 (CAN0TR2, 0xA4);                 // Transmission Request 2
           =3 SFR16 (CAN0ND1, 0xAA);                 // New Data 1
           =3 SFR16 (CAN0ND2, 0xAC);                 // New Data 2
           =3 SFR16 (CAN0IP1, 0xAE);                 // Interrupt Pending 1
           =3 SFR16 (CAN0IP2, 0xB2);                 // Interrupt Pending 2
           =3 SFR16 (CAN0MV1, 0xBA);                 // Message Valid 1
           =3 SFR16 (CAN0MV2, 0xBC);                 // Message Valid 2
           =3 SFR16 (CAN0IF1CR, 0xBE);               // IF1 Command Request
           =3 SFR16 (CAN0IF1CM, 0xC2);               // IF1 Command Mask
           =3 SFR16 (CAN0IF1M1, 0xC4);               // IF1 Mask 1
           =3 SFR16 (CAN0IF1M2, 0xC6);               // IF1 Mask 2
           =3 SFR16 (CAN0IF1A1, 0xCA);               // IF1 Arbitration 1
           =3 SFR16 (CAN0IF1A2, 0xCC);               // IF1 Arbitration 2
           =3 SFR16 (CAN0IF1MC, 0xD2);               // IF1 Message Control
           =3 SFR16 (CAN0IF1DA1, 0xD4);              // IF1 Data A 1
           =3 SFR16 (CAN0IF1DA2, 0xD6);              // IF1 Data A 2
           =3 SFR16 (CAN0IF1DB1, 0xDA);              // IF1 Data B 1
           =3 SFR16 (CAN0IF1DB2, 0xDC);              // IF1 Data B 2
           =3 SFR16 (CAN0IF2CR, 0xDE);               // IF2 Command Request
           =3 SFR16 (CAN0IF2CM, 0xE2);               // IF2 Command Mask
           =3 SFR16 (CAN0IF2M1, 0xEA);               // IF2 Mask 1
           =3 SFR16 (CAN0IF2M2, 0xEC);               // IF2 Mask 2
           =3 SFR16 (CAN0IF2A1, 0xEE);               // IF2 Arbitration 1
           =3 SFR16 (CAN0IF2A2, 0xF2);               // IF2 Arbitration 2
           =3 SFR16 (CAN0IF2MC, 0xCE);               // IF2 Message Control
           =3 SFR16 (CAN0IF2DA1, 0xF6);              // IF2 Data A 1
           =3 SFR16 (CAN0IF2DA2, 0xFA);              // IF2 Data A 2
           =3 SFR16 (CAN0IF2DB1, 0xFC);              // IF2 Data B 1
           =3 SFR16 (CAN0IF2DB2, 0xFE);              // IF2 Data B 2
           =3 
           =3 //-----------------------------------------------------------------------------
           =3 // LIN0 Indirect Registers
           =3 //-----------------------------------------------------------------------------
           =3 
           =3 #define  LIN0DT1   0x00                // LIN0 Data Byte 1
           =3 #define  LIN0DT2   0x01                // LIN0 Data Byte 2
           =3 #define  LIN0DT3   0x02                // LIN0 Data Byte 3
           =3 #define  LIN0DT4   0x03                // LIN0 Data Byte 4
           =3 #define  LIN0DT5   0x04                // LIN0 Data Byte 5
           =3 #define  LIN0DT6   0x05                // LIN0 Data Byte 6
           =3 #define  LIN0DT7   0x06                // LIN0 Data Byte 7
           =3 #define  LIN0DT8   0x07                // LIN0 Data Byte 8
           =3 #define  LIN0CTRL  0x08                // LIN0 Control
           =3 #define  LIN0ST    0x09                // LIN0 Status
           =3 #define  LIN0ERR   0x0A                // LIN0 Error
           =3 #define  LIN0SIZE  0x0B                // LIN0 Message Size
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 103 

           =3 #define  LIN0DIV   0x0C                // LIN0 Divider
           =3 #define  LIN0MUL   0x0D                // LIN0 Multiplier
           =3 #define  LIN0ID    0x0E                // LIN0 Identifier
           =3 
           =3 //-----------------------------------------------------------------------------
           =3 // Address Definitions for Bit-addressable Registers
           =3 //-----------------------------------------------------------------------------
           =3 
           =3 #define SFR_P0       0x80
           =3 #define SFR_TCON     0x88
           =3 #define SFR_P1       0x90
           =3 #define SFR_SCON0    0x98
           =3 #define SFR_SCON1    0x98
           =3 #define SFR_P2       0xA0
           =3 #define SFR_IE       0xA8
           =3 #define SFR_P3       0xB0
           =3 #define SFR_IP       0xB8
           =3 #define SFR_SMB0CN   0xC0
           =3 #define SFR_TMR2CN   0xC8
           =3 #define SFR_TMR4CN   0xC8
           =3 #define SFR_PSW      0xD0
           =3 #define SFR_PCA0CN   0xD8
           =3 #define SFR_PCA1CN   0xD8
           =3 #define SFR_ACC      0xE0
           =3 #define SFR_ADC0CN   0xE8
           =3 #define SFR_B        0xF0
           =3 #define SFR_SPI0CN   0xF8
           =3 
           =3 //-----------------------------------------------------------------------------
           =3 // Bit Definitions
           =3 //-----------------------------------------------------------------------------
           =3 
           =3 // TCON 0x88
           =3 SBIT (TF1, SFR_TCON, 7);               // Timer 1 Overflow Flag
           =3 SBIT (TR1, SFR_TCON, 6);               // Timer 1 On/Off Control
           =3 SBIT (TF0, SFR_TCON, 5);               // Timer 0 Overflow Flag
           =3 SBIT (TR0, SFR_TCON, 4);               // Timer 0 On/Off Control
           =3 SBIT (IE1, SFR_TCON, 3);               // Ext. Interrupt 1 Edge Flag
           =3 SBIT (IT1, SFR_TCON, 2);               // Ext. Interrupt 1 Type
           =3 SBIT (IE0, SFR_TCON, 1);               // Ext. Interrupt 0 Edge Flag
           =3 SBIT (IT0, SFR_TCON, 0);               // Ext. Interrupt 0 Type
           =3 
           =3 // SCON0 0x98
           =3 SBIT (OVR0, SFR_SCON0, 7);             // UART0 Receive FIFO Overrun Flag
           =3 SBIT (PERR0, SFR_SCON0, 6);            // UART0 Parity Error Flag
           =3 SBIT (THRE0, SFR_SCON0, 5);            // UART0 Transmit Register Empty Flag
           =3 SBIT (REN0, SFR_SCON0, 4);             // UART0 RX Enable
           =3 SBIT (TBX0, SFR_SCON0, 3);             // UART0 Extra Transmission Bit
           =3 SBIT (RBX0, SFR_SCON0, 2);             // UART0 Extra Receive Bit
           =3 SBIT (TI0, SFR_SCON0, 1);              // UART0 TX Interrupt Flag
           =3 SBIT (RI0, SFR_SCON0, 0);              // UART0 RX Interrupt Flag
           =3 
           =3 // SCON1 0x98
           =3 SBIT (S1MODE, SFR_SCON1, 7);           // UART1 Mode 0
           =3                                        // Bit 6 UNUSED
           =3 SBIT (MCE1, SFR_SCON1, 5);             // UART1 Multiprocessor enable
           =3 SBIT (REN1, SFR_SCON1, 4);             // UART1 RX Enable
           =3 SBIT (TB81, SFR_SCON1, 3);             // UART1 TX Bit 8
           =3 SBIT (RB81, SFR_SCON1, 2);             // UART1 RX Bit 8
           =3 SBIT (TI1, SFR_SCON1, 1);              // UART1 TX Interrupt Flag
           =3 SBIT (RI1, SFR_SCON1, 0);              // UART1 RX Interrupt Flag
           =3 
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 104 

           =3 // IE 0xA8
           =3 SBIT (EA, SFR_IE, 7);                  // Global Interrupt Enable
           =3 SBIT (ESPI0, SFR_IE, 6);               // SPI0 Interrupt Enable
           =3 SBIT (ET2, SFR_IE, 5);                 // Timer 2 Interrupt Enable
           =3 SBIT (ES0, SFR_IE, 4);                 // UART0 Interrupt Enable
           =3 SBIT (ET1, SFR_IE, 3);                 // Timer 1 Interrupt Enable
           =3 SBIT (EX1, SFR_IE, 2);                 // External Interrupt 1 Enable
           =3 SBIT (ET0, SFR_IE, 1);                 // Timer 0 Interrupt Enable
           =3 SBIT (EX0, SFR_IE, 0);                 // External Interrupt 0 Enable
           =3 
           =3 // IP 0xB8
           =3                                        // Bit 7 unused
           =3 SBIT (PSPI0, SFR_IP, 6);               // SPI0 Interrupt Priority
           =3 SBIT (PT2, SFR_IP, 5);                 // Timer 2 Priority
           =3 SBIT (PS0, SFR_IP, 4);                 // UART0 Priority
           =3 SBIT (PS, SFR_IP, 4);                  // UART0 Priority
           =3 SBIT (PT1, SFR_IP, 3);                 // Timer 1 Priority
           =3 SBIT (PX1, SFR_IP, 2);                 // External Interrupt 1 Priority
           =3 SBIT (PT0, SFR_IP, 1);                 // Timer 0 Priority
           =3 SBIT (PX0, SFR_IP, 0);                 // External Interrupt 0 Priority
           =3 
           =3 // SMB0CN 0xC0
           =3 SBIT (MASTER, SFR_SMB0CN, 7);          // SMBus0 Master/Slave Indicator
           =3 SBIT (TXMODE, SFR_SMB0CN, 6);          // SMBus0 Transmit Mode Indicator
           =3 SBIT (STA, SFR_SMB0CN, 5);             // SMBus0 Start Flag
           =3 SBIT (STO, SFR_SMB0CN, 4);             // SMBus0 Stop Flag
           =3 SBIT (ACKRQ, SFR_SMB0CN, 3);           // SMBus0 Acknowledge Request
           =3 SBIT (ARBLOST, SFR_SMB0CN, 2);         // SMBus0 Arbitration Lost Indicator
           =3 SBIT (ACK, SFR_SMB0CN, 1);             // SMBus0 Acknowledge
           =3 SBIT (SI, SFR_SMB0CN, 0);              // SMBus0 Interrupt Flag
           =3 
           =3 // TMR2CN 0xC8
           =3 SBIT (TF2H, SFR_TMR2CN, 7);            // Timer 2 High-Byte Overflow Flag
           =3 SBIT (TF2L, SFR_TMR2CN, 6);            // Timer 2 Low-Byte  Overflow Flag
           =3 SBIT (TF2LEN, SFR_TMR2CN, 5);          // Timer 2 Low-Byte Flag Enable
           =3 SBIT (TF2CEN, SFR_TMR2CN, 4);          // Timer 2 Capture Enable
           =3 SBIT (T2SPLIT, SFR_TMR2CN, 3);         // Timer 2 Split-Mode Enable
           =3 SBIT (TR2, SFR_TMR2CN, 2);             // Timer 2 Run Enable
           =3 SBIT (T2RCLK, SFR_TMR2CN, 1);          // Timer 2 Xclk/Rclk Select
           =3 SBIT (T2XCLK, SFR_TMR2CN, 0);          // Timer 2 Clk/8 Clock Source
           =3 
           =3 // TMR4CN 0xC8
           =3 SBIT (TF4, SFR_TMR4CN, 7);             // Timer 4 Overflow/Underflow Flag
           =3 SBIT (EXF4, SFR_TMR4CN, 6);            // Timer 4 External Flag
           =3                                        // Bit 5 unused
           =3                                        // Bit 4 unused
           =3 SBIT (EXE4, SFR_TMR4CN, 3);            // Timer 4 External Enable
           =3 SBIT (TR4, SFR_TMR4CN, 2);             // Timer 4 Run Enable
           =3 SBIT (CT4, SFR_TMR4CN, 1);             // Timer 4 Counter/Timer Select
           =3 SBIT (CPRL4, SFR_TMR4CN, 0);           // Timer 4 Capture/Reload Select
           =3 
           =3 // PSW 0xD0
           =3 SBIT (CY, SFR_PSW, 7);                 // Carry Flag
           =3 SBIT (AC, SFR_PSW, 6);                 // Auxiliary Carry Flag
           =3 SBIT (F0, SFR_PSW, 5);                 // User Flag 0
           =3 SBIT (RS1, SFR_PSW, 4);                // Register Bank Select 1
           =3 SBIT (RS0, SFR_PSW, 3);                // Register Bank Select 0
           =3 SBIT (OV, SFR_PSW, 2);                 // Overflow Flag
           =3 SBIT (F1, SFR_PSW, 1);                 // User Flag 1
           =3 SBIT (P, SFR_PSW, 0);                  // Accumulator Parity Flag
           =3 
           =3 // PCA0CN 0xD8
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 105 

           =3 SBIT (CF, SFR_PCA0CN, 7);              // PCA0 Counter Overflow Flag
           =3 SBIT (CR, SFR_PCA0CN, 6);              // PCA0 Counter Run Control Bit
           =3 SBIT (CCF5, SFR_PCA0CN, 5);            // PCA0 Module 5 Interrupt Flag
           =3 SBIT (CCF4, SFR_PCA0CN, 4);            // PCA0 Module 4 Interrupt Flag
           =3 SBIT (CCF3, SFR_PCA0CN, 3);            // PCA0 Module 3 Interrupt Flag
           =3 SBIT (CCF2, SFR_PCA0CN, 2);            // PCA0 Module 2 Interrupt Flag
           =3 SBIT (CCF1, SFR_PCA0CN, 1);            // PCA0 Module 1 Interrupt Flag
           =3 SBIT (CCF0, SFR_PCA0CN, 0);            // PCA0 Module 0 Interrupt Flag
           =3 
           =3 // PCA1CN 0xD8
           =3 SBIT (CF1, SFR_PCA1CN, 7);             // PCA1 Counter Overflow Flag
           =3 SBIT (CR1, SFR_PCA1CN, 6);             // PCA1 Counter Run Control Bit
           =3 SBIT (CCF11, SFR_PCA1CN, 5);           // PCA1 Module 11 Interrupt Flag
           =3 SBIT (CCF10, SFR_PCA1CN, 4);           // PCA1 Module 10 Interrupt Flag
           =3 SBIT (CCF9, SFR_PCA1CN, 3);            // PCA1 Module 9 Interrupt Flag
           =3 SBIT (CCF8, SFR_PCA1CN, 2);            // PCA1 Module 8 Interrupt Flag
           =3 SBIT (CCF7, SFR_PCA1CN, 1);            // PCA1 Module 7 Interrupt Flag
           =3 SBIT (CCF6, SFR_PCA1CN, 0);            // PCA1 Module 6 Interrupt Flag
           =3 
           =3 // ADC0CN 0xE8
           =3 SBIT (AD0EN, SFR_ADC0CN, 7);           // ADC0 Enable
           =3 SBIT (BURSTEN, SFR_ADC0CN, 6);         // ADC0 Burst Enable
           =3 SBIT (AD0INT, SFR_ADC0CN, 5);          // ADC0 EOC Interrupt Flag
           =3 SBIT (AD0BUSY, SFR_ADC0CN, 4);         // ADC0 Busy Flag
           =3 SBIT (AD0WINT, SFR_ADC0CN, 3);         // ADC0 Window Compare Interrupt Flag
           =3 SBIT (AD0LJST, SFR_ADC0CN, 2);         // ADC0 Left Justified
           =3 SBIT (AD0CM1, SFR_ADC0CN, 1);          // ADC0 Start Of Conversion Mode Bit 1
           =3 SBIT (AD0CM0, SFR_ADC0CN, 0);          // ADC0 Start Of Conversion Mode Bit 0
           =3 
           =3 // SPI0CN 0xF8
           =3 SBIT (SPIF, SFR_SPI0CN, 7);            // SPI0 Interrupt Flag
           =3 SBIT (WCOL, SFR_SPI0CN, 6);            // SPI0 Write Collision Flag
           =3 SBIT (MODF, SFR_SPI0CN, 5);            // SPI0 Mode Fault Flag
           =3 SBIT (RXOVRN, SFR_SPI0CN, 4);          // SPI0 RX Overrun Flag
           =3 SBIT (NSSMD1, SFR_SPI0CN, 3);          // SPI0 Slave Select Mode 1
           =3 SBIT (NSSMD0, SFR_SPI0CN, 2);          // SPI0 Slave Select Mode 0
           =3 SBIT (TXBMT, SFR_SPI0CN, 1);           // SPI0 TX Buffer Empty Flag
           =3 SBIT (SPIEN, SFR_SPI0CN, 0);           // SPI0 Enable
           =3 
           =3 //-----------------------------------------------------------------------------
           =3 // Interrupt Priorities
           =3 //-----------------------------------------------------------------------------
           =3 
           =3 #define INTERRUPT_INT0             0   // External Interrupt 0
           =3 #define INTERRUPT_TIMER0           1   // Timer 0 Overflow
           =3 #define INTERRUPT_INT1             2   // External Interrupt 1
           =3 #define INTERRUPT_TIMER1           3   // Timer 1 Overflow
           =3 #define INTERRUPT_UART0            4   // UART0
           =3 #define INTERRUPT_TIMER2           5   // Timer 2 Overflow
           =3 #define INTERRUPT_SPI0             6   // SPI0
           =3 #define INTERRUPT_SMBUS0           7   // SMBus0 Interface
           =3 #define INTERRUPT_ADC0_WINDOW      8   // ADC0 Window Comparison
           =3 #define INTERRUPT_ADC0_EOC         9   // ADC0 End Of Conversion
           =3 #define INTERRUPT_PCA0            10   // PCA0 Peripheral
           =3 #define INTERRUPT_COMPARATOR0     11   // Comparator 0 Comparison
           =3 #define INTERRUPT_COMPARATOR1     12   // Comparator 1 Comparison
           =3 #define INTERRUPT_TIMER3          13   // Timer 3 Overflow
           =3 #define INTERRUPT_LIN0            14   // LIN Bus Interrupt
           =3 #define INTERRUPT_VREG            15   // Voltage Regulator
           =3 #define INTERRUPT_CAN0            16   // CAN Bus Interrupt
           =3 #define INTERRUPT_PORT_MATCH      17   // Port Match
           =3 #define INTERRUPT_UART1           18   // UART1
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 106 

           =3 #define INTERRUPT_PCA1            19   // PCA1 Peripheral
           =3 #define INTERRUPT_COMPARATOR2     20   // Comparator 2 Comparison
           =3 #define INTERRUPT_TIMER4          21   // Timer 4 Overflow
           =3 #define INTERRUPT_TIMER5          22   // Timer 5 Overflow
           =3 
           =3 
           =3 //-----------------------------------------------------------------------------
           =3 // SFR Page Definitions
           =3 //-----------------------------------------------------------------------------
           =3 
           =3 #define  CONFIG_PAGE       0x0F        // System and Port Configuration Page
           =3 #define  ACTIVE_PAGE       0x00        // Active Use Page
           =3 #define  ACTIVE2_PAGE      0x10        // Active Use Page 2
           =3 #define  CAN0_PAGE         0x0C        // CAN0 Registers
           =3 
           =3 //-----------------------------------------------------------------------------
           =3 // SDCC PDATA External Memory Paging Support
           =3 //-----------------------------------------------------------------------------
           =3 
           =3 #if defined SDCC
           =3 
           =3 SFR(_XPAGE, 0xAA); // Point to the EMI0CN register
           =3 
           =3 #endif
           =3 
           =3 //-----------------------------------------------------------------------------
           =3 // Header File PreProcessor Directive
           =3 //-----------------------------------------------------------------------------
           =3 
           =3 #endif                                 // #define C8051F580_DEFS_H
 607      =3  
 608      =3  //-----------------------------------------------------------------------------
 609      =3  // End Of File
 610      =3  //-----------------------------------------------------------------------------
   9      =2  
  10      =2  /* ----- Global Define -------------------------------*/
  11      =2  //DTC INFO
  12      =2  #define DTC_MCU_WT_ERR                          0x00U
  13      =2  #define DTC_MCU_MC_ERR                          0x01U
  14      =2  #define DTC_SENSOR_FV_ERR                       0x02U
  15      =2  #define DTC_SENSOR_FC_ERR                       0x03U
  16      =2  #define DTC_SENSOR_ISPSTAT_ERR          0x04U
  17      =2  #define DTC_SENSOR_COMM_ERR                     0x05U
  18      =2  #define DTC_SENOSR_INIT_ERR                     0x06U
  19      =2  #define DTC_VIDEO_OUT_CUT_ERR           0x07U
  20      =2  #define DTC_VIDEO_OVER_VOL_ERR          0x08U
  21      =2  #define DTC_CODE_COUNT                          0x09U
  22      =2  
  23      =2  #define DTC_CODE_INTERNAL_ERROR         0x00U
  24      =2  #define DTC_CODE_SENSOR_ERROR           0x01U
  25      =2  #define DTC_CODE_OUTPUT_ERROR           0x02U
  26      =2  
  27      =2  
  28      =2  #define DTC_MCU_WD_ERROR                        Record_DTC_Error(DTC_MCU_WT_ERR)
  29      =2  #define DTC_MCU_WD_CLEAR                        Record_DTC_Clear(DTC_MCU_WT_ERR)
  30      =2  #define DTC_MCU_MC_ERROR                        Record_DTC_Error(DTC_MCU_MC_ERR)
  31      =2  #define DTC_MCU_MC_CLEAR                        Record_DTC_Clear(DTC_MCU_MC_ERR)
  32      =2  #define DTC_ISP_FV_ERROR                        Record_DTC_Error(DTC_SENSOR_FV_ERR)
  33      =2  #define DTC_ISP_FV_CLEAR                        Record_DTC_Clear(DTC_SENSOR_FV_ERR)
  34      =2  #define DTC_ISP_FC_ERROR                        Record_DTC_Error(DTC_SENSOR_FC_ERR)
  35      =2  #define DTC_ISP_FC_CLEAR                        Record_DTC_Clear(DTC_SENSOR_FC_ERR)
  36      =2  #define DTC_ISP_IS_ERROR                        Record_DTC_Error(DTC_SENSOR_ISPSTAT_ERR)
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 107 

  37      =2  #define DTC_ISP_IS_CLEAR                        Record_DTC_Clear(DTC_SENSOR_ISPSTAT_ERR)
  38      =2  #define DTC_ISP_CM_ERROR                        Record_DTC_Error(DTC_SENSOR_COMM_ERR)
  39      =2  #define DTC_ISP_CM_CLEAR                        Record_DTC_Clear(DTC_SENSOR_COMM_ERR)
  40      =2  #define DTC_ISP_IT_ERROR                        Record_DTC_Error(DTC_SENOSR_INIT_ERR)
  41      =2  #define DTC_ISP_IT_CLEAR                        Record_DTC_Clear(DTC_SENOSR_INIT_ERR)
  42      =2  #define DTC_VID_OC_ERROR                        Record_DTC_Error(DTC_VIDEO_OUT_CUT_ERR)
  43      =2  #define DTC_VID_OC_CLEAR                        Record_DTC_Clear(DTC_VIDEO_OUT_CUT_ERR)
  44      =2  #define DTC_VID_VO_ERROR                        Record_DTC_Error(DTC_VIDEO_OVER_VOL_ERR)
  45      =2  #define DTC_VID_VO_CLEAR                        Record_DTC_Clear(DTC_VIDEO_OVER_VOL_ERR)
  46      =2          
  47      =2  
  48      =2  #define DTC_CURRENT_ERROR                       0x09U
  49      =2  #define DTC_CONFIRM_ERROR                       0x08U
  50      =2  #define DTC_CLEAR                                       0xFFU
  51      =2  
  52      =2  //SYSTEM INFO
  53      =2  #define SYS_HMC_SPEC                            0x02U
  54      =2  #define SYS_HMC_SPEC_L                          0x03U
  55      =2  
  56      =2  #define SYS_PART_NUMBER                         0x87U
  57      =2  #define SYS_PART_NUMBER_L                       0x00U
  58      =2  #define SYS_MANU_DATE                           0x8BU
  59      =2  #define SYS_MANU_DATE_L                         (U8)SYS_PART_NUMBER_L+0x0aU
  60      =2  #define SYS_HW_VERSION                          0x93U
  61      =2  #define SYS_HW_VERSION_L                        (U8)SYS_MANU_DATE_L + 0x08U
  62      =2  #define SYS_SW_VERSION                          0x95U
  63      =2  #define SYS_SW_VERSION_L                        (U8)SYS_HW_VERSION_L + 0x03U
  64      =2  #define SYS_CAN_VERSION                         0x00U
  65      =2  #define SYS_CAN_VERSION_L                       (U8)SYS_SW_VERSION_L + 0x03U
  66      =2  #define SYS_CODE_COUNT                          0x07U
  67      =2  #define SYS_CODE_SIZE                           0x25U
  68      =2  #define SYS_WRITE_CODE_SIZE                     0x27U
  69      =2  //ROUTINE CONTROL 
  70      =2  
  71      =2  #define RTN_CTRL_ERASE_MEMORY           0xFF00U
  72      =2  #define RTN_CTRL_CHECK_PRG_DEPEND       0xFF01U
  73      =2  #define RTN_CTRL_SENSOR_RESET           0xF1F0U
  74      =2  #define RTN_CTRL_GUIDE_ONOFF            0xF1F1U
  75      =2  #define RTN_CTRL_WARNING_ONOFF          0xF1F2U
  76      =2  
  77      =2  #define RTN_CTRL_DEFAULT                        0x00U
  78      =2  #define RTN_CTRL_FIMR_UPDATE            0x01U //only RTN_CTRL_ERASE_MEMORY
  79      =2  #define RTN_CTRL_BINARY_UPDATE          0x02U //only RTN_CTRL_ERASE_MEMORY 
  80      =2  
  81      =2  #define HMC_SPEC_OPTIC_X_HIGH_PID                        4U
  82      =2  #define HMC_SPEC_OPTIC_X_LOW_PID                         5U
  83      =2  #define HMC_SPEC_OPTIC_Y_HIGH_PID                        6U
  84      =2  #define HMC_SPEC_OPTIC_Y_LOW_PID                         7U
  85      =2  #define HMC_SPEC_COUNTRY_CFG_PID                         8U
  86      =2  #define HMC_SPEC_TEMPERATURE_PID                         9U
  87      =2  #define HMC_SPEC_SAS_ANGLE_HIGH_PID                     10U
  88      =2  #define HMC_SPEC_SAS_ANGLE_LOW_PID                      11U
  89      =2  #define HMC_SPEC_DTC_CURRENT_HIGH_PID           12U
  90      =2  #define HMC_SPEC_DTC_CURRENT_LOW_PID            13U
  91      =2  #define HMC_SPEC_DTC_CONFIRM_HIGH_PID           14U
  92      =2  #define HMC_SPEC_DTC_CONFIRM_LOW_PID            15U
  93      =2  #define HMC_SPEC_RELATIVE_OPTIC_X_PID           16U
  94      =2  #define HMC_SPEC_RELATIVE_OPTIC_Y_PID           17U
  95      =2  #define HMC_SPEC_TOTAL_COUNT                            18U
  96      =2  
  97      =2  #define OPTIC_X_HIGH_PID_1                       0x80U
  98      =2  #define OPTIC_X_LOW_PID_2                        0x40U
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 108 

  99      =2  #define OPTIC_Y_HIGH_PID_3                       0x20U
 100      =2  #define OPTIC_Y_LOW_PID_4                        0x10U
 101      =2  #define COUNTRY_CFG_PID_5                        0x08U
 102      =2  #define TEMPERATURE_PID_6                        0x04U
 103      =2  #define SAS_ANGLE_HIGH_PID_7             0x02U
 104      =2  #define SAS_ANGLE_LOW_PID_8                      0x01U
 105      =2  #define DTC_CURRENT_HIGH_PID_9           0x80U
 106      =2  #define DTC_CURRENT_LOW_PID_A            0x40U
 107      =2  #define DTC_CONFIRM_HIGH_PID_B           0x20U
 108      =2  #define DTC_CONFIRM_LOW_PID_C            0x10U
 109      =2  
 110      =2  #define USE_CASE_1BYTE                           0xFFU  
 111      =2  #define USE_CASE_2BYTE                           0xFCU
 112      =2  #define USE_CASE_3BYTE                           0x00U
 113      =2  #define USE_CASE_4BYTE                           0x00U
 114      =2  
 115      =2  #define SAS_CLEAR                                        0x00U
 116      =2  #define SAS_ON                                           0x01U
 117      =2  #define SAS_PRE_ON                                       0x02U
 118      =2  
 119      =2  #define OPTIC_SETTING                           0x00U
 120      =2  #define ERASE_ONESPEC                           0x01U
 121      =2  #define ERASE_FLASH_ALL                         0x02U
 122      =2  
 123      =2  #define CALIBRATION_MODE_START          0x00U
 124      =2  #define CALIBRATION_MODE_STOP           0x01U
 125      =2  #define CALIBRATION_MOVE_DEFAULT        0x02U
 126      =2  #define CALIBRATION_MOVE_LEFT           0x03U
 127      =2  #define CALIBRATION_MOVE_RIGHT          0x04U
 128      =2  #define CALIBRATION_MOVE_UP                     0x05U
 129      =2  #define CALIBRATION_MOVE_DOWN           0x06U
 130      =2  
 131      =2  //Calibration mode
 132      =2  #define DIAG_CALIBRATION_MODE_ACTIVE(flag)      ((CalibrationMode_OnOff) = (flag))
 133      =2  #define DIAG_CALIBRATION_MODE_STATE                     (CalibrationMode_OnOff)
 134      =2  
 135      =2  #define DIAG_OPTIC_OFFSET_SET_ACTIVE(flag)      ((OpticOffset_Set) = (flag))
 136      =2  #define DIAG_OPTIC_OFFSET_SET_STATE                     (OpticOffset_Set)
 137      =2  
 138      =2  #define OPTIC_X_LIMIT_PLUS                      0x18U
 139      =2  #define OPTIC_X_LIMIT_MINUS                     0xE8U
 140      =2  #define OPTIC_Y_LIMIT_PLUS                      0x20U
 141      =2  #define OPTIC_Y_LIMIT_MINUS                     0xE0U
 142      =2  
 143      =2  #define IGN_CLEAR                                        0x00U
 144      =2  #define IGN_ON                                           0x01U
 145      =2  #define IGN_PRE_ON                                       0x02U
 146      =2  /*----------------------------------------------------*/
 147      =2  
 148      =2  /* ----- Function ------------------------------------*/
 149      =2  void Reset_Diag(void);
 150      =2  void Init_DiagTask(void);
 151      =2  void Operate_DiagTask(void);
 152      =2  
 153      =2  void Diag_Ecu_Reset(void);
 154      =2  void Diag_Clear_DTC(void);
 155      =2  U8   Diag_Read_Dtc(U8 index);
 156      =2  void Diag_DTC_Error_WT(void);
 157      =2  void Diag_Sensor_Reset(void);
 158      =2  void Diag_Guid_OnOff(U8 OnOff);
 159      =2  
 160      =2  
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 109 

 161      =2  void Clear_DTC_Struct(void);
 162      =2  void Clear_DTC_Status(void);
 163      =2  void Record_DTC_Error(U8 ID);
 164      =2  void Record_DTC_Clear(U8 ID);
 165      =2  void Diag_Read_Sys(U8 ID, U8 *Buf,U8 Length);
 166      =2  void Diag_Write_Sys(U8 *Write_Buf,U8 Length);
 167      =2  
 168      =2  void Firmware_Update(void);
 169      =2  
 170      =2  void Diag_Write_Transfer_Data(U8 *Buf);
 171      =2  void TGT_Set_Addr (U8 *Write_Addr);
 172      =2  void    Diag_DTC_Set_On(void);
 173      =2  void    Diag_DTC_Set_Off(void);
 174      =2  void Flash_DTC_Write(void);
 175      =2  void Flash_DTC_Read(void);
 176      =2  void Diag_Exit_Update(void);
 177      =2  U16   Diag_Get_Time(void);
 178      =2  void SYS_Flash_Read(U8 ID,U8 *Read_Buf,U8 Length);
 179      =2  void Diag_Read_Address(U8 *Read_Buf, U32 DataAddr, U16 DataLen);
 180      =2  void Diag_Extra_Data_Process(U8 *Write_Buf);
 181      =2  void Diag_Eeprom_Update(void);
 182      =2  void Diag_Calibration_Mode_start(void);
 183      =2  void Diag_Calibration_Mode(U8 Ctrl_Para);
 184      =2  /*----------------------------------------------------*/
 185      =2  
 186      =2  /* ----- Extern Function -----------------------------*/
 187      =2  extern SEG_XDATA volatile tMsg_CAN_Rx_Data_s tCAN_Rx_Msg[USE_CAN_COUNT];
 188      =2  extern SEG_XDATA volatile U8 CalibrationMode_OnOff;
 189      =2  extern SEG_XDATA volatile U8 OpticOffset_Set;
 190      =2  /*----------------------------------------------------*/
 191      =2  
 192      =2  /* ----- Global Value --------------------------------*/
 193      =2  typedef struct {
 194      =2          U8 Status;
 195      =2          U8 Count;
 196      =2  } tMsg_DTC_Type;
 197      =2  
 198      =2  
 199      =2  typedef struct {
 200      =2          tMsg_DTC_Type tDTC_Type[DTC_CODE_COUNT];
 201      =2          U8 DTC_Clear_Count[3U];
 202      =2          U8 DTC_State[3U];
 203      =2          U8 Checksum;
 204      =2  } tMsg_Ext_DTC_Type;
 205      =2  typedef struct {
 206      =2          U8 update_set;
 207      =2          U8 write_count;
 208      =2          U8 erase_set;
 209      =2          U32 total_write_cnt;
 210      =2          U32 write_cnt;
 211      =2          U32 size;       
 212      =2  } tMsg_Update;
 213      =2  extern SEG_XDATA tMsg_Ext_DTC_Type ga_Ext_tDTC_Type_Msg;
 214      =2  #endif
 215      =2  /*----------------------------------------------------*/
 216      =2  
 217      =2  
 218      =2  
 219      =2  
  21      =1  #include "mgr_comm.h"
   1      =2  #ifndef MGR_COMM_H
           =2 #define MGR_COMM_H
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 110 

           =2 
           =2 #include "compiler_defs.h"
           =2 #include "C8051F580_defs.h"
           =2 
           =2 /* ----- Global Define -------------------------------*/
           =2 /*
           =2 #define TW8836          0x00U
           =2 #define DESERIALIZE     0x01U
           =2 #define SERIALIZE       0x02U
           =2 */
           =2 #define  TW8836_SLAVE_ADDRESS   (U8)0x8A
           =2 #define  TW8836_ID_ADRESS           (U8)0x00
           =2 #define  TW8836_ID                              (U16)0x0036
           =2 
           =2 #define  INIT                           0x00U           // (MR) data byte received
           =2 #define  RX                                     0x01U           // (MR) data byte received
           =2 #define  TX                                     0x02U           // (MR) data byte received
           =2 
           =2 #define USE_MDPS11                              0x00U
           =2 #define USE_LANGUAGEINFO                0x01U
           =2 #define USE_HUTYPE                              0x02U
           =2 #define USE_GATEWAY                             0x03U
           =2 #define USE_NAVIONOFF                   0x04U
           =2 #define USE_G_SEL_DISP                  0x05U
           =2 #define USE_IGN_SW                              0x06U
           =2 #define USE_RVM_CAMERAOFF               0x07U
           =2 #define FCZC_RVM_SW                             0x08U
           =2 #define USE_4WDERR                              0x09U
           =2 #define USE_ENGVOL                              0x0AU
           =2 #define USE_CAN_COUNT                   0x0BU           
           =2 
           =2 #define TYPE_2WD                                0x00U
           =2 #define TYPE_4WD                                0x01U
           =2 
           =2 #define TYPE_ENGVOL20                   0x14U
           =2 #define TYPE_ENGVOL22                   0x16U
           =2 #define TYPE_ENGVOL33                   0x21U
           =2 /*----------------------------------------------------*/
           =2 
           =2 /* ----- Function ------------------------------------*/
           =2 void Init_CommTask(void);
           =2 void Operate_CommTask(void);
           =2 void Rx_Data_Process(void);
           =2 //void Comm_I2C_Tx_Data(void);
           =2 void Comm_I2C_Tx(U8 Slave_Addr,U8 Length,U16 Addr, U16 TData,U16 RData );
           =2 U16   Comm_I2C_Rx(U8 Slave_Addr,U8 Length,U16 Addr, U16 TData,U16 RData );
           =2 void Clear_I2C_Tx_Data(void);
           =2 void Clear_CAN_Tx_Data(void);
           =2 void Clear_Can_Data(void);
           =2 void Clear_Sas_Data(void);
           =2 
           =2 void Comm_RearView_Data(void);
           =2 void Comm_Tuning_Value_Type(U8 Type4WdErr, U8 TypeEngVol);
           =2 U8 Comm_Sas_Data(U8 *pa_Data);
           =2 U8 Comm_Hutype_Data(U8 *pa_Data);
           =2 U8 Comm_Language_Data(U8 *pa_Data);
           =2 U8 Comm_G_Sel_Disp_Data(U8 *Data);
           =2 U8 Comm_IGN_Sw_Data(U8 *Data);
           =2 U8 Comm_RVM_CameraOff_Data(U8 *Data);
           =2 U8 Comm_RVM_SW_Data(U8 *Data);
           =2 U8 Comm_ENG_Vol_Data(U8 *pa_Data);
           =2 U8 Comm_4WD_Err_Data(U8 *pa_Data);
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 111 

           =2 void Comm_Tx_RVM_View(U8 sigData);
           =2 void Comm_Tx_RVM_SW_IND(U8 sigData);
           =2 
           =2 void Flash_OneSpec_Write(void);
           =2 void Flash_OneSpec_Read(void);
           =2 void Comm_Error_Check(void);
           =2 
           =2 void IlPutTxRVM_View(U8 sigData);
           =2 
           =2 void IlPutTxRVM_SW_IND(U8 sigData);
           =2 /*----------------------------------------------------*/
           =2 
           =2 /* ----- Extern Function -----------------------------*/
           =2 /*----------------------------------------------------*/
           =2 
           =2 /* ----- Global Value --------------------------------*/
           =2 
           =2 typedef struct {
           =2         U8  Slave;
           =2         U8  Length;
           =2         U8  TRX_Flag;
           =2         U16 Addr;
           =2         U16 TxData;
           =2         U16 RxData;
           =2 }tMsg_I2C_Tx_Data_s;
           =2 
           =2 typedef struct {
           =2         U8  Slave;
           =2         U8  Length;
           =2         U8  TRX_Flag;
           =2         U16 Addr;
           =2         U16 TxData;
           =2         U16 RxData;
           =2 }tMsg_CAN_Tx_Data_s;
           =2 
           =2 typedef struct {
           =2         U8 Is_Change;
           =2         U8 Change_Count;
           =2         U8 Time_Out;
           =2         U8 Cur_Data;
           =2         U8 Mid_Data;
           =2         U8 Pre_Data;
           =2         U16 Chatter_Time;
           =2 }tMsg_CAN_Rx_Data_s;
           =2 
           =2 typedef struct {
           =2         U8  Is_Change;
           =2         U8  Pre_Sign;
           =2         U8  Angle;
           =2         U8  Angle_Pre_Sign;
           =2         U8  Time_Out;
           =2         U16 Pre_Data;
           =2         U8      Tuning_Type;
           =2 }tMsg_CAN_SAS_Data_s;
           =2 
           =2 typedef struct {
           =2         U8  Is_Change;
           =2         U8  Pre_Sign;
           =2         U8  Angle;
           =2         U16 Pre_Data;
           =2 }tMsg_CAN_State_s;
           =2 
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 112 

           =2 
           =2 /*
           =2 struct tCAN_Tx_Data_s {
           =2         U8 Flag;
           =2         U8 Dest;
           =2         U8 Length;
           =2         U8 *TxData;
           =2 }
           =2 
           =2 struct tCAN_Rx_Data_s {
           =2         U8 Flag;
           =2         U8 Src;
           =2         U8 Length;
           =2         U8 RxData;
           =2 }
           =2 */
           =2 /*----------------------------------------------------*/
           =2 
           =2 extern SEG_XDATA volatile tMsg_CAN_SAS_Data_s tCAN_Rx_SAS_Msg;
           =2 #endif
 147      =2  
  22      =1  //-----------------------------------------------------------------------------
  23      =1  // Open Header #define
  24      =1  //-----------------------------------------------------------------------------
  25      =1  
  26      =1  
  27      =1  
  28      =1  //-----------------------------------------------------------------------------
  29      =1  // Structures, Unions, Enumerations, and Type Definitions
  30      =1  //-----------------------------------------------------------------------------
  31      =1  //BANK1
  32      =1  //#define DTCCODE_ADDRESS                               0xFC00U //0xF800U
  33      =1  //#define ONESPEC_ADDRESS                               0xFD00U //0xFA00U
  34      =1  //#define SYSINFO_ADDRESS                               0xFE00U //0xFC00U
  35      =1  //#define OPTIC_ADDRESS                                 0xFF00U //0xFE00U
  36      =1  //BANK2
  37      =1  #define DTCCODE_ADDRESS                                 0xFF00U
  38      =1  #define ONESPEC_ADDRESS                                 0xFA00U
  39      =1  #define SYSINFO_ADDRESS                                 0xFC00U
  40      =1  #define OPTIC_ADDRESS                                   0xFE00U
  41      =1  
  42      =1  #define PAGE_SIZE                                               0x100
  43      =1  
  44      =1  typedef U16 FLADDR;
  45      =1  
  46      =1  //-----------------------------------------------------------------------------
  47      =1  // Global Constants
  48      =1  //-----------------------------------------------------------------------------
  49      =1  
  50      =1  #ifndef FLASH_PAGESIZE
  51      =1  #define FLASH_PAGESIZE (512)
  52      =1  #endif
  53      =1  
  54      =1  #ifndef FLASH_TEMP
  55      =1  #define FLASH_TEMP 0x7800L             // For 32K Flash devices
  56      =1  //#define FLASH_TEMP 0x3C00L           // For 16K Flash devices
  57      =1  #endif
  58      =1  
  59      =1  #ifndef FLASH_LAST
  60      =1  #define FLASH_LAST 0x7A00L             // For 32K Flash devices
  61      =1  //#define FLASH_LAST 0x3E00L           // For 16K Flash devices
  62      =1  #endif
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 113 

  63      =1  
  64      =1  //-----------------------------------------------------------------------------
  65      =1  // Exported Function Prototypes
  66      =1  //-----------------------------------------------------------------------------
  67      =1  
  68      =1  // FLASH read/write/erase routines
  69      =1  extern volatile U8 FLKEY1;
  70      =1  extern volatile U8 FLKEY2;
  71      =1  
  72      =1  #define FLASH_ByteWriteWithKey(addr, byte, bank) FLASH_ByteWrite(addr, byte, bank, FLKEY1, FLKEY2);
  73      =1  #define FLASH_PageEraseWithKey(addr, bank) FLASH_PageErase(addr, bank, FLKEY1, FLKEY2);
  74      =1  // FLASH update/copy routines
  75      =1  void FLASH_Update (FLADDR dest, U8 *src, U16 numbytes);
  76      =1  void FLASH_Copy (FLADDR dest, FLADDR src, U16 numbytes);
  77      =1  
  78      =1  // FLASH test routines
  79      =1  void F560_FLASH_Fill (FLADDR addr, U16 length, U8 fill);
  80      =1  //-----------------------------------------------------------------------------
  81      =1  // Close Header #define
  82      =1  //-----------------------------------------------------------------------------
  83      =1  void Mem_Flash_DTC_Read(tMsg_DTC_Type *dtc_type);
  84      =1  
  85      =1  U8 FLASH_ByteWrite (FLADDR addr, U8 byte, U8 bank, U8 flkey1, U8 flkey2);
  86      =1  U8  FLASH_ByteRead  (FLADDR addr, U8 bank);
  87      =1  U8 FLASH_PageErase (FLADDR addr,U8 bank, U8 flkey1, U8 flkey2);
  88      =1  void FLASH_Write_Buf (FLADDR dest, U8 *src, U16 numbytes,U8 bank);
  89      =1  void FLASH_Read_Buf (U8 *dest, FLADDR src, U16 numbytes,U8 bank);
  90      =1  void FLASH_Erase_Buf (FLADDR dest,U8 bank);
  91      =1  
  92      =1  #endif    // _F560_FLASHPRIMITIVES_H_
  93      =1  
  94      =1  //-----------------------------------------------------------------------------
  95      =1  // End Of File
  96      =1  //-----------------------------------------------------------------------------
  12          #include "drv_spi.h"
   1      =1  #ifndef DRV_SPI_H
           =1 #define DRV_SPI_H
           =1 
           =1 // Target MCU Commands
           =1 #define TGT_CMD_ENTER_BL_MODE    (0x90U)
           =1 #define TGT_CMD_GET_INFO         (0x91U)
           =1 #define TGT_CMD_SET_FLASH_KEYS   (0x92U)
           =1 #define TGT_CMD_SET_ADDR         (0x93U)
           =1 #define TGT_CMD_ERASE_PAGE       (0x94U)
           =1 #define TGT_CMD_WRITE_FLASH      (0x95U)
           =1 #define TGT_CMD_GET_PAGE_CRC     (0x96U)
           =1 #define TGT_CMD_WRITE_SIGNATURE  (0x97U)
           =1 #define TGT_CMD_SW_RESET         (0x98U)
           =1 #define TGT_CMD_SW_INFO          (0x9FU)
           =1 
           =1 // EEPROM
           =1 #define  EEPROM_CAPACITY                        (1048576)       // EEPROM Capacity (bytes)
           =1 #define  EEPROM_PAGE_SIZE                       (256)           // EEPROM Page Size (bytes)
           =1 #define  EEPROM_SECTOR_SIZE                     (4096)          // EEPROM Sector Size (bytes)
           =1 #define  EEPROM_BLOCK_SIZE                      (65536)         // EEPROM Block Size (bytes)
           =1 #define  EEPROM_CMD_WREN                        (0x06U)         // write enable
           =1 #define  EEPROM_CMD_RDDT                        (0x03U)         // read data
           =1 #define  EEPROM_CMD_WRDI                        (0x04U)         // write disable
           =1 #define  EEPROM_CMD_RDSR                        (0x05U)         // status register read
           =1 #define  EEPROM_CMD_FAST_READ           (0x0BU)         // +AD1,AD2,AD3+Dummy fast read data
           =1 #define  EEPROM_CMD_REMS                        (0x90U)         // +Dummy,Dummy,ADD read electronic manufacturer & device ID)
           =1 #define  EEPROM_CMD_SE                          (0x20U)         // +AD1,AD2,AD3 sector erase (4KB) 0~255 sector
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 114 

           =1 #define  EEPROM_CMD_PP                          (0x02U)         // +AD1,AD2,AD3 page program (256 byte)
           =1 #define  EEPROM_STATUS_WIP                      (0x01U)         // write in progress bit
           =1 
           =1 // Reserved space first byte
           =1 #define RESERVED_SPACE_ADDR                     (31*1024)       // 0x7C00U
           =1 
           =1 void Flash_Wait(void);
           =1 void Flash_DataSet(U8 flash_data);
           =1 void Flash_Slave_Select(void);
           =1 void Flash_Slave_Command(U8 flash_cmd);
           =1 void Update_Flash_Proc(U8 Mode, U8 Buf);
           =1 void Flash_EraseSector( U32 Addr );
           =1 void Spi_Init (void);
           =1 U8      Check_Flash_ID( void );
           =1 U8 spi_master_read(U8 addr);
           =1 void spi_master_write(U8 addr, U8 dat);
           =1 void    Flash_Write( U32 Addr,U8 *Data, U16 Len );
           =1 U8      Read_Guide_Value( U8 *Value );
           =1 #endif
  47      =1  
  48      =1  
  13          #include "mgr_diag.h"
   1      =1  //#include "drv_i2c.h"
   2      =1  
   3      =1  #ifndef MGR_DIAG_H
           =1 #define MGR_DIAG_H
           =1 
           =1 #include "mgr_comm.h"
           =1 #include "compiler_defs.h"
           =1 #include "C8051F580_defs.h"
           =1 
           =1 /* ----- Global Define -------------------------------*/
           =1 //DTC INFO
           =1 #define DTC_MCU_WT_ERR                          0x00U
           =1 #define DTC_MCU_MC_ERR                          0x01U
           =1 #define DTC_SENSOR_FV_ERR                       0x02U
           =1 #define DTC_SENSOR_FC_ERR                       0x03U
           =1 #define DTC_SENSOR_ISPSTAT_ERR          0x04U
           =1 #define DTC_SENSOR_COMM_ERR                     0x05U
           =1 #define DTC_SENOSR_INIT_ERR                     0x06U
           =1 #define DTC_VIDEO_OUT_CUT_ERR           0x07U
           =1 #define DTC_VIDEO_OVER_VOL_ERR          0x08U
           =1 #define DTC_CODE_COUNT                          0x09U
           =1 
           =1 #define DTC_CODE_INTERNAL_ERROR         0x00U
           =1 #define DTC_CODE_SENSOR_ERROR           0x01U
           =1 #define DTC_CODE_OUTPUT_ERROR           0x02U
           =1 
           =1 
           =1 #define DTC_MCU_WD_ERROR                        Record_DTC_Error(DTC_MCU_WT_ERR)
           =1 #define DTC_MCU_WD_CLEAR                        Record_DTC_Clear(DTC_MCU_WT_ERR)
           =1 #define DTC_MCU_MC_ERROR                        Record_DTC_Error(DTC_MCU_MC_ERR)
           =1 #define DTC_MCU_MC_CLEAR                        Record_DTC_Clear(DTC_MCU_MC_ERR)
           =1 #define DTC_ISP_FV_ERROR                        Record_DTC_Error(DTC_SENSOR_FV_ERR)
           =1 #define DTC_ISP_FV_CLEAR                        Record_DTC_Clear(DTC_SENSOR_FV_ERR)
           =1 #define DTC_ISP_FC_ERROR                        Record_DTC_Error(DTC_SENSOR_FC_ERR)
           =1 #define DTC_ISP_FC_CLEAR                        Record_DTC_Clear(DTC_SENSOR_FC_ERR)
           =1 #define DTC_ISP_IS_ERROR                        Record_DTC_Error(DTC_SENSOR_ISPSTAT_ERR)
           =1 #define DTC_ISP_IS_CLEAR                        Record_DTC_Clear(DTC_SENSOR_ISPSTAT_ERR)
           =1 #define DTC_ISP_CM_ERROR                        Record_DTC_Error(DTC_SENSOR_COMM_ERR)
           =1 #define DTC_ISP_CM_CLEAR                        Record_DTC_Clear(DTC_SENSOR_COMM_ERR)
           =1 #define DTC_ISP_IT_ERROR                        Record_DTC_Error(DTC_SENOSR_INIT_ERR)
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 115 

           =1 #define DTC_ISP_IT_CLEAR                        Record_DTC_Clear(DTC_SENOSR_INIT_ERR)
           =1 #define DTC_VID_OC_ERROR                        Record_DTC_Error(DTC_VIDEO_OUT_CUT_ERR)
           =1 #define DTC_VID_OC_CLEAR                        Record_DTC_Clear(DTC_VIDEO_OUT_CUT_ERR)
           =1 #define DTC_VID_VO_ERROR                        Record_DTC_Error(DTC_VIDEO_OVER_VOL_ERR)
           =1 #define DTC_VID_VO_CLEAR                        Record_DTC_Clear(DTC_VIDEO_OVER_VOL_ERR)
           =1         
           =1 
           =1 #define DTC_CURRENT_ERROR                       0x09U
           =1 #define DTC_CONFIRM_ERROR                       0x08U
           =1 #define DTC_CLEAR                                       0xFFU
           =1 
           =1 //SYSTEM INFO
           =1 #define SYS_HMC_SPEC                            0x02U
           =1 #define SYS_HMC_SPEC_L                          0x03U
           =1 
           =1 #define SYS_PART_NUMBER                         0x87U
           =1 #define SYS_PART_NUMBER_L                       0x00U
           =1 #define SYS_MANU_DATE                           0x8BU
           =1 #define SYS_MANU_DATE_L                         (U8)SYS_PART_NUMBER_L+0x0aU
           =1 #define SYS_HW_VERSION                          0x93U
           =1 #define SYS_HW_VERSION_L                        (U8)SYS_MANU_DATE_L + 0x08U
           =1 #define SYS_SW_VERSION                          0x95U
           =1 #define SYS_SW_VERSION_L                        (U8)SYS_HW_VERSION_L + 0x03U
           =1 #define SYS_CAN_VERSION                         0x00U
           =1 #define SYS_CAN_VERSION_L                       (U8)SYS_SW_VERSION_L + 0x03U
           =1 #define SYS_CODE_COUNT                          0x07U
           =1 #define SYS_CODE_SIZE                           0x25U
           =1 #define SYS_WRITE_CODE_SIZE                     0x27U
           =1 //ROUTINE CONTROL 
           =1 
           =1 #define RTN_CTRL_ERASE_MEMORY           0xFF00U
           =1 #define RTN_CTRL_CHECK_PRG_DEPEND       0xFF01U
           =1 #define RTN_CTRL_SENSOR_RESET           0xF1F0U
           =1 #define RTN_CTRL_GUIDE_ONOFF            0xF1F1U
           =1 #define RTN_CTRL_WARNING_ONOFF          0xF1F2U
           =1 
           =1 #define RTN_CTRL_DEFAULT                        0x00U
           =1 #define RTN_CTRL_FIMR_UPDATE            0x01U //only RTN_CTRL_ERASE_MEMORY
           =1 #define RTN_CTRL_BINARY_UPDATE          0x02U //only RTN_CTRL_ERASE_MEMORY 
           =1 
           =1 #define HMC_SPEC_OPTIC_X_HIGH_PID                        4U
           =1 #define HMC_SPEC_OPTIC_X_LOW_PID                         5U
           =1 #define HMC_SPEC_OPTIC_Y_HIGH_PID                        6U
           =1 #define HMC_SPEC_OPTIC_Y_LOW_PID                         7U
           =1 #define HMC_SPEC_COUNTRY_CFG_PID                         8U
           =1 #define HMC_SPEC_TEMPERATURE_PID                         9U
           =1 #define HMC_SPEC_SAS_ANGLE_HIGH_PID                     10U
           =1 #define HMC_SPEC_SAS_ANGLE_LOW_PID                      11U
           =1 #define HMC_SPEC_DTC_CURRENT_HIGH_PID           12U
           =1 #define HMC_SPEC_DTC_CURRENT_LOW_PID            13U
           =1 #define HMC_SPEC_DTC_CONFIRM_HIGH_PID           14U
           =1 #define HMC_SPEC_DTC_CONFIRM_LOW_PID            15U
           =1 #define HMC_SPEC_RELATIVE_OPTIC_X_PID           16U
           =1 #define HMC_SPEC_RELATIVE_OPTIC_Y_PID           17U
           =1 #define HMC_SPEC_TOTAL_COUNT                            18U
           =1 
           =1 #define OPTIC_X_HIGH_PID_1                       0x80U
           =1 #define OPTIC_X_LOW_PID_2                        0x40U
           =1 #define OPTIC_Y_HIGH_PID_3                       0x20U
           =1 #define OPTIC_Y_LOW_PID_4                        0x10U
           =1 #define COUNTRY_CFG_PID_5                        0x08U
           =1 #define TEMPERATURE_PID_6                        0x04U
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 116 

           =1 #define SAS_ANGLE_HIGH_PID_7             0x02U
           =1 #define SAS_ANGLE_LOW_PID_8                      0x01U
           =1 #define DTC_CURRENT_HIGH_PID_9           0x80U
           =1 #define DTC_CURRENT_LOW_PID_A            0x40U
           =1 #define DTC_CONFIRM_HIGH_PID_B           0x20U
           =1 #define DTC_CONFIRM_LOW_PID_C            0x10U
           =1 
           =1 #define USE_CASE_1BYTE                           0xFFU  
           =1 #define USE_CASE_2BYTE                           0xFCU
           =1 #define USE_CASE_3BYTE                           0x00U
           =1 #define USE_CASE_4BYTE                           0x00U
           =1 
           =1 #define SAS_CLEAR                                        0x00U
           =1 #define SAS_ON                                           0x01U
           =1 #define SAS_PRE_ON                                       0x02U
           =1 
           =1 #define OPTIC_SETTING                           0x00U
           =1 #define ERASE_ONESPEC                           0x01U
           =1 #define ERASE_FLASH_ALL                         0x02U
           =1 
           =1 #define CALIBRATION_MODE_START          0x00U
           =1 #define CALIBRATION_MODE_STOP           0x01U
           =1 #define CALIBRATION_MOVE_DEFAULT        0x02U
           =1 #define CALIBRATION_MOVE_LEFT           0x03U
           =1 #define CALIBRATION_MOVE_RIGHT          0x04U
           =1 #define CALIBRATION_MOVE_UP                     0x05U
           =1 #define CALIBRATION_MOVE_DOWN           0x06U
           =1 
           =1 //Calibration mode
           =1 #define DIAG_CALIBRATION_MODE_ACTIVE(flag)      ((CalibrationMode_OnOff) = (flag))
           =1 #define DIAG_CALIBRATION_MODE_STATE                     (CalibrationMode_OnOff)
           =1 
           =1 #define DIAG_OPTIC_OFFSET_SET_ACTIVE(flag)      ((OpticOffset_Set) = (flag))
           =1 #define DIAG_OPTIC_OFFSET_SET_STATE                     (OpticOffset_Set)
           =1 
           =1 #define OPTIC_X_LIMIT_PLUS                      0x18U
           =1 #define OPTIC_X_LIMIT_MINUS                     0xE8U
           =1 #define OPTIC_Y_LIMIT_PLUS                      0x20U
           =1 #define OPTIC_Y_LIMIT_MINUS                     0xE0U
           =1 
           =1 #define IGN_CLEAR                                        0x00U
           =1 #define IGN_ON                                           0x01U
           =1 #define IGN_PRE_ON                                       0x02U
           =1 /*----------------------------------------------------*/
           =1 
           =1 /* ----- Function ------------------------------------*/
           =1 void Reset_Diag(void);
           =1 void Init_DiagTask(void);
           =1 void Operate_DiagTask(void);
           =1 
           =1 void Diag_Ecu_Reset(void);
           =1 void Diag_Clear_DTC(void);
           =1 U8   Diag_Read_Dtc(U8 index);
           =1 void Diag_DTC_Error_WT(void);
           =1 void Diag_Sensor_Reset(void);
           =1 void Diag_Guid_OnOff(U8 OnOff);
           =1 
           =1 
           =1 void Clear_DTC_Struct(void);
           =1 void Clear_DTC_Status(void);
           =1 void Record_DTC_Error(U8 ID);
           =1 void Record_DTC_Clear(U8 ID);
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 117 

           =1 void Diag_Read_Sys(U8 ID, U8 *Buf,U8 Length);
           =1 void Diag_Write_Sys(U8 *Write_Buf,U8 Length);
           =1 
           =1 void Firmware_Update(void);
           =1 
           =1 void Diag_Write_Transfer_Data(U8 *Buf);
           =1 void TGT_Set_Addr (U8 *Write_Addr);
           =1 void    Diag_DTC_Set_On(void);
           =1 void    Diag_DTC_Set_Off(void);
           =1 void Flash_DTC_Write(void);
           =1 void Flash_DTC_Read(void);
           =1 void Diag_Exit_Update(void);
           =1 U16   Diag_Get_Time(void);
           =1 void SYS_Flash_Read(U8 ID,U8 *Read_Buf,U8 Length);
           =1 void Diag_Read_Address(U8 *Read_Buf, U32 DataAddr, U16 DataLen);
           =1 void Diag_Extra_Data_Process(U8 *Write_Buf);
           =1 void Diag_Eeprom_Update(void);
           =1 void Diag_Calibration_Mode_start(void);
           =1 void Diag_Calibration_Mode(U8 Ctrl_Para);
           =1 /*----------------------------------------------------*/
           =1 
           =1 /* ----- Extern Function -----------------------------*/
           =1 extern SEG_XDATA volatile tMsg_CAN_Rx_Data_s tCAN_Rx_Msg[USE_CAN_COUNT];
           =1 extern SEG_XDATA volatile U8 CalibrationMode_OnOff;
           =1 extern SEG_XDATA volatile U8 OpticOffset_Set;
           =1 /*----------------------------------------------------*/
           =1 
           =1 /* ----- Global Value --------------------------------*/
           =1 typedef struct {
           =1         U8 Status;
           =1         U8 Count;
           =1 } tMsg_DTC_Type;
           =1 
           =1 
           =1 typedef struct {
           =1         tMsg_DTC_Type tDTC_Type[DTC_CODE_COUNT];
           =1         U8 DTC_Clear_Count[3U];
           =1         U8 DTC_State[3U];
           =1         U8 Checksum;
           =1 } tMsg_Ext_DTC_Type;
           =1 typedef struct {
           =1         U8 update_set;
           =1         U8 write_count;
           =1         U8 erase_set;
           =1         U32 total_write_cnt;
           =1         U32 write_cnt;
           =1         U32 size;       
           =1 } tMsg_Update;
           =1 extern SEG_XDATA tMsg_Ext_DTC_Type ga_Ext_tDTC_Type_Msg;
           =1 #endif
 215      =1  /*----------------------------------------------------*/
 216      =1  
 217      =1  
 218      =1  
 219      =1  
  14          #include "mgr_isp.h"
   1      =1  /* ----- Global Define -------------------------------*/
   2      =1  #ifndef MGR_ISP_H
   3      =1  #define MGR_ISP_H
   4      =1  
   5      =1  #include "mgr_comm.h"
   1      =2  #ifndef MGR_COMM_H
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 118 

           =2 #define MGR_COMM_H
           =2 
           =2 #include "compiler_defs.h"
           =2 #include "C8051F580_defs.h"
           =2 
           =2 /* ----- Global Define -------------------------------*/
           =2 /*
           =2 #define TW8836          0x00U
           =2 #define DESERIALIZE     0x01U
           =2 #define SERIALIZE       0x02U
           =2 */
           =2 #define  TW8836_SLAVE_ADDRESS   (U8)0x8A
           =2 #define  TW8836_ID_ADRESS           (U8)0x00
           =2 #define  TW8836_ID                              (U16)0x0036
           =2 
           =2 #define  INIT                           0x00U           // (MR) data byte received
           =2 #define  RX                                     0x01U           // (MR) data byte received
           =2 #define  TX                                     0x02U           // (MR) data byte received
           =2 
           =2 #define USE_MDPS11                              0x00U
           =2 #define USE_LANGUAGEINFO                0x01U
           =2 #define USE_HUTYPE                              0x02U
           =2 #define USE_GATEWAY                             0x03U
           =2 #define USE_NAVIONOFF                   0x04U
           =2 #define USE_G_SEL_DISP                  0x05U
           =2 #define USE_IGN_SW                              0x06U
           =2 #define USE_RVM_CAMERAOFF               0x07U
           =2 #define FCZC_RVM_SW                             0x08U
           =2 #define USE_4WDERR                              0x09U
           =2 #define USE_ENGVOL                              0x0AU
           =2 #define USE_CAN_COUNT                   0x0BU           
           =2 
           =2 #define TYPE_2WD                                0x00U
           =2 #define TYPE_4WD                                0x01U
           =2 
           =2 #define TYPE_ENGVOL20                   0x14U
           =2 #define TYPE_ENGVOL22                   0x16U
           =2 #define TYPE_ENGVOL33                   0x21U
           =2 /*----------------------------------------------------*/
           =2 
           =2 /* ----- Function ------------------------------------*/
           =2 void Init_CommTask(void);
           =2 void Operate_CommTask(void);
           =2 void Rx_Data_Process(void);
           =2 //void Comm_I2C_Tx_Data(void);
           =2 void Comm_I2C_Tx(U8 Slave_Addr,U8 Length,U16 Addr, U16 TData,U16 RData );
           =2 U16   Comm_I2C_Rx(U8 Slave_Addr,U8 Length,U16 Addr, U16 TData,U16 RData );
           =2 void Clear_I2C_Tx_Data(void);
           =2 void Clear_CAN_Tx_Data(void);
           =2 void Clear_Can_Data(void);
           =2 void Clear_Sas_Data(void);
           =2 
           =2 void Comm_RearView_Data(void);
           =2 void Comm_Tuning_Value_Type(U8 Type4WdErr, U8 TypeEngVol);
           =2 U8 Comm_Sas_Data(U8 *pa_Data);
           =2 U8 Comm_Hutype_Data(U8 *pa_Data);
           =2 U8 Comm_Language_Data(U8 *pa_Data);
           =2 U8 Comm_G_Sel_Disp_Data(U8 *Data);
           =2 U8 Comm_IGN_Sw_Data(U8 *Data);
           =2 U8 Comm_RVM_CameraOff_Data(U8 *Data);
           =2 U8 Comm_RVM_SW_Data(U8 *Data);
           =2 U8 Comm_ENG_Vol_Data(U8 *pa_Data);
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 119 

           =2 U8 Comm_4WD_Err_Data(U8 *pa_Data);
           =2 void Comm_Tx_RVM_View(U8 sigData);
           =2 void Comm_Tx_RVM_SW_IND(U8 sigData);
           =2 
           =2 void Flash_OneSpec_Write(void);
           =2 void Flash_OneSpec_Read(void);
           =2 void Comm_Error_Check(void);
           =2 
           =2 void IlPutTxRVM_View(U8 sigData);
           =2 
           =2 void IlPutTxRVM_SW_IND(U8 sigData);
           =2 /*----------------------------------------------------*/
           =2 
           =2 /* ----- Extern Function -----------------------------*/
           =2 /*----------------------------------------------------*/
           =2 
           =2 /* ----- Global Value --------------------------------*/
           =2 
           =2 typedef struct {
           =2         U8  Slave;
           =2         U8  Length;
           =2         U8  TRX_Flag;
           =2         U16 Addr;
           =2         U16 TxData;
           =2         U16 RxData;
           =2 }tMsg_I2C_Tx_Data_s;
           =2 
           =2 typedef struct {
           =2         U8  Slave;
           =2         U8  Length;
           =2         U8  TRX_Flag;
           =2         U16 Addr;
           =2         U16 TxData;
           =2         U16 RxData;
           =2 }tMsg_CAN_Tx_Data_s;
           =2 
           =2 typedef struct {
           =2         U8 Is_Change;
           =2         U8 Change_Count;
           =2         U8 Time_Out;
           =2         U8 Cur_Data;
           =2         U8 Mid_Data;
           =2         U8 Pre_Data;
           =2         U16 Chatter_Time;
           =2 }tMsg_CAN_Rx_Data_s;
           =2 
           =2 typedef struct {
           =2         U8  Is_Change;
           =2         U8  Pre_Sign;
           =2         U8  Angle;
           =2         U8  Angle_Pre_Sign;
           =2         U8  Time_Out;
           =2         U16 Pre_Data;
           =2         U8      Tuning_Type;
           =2 }tMsg_CAN_SAS_Data_s;
           =2 
           =2 typedef struct {
           =2         U8  Is_Change;
           =2         U8  Pre_Sign;
           =2         U8  Angle;
           =2         U16 Pre_Data;
           =2 }tMsg_CAN_State_s;
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 120 

           =2 
           =2 
           =2 /*
           =2 struct tCAN_Tx_Data_s {
           =2         U8 Flag;
           =2         U8 Dest;
           =2         U8 Length;
           =2         U8 *TxData;
           =2 }
           =2 
           =2 struct tCAN_Rx_Data_s {
           =2         U8 Flag;
           =2         U8 Src;
           =2         U8 Length;
           =2         U8 RxData;
           =2 }
           =2 */
           =2 /*----------------------------------------------------*/
           =2 
           =2 extern SEG_XDATA volatile tMsg_CAN_SAS_Data_s tCAN_Rx_SAS_Msg;
           =2 #endif
 147      =2  
   6      =1  
   7      =1  #define LOAD_COMMAND_SIZE                               (4)
   8      =1  #define CLEAR_COMMAND_SIZE                              (3)
   9      =1  
  10      =1  #define STEERING_ANGLE_LIMIT            (0x0028U)
  11      =1  
  12      =1  //G_SEL_DISP
  13      =1  #define GEAR_P                                          0x00U
  14      =1  #define GEAR_D                                          0x05U
  15      =1  #define GEAR_N                                          0x06U
  16      =1  #define GEAR_R                                          0x07U
  17      =1  #define GEAR_INVALID                            0x09U
  18      =1  #define GEAR_INTERMEDIATE                       0x0EU
  19      =1  
  20      =1  //IGN SW
  21      =1  #define IGN_SW_KEY_OFF                          0x00U
  22      =1  #define IGN_SW_ON                                       0x03U
  23      =1  
  24      =1  //RVM CameraOff
  25      =1  #define RVM_CAMERA_DEFAULT                      0x00U
  26      =1  #define RVM_CAMERA_OFF                          0x01U
  27      =1  #define RVM_CAMERA_INVALID                      0x03U
  28      =1  
  29      =1  //FCZC RVM SW
  30      =1  #define FCZC_RVM_SW_OFF                         0x00U
  31      =1  #define FCZC_RVM_SW_ON                          0x01U
  32      =1  
  33      =1  //RVM VIEW
  34      =1  #define RVM_VIEW_OFF                            0x00U
  35      =1  #define RVM_PARKING_ASSIST_VIEW         0x01U
  36      =1  #define RVM_DRIVING_ASSIST_VIEW         0x02U
  37      =1  #define RVM_VIEW_INVALID                        0x0FU
  38      =1  
  39      =1  //RVM SW IND
  40      =1  #define RVM_SW_IND_OFF                          0x00U
  41      =1  #define RVM_SW_IND_ON                           0x01U
  42      =1  #define RVM_SW_IND_INVALID                      0x03U
  43      =1  
  44      =1  #define NORMAL_3M_GUIDE_LINE_ADDR               (0x0001)
  45      =1  
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 121 

  46      =1  //RVM CONFIG
  47      =1  #define          CMD_PARKING_CONFIG                     (0x0000U)
  48      =1  #define          CMD_DRIVING_CONFIG                     (0x0001U)
  49      =1  
  50      =1  #define         CHECKING_LAYER_DATA                     (0x4F08U)
  51      =1  #define         CHECKING_LAYER0_DATA            (0x4F0AU)
  52      =1  #define         CHECKING_LAYER1_DATA            (0x4F0CU)
  53      =1  #define         CHECKING_LAYER2_DATA            (0x4F0EU)
  54      =1  
  55      =1  #define         CMD_PARAM_POOL_0_ADDR           (0xFC00U)
  56      =1  #define         CMD_PARAM_POOL_1_ADDR           (0xFC01U)
  57      =1  #define         CMD_PARAM_POOL_2_ADDR           (0xFC02U)
  58      =1  #define         CMD_PARAM_POOL_3_ADDR           (0xFC03U)
  59      =1  #define         CMD_PARAM_POOL_4_ADDR           (0xFC04U)
  60      =1  #define         CMD_PARAM_POOL_5_ADDR           (0xFC04U)
  61      =1  #define         CMD_PARAM_POOL_6_ADDR           (0xFC06U)
  62      =1  #define         CMD_PARAM_POOL_7_ADDR           (0xFC07U)
  63      =1  #define         CMD_PARAM_POOL_8_ADDR           (0xFC08U)
  64      =1  
  65      =1  #define         CMD_REGISTER_ADDR                       (0x0040U)
  66      =1  
  67      =1  #define         CMD_SET_STATE                           (0x8100U)
  68      =1  #define         CMD_GET_STATE                           (0x8101U)
  69      =1  
  70      =1  #define         CMD_OVRL_LOAD_BUFFER            (0x8206U)
  71      =1  #define         CMD_OVRL_LOAD_STATUS            (0x8207U)
  72      =1  
  73      =1  #define         OVRL_ENABLE_DATA                        (0x0100U)
  74      =1  #define         OVRL_DISABLE_DATA                       (0x0000U)
  75      =1  
  76      =1  #define         OVR_LAYER0_DATA                         (0x0000U)
  77      =1  #define         OVR_LAYER1_DATA                         (0x0100U)
  78      =1  #define         OVR_LAYER2_DATA                         (0x0200U)
  79      =1  #define         OVR_LAYER3_DATA                         (0x0300U)
  80      =1  
  81      =1  #define         BUFFER0_LAYER0_DATA                     (0x0000U)
  82      =1  #define         BUFFER1_LAYER0_DATA                     (0x0100U)
  83      =1  #define         BUFFER2_LAYER0_DATA                     (0x0200U)
  84      =1  #define         BUFFER3_LAYER0_DATA                     (0x0300U)
  85      =1  #define         BUFFER4_LAYER0_DATA                     (0x0400U)
  86      =1  #define         BUFFER5_LAYER0_DATA                     (0x0500U)
  87      =1  #define         BUFFER6_LAYER0_DATA                     (0x0600U)
  88      =1  
  89      =1  #define         BUFFER0_LAYER1_DATA                     (0x0001U)
  90      =1  #define         BUFFER1_LAYER1_DATA                     (0x0101U)
  91      =1  #define         BUFFER2_LAYER1_DATA                     (0x0201U)
  92      =1  #define         BUFFER3_LAYER1_DATA                     (0x0301U)
  93      =1  #define         BUFFER4_LAYER1_DATA                     (0x0401U)
  94      =1  #define         BUFFER5_LAYER1_DATA                     (0x0501U)
  95      =1  #define         BUFFER6_LAYER1_DATA                     (0x0601U)
  96      =1  
  97      =1  #define         BUFFER0_LAYER2_DATA                     (0x0002U)
  98      =1  #define         BUFFER1_LAYER2_DATA                     (0x0102U)
  99      =1  #define         BUFFER2_LAYER2_DATA                     (0x0202U)
 100      =1  #define         BUFFER3_LAYER2_DATA                     (0x0302U)
 101      =1  #define         BUFFER4_LAYER2_DATA                     (0x0402U)
 102      =1  #define         BUFFER5_LAYER2_DATA                     (0x0502U)
 103      =1  #define         BUFFER6_LAYER2_DATA                     (0x0602U)
 104      =1  
 105      =1  #define         BUFFER0_LAYER3_DATA                     (0x0003U)
 106      =1  #define         BUFFER1_LAYER3_DATA                     (0x0103U)
 107      =1  #define         BUFFER2_LAYER3_DATA                     (0x0203U)
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 122 

 108      =1  #define         BUFFER3_LAYER3_DATA                     (0x0303U)
 109      =1  #define         BUFFER4_LAYER3_DATA                     (0x0403U)
 110      =1  #define         BUFFER5_LAYER3_DATA                     (0x0503U)
 111      =1  #define         BUFFER6_LAYER3_DATA                     (0x0603U)
 112      =1  
 113      =1  #define         EXTRA_BUFFER0_DATA                      (BUFFER0_LAYER0_DATA)
 114      =1  #define         EXTRA_BUFFER1_DATA                      (BUFFER1_LAYER0_DATA)
 115      =1  #define         EXTRA_BUFFER2_DATA                      (BUFFER2_LAYER0_DATA)
 116      =1  #define         EXTRA_BUFFER3_DATA                      (BUFFER3_LAYER0_DATA)
 117      =1  #define         EXTRA_BUFFER4_DATA                      (BUFFER4_LAYER0_DATA)
 118      =1  #define         EXTRA_BUFFER5_DATA                      (BUFFER5_LAYER0_DATA)
 119      =1  #define         EXTRA_BUFFER6_DATA                      (BUFFER6_LAYER0_DATA)
 120      =1  
 121      =1  #define         WARNING_BUFFER0_DATA            (BUFFER0_LAYER1_DATA)
 122      =1  #define         WARNING_BUFFER1_DATA            (BUFFER1_LAYER1_DATA)
 123      =1  #define         WARNING_BUFFER2_DATA            (BUFFER2_LAYER1_DATA)
 124      =1  #define         WARNING_BUFFER3_DATA            (BUFFER3_LAYER1_DATA)
 125      =1  #define         WARNING_BUFFER4_DATA            (BUFFER4_LAYER1_DATA)
 126      =1  #define         WARNING_BUFFER5_DATA            (BUFFER5_LAYER1_DATA)
 127      =1  #define         WARNING_BUFFER6_DATA            (BUFFER6_LAYER1_DATA)
 128      =1  
 129      =1  #define         GUIDELINE_BUFFER0_DATA          (BUFFER0_LAYER2_DATA)
 130      =1  #define         GUIDELINE_BUFFER1_DATA          (BUFFER1_LAYER2_DATA)
 131      =1  #define         GUIDELINE_BUFFER2_DATA          (BUFFER2_LAYER2_DATA)
 132      =1  #define         GUIDELINE_BUFFER3_DATA          (BUFFER3_LAYER2_DATA)
 133      =1  #define         GUIDELINE_BUFFER4_DATA          (BUFFER4_LAYER2_DATA)
 134      =1  #define         GUIDELINE_BUFFER5_DATA          (BUFFER5_LAYER2_DATA)
 135      =1  #define         GUIDELINE_BUFFER6_DATA          (BUFFER6_LAYER2_DATA)
 136      =1  
 137      =1  #define         FIXED_GUIDELINE_BUFFER0_DATA            (BUFFER0_LAYER3_DATA)
 138      =1  #define         FIXED_GUIDELINE_BUFFER1_DATA            (BUFFER1_LAYER3_DATA)
 139      =1  #define         FIXED_GUIDELINE_BUFFER2_DATA            (BUFFER2_LAYER3_DATA)
 140      =1  #define         FIXED_GUIDELINE_BUFFER3_DATA            (BUFFER3_LAYER3_DATA)
 141      =1  #define         FIXED_GUIDELINE_BUFFER4_DATA            (BUFFER4_LAYER3_DATA)
 142      =1  #define         FIXED_GUIDELINE_BUFFER5_DATA            (BUFFER5_LAYER3_DATA)
 143      =1  #define         FIXED_GUIDELINE_BUFFER6_DATA            (BUFFER6_LAYER3_DATA)
 144      =1  
 145      =1  // Language Address in Flash
 146      =1  #define         MEM_FIXED_GUIDE_ADDR                    (0x0074U)       // 0x006DU 0x0048U
 147      =1  #define         MEM_FIXED_GUIDE_ADDR_D                  (0x0075U)
 148      =1  #define         MEM_BLACK_IMAGE_ADDR                    (0x0076U)
 149      =1  #define         MEM_LAN_START_ADDR                              (0x0053U)       // 0x004CU 0x0048U
 150      =1  #define         MEM_LAN_INVALID_ADDR                    (0x0072U)       // 0x006CU
 151      =1  #define         CAN_LAN_OFF_ADDR                                (0x0000U)
 152      =1  #define         CAN_LAN_INVALID_ADDR                    (0x001FU)
 153      =1  
 154      =1  #define AP0100_SENSOR_X_OFFSET  0xc8A8U
 155      =1  #define AP0100_SENSOR_Y_OFFSET  0xc8A9U
 156      =1  
 157      =1  #define ASX344_SENSOR_X_OFFSET  0xc860U
 158      =1  #define ASX344_SENSOR_Y_OFFSET  0xc861U
 159      =1  
 160      =1  #define AP0100_FRAME_COUNT_REGISTER             0x8006U
 161      =1  #define ASX344_FRAME_COUNT_REGISTER             0x8004U
 162      =1  
 163      =1  #define SENSOR_INIT                                             0x01U
 164      =1  #define SENSOR_RUNNING                                  0x02U
 165      =1  #define SENSOR_STATE_STREAMING                  0x3100U
 166      =1  
 167      =1  /*----------------------------------------------------*/
 168      =1  /* ----- Function ------------------------------------*/
 169      =1  void    Init_IspTask(void);
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 123 

 170      =1  void    ui_event_process(void);
 171      =1  void    steering_angle_display_guide_line(S8 display_flag);
 172      =1  void Sensor_XY_Offset_set(U8 x, U8 y );
 173      =1  U8              CheckCommandStatusLoop(void);
 174      =1  
 175      =1  void Init_IspTask(void);
 176      =1  void Isp_InterInit(void);
 177      =1  void Operate_IspTask(void);
 178      =1  void Isp_Parking_Assist_View(void);
 179      =1  void Isp_Driving_Assist_View(void);
 180      =1  void Isp_View_Mode_Change(volatile U8 ViewMode);
 181      =1  void Isp_Off(void);
 182      =1  void Isp_On(void);
 183      =1  
 184      =1  void Fixed_Guidline_On(const U8 ViewMode);
 185      =1  void Fixed_Guidline_Off(void);
 186      =1  void Guidline_On(void);
 187      =1  void Guidline_Off(void);
 188      =1  void isp_guide_on_off(U8 Guide_On_Off);
 189      =1  void V_STB_Check(void);
 190      =1  void Video_Signal_Check(void);
 191      =1  void Frame_Count_Check(void);
 192      =1  void Frame_Valide_Check(void);
 193      =1  void Check_Isp_InitState(void);
 194      =1  /*--------------------*/
 195      =1  
 196      =1  /* ----- Global Value --------------------------------*/
 197      =1  
 198      =1  /*----------------------------------------------------*/
 199      =1  typedef struct {
 200      =1          U8 IGNSw;
 201      =1          U8 Pre_Gear;
 202      =1          U8 Cur_Gear;
 203      =1          U8 Pre_RVM_CamOff;
 204      =1          U8 Cur_RVM_CamOff;
 205      =1          U8 Pre_RVM_SW;
 206      =1          U8 Cur_RVM_SW;
 207      =1          U8 Pre_SW_IND;
 208      =1          U8 Cur_SW_IND;
 209      =1          U8 Pre_ViewMode;
 210      =1          U8 Cur_ViewMode;
 211      =1          U8 RVM_SW_Status;
 212      =1  }tMsg_ISP_Function;
 213      =1  
 214      =1  /* ----- Extern Function -----------------------------*/
 215      =1  extern SEG_XDATA volatile tMsg_CAN_SAS_Data_s tCAN_Rx_SAS_Msg;
 216      =1  extern SEG_XDATA volatile tMsg_CAN_Rx_Data_s tCAN_Rx_Msg[USE_CAN_COUNT];
 217      =1  extern SEG_XDATA volatile U8 g_I2C_Err_Cnt;  // Counter for the number of errors.
 218      =1  extern SEG_XDATA volatile tMsg_ISP_Function tISP_Func_Msg;
 219      =1  /*----------------------------------------------------*/
 220      =1  
 221      =1  #endif
 222      =1  
 223      =1  
  15          #include "mgr_comm.h"
   1      =1  #ifndef MGR_COMM_H
           =1 #define MGR_COMM_H
           =1 
           =1 #include "compiler_defs.h"
           =1 #include "C8051F580_defs.h"
           =1 
           =1 /* ----- Global Define -------------------------------*/
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 124 

           =1 /*
           =1 #define TW8836          0x00U
           =1 #define DESERIALIZE     0x01U
           =1 #define SERIALIZE       0x02U
           =1 */
           =1 #define  TW8836_SLAVE_ADDRESS   (U8)0x8A
           =1 #define  TW8836_ID_ADRESS           (U8)0x00
           =1 #define  TW8836_ID                              (U16)0x0036
           =1 
           =1 #define  INIT                           0x00U           // (MR) data byte received
           =1 #define  RX                                     0x01U           // (MR) data byte received
           =1 #define  TX                                     0x02U           // (MR) data byte received
           =1 
           =1 #define USE_MDPS11                              0x00U
           =1 #define USE_LANGUAGEINFO                0x01U
           =1 #define USE_HUTYPE                              0x02U
           =1 #define USE_GATEWAY                             0x03U
           =1 #define USE_NAVIONOFF                   0x04U
           =1 #define USE_G_SEL_DISP                  0x05U
           =1 #define USE_IGN_SW                              0x06U
           =1 #define USE_RVM_CAMERAOFF               0x07U
           =1 #define FCZC_RVM_SW                             0x08U
           =1 #define USE_4WDERR                              0x09U
           =1 #define USE_ENGVOL                              0x0AU
           =1 #define USE_CAN_COUNT                   0x0BU           
           =1 
           =1 #define TYPE_2WD                                0x00U
           =1 #define TYPE_4WD                                0x01U
           =1 
           =1 #define TYPE_ENGVOL20                   0x14U
           =1 #define TYPE_ENGVOL22                   0x16U
           =1 #define TYPE_ENGVOL33                   0x21U
           =1 /*----------------------------------------------------*/
           =1 
           =1 /* ----- Function ------------------------------------*/
           =1 void Init_CommTask(void);
           =1 void Operate_CommTask(void);
           =1 void Rx_Data_Process(void);
           =1 //void Comm_I2C_Tx_Data(void);
           =1 void Comm_I2C_Tx(U8 Slave_Addr,U8 Length,U16 Addr, U16 TData,U16 RData );
           =1 U16   Comm_I2C_Rx(U8 Slave_Addr,U8 Length,U16 Addr, U16 TData,U16 RData );
           =1 void Clear_I2C_Tx_Data(void);
           =1 void Clear_CAN_Tx_Data(void);
           =1 void Clear_Can_Data(void);
           =1 void Clear_Sas_Data(void);
           =1 
           =1 void Comm_RearView_Data(void);
           =1 void Comm_Tuning_Value_Type(U8 Type4WdErr, U8 TypeEngVol);
           =1 U8 Comm_Sas_Data(U8 *pa_Data);
           =1 U8 Comm_Hutype_Data(U8 *pa_Data);
           =1 U8 Comm_Language_Data(U8 *pa_Data);
           =1 U8 Comm_G_Sel_Disp_Data(U8 *Data);
           =1 U8 Comm_IGN_Sw_Data(U8 *Data);
           =1 U8 Comm_RVM_CameraOff_Data(U8 *Data);
           =1 U8 Comm_RVM_SW_Data(U8 *Data);
           =1 U8 Comm_ENG_Vol_Data(U8 *pa_Data);
           =1 U8 Comm_4WD_Err_Data(U8 *pa_Data);
           =1 void Comm_Tx_RVM_View(U8 sigData);
           =1 void Comm_Tx_RVM_SW_IND(U8 sigData);
           =1 
           =1 void Flash_OneSpec_Write(void);
           =1 void Flash_OneSpec_Read(void);
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 125 

           =1 void Comm_Error_Check(void);
           =1 
           =1 void IlPutTxRVM_View(U8 sigData);
           =1 
           =1 void IlPutTxRVM_SW_IND(U8 sigData);
           =1 /*----------------------------------------------------*/
           =1 
           =1 /* ----- Extern Function -----------------------------*/
           =1 /*----------------------------------------------------*/
           =1 
           =1 /* ----- Global Value --------------------------------*/
           =1 
           =1 typedef struct {
           =1         U8  Slave;
           =1         U8  Length;
           =1         U8  TRX_Flag;
           =1         U16 Addr;
           =1         U16 TxData;
           =1         U16 RxData;
           =1 }tMsg_I2C_Tx_Data_s;
           =1 
           =1 typedef struct {
           =1         U8  Slave;
           =1         U8  Length;
           =1         U8  TRX_Flag;
           =1         U16 Addr;
           =1         U16 TxData;
           =1         U16 RxData;
           =1 }tMsg_CAN_Tx_Data_s;
           =1 
           =1 typedef struct {
           =1         U8 Is_Change;
           =1         U8 Change_Count;
           =1         U8 Time_Out;
           =1         U8 Cur_Data;
           =1         U8 Mid_Data;
           =1         U8 Pre_Data;
           =1         U16 Chatter_Time;
           =1 }tMsg_CAN_Rx_Data_s;
           =1 
           =1 typedef struct {
           =1         U8  Is_Change;
           =1         U8  Pre_Sign;
           =1         U8  Angle;
           =1         U8  Angle_Pre_Sign;
           =1         U8  Time_Out;
           =1         U16 Pre_Data;
           =1         U8      Tuning_Type;
           =1 }tMsg_CAN_SAS_Data_s;
           =1 
           =1 typedef struct {
           =1         U8  Is_Change;
           =1         U8  Pre_Sign;
           =1         U8  Angle;
           =1         U16 Pre_Data;
           =1 }tMsg_CAN_State_s;
           =1 
           =1 
           =1 /*
           =1 struct tCAN_Tx_Data_s {
           =1         U8 Flag;
           =1         U8 Dest;
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 126 

           =1         U8 Length;
           =1         U8 *TxData;
           =1 }
           =1 
           =1 struct tCAN_Rx_Data_s {
           =1         U8 Flag;
           =1         U8 Src;
           =1         U8 Length;
           =1         U8 RxData;
           =1 }
           =1 */
           =1 /*----------------------------------------------------*/
           =1 
           =1 extern SEG_XDATA volatile tMsg_CAN_SAS_Data_s tCAN_Rx_SAS_Msg;
           =1 #endif
 147      =1  
  16          #include "mgr_mcu.h"
   1      =1  
   2      =1  /* ----- Global Define -------------------------------*/
   3      =1  
   4      =1  #define DTC                                                             (U8)0x01
   5      =1  #define ONESPEC                                                 (U8)0x02
   6      =1  
   7      =1  /*----------------------------------------------------*/
   8      =1  
   9      =1  /* ----- Function ------------------------------------*/
  10      =1  void Init_McuTask(void);
  11      =1  void Reset_Mcu(void);
  12      =1  void Operate_McuTask(void);
  13      =1  void Mcu_StandBy(U8 *pError);
  14      =1  void Mcu_InterInit(U8 *pError);
  15      =1  void Mcu_Idle(U8 *pError);
  16      =1  void Mcu_Running(U8 *pError);
  17      =1  U8 Get_Dser_Vs_Status(void);
  18      =1  
  19      =1  /*----------------------------------------------------*/
  20      =1  
  21      =1  /* ----- Extern Function -----------------------------*/
  22      =1  //extern U16 i2c_master_read(U8 slave_addr, U16 addr);
  23      =1  /*----------------------------------------------------*/
  24      =1  
  25      =1  /* ----- Global Value --------------------------------*/
  26      =1  /*----------------------------------------------------*/
  27      =1  
  28      =1  
  29      =1  
  17          #include "string.h"
   1      =1  /*--------------------------------------------------------------------------
   2      =1  STRING.H
   3      =1  
   4      =1  String functions.
   5      =1  Copyright (c) 1988-2014 Keil Elektronik GmbH and Keil Software, Inc.
   6      =1  All rights reserved.
   7      =1  --------------------------------------------------------------------------*/
   8      =1  
   9      =1  #ifndef __STRING_H__
  10      =1  #define __STRING_H__
  11      =1  
  12      =1  #ifndef _SIZE_T
  13      =1   #define _SIZE_T
  14      =1   typedef unsigned int size_t;
  15      =1  #endif
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 127 

  16      =1  
  17      =1  #ifndef NULL
  18      =1   #define NULL ((void *) 0L)
  19      =1  #endif
  20      =1  
  21      =1  #pragma SAVE
  22      =1  #pragma REGPARMS
  23      =1  extern char  *strcat  (char *s1, const char *s2);
  24      =1  extern char  *strncat (char *s1, const char *s2, size_t n);
  25      =1  
  26      =1  extern char   strcmp  (const char *s1, const char *s2);
  27      =1  extern char   strncmp (const char *s1, const char *s2, size_t n);
  28      =1  
  29      =1  extern char  *strcpy  (char *s1, const char *s2);
  30      =1  extern char  *strncpy (char *s1, const char *s2, size_t n);
  31      =1  
  32      =1  extern size_t strlen  (const char *);
  33      =1  
  34      =1  extern char  *strchr  (const char *s, char c);
  35      =1  extern int    strpos  (const char *s, char c);
  36      =1  extern char  *strrchr (const char *s, char c);
  37      =1  extern int    strrpos (const char *s, char c);
  38      =1  
  39      =1  extern size_t strspn  (const char *s, const char *set);
  40      =1  extern size_t strcspn (const char *s, const char *set);
  41      =1  extern char  *strpbrk (const char *s, const char *set);
  42      =1  extern char  *strrpbrk(const char *s, const char *set);
  43      =1  extern char  *strstr  (const char *s, const char *sub);
  44      =1  extern char  *strtok  (char *str, const char *set);
  45      =1  
  46      =1  extern char   memcmp  (const void *s1, const void *s2, size_t n);
  47      =1  extern void  *memcpy  (void *s1, const void *s2, size_t n);
  48      =1  extern void  *memchr  (const void *s, char val, size_t n);
  49      =1  extern void  *memccpy (void *s1, const void *s2, char val, size_t n);
  50      =1  extern void  *memmove (void *s1, const void *s2, size_t n);
  51      =1  extern void  *memset  (void *s, char val, size_t n);
  52      =1  #pragma RESTORE
  53      =1  
  54      =1  #endif
  18          
  19          #include "desc.h"
   1      =1  /* -----------------------------------------------------------------------------
   2      =1    Filename:    desc.h
   3      =1    Description: Interface of CANdesc visible to any application.
   4      =1                  
   5      =1                  Manufacturer: HMC
   6      =1                  EcuDocFile:   Y:\20150826_MOBIS_CAMERA_DE_AddRoutineIds.cdd
   7      =1                  Variant:      CommonDiagnostics
   8      =1  
   9      =1    Generated by CANdelaGen, Mon Oct 19 18:50:07 2015
  10      =1   
  11      =1   ----------------------------------------------------------------------------- */
  12      =1  /* -----------------------------------------------------------------------------
  13      =1    C O P Y R I G H T
  14      =1   -------------------------------------------------------------------------------
  15      =1    Copyright (c) 2001-2013 by Vector Informatik GmbH. All rights reserved.
  16      =1   
  17      =1    This software is copyright protected and proprietary to Vector Informatik 
  18      =1    GmbH.
  19      =1    
  20      =1    Vector Informatik GmbH grants to you only those rights as set out in the 
  21      =1    license conditions.
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 128 

  22      =1    
  23      =1    All other rights remain with Vector Informatik GmbH.
  24      =1   -------------------------------------------------------------------------------
  25      =1   ----------------------------------------------------------------------------- */
  26      =1  
  27      =1  #if !defined(__DESC_H__)
  28      =1  #define __DESC_H__
  29      =1  
  30      =1  /* -----------------------------------------------------------------------------
  31      =1      &&&~ History
  32      =1   ----------------------------------------------------------------------------- */
  33      =1  
  34      =1  /* 
  35      =1  ----------------------------------------------------------------------------------------------------------
             ---------------
  36      =1                                               A U T H O R   I D E N T I T Y                                
             -              
  37      =1  ----------------------------------------------------------------------------------------------------------
             ---------------
  38      =1  Initials   Name                  Company                                                                  
             -              
  39      =1  ---------- --------------------- -------------------------------------------------------------------------
             ---------------
  40      =1  Ktw        Katrin Thurow         Vector Informatik GmbH                                                   
             -              
  41      =1  Mhe        Matthias Heil         Vector Informatik GmbH                                                   
             -              
  42      =1  Sa         Mishel Shishmanyan    Vector Informatik GmbH                                                   
             -              
  43      =1  ----------------------------------------------------------------------------------------------------------
             ---------------
  44      =1                                              R E V I S I O N   H I S T O R Y                               
             -              
  45      =1  ----------------------------------------------------------------------------------------------------------
             ---------------
  46      =1  Date       Version  Author Modification type Issue Id      Affects                        Description     
             -               
  47      =1  ---------- -------- ------ ----------------- ------------- ------------------------------ ----------------
             ----------------
  48      =1  2009-01-11  6.01.00
  49      =1                      Ktw    Added             ESCAN00032908 HMC(UDS)                       Support HMC     
             -               
  50      =1                      Ktw    Modified          ESCAN00040135 All                            CanChannelIdenti
             -tyAssignment is generated in RAM section
  51      =1  2010-03-18  6.02.00
  52      =1                      Ktw    Fixed             ESCAN00041708 UDS                            Wrong minimum le
             -ngth calculation for services without sub-function
  53      =1                      Ktw    Fixed             ESCAN00041576 All                            Compiler warning
             - for constant expression in DescDispatcher
  54      =1  2010-05-07  6.03.00
  55      =1                      Ktw    Fixed             ESCAN00042963 All                            DescCopyToCan AP
             -I does not support CAN message buffers located in the gpage
  56      =1  2010-26-07  6.03.01
  57      =1                      Ktw    Fixed             ESCAN00043240 UDS                            Compiler error f
             -or missing data types DescDynDidMemBlockAddress and DescDynDidMemBlockSize
  58      =1                      Ktw    Fixed             ESCAN00044050 All                            Compiler warning
             -: condition is always false
  59      =1                      Ktw    Fixed             ESCAN00044118 All                            CANdesc task per
             -iod not changeable
  60      =1                      Ktw    Fixed             ESCAN00043273 All                            Unexpected gener
             -ation error occurs
  61      =1                      Ktw    Fixed             ESCAN00044197 All                            Not all buffers 
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 129 

             -used in DANIS can be located in far RAM
  62      =1  2010-08-16  6.04.00
  63      =1                      Ktw    Fixed             ESCAN00044528 All                            Compile errors i
             -n DanisIsoTp communication adapter
  64      =1                      Ktw    Fixed             ESCAN00044371 All                            v_inc.h is not i
             -ncluded in the generated DANIS adapter template
  65      =1  2011-01-11  6.05.00
  66      =1                      Ktw    Fixed             ESCAN00045932 All                            Compile error on
             - each usage of DescInterruptDisable/-Restore internal API
  67      =1                      Ktw    Fixed             ESCAN00047741 All                            Adapt CANdesc TM
             -S320 support for GENy enabled CANdriver
  68      =1                      Ktw    Fixed             ESCAN00047355 All                            Memory mapping o
             -f FAR buffer support use incomplete description for paged memory µC
  69      =1                      Ktw    Fixed             ESCAN00046410 All                            After ECU reset 
             -the diagnostic response is not transmitted after the function DescSendPosRespFBL has been called
  70      =1  2011-04-11  6.06.00
  71      =1                      Mhe    Modified          ESCAN00043238 UDS                            Communication Co
             -ntrol will not compile with communication  parameters that have a certain value
  72      =1                      Ktw    Fixed             ESCAN00050894 UDS                            Service 0x2C 0x0
             -2 with invalid ALFID leads to positive response without appending new items to the DynDID
  73      =1                      Ktw    Fixed             ESCAN00049396 UDS                            No positive resp
             -onse sent if SPRMIB=TRUE and API DescForceRcrRpResponse is used
  74      =1                      Ktw    Fixed             ESCAN00049396 UDS                            CANdesc does not
             - reject requested service 0x2C 0x02 with ALFID==0x00
  75      =1                      Mhe    Modified          ESCAN00036927 All                            Allow parallel O
             -BD support if only the TPMC DANIS adapter is available
  76      =1                      Mhe    Added             ESCAN00044127 All                            Support for DANI
             -S adapter specific available buffer size information to the application
  77      =1                      Mhe    Added             ESCAN00048157 All                            Add Danis adapte
             -r for LinTp    
  78      =1                      Ktw    Fixed             ESCAN00048636 All                            Error message re
             -ferences non-existent file 'ApplDesc.h'
  79      =1  2011-08-12  6.07.00
  80      =1                      Ktw    Fixed             ESCAN00051088 UDS                            Service 0x2A 0x0
             -4 ends up with endless RCR-RP responses on asynchronously read periodic DIDs
  81      =1                      Ktw    Modified          ESCAN00051315 All                            API DescGetCurre
             -ntBusInfo should be usable for periodic transmission
  82      =1                      Ktw    Added             ESCAN00052870 All                            Support Multiple
             - Addressing (combination Normal and Extended Addressing)
  83      =1  2011-09-01  6.07.01
  84      =1                      Ktw    Fixed             ESCAN00053205 All                            Wrong function i
             -s called to get addressing type
  85      =1  2011-09-06  6.08.00
  86      =1                      -      -                 -             -                              No relevant chan
             -ges available in this version.
  87      =1  2011-09-24  6.08.01
  88      =1                      Ktw    Fixed             ESCAN00053847 All                            No response is s
             -ent to a physical request
  89      =1                      Ktw    Fixed             ESCAN00053042 All                            CANdesc sends UU
             -DT responses with CAN IDs from other identities
  90      =1  2011-10-04  6.08.02
  91      =1                      Ktw    Fixed             ESCAN00054014 HMC(UDS)                       Generator crash:
             - Service 0x2a activated and no UUDT messages
  92      =1                      Ktw    Added             ESCAN00054105 All                            Move some config
             -uration defines of Service 0x2c and 0x2a to the header file
  93      =1  2011-10-25  6.09.00
  94      =1                      Ktw    Added             ESCAN00055161 HMC(UDS)                       Support HMC spec
             -ification ES96590
  95      =1                      Ktw    Added             ESCAN00055172 UDS                            Support means fo
             -r spontaneous responses
  96      =1  2011-12-09  6.10.00
  97      =1                      Ktw    Fixed             ESCAN00055009 UDS                            Already schedule
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 130 

             -d Did is denied as not supported
  98      =1  2011-12-29  6.10.01
  99      =1                      -      -                 -             -                              No relevant chan
             -ges available in this version.
 100      =1  2012-01-13  6.10.02
 101      =1                      Ktw    Fixed             ESCAN00055791 UDS                            Not possible to 
             -switch of  functional addressing for Service 0x2c
 102      =1  2012-02-09  6.10.03
 103      =1                      -      -                 -             -                              No relevant chan
             -ges available in this version.
 104      =1  2012-02-23  6.11.00
 105      =1                      Ktw    Fixed             ESCAN00057448 HMC(UDS)                       Not possible to 
             -configure a value for start on delay
 106      =1                      Ktw    Added             ESCAN00057614 All                            Better error mes
             -sage if an Oem is not supported by CANdesc but supported in the datamodel
 107      =1  2012-04-18  6.11.01
 108      =1                      -      -                 -             -                              No relevant chan
             -ges available in this version.
 109      =1  2012-07-02  6.11.02
 110      =1                      Ktw    Fixed             ESCAN00059114 HMC(UDS)                       Service 0x2a: no
             -t possible to add Pids to scheduler first with a functional and then with a physical request
 111      =1  2012-07-27  6.12.00
 112      =1                      -      -                 -             -                              No relevant chan
             -ges available in this version.
 113      =1  2012-10-27  6.12.01
 114      =1                      Ktw    Modified          ESCAN00062366 All                            CANDesc on multi
             -ple channels: Support more than 4 channels 
 115      =1  2012-11-12  6.13.00
 116      =1                      Ktw    Fixed             ESCAN00062765 HMC(UDS)                       Service 0x29: Ot
             -her NRC than 0x22 is sent
 117      =1                      Ktw    Fixed             ESCAN00062764 HMC(UDS)                       Service 0x29/0x2
             -8 0x02: No negative response is sent
 118      =1                      Ktw    Modified          ESCAN00065354 UDS                            Send a pending r
             -esponse for a request with SPRMIB and ring buffer usage for the response
 119      =1  2013-06-04  6.14.00
 120      =1                      -      -                 -             -                              No relevant chan
             -ges available in this version.
 121      =1  2013-09-05  6.14.01
 122      =1                      Sa     Fixed             ESCAN00070242 UDS                            Unexpected behav
             -ior executing service 0x2A 0x04 with concrete PDID(s)
 123      =1  ----------------------------------------------------------------------------------------------------------
             ---------------
 124      =1   */
 125      =1  
 126      =1  
 127      =1  /* -----------------------------------------------------------------------------
 128      =1      &&&~ Includes
 129      =1   ----------------------------------------------------------------------------- */
 130      =1  
 131      =1  /* include of TP interface */
 132      =1  #include "tpmc.h"
   1      =2  /* STARTSINGLE_OF_MULTIPLE */
   2      =2  /*******************************************************************************
   3      =2  | Project Name: Tp_Iso15765
   4      =2  |               OSEK single-/multiconnection transport layer
   5      =2  |    File Name: tpmc.h
   6      =2  |
   7      =2  |  Description: This version supports the specification for 
   8      =2  |               the ISO 15765-2 transport protocol
   9      =2  |
  10      =2  |-------------------------------------------------------------------------------
  11      =2  |               C O P Y R I G H T
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 131 

  12      =2  |-------------------------------------------------------------------------------
  13      =2  | Copyright (c) 2000-2013 Vector Informatik GmbH            All rights reserved.
  14      =2  |
  15      =2  |     This software is copyright protected and proprietary 
  16      =2  |     to Vector Informatik GmbH. Vector Informatik GmbH 
  17      =2  |     grants to you only those rights as set out in the 
  18      =2  |     license conditions. All other rights remain with 
  19      =2  |     Vector Informatik GmbH.
  20      =2  |
  21      =2  |     REMOVAL OF THESE COMMENTS IS A VIOLATION OF THE LICENSE AGREEMENT.
  22      =2  |
  23      =2  |-------------------------------------------------------------------------------
  24      =2  |               A U T H O R   I D E N T I T Y
  25      =2  |-------------------------------------------------------------------------------
  26      =2  | Initials     Name                      Company
  27      =2  | --------     ---------------------     ---------------------------------------
  28      =2  | Gz           Oliver Garnatz            Vector Informatik GmbH
  29      =2  | Js           Bernd Jesse               Vector Informatik GmbH
  30      =2  | Ap           Andreas Pick              Vector Informatik GmbH
  31      =2  | Her          Peter Herrmann            Vector Informatik GmbH
  32      =2  | EJW          Eric J. Winder            Vector CANtech, Inc.
  33      =2  | Dth          Thomas Dedler             Vector Informatik GmbH
  34      =2  |-------------------------------------------------------------------------------
  35      =2  |               R E V I S I O N   H I S T O R Y
  36      =2  |-------------------------------------------------------------------------------
  37      =2  | Date         Ver   Author  Description
  38      =2  | ---------    ----  ------  ---------------------------------------------------
  39      =2  | 16-Jun-00    2.00    Gz    Creation
  40      =2  | 26-Jul-00    2.01    Gz    Compatibility for DBKOMGen (files needed: tp_mch.h & tpmc.cfg)
  41      =2  | 31-Jul-00    2.02    Gz    Old Switches deleted/renamed
  42      =2  | 31-Aug-00    2.03    Gz    support of normal_addressing including dynamic_ids
  43      =2  | 12-Oct-00    2.05    Gz    support of normal_fixed_addressing (ext.ID) format
  44      =2  |                            added Channel-Lock
  45      =2  |                            added Reception Break while sending Wait-Frame 
  46      =2  |                            added BugFix Version
  47      =2  |                            added more Assertions
  48      =2  |                            added indicated CAN-Driver support
  49      =2  |                            added/modified some API-functions
  50      =2  |                            modified Custom TX/RX CopyFunctions 
  51      =2  |                            modified concerning DBKOMGen Tool
  52      =2  |                            deleted TransmitSF
  53      =2  |                            deleted compatibility Mode
  54      =2  | 24-Nov-00    2.06    Gz    no changes
  55      =2  | 05-Mar-01    2.07    Gz    added connections for rx-side; adjustable stmin-time
  56      =2  |                      Gz    added Review changes
  57      =2  | 14-Mar-01    2.08    Gz    corrections for Busoff handling
  58      =2  | 09-Apr-01    2.09    Gz    extension of the Gateway-API
  59      =2  | 20-Apr-01    2.10    Gz    added missing lines
  60      =2  | 11-May-01    2.11    Gz    enlarged support for multiple CAN-channel ECUs
  61      =2  | 05-Jun-01    2.12    Gz    support of extended addressing
  62      =2  | 11-Jun-01            Gz    support of single channel TP
  63      =2  | 15-Jun-01    2.13    Gz    no changes
  64      =2  | 19-Jun-01    2.14    Js    pChipDataPtr substituted with CanChipDataPtr
  65      =2  | 27-Jul-01    2.15    Gz    no changes
  66      =2  | 07-Sep-01    2.16    Gz    ESCAN00000819: better support for singlechannel-TP
  67      =2  |                            ESCAN00001096: Support of Tp-Connections without FC
  68      =2  |                            ESCAN00001097: TP is always in compatibility mode 
  69      =2  |                                           while reading Source-/TargetAddress
  70      =2  |                            ESCAN00001101: early termination of the 
  71      =2  |                                           queueing mechanism (only if CanChannels > 1)
  72      =2  |                            ESCAN00001149: New TP-class: Dynamic Multiple Addressing
  73      =2  | 07-Sep-01    2.17    Gz    no changes
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 132 

  74      =2  | 20-Sep-01    2.18    Gz    ESCAN00001482: 'Connection specific timings' is not 
  75      =2  |                                           working correctly
  76      =2  |                            ESCAN00001526: Timings should be normalized by the GenTool
  77      =2  |                            ESCAN00001537: TransmitHandles should be changeable 
  78      =2  |                                           while runtime
  79      =2  | 26-Oct-01    2.19    VC    Reserved (only VectorCantech)
  80      =2  | 26-Oct-01    2.20    VC    Reserved (only VectorCantech)
  81      =2  | 26-Oct-01    2.21    VC    Reserved (only VectorCantech)
  82      =2  | 26-Oct-01    2.22    Gz    General improvement
  83      =2  | 06-Nov-01            Rn    ESCAN00001724: delete used in TpTxHoldChannel
  84      =2  | 06-Nov-01            Gz    ESCAN00001744: Combination of 'Use STMin from flow control 
  85      =2  |                                           frame' together with a 'connection without FC' 
  86      =2  |                                           will not work
  87      =2  | 06-Nov-01            Gz    ESCAN00001746: (only DC) complementary to 'connecntions 
  88      =2  |                                           without FC' an additional BIT is set in the 
  89      =2  |                                           TPCI-Byte to differ between
  90      =2  | 08-Nov-01    2.23    Gz    ESCAN00001764: In case of single optimized version some 
  91      =2  |                                           macros have still parameter channel.
  92      =2  | 27-Nov-01    2.24    Gz    no changes
  93      =2  | 2001-Dec-06  2.25.00 Gz    ESCAN00001891: The limitation having an unique CAN-ID over 
  94      =2  |                                           all CAN-Channels is eliminated
  95      =2  | 2001-Dec-12  2.26.00 Gz    ESCAN00001662: It should be possible to have more than one Base-Address
  96      =2  | 2001-Dec-18          Gz    ESCAN00001798: The TPCI-Byte for FlowControl's is not checked 
  97      =2  |                                           for valid values
  98      =2  | 2002-Jan-07          Gz    ESCAN00001853: insert keyword for far APIm and far callback-functions
  99      =2  | 2002-Jan-30          Gz    ESCAN00002185: for multiple CAN-systems and dynamicTP: 
 100      =2  |                                           TpPrecopy-function is not reentrant 
 101      =2  |                            ESCAN00002175: Illegal SingleFrame lengths will be shorten 
 102      =2  |                                           to a legal SingleFrame length.
 103      =2  |                            ESCAN00002190: ApplTpRxErrorIndication is called after ApplTpRxIndication
 104      =2  | 2002-Jan-14  2.27.00 Gz    ESCAN00002323: No transmission or reception possible in case of enable debug 
             -mode
 105      =2  |                            ESCAN00002324: support indexed CAN-driver for all dynamic TP-classes
 106      =2  | 2002-Feb-28  2.28.00 Gz    ESCAN00002374: Limiting the STmin time from FC to a minimum
 107      =2  | 2002-Mar-11          Gz    ESCAN00002392: Observing CAN frame DLC (Data Length Code)
 108      =2  | 2002-Mar-11          Gz    ESCAN00002379: Illegal reception, if a CAN-message with DLC=0 is received
 109      =2  | 2002-Mar-11          Gz    ESCAN00002380: The TP can't receive a FirstFrame with a dataLength 
 110      =2  |                                           smaller six(6)/seven(7) bytes successfully
 111      =2  | 2002-Mar-11          Gz    ESCAN00002459: enhance the fault tolerance 
 112      =2  | 2002-Mar-14          Gz    ESCAN00002490: A possibility should be provided to pre-check 
 113      =2  |                                           each CAN-message of a TP-frame
 114      =2  | 2002-Mar-15          Gz    ESCAN00002496: Syntax error in definition of function TpRxGetBS
 115      =2  | 2002-Mar-20  2.29.00 Gz    ESCAN00002534: Tp is blocked after TpTransmit returns 'kTpFailed'
 116      =2  | 2002-Mar-22          Gz    ESCAN00002554: Tp stays blocked after receiving a TP-frame with 
 117      =2  |                                           wrong DLC or incorrect frame-length 
 118      =2  |                      Gz    ESCAN00002555: AppltpTxErrorFunction() will be called 
 119      =2  |                                           after TpTransmit returns 'kTpFailed'
 120      =2  |                      Gz    ESCAN00002534: TP is locked after wakeup 
 121      =2  | 2002-Mar-27  2.30.00 Gz    ESCAN00002565: Possible under-run of the requested STmin time
 122      =2  |                      Gz    ESCAN00002558: Only Cosmic HC12 with option -pck : 
 123      =2  |                                           Compiler reports truncating assignment when TpTxQueueCheck() i
             -s called
 124      =2  | 2002-Apr-03          Gz    ESCAN00002578: It should be not possible to change communication parameters 
 125      =2  |                                           while a communication is running
 126      =2  | 2002-Apr-05          Gz    ESCAN00002632: compatibility mode for old style 
 127      =2  |                                           TpTxErrorIndication function is deleted 
 128      =2  |                      Gz    ESCAN00002636: the possibility to switch off the feature 
 129      =2  |                                           'using connections' are not supported any more
 130      =2  | 2002-Apr-26  2.31.00 Gz    ESCAN00002642: Partially written frames are transmitted by the TP 
 131      =2  |                                           (only if 'ApplTpTxCopyToCAN' is used)
 132      =2  | 2002-May-07  2.32.00 Gz    ESCAN00002798: connections will terminate very often and run into a 
 133      =2  |                                           confirmation timeout (only with disabled can transmit queue)
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 133 

 134      =2  | 2002-Jun-05  2.33.00 Gz    ESCAN00003065: It should be possible to deactivate the TP separately on each 
             -CAN-channel 
 135      =2  |                      Gz    ESCAN00002652: no changes
 136      =2  |                      Gz    ESCAN00003077: no changes
 137      =2  |                      Gz    ESCAN00003076: no changes
 138      =2  | 2002-Jul-11  2.34.00 Gz    ESCAN00003204: no changes
 139      =2  | 2002-Jul-22          Gz    ESCAN00003135: no changes
 140      =2  | 2002-Jul-22          Gz    ESCAN00003081: Fully compliance to the ISO-specification
 141      =2  | 2002-Jul-22          Gz    ESCAN00003344: no changes
 142      =2  | 2002-Jul-22          Gz    ESCAN00003345: no changes
 143      =2  | 2002-Jul-24          Gz    ESCAN00003342: Change in observing the minimum sending time foy dyn.TP
 144      =2  | 2002-Jul-24          Gz    ESCAN00003374: Calculate STmin and BS only from the first FlowControl 
 145      =2  | 2002-Aug-22  2.35.00 Gz    ESCAN00003584: no changes
 146      =2  | 2002-Sep-02          Gz    ESCAN00003617: no changes
 147      =2  | 2002-Sep-04          Gz    ESCAN00003586: no changes
 148      =2  | 2002-Sep-04          Gz    ESCAN00003655: no changes
 149      =2  | 2002-Sep-05          Gz    ESCAN00003375: Separation of TimerTask and TransmissionTask (StateTask)
 150      =2  | 2002-Sep-05          Gz    ESCAN00003376: CF Transmission faster than callycyle of TpTxTimerTask()
 151      =2  | 2002-Okt-07  2.36.00 Ap    ESCAN00003809: While polling the CAN-driver slowly the connection can be lost
             --> define added
 152      =2  | 2002-Okt-09          Gz    ESCAN00003520: Change hook-functions (delete 'ApplTpRxCanMessageReceived' / 
 153      =2  |                                           add 'ApplTpTxFC' / add 'TpPreCopyCheckFunction')
 154      =2  | 2002-Okt-09          Gz    ESCAN00003750: prototype for ApplTpFataleError missing
 155      =2  | 2002-Okt-09          Gz    ESCAN00003751: no changes
 156      =2  | 2002-12-06   2.37.00 Gz    ESCAN00004216: no changes
 157      =2  |                      Gz    ESCAN00004340: no changes
 158      =2  |                      Gz    ESCAN00004373: no changes
 159      =2  | 2002-12-09   2.38.00 Gz    ESCAN00004399: no changes
 160      =2  | 2003-01-11   2.39.00 Gz    ESCAN00004587: Compatibility mode for older DBKOMgen versions 
 161      =2  |                                           won't work, if DBKOM is deativated 
 162      =2  | 2003-02-03   2.40.00 Gz    ESCAN00004757: no changes
 163      =2  | 2003-11-13   2.41.00 Gz    ESCAN00005041: no changes
 164      =2  |                      Gz    ESCAN00004199: Conditional Pre-Processor directives misses parantheses
 165      =2  |                      Gz    ESCAN00003891: Add a CANchannel-specific re-initialization function.
 166      =2  |                      Gz    ESCAN00005100: no changes
 167      =2  |                      Gz    ESCAN00005221: no changes
 168      =2  |                      Gz    ESCAN00005257: no changes
 169      =2  |                      Gz    ESCAN00005539: TpRxSetBufferOverrun is provided: Do not copy all frames if a 
             -buffer overrun occured
 170      =2  |                      Gz    ESCAN00005541: Call ApplXxErrorIndication() if for a running connection TpXxR
             -esetChannel() is called.
 171      =2  |                      !!! Warning this version has a change in its behaviour !!!
 172      =2  |                      Gz    ESCAN00006155: no changes
 173      =2  |                      Gz    ESCAN00006159: Add TpTask() function
 174      =2  |                      Gz    ESCAN00006156: Add new requirements from ISO 15765-2.2
 175      =2  |                      !!! Warning if these changes are active there will be changes in the behaviour !!!
 176      =2  |                      Gz    ESCAN00006158: Add a separat channel for functional reception (N_TAtype = fun
             -ctional)
 177      =2  |                      Gz    ESCAN00006040: An API should be added which results the current CAN-channel 
 178      =2  |                                           of the received frame (only multiple CAN-channel systems)
 179      =2  |                      Gz    ESCAN00006014: no changes
 180      =2  |                      Gz    ESCAN00006341: no changes
 181      =2  |                      Gz    ESCAN00006354: C-Library functions not longer used
 182      =2  |                      Gz    ESCAN00006465: no changes
 183      =2  |                      Gz    ESCAN00006379: no changes
 184      =2  |                      Gz    ESCAN00006850: no changes
 185      =2  |                      Gz    ESCAN00007005: no changes
 186      =2  |                      Gz    ESCAN00007006: Support for GENy
 187      =2  | 2003-11-17  2.42.00  Ap    ESCAN00007029: channel specific minimum sending distance
 188      =2  |                      Gz    ESCAN00007005: no changes
 189      =2  | 2004-01-09  2.43.00  Gz    ESCAN00007108: no changes
 190      =2  |                      Gz    ESCAN00007107: no changes
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 134 

 191      =2  |                      Gz    ESCAN00007005: no changes
 192      =2  | 2004-01-15  2.44.00  Gz    ESCAN00007173: no changes
 193      =2  |                      Gz    ESCAN00007005: no changes
 194      =2  |                      Ap    ESCAN00007229: tTpCopyToCanInfoStruct_s not used with GENy
 195      =2  |                      Gz    ESCAN00007193: no changes
 196      =2  |                      Gz    ESCAN00007192: OEM specific preselection for ISO 15765_2_2 is wrong
 197      =2  |                      Gz    ESCAN00007191: no changes
 198      =2  |                      Gz    ESCAN00007098: no changes
 199      =2  |                      Ap    ESCAN00007257: no changes
 200      =2  |                      Gz    ESCAN00005679: The memory qualifier V_MEMROM0 has to be implemented in this m
             -odule
 201      =2  |                      Gz    ESCAN00007273: Assertions should be able to configure independent from the CA
             -Ndriver assertions
 202      =2  | 2004-01-30  2.45.00  Gz    ESCAN00007293: Additional memory qualifier should be added
 203      =2  |                      Ap    ESCAN00007349: no changes
 204      =2  |                      Gz    ESCAN00007318: In each transmission wrong data will be sent. (only 8bit contr
             -oller)
 205      =2  | 2004-01-30  2.50.00  Ap    ESCAN00007341: ApplTpCopyToCAN parameter harmonisation for 8-bit controllers
 206      =2  |                      Ap    ESCAN00007392: no changes 
 207      =2  | 2004-02-05  2.51.00  Ap    ESCAN00007426: redefinition of macro __ApplTpTxFC
 208      =2  |                      Ap    ESCAN00007441: no changes
 209      =2  |                      Ap    ESCAN00007471: no changes
 210      =2  | 2004-03-02  2.52.00  Gz    ESCAN00007778: Compile error while using TP handle changeable
 211      =2  | 2004-03-12  2.53.00  Ap    ESCAN00007864: no changes
 212      =2  | 2004-03-19  2.54.00  Ap    ESCAN00007932: no changes
 213      =2  | 2004-03-23  2.55.00  Ap    ESCAN00007519: Support for CAN buffer access in ApplTpRxGetBuffer callback fu
             -nction
 214      =2  | 2004-04-02  2.56.00  Ap    ESCAN00007675: no changes
 215      =2  |                      Gz    ESCAN00008089: no changes
 216      =2  | 2004-04-06  2.57.00  Gz    ESCAN00008142: no changes
 217      =2  |                      Gz    ESCAN00008143: no changes
 218      =2  |                      Gz    ESCAN00008091: Diagnostic requests with DLC < 8 bytes are considered invalid
 219      =2  | 2004-04-23  2.58.00  Gz    ESCAN00008246: no changes
 220      =2  |                      Gz    ESCAN00007675: no changes
 221      =2  |                      Ap    ESCAN00008259: no changes
 222      =2  | 2004-05-13  2.60.00  Ap    ESCAN00007624: Support for mixed addressing 
 223      =2  |                      Ap    ESCAN00007831: MISRA: tpmc.h: Macro body not enclosed in ()
 224      =2  |                      Ap    ESCAN00008170: no changes
 225      =2  |                      Ap    ESCAN00008037: Variable DLC support
 226      =2  |                      Ap    ESCAN00008390: no changes
 227      =2  | 2004-05-25  2.61.00  Ap    ESCAN00008474: tTpCopyToCanInfoStruct defined twice for 8bit controllers
 228      =2  | 2004-05-26  2.62.00  Ap    ESCAN00008488: no changes
 229      =2  |                      Gz    ESCAN00008520: Add special routines for testing purpose
 230      =2  |                      Ap    ESCAN00008629: Preprocessor comparison with = instead of ==
 231      =2  |                      Ap    ESCAN00008630: no changes
 232      =2  | 2004-08-06  2.63.00  Gz    ESCAN00008520: Add special routines for testing purpose (2.nd)
 233      =2  |                      Gz    ESCAN00008778: no changes
 234      =2  |                      Gz    ESCAN00008983: no changes
 235      =2  |                      Gz    ESCAN00007440: Rx-Tx-inversion should be handled in each configurations
 236      =2  |                      Ap    ESCAN00009095: no changes
 237      =2  | 2004-06-18  2.64.00  Ap    ESCAN00009112: no changes
 238      =2  |                      Ap    ESCAN00009111: New default settings for TP_USE_PADDING
 239      =2  | 2004-08-23  2.65.00  Gz    ESCAN00009502: Remove of error directives due to new organi structure
 240      =2  |                      Ap    ESCAN00009153: no changes   
 241      =2  |                      Ap    ESCAN00009375: no changes   
 242      =2  |                      Ap    ESCAN00009511: Naming Conventions: New version defines
 243      =2  |                      Ap    ESCAN00004702: BS and STmin shall be ignored
 244      =2  | 2004-10-15  2.66.00  Ap    ESCAN00009865: no changes
 245      =2  | 2004-10-22  2.67.00  Ap    ESCAN00009979: no changes
 246      =2  |                      Ap    ESCAN00009797: Old naming of compiler switch "MULTIPLE_RECEIVE_BUFFER"
 247      =2  | 2005-01-11  2.68.00  Ap    ESCAN00010029: no changes
 248      =2  |                      Ap    ESCAN00010186: No libary functions should be used - VSTDLIB used (mendatory) 
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 135 

             -instead  
 249      =2  |                      Ap    ESCAN00010770: Use of official CAN Driver API CanGetTxDataPtr
 250      =2  |                      Ap    ESCAN00010773: Support for multiple ECUs in combination with single optimizat
             -ion and Mixed29/Extended/NormalFixed
 251      =2  |                      Ap    ESCAN00010774: Support for Multiple Addressing with GENy
 252      =2  |                      Ap    ESCAN00010775: MISRA and pclint status and improvement request
 253      =2  |                      Ap    ESCAN00010776: no changes
 254      =2  |                      Ap    ESCAN00010777: Support for AddressingType specific PGN and Priority
 255      =2  |                      Ap    ESCAN00010781: no changes
 256      =2  | 2005-02-08  2.69.00  Ap    ESCAN00010829: Support for non ISO feature AcknowledgedConnection
 257      =2  |                      Ap    ESCAN00010831: Support for GatewayAPI on diagnostic functional requests
 258      =2  |                      Ap    ESCAN00011025: Availability of API function TpRxGetStatus extended (as docume
             -nted in TechRef)
 259      =2  |                      Gz    ESCAN00011041: Extra OBD reception path has to be added
 260      =2  |                      Gz    ESCAN00011040: TpTransmit has to be accepted while TP is in minimum sending d
             -istance state
 261      =2  | 2005-02-11  2.70.00  Ap    ESCAN00010186: Compliency to CANGen and DBKOMGen  
 262      =2  | 2005-02-25  2.71.00  Ap    ESCAN00011124: no changes
 263      =2  |                      Ap    ESCAN00010186: No libary functions should be used - include of string.h remov
             -ed
 264      =2  |                      Ap    ESCAN00011285: No changes
 265      =2  | 2005-03-16  2.72.00  Ap    ESCAN00011292: No changes
 266      =2  |                      Ap    ESCAN00011443: No changes
 267      =2  |                      Ap    ESCAN00011415: Support for IAR Compiler required
 268      =2  | 2005-08-11  2.73.00  Ap    ESCAN00011729: Undefined preprocessor define compared to value leading to com
             -pile error
 269      =2  |                      Ap    ESCAN00011738: No changes
 270      =2  |                      Ap    ESCAN00011897: Transmissions of FlowControl.Wait / suspend of reception (inte
             -rface behaviour change required!)
 271      =2  |                      Ap    ESCAN00011924: No changes
 272      =2  |                      Ap    ESCAN00012015: Possible overlap of bitfield over word boundary
 273      =2  |                      Her   ESCAN00012778: Added dynamic handling of SN and FC strict checking
 274      =2  |                                           (TP_ENABLE_FC_MSG_FLOW_DYN_CHECK, TP_ENABLE_DYN_AWAIT_CORRECT_
             -SN)
 275      =2  |                      Gz    ESCAN00012915: Change the functionality of the ApplTpCheckTA() callback funct
             -ion 
 276      =2  |                                           !!! Warning this version has a change in its behaviour !!!
 277      =2  |                      Ap    ESCAN00011586: No changes
 278      =2  |                      Ap    ESCAN00011117: No changes
 279      =2  |                      Her   ESCAN00013192: added dynamic handling of timeout values (N_As,N_Ar,N_Bs,N_Cr)
             - 
 280      =2  |                                           (TP_ENABLE_DYN_CHANNEL_TIMING)
 281      =2  | 2005-08-22  2.74.00  Her   ESCAN00013222: MISRA compliancy (cancelled context switch)
 282      =2  | 2005-09-12  2.75.00  Ap    ESCAN00013489: Acceptance of functional FirstFrame
 283      =2  | 2005-09-25           Her   ESCAN00013590: no changes
 284      =2  | 2005-10-17  2.76.00  Her   ESCAN00013654: FirstFrame / SingleFrame acceptance to wrong parallel connecti
             -on in multi addressing TP class
 285      =2  |                            ESCAN00013914: cleanup of compiler warnings 
 286      =2  |                            ESCAN00013995: added single channel multi connection multi CAN channels
 287      =2  |                                           (TP_ENABLE_SINGLE_CHAN_MULTICONN)
 288      =2  | 2005-11-10  2.77.00  Gz    ESCAN00014224: FC.overflow is not automatically supported
 289      =2  |                      Gz    ESCAN00013335: Wrong calculation of data length when receiving a first frame 
             -(only PIC18)
 290      =2  |                      Gz    ESCAN00014153: Compiler warning W1353C "assignment incompatible pointer types
             -" occurs
 291      =2  |                      Gz    ESCAN00014000: CAN driver assertion is called in TpInitPowerOn()
 292      =2  |                      Gz    ESCAN00014015: Multiple ECU numbers in functional requests
 293      =2  |                      Gz    ESCAN00013054: memcpy() should used instead of VStdRamMemCpy()
 294      =2  | 2005-11-10  2.78.00  Gz    ESCAN00014444: Compile error: kTpFCSuppressFrame is undefined
 295      =2  | 2005-12-19  2.79.00  Gz    ESCAN00014547: Invalid call of "dynamic tx object set data pointer" macro und
             -er certain configuration.
 296      =2  | 2006-01-10  2.80.00  Gz    ESCAN00014790: no changes
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 136 

 297      =2  |                      Gz    ESCAN00014838: no changes
 298      =2  |                      Gz    ESCAN00014839: no changes
 299      =2  | 2006-01-18  2.81.00  Her   ESCAN00014937: no changes
 300      =2  | 2006-01-31  2.82.00  Her   ESCAN00014888: Tx/Rx interrupt priority inversion re-released
 301      =2  | 2006-02-06           Her   ESCAN00015232: TP_ENABLE_FC_SUP[P]RESS backward compatibility
 302      =2  | 2006-02-15  2.83.00  Her   ESCAN00015346: no changes
 303      =2  | 2006-02-18  2.84.00  Her   ESCAN00013656: no changes
 304      =2  |                      Her   ESCAN00013658: disable functional addressing support (multiple addressing)
 305      =2  |                      Her   ESCAN00015368: replace string.h
 306      =2  |                      Her   ESCAN00015427: no changes
 307      =2  | 2006-02-27  2.85.00  Her   ESCAN00015472: no changes
 308      =2  | 2006-03-06  2.86.00  Her   ESCAN00015521: cleanup of compiler warnings, additional consistency check
 309      =2  |                      Her   ESCAN00015595: no changes
 310      =2  | 2006-04-06  2.87.00  Her   ESCAN00015988: no changes
 311      =2  |                      Her   ESCAN00016008: no changes
 312      =2  |                      Her   ESCAN00016050: TP is not configured on all CAN channels (kTpNumberOfCanChanne
             -ls != kCanNumberOfChannel)
 313      =2  |                      Her   ESCAN00016055: no changes
 314      =2  | 2006-04-24  2.88.00  Her   ESCAN00016125: set TP_ENABLE_CHECKTA_COMPATIBILITY as default for old GenTool
             -,
 315      =2  |                                           Misra compliancy adaptations
 316      =2  |                      Her   ESCAN00016214: no changes
 317      =2  |                      Her   ESCAN00016229: no changes
 318      =2  | 2006-06-16  2.89.00  Her   ESCAN00016608: no changes
 319      =2  |                      Her   ESCAN00016610: no changes
 320      =2  |                      Her   ESCAN00016611: no changes
 321      =2  |                      Her   ESCAN00016632: no changes
 322      =2  |                      Her   ESCAN00016639: no changes
 323      =2  |                      Her   ESCAN00016658: no changes
 324      =2  |                      Her   ESCAN00016678: no changes
 325      =2  |                      Her   ESCAN00016581: Support max. number of wait frames (N_WFTmax)
 326      =2  |                      Her   ESCAN00016821: no changes
 327      =2  |                      Her   ESCAN00016920: use macro VStdMemCpyRamToRam instead of function VStdRamMemCpy
 328      =2  | 2006-07-27  2.89.01  Her   ESCAN00017063: no changes
 329      =2  | 2006-08-10  2.89.02  Her   ESCAN00017206: no changes
 330      =2  |                      Her   ESCAN00017305: no changes
 331      =2  | 2006-10-12  2.89.03  EJW   ESCAN00018009: changes to support data buffers in far RAM
 332      =2  | 2006-10-18  2.89.04  Her   ESCAN00018058: no changes
 333      =2  |                      Her   ESCAN00018299: no changes
 334      =2  |                      Her   ESCAN00018508: Extend ApplTpCopyFromCan API with rxStruct for usage by GW 
 335      =2  |                      Her   ESCAN00018791: no changes
 336      =2  | 2007-01-04  2.90.00  Her   ESCAN00018236: separate SF/MF acknowledged connection
 337      =2  |                      Her   ESCAN00019126: no changes
 338      =2  |                      Her   ESCAN00019137: no changes
 339      =2  | 2007-02-19  2.91.00  Her   ESCAN00019597: Disable MF reception
 340      =2  | 2007-03-15  2.92.00  Her   ESCAN00019850: no changes
 341      =2  |                      Her   ESCAN00019928: no changes
 342      =2  |                      Her   ESCAN00020136: Add ASR CanIf interface for Static SingleTP use case
 343      =2  |                      Her   ESCAN00020427: no changes
 344      =2  | 2007-05-10  2.93.00  Her   ESCAN00020926: no changes
 345      =2  |                      Her   ESCAN00021048: Add ASR CanIf interface for Static SingleTP use case (function
             -al connection group)
 346      =2  |                      Her   ESCAN00021049: no changes
 347      =2  | 2007-08-28  2.94.00  Her   ESCAN00021597: Redefinitions in mixed configurations (ASR/nonASR) solved 
 348      =2  |                      Her   ESCAN00022111: Support AUTOSAR post built functionality for transmitting PDU-
             -IDs
 349      =2  |                      Her   ESCAN00022166: Set default value of TP_DISABLE_FC_WAIT
 350      =2  |                      Her   ESCAN00022281: no changes
 351      =2  |                      Her   ESCAN00022424: no changes
 352      =2  |                      Her   ESCAN00022582: no changes
 353      =2  | 2007-10-30  3.00.00  Her   ESCAN00023023: Dispatched Multi TP classes
 354      =2  |                      Her   ESCAN00022661: no changes
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 137 

 355      =2  |                      Her   ESCAN00022683: no changes
 356      =2  |                      Her   ESCAN00023030: ASR - Single Channel TP used with multiple channels (TP_ENABLE
             -_SINGLE_CHAN_MULTICONN)
 357      =2  | 2007-11-08  3.00.01  Her   ESCAN00023135: no changes
 358      =2  | 2007-11-20  3.01.00  Her   ESCAN00023262: no changes
 359      =2  |                      Her   ESCAN00022704: no changes
 360      =2  |                      Her   ESCAN00023482: no changes
 361      =2  | 2007-12-07  3.02.00  Her   ESCAN00023568: no changes
 362      =2  |                      Her   ESCAN00023572: API function TpTxGetTargetAddress for DISPATCHED Multi TP clas
             -ses
 363      =2  | 2008-01-08  3.03.00  Her   ESCAN00023881: no changes
 364      =2  | 2008-01-09  3.04.00  Her   ESCAN00023959: Application buffer resides in paged (far)  memory
 365      =2  |                      Her   ESCAN00023972: added extended API for ApplTpGetRxBufferFct 
 366      =2  |                      Her   ESCAN00023991: API function TpFuncGetReceiveCanID returns a wrong type.
 367      =2  |                      Her   ESCAN00013328: no changes
 368      =2  |                      Her   ESCAN00024096: no changes
 369      =2  |                      Her   ESCAN00024024: TP messages sent on another CAN than expected
 370      =2  | 2008-01-25  3.04.01  Her   ESCAN00024227: new API function for functional requested multiframe responses
             - 
 371      =2  | 2008-02-08  3.04.02  Her   ESCAN00024290: no changes
 372      =2  |                      Her   ESCAN00024448: no changes
 373      =2  |                      Her   ESCAN00024771: Wrong memory qualifier used
 374      =2  | 2008-02-28  3.04.03  Her   ESCAN00024960: no changes
 375      =2  |                      Her   ESCAN00024963: no changes
 376      =2  |                      Her   ESCAN00024845: no changes
 377      =2  |                      Her   ESCAN00025819: no changes
 378      =2  |                      Her   ESCAN00026052: no changes
 379      =2  | 2008-07-17  3.04.04  Her   ESCAN00028477: Mixed CANbedded - AUTOSAR communication stack compiler and  li
             -nker issues
 380      =2  |                      Her   ESCAN00028485: Support mixed CAN-IDs dynamically at runtime
 381      =2  |                      Her   ESCAN00027903: no changes
 382      =2  |                      Her   ESCAN00028580: no changes
 383      =2  | 2008-08-18  3.04.05  Her   ESCAN00029252: Mixed CANbedded - AUTOSAR communication stack: check for DLC
 384      =2  |                      Her   ESCAN00029194: no changes
 385      =2  |                      Her   ESCAN00029288: no changes
 386      =2  | 2008-08-28  3.04.06  Gz    ESCAN00029557: no changes
 387      =2  | 2008-09-15  3.04.07  Her   ESCAN00030490: no changes
 388      =2  |                      Her   ESCAN00030239: no changes
 389      =2  | 2008-11-12  3.04.08  Her   ESCAN00031187: no changes
 390      =2  | 2009-01-08  3.04.09  Her   ESCAN00031601: no changes
 391      =2  |                      Her   ESCAN00031930: no changes
 392      =2  |                      Her   ESCAN00032048: Support far data access for paged applications
 393      =2  | 2009-01-28  3.04.10  Her   ESCAN00032602: Extend the maximum number of configurable CAN channels
 394      =2  | 2009-04-01  3.04.11  Her   ESCAN00034323: New preprocessor switch coming up with MCAN support by GENy
 395      =2  |                      Her   ESCAN00034343: no changes
 396      =2  | 2009-05-29  3.04.12  Her   ESCAN00035016: Timeout definitions missing for channel specific use case
 397      =2  |                      Her   ESCAN00035351: no changes
 398      =2  | 2009-07-01  3.04.13  Her   ESCAN00036069: no changes
 399      =2  | 2009-09-18  3.04.14  Her   ESCAN00037745: no changes
 400      =2  |                      Her   ESCAN00037463: no changes
 401      =2  |                      Her   ESCAN00038018: no changes
 402      =2  | 2009-11-26  3.04.15  Her   ESCAN00039239: no changes
 403      =2  | 2009-11-27  3.04.16  Her   ESCAN00039440: no changes
 404      =2  | 2010-03-26  3.04.17  Her   ESCAN00040914: no changes
 405      =2  |                      Her   ESCAN00041597: Use v_inc.h instead of vstdlib.h
 406      =2  |                      Her   ESCAN00042152: Support dynamic priority and PGN for NormalFixed Addressing
 407      =2  | 2010-07-14  3.04.18  Her   ESCAN00043607: no changes
 408      =2  |                      Her   ESCAN00044057: Missing variable definition
 409      =2  | 2010-11-14  3.04.19  Her   ESCAN00046715: parameter name "pdata" is interpreted as compiler keyword
 410      =2  | 2011-01-10  3.05.00  Her   ESCAN00047913: Reserve a dynamic Tp channel on reception side
 411      =2  |                      Her   ESCAN00047970: no changes
 412      =2  |                      Her   ESCAN00047840: Renesas compiler issue
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 138 

 413      =2  |                      Her   ESCAN00047981: no changes
 414      =2  | 2011-02-14  3.05.01  Her   ESCAN00048680: no changes
 415      =2  |                      Her   ESCAN00048682: no changes
 416      =2  | 2011-03-10  3.06.00  Her   ESCAN00048797: TP shall judge the FC to be invalid
 417      =2  | 2011-06-29  3.06.01  Her   ESCAN00049499: NDV V2.3.2 test "FC.WAIT" fails (NISSAN V-CAN/M-CAN GW)
 418      =2  |                      Her   ESCAN00051019: Extended CAN-Id (PGN and Priority bits) is not as configured 
 419      =2  | 2011-09-15  3.06.02  Dth   ESCAN00053515: no changes
 420      =2  | 2011-09-20  3.06.03  Dth   ESCAN00053704: wrong version check
 421      =2  | 2011-09-21  3.06.04  Dth   ESCAN00053735: no change
 422      =2  | 2011-12-14  3.06.05  Dth   ESCAN00052470: declaration of TpRxCanMessageReceived changed to TpRxCanMessag
             -eTransmitted
 423      =2  | 2012-01-24  3.07.00  Dth   ESCAN00053735: default value for TP_USE_UNEXPECTED_FC_CANCELATION added
 424      =2  |                      Dth   ESCAN00056224: default value for TP_ENABLE_TX_ERR_ON_RX_FC_WAIT & error kTpTx
             -ErrUnsupportedFCWait added
 425      =2  | 2012-04-02  3.07.01  Dth   ESCAN00057225: no changes
 426      =2  |                      Dth   ESCAN00057399: new switch to disable support of STmin in microseconds
 427      =2  |                      Dth   ESCAN00058024: optional factor for channel specific timing introduced
 428      =2  | 2012-04-13  3.07.02  Dth   ESCAN00058320: corruption of data due to union access
 429      =2  | 2012-07-25  3.07.03  Dth   ESCAN00060198: Compiler error with dynamic TP and normal+extended addressing 
             -use case
 430      =2  | 2013-03-21  3.07.04  Dth   ESCAN00066083: no changes
 431      =2  | 2013-04-29  3.08.00  Dth   ESCAN00065244: Support 16Bit WFTmax
 432      =2  |                      Dth   ESCAN00065966: Stop transmission if FC with reserved STmin is received
 433      =2  |                      Dth   ESCAN00066741: no changes
 434      =2  | 2013-08-23  3.08.01  Dth   ESCAN00069636: Compiler error: tpCanRxActualIdType is undefined
 435      =2  |                      Dth   ESCAN00069776: no changes
 436      =2  |                      Dth   ESCAN00069980: no changes
 437      =2    ******************************************************************************/
 438      =2  #ifndef OSEKTPMC_H
 439      =2  #define OSEKTPMC_H
 440      =2  
 441      =2  #if defined (__cplusplus) /* enable C++ access to TPMC API */
           =2 extern "C" {
           =2 #endif
 444      =2  /* ##V_CFG_MANAGEMENT ##CQProject : Tp_Iso15765 CQComponent : Implementation */
 445      =2  #define TP_ISO15765_VERSION           0x0308
 446      =2  #define TP_ISO15765_RELEASE_VERSION   0x01
 447      =2  /* Old TPMC version defines */
 448      =2  #define OSEK_TRANSPORT_LAYER_VERSION         TP_ISO15765_VERSION
 449      =2  #define OSEK_TRANSPORT_LAYER_BUGFIX_VERSION  TP_ISO15765_RELEASE_VERSION
 450      =2  /* Set this value according to the actual version number of this module. */
 451      =2  /* The value is used to generate the Main- and Subversion number for diagnosis.*/
 452      =2  
 453      =2  #define OSEKTP_C_MODULE /* Only for compatibility with tp_cfg.h */
 454      =2  /*Tool configurated header file for global and local usage*/
 455      =2  #include "tp_cfg.h" 
   1      =3  /* -----------------------------------------------------------------------------
   2      =3    Filename:    tp_cfg.h
   3      =3    Description: Toolversion: 05.00.51.01.30.02.86.01.00.00
   4      =3                 
   5      =3                 Serial Number: CBD1300286
   6      =3                 Customer Info: Hyundai Mobis Co., Ltd.
   7      =3                                Package: CBD Hmc SLP5 - CBD License f. HKMC
   8      =3                                Micro: C8051F582
   9      =3                                Compiler: Keil PK51
  10      =3                 
  11      =3                 
  12      =3                 Generator Fwk   : GENy 
  13      =3                 Generator Module: Tp_Iso15765
  14      =3                 
  15      =3                 Configuration   : Y:\20150903_DiagCam_DE.gny
  16      =3                 
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 139 

  17      =3                 ECU: 
  18      =3                         TargetSystem: Hw_Slc8051Cpu
  19      =3                         Compiler:     KEIL
  20      =3                         Derivates:    C8051F58x_59x
  21      =3                 
  22      =3                 Channel "Channel0":
  23      =3                         Databasefile: Y:\20150206_JF_DiagCamera_CAN_DB_R6(LangInfo).dbc
  24      =3                         Bussystem:    CAN
  25      =3                         Manufacturer: HMC
  26      =3                         Node:         PGS
  27      =3  
  28      =3    Generated by , 2015-10-19  18:50:07
  29      =3   ----------------------------------------------------------------------------- */
  30      =3  /* -----------------------------------------------------------------------------
  31      =3    C O P Y R I G H T
  32      =3   -------------------------------------------------------------------------------
  33      =3    Copyright (c) 2001-2011 by Vector Informatik GmbH. All rights reserved.
  34      =3   
  35      =3    This software is copyright protected and proprietary to Vector Informatik 
  36      =3    GmbH.
  37      =3    
  38      =3    Vector Informatik GmbH grants to you only those rights as set out in the 
  39      =3    license conditions.
  40      =3    
  41      =3    All other rights remain with Vector Informatik GmbH.
  42      =3   -------------------------------------------------------------------------------
  43      =3   ----------------------------------------------------------------------------- */
  44      =3  
  45      =3  #if !defined(__TP_CFG_H__)
  46      =3  #define __TP_CFG_H__
  47      =3  
  48      =3  #include "can_par.h"
   1      =4  /* -----------------------------------------------------------------------------
   2      =4    Filename:    can_par.h
   3      =4    Description: Toolversion: 05.00.51.01.30.02.86.01.00.00
   4      =4                 
   5      =4                 Serial Number: CBD1300286
   6      =4                 Customer Info: Hyundai Mobis Co., Ltd.
   7      =4                                Package: CBD Hmc SLP5 - CBD License f. HKMC
   8      =4                                Micro: C8051F582
   9      =4                                Compiler: Keil PK51
  10      =4                 
  11      =4                 
  12      =4                 Generator Fwk   : GENy 
  13      =4                 Generator Module: DrvCan__base
  14      =4                 
  15      =4                 Configuration   : Y:\20150903_DiagCam_DE.gny
  16      =4                 
  17      =4                 ECU: 
  18      =4                         TargetSystem: Hw_Slc8051Cpu
  19      =4                         Compiler:     KEIL
  20      =4                         Derivates:    C8051F58x_59x
  21      =4                 
  22      =4                 Channel "Channel0":
  23      =4                         Databasefile: Y:\20150206_JF_DiagCamera_CAN_DB_R6(LangInfo).dbc
  24      =4                         Bussystem:    CAN
  25      =4                         Manufacturer: HMC
  26      =4                         Node:         PGS
  27      =4  
  28      =4    Generated by , 2015-10-19  18:50:07
  29      =4   ----------------------------------------------------------------------------- */
  30      =4  /* -----------------------------------------------------------------------------
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 140 

  31      =4    C O P Y R I G H T
  32      =4   -------------------------------------------------------------------------------
  33      =4    Copyright (c) 2001-2011 by Vector Informatik GmbH. All rights reserved.
  34      =4   
  35      =4    This software is copyright protected and proprietary to Vector Informatik 
  36      =4    GmbH.
  37      =4    
  38      =4    Vector Informatik GmbH grants to you only those rights as set out in the 
  39      =4    license conditions.
  40      =4    
  41      =4    All other rights remain with Vector Informatik GmbH.
  42      =4   -------------------------------------------------------------------------------
  43      =4   ----------------------------------------------------------------------------- */
  44      =4  
  45      =4  #if !defined(__CAN_PAR_H__)
  46      =4  #define __CAN_PAR_H__
  47      =4  
  48      =4  #include "can_cfg.h"
   1      =5  /* -----------------------------------------------------------------------------
   2      =5    Filename:    can_cfg.h
   3      =5    Description: Toolversion: 05.00.51.01.30.02.86.01.00.00
   4      =5                 
   5      =5                 Serial Number: CBD1300286
   6      =5                 Customer Info: Hyundai Mobis Co., Ltd.
   7      =5                                Package: CBD Hmc SLP5 - CBD License f. HKMC
   8      =5                                Micro: C8051F582
   9      =5                                Compiler: Keil PK51
  10      =5                 
  11      =5                 
  12      =5                 Generator Fwk   : GENy 
  13      =5                 Generator Module: DrvCan__base
  14      =5                 
  15      =5                 Configuration   : Y:\20150903_DiagCam_DE.gny
  16      =5                 
  17      =5                 ECU: 
  18      =5                         TargetSystem: Hw_Slc8051Cpu
  19      =5                         Compiler:     KEIL
  20      =5                         Derivates:    C8051F58x_59x
  21      =5                 
  22      =5                 Channel "Channel0":
  23      =5                         Databasefile: Y:\20150206_JF_DiagCamera_CAN_DB_R6(LangInfo).dbc
  24      =5                         Bussystem:    CAN
  25      =5                         Manufacturer: HMC
  26      =5                         Node:         PGS
  27      =5  
  28      =5    Generated by , 2015-10-19  18:50:07
  29      =5   ----------------------------------------------------------------------------- */
  30      =5  /* -----------------------------------------------------------------------------
  31      =5    C O P Y R I G H T
  32      =5   -------------------------------------------------------------------------------
  33      =5    Copyright (c) 2001-2011 by Vector Informatik GmbH. All rights reserved.
  34      =5   
  35      =5    This software is copyright protected and proprietary to Vector Informatik 
  36      =5    GmbH.
  37      =5    
  38      =5    Vector Informatik GmbH grants to you only those rights as set out in the 
  39      =5    license conditions.
  40      =5    
  41      =5    All other rights remain with Vector Informatik GmbH.
  42      =5   -------------------------------------------------------------------------------
  43      =5   ----------------------------------------------------------------------------- */
  44      =5  
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 141 

  45      =5  #if !defined(__CAN_CFG_H__)
  46      =5  #define __CAN_CFG_H__
  47      =5  
  48      =5  #include "v_cfg.h"
   1      =6  /* -----------------------------------------------------------------------------
   2      =6    Filename:    v_cfg.h
   3      =6    Description: Toolversion: 05.00.51.01.30.02.86.01.00.00
   4      =6                 
   5      =6                 Serial Number: CBD1300286
   6      =6                 Customer Info: Hyundai Mobis Co., Ltd.
   7      =6                                Package: CBD Hmc SLP5 - CBD License f. HKMC
   8      =6                                Micro: C8051F582
   9      =6                                Compiler: Keil PK51
  10      =6                 
  11      =6                 
  12      =6                 Generator Fwk   : GENy 
  13      =6                 Generator Module: GenTool_GenyVcfgNameDecorator
  14      =6                 
  15      =6                 Configuration   : Y:\20150903_DiagCam_DE.gny
  16      =6                 
  17      =6                 ECU: 
  18      =6                         TargetSystem: Hw_Slc8051Cpu
  19      =6                         Compiler:     KEIL
  20      =6                         Derivates:    C8051F58x_59x
  21      =6                 
  22      =6                 Channel "Channel0":
  23      =6                         Databasefile: Y:\20150206_JF_DiagCamera_CAN_DB_R6(LangInfo).dbc
  24      =6                         Bussystem:    CAN
  25      =6                         Manufacturer: HMC
  26      =6                         Node:         PGS
  27      =6  
  28      =6    Generated by , 2015-10-19  18:50:07
  29      =6   ----------------------------------------------------------------------------- */
  30      =6  /* -----------------------------------------------------------------------------
  31      =6    C O P Y R I G H T
  32      =6   -------------------------------------------------------------------------------
  33      =6    Copyright (c) 2001-2011 by Vector Informatik GmbH. All rights reserved.
  34      =6   
  35      =6    This software is copyright protected and proprietary to Vector Informatik 
  36      =6    GmbH.
  37      =6    
  38      =6    Vector Informatik GmbH grants to you only those rights as set out in the 
  39      =6    license conditions.
  40      =6    
  41      =6    All other rights remain with Vector Informatik GmbH.
  42      =6   -------------------------------------------------------------------------------
  43      =6   ----------------------------------------------------------------------------- */
  44      =6  
  45      =6  #if !defined(__V_CFG_H__)
  46      =6  #define __V_CFG_H__
  47      =6  
  48      =6  #ifndef VGEN_GENY
  49      =6  #define VGEN_GENY
  50      =6  #endif
  51      =6  
  52      =6  #ifndef GENy
  53      =6  #define GENy
  54      =6  #endif
  55      =6  
  56      =6  #ifndef SUPPLIER_CANBEDDED
  57      =6  #define SUPPLIER_CANBEDDED                   30
  58      =6  #endif
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 142 

  59      =6  
  60      =6  /* -----------------------------------------------------------------------------
  61      =6      &&&~ Version
  62      =6   ----------------------------------------------------------------------------- */
  63      =6  
  64      =6  #ifndef VERSIONNUMBER
  65      =6  #define VERSIONNUMBER                        0x178
  66      =6  #endif
  67      =6  
  68      =6  
  69      =6  
  70      =6  /* -----------------------------------------------------------------------------
  71      =6      &&&~ General Switches
  72      =6   ----------------------------------------------------------------------------- */
  73      =6  
  74      =6  #ifndef V_OSTYPE_NONE
  75      =6  #define V_OSTYPE_NONE
  76      =6  #endif
  77      =6  
  78      =6  
  79      =6  
  80      =6  /* -----------------------------------------------------------------------------
  81      =6      &&&~ Processor specific
  82      =6   ----------------------------------------------------------------------------- */
  83      =6  
  84      =6  #ifndef C_CPUTYPE_8BIT
  85      =6  #define C_CPUTYPE_8BIT
  86      =6  #endif
  87      =6  
  88      =6  
  89      =6  #ifndef V_CPUTYPE_BITARRAY_16BIT
  90      =6  #define V_CPUTYPE_BITARRAY_16BIT
  91      =6  #endif
  92      =6  
  93      =6  
  94      =6  #ifndef C_CPUTYPE_BIGENDIAN
  95      =6  #define C_CPUTYPE_BIGENDIAN
  96      =6  #endif
  97      =6  
  98      =6  
  99      =6  #ifndef C_CPUTYPE_BITORDER_LSB2MSB
 100      =6  #define C_CPUTYPE_BITORDER_LSB2MSB
 101      =6  #endif
 102      =6  
 103      =6  
 104      =6  #ifndef V_DISABLE_USE_DUMMY_FUNCTIONS
 105      =6  #define V_DISABLE_USE_DUMMY_FUNCTIONS
 106      =6  #endif
 107      =6  
 108      =6  
 109      =6  #ifndef V_ENABLE_USE_DUMMY_STATEMENT
 110      =6  #define V_ENABLE_USE_DUMMY_STATEMENT
 111      =6  #endif
 112      =6  
 113      =6  
 114      =6  #ifndef C_COMP_KEIL_SLC8051_CCAN
 115      =6  #define C_COMP_KEIL_SLC8051_CCAN
 116      =6  #endif
 117      =6  
 118      =6  
 119      =6  #ifndef V_CPU_SLC8051
 120      =6  #define V_CPU_SLC8051
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 143 

 121      =6  #endif
 122      =6  
 123      =6  #ifndef V_COMP_KEIL
 124      =6  #define V_COMP_KEIL
 125      =6  #endif
 126      =6  
 127      =6  #ifndef V_COMP_KEIL_SLC8051
 128      =6  #define V_COMP_KEIL_SLC8051
 129      =6  #endif
 130      =6  
 131      =6  #ifndef V_PROCESSOR_C8051F58X_59X
 132      =6  #define V_PROCESSOR_C8051F58X_59X
 133      =6  #endif
 134      =6  
 135      =6  
 136      =6  #ifndef C_PROCESSOR_C8051F58X_59X
 137      =6  #define C_PROCESSOR_C8051F58X_59X
 138      =6  #endif
 139      =6  
 140      =6  
 141      =6  
 142      =6  
 143      =6  /* -----------------------------------------------------------------------------
 144      =6      &&&~ Used Modules
 145      =6   ----------------------------------------------------------------------------- */
 146      =6  
 147      =6  #define VGEN_ENABLE_DIAG_CANDESC_UDS
 148      =6  #ifndef VGEN_ENABLE_VSTDLIB
 149      =6  #define VGEN_ENABLE_VSTDLIB
 150      =6  #endif
 151      =6  
 152      =6  #ifndef VSTD_ENABLE_DEFAULT_INTCTRL
 153      =6  #define VSTD_ENABLE_DEFAULT_INTCTRL
 154      =6  #endif
 155      =6  
 156      =6  #ifndef VSTD_ENABLE_GLOBAL_LOCK
 157      =6  #define VSTD_ENABLE_GLOBAL_LOCK
 158      =6  #endif
 159      =6  
 160      =6  #ifndef VSTD_DISABLE_DEBUG_SUPPORT
 161      =6  #define VSTD_DISABLE_DEBUG_SUPPORT
 162      =6  #endif
 163      =6  
 164      =6  #ifndef VSTD_ENABLE_LIBRARY_FUNCTIONS
 165      =6  #define VSTD_ENABLE_LIBRARY_FUNCTIONS
 166      =6  #endif
 167      =6  
 168      =6  
 169      =6  #define VGEN_ENABLE_CAN_DRV
 170      =6  #define C_ENABLE_CAN_CHANNELS
 171      =6  #define V_BUSTYPE_CAN
 172      =6  #define VGEN_ENABLE_IL_VECTOR
 173      =6  #define VGEN_ENABLE_NM_BASIC
 174      =6  #define VGEN_ENABLE_TP_ISO_MC
 175      =6  
 176      =6  
 177      =6  #ifndef kVNumberOfIdentities
 178      =6  #define kVNumberOfIdentities                 1
 179      =6  #endif
 180      =6  
 181      =6  #ifndef tVIdentityMsk
 182      =6  #define tVIdentityMsk                        vuint8
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 144 

 183      =6  #endif
 184      =6  
 185      =6  #ifndef kVIdentityIdentity_0
 186      =6  #define kVIdentityIdentity_0                 (vuint8) 0
 187      =6  #endif
 188      =6  
 189      =6  #ifndef VSetActiveIdentity
 190      =6  #define VSetActiveIdentity(identityLog)
 191      =6  #endif
 192      =6  
 193      =6  #ifndef V_ACTIVE_IDENTITY_MSK
 194      =6  #define V_ACTIVE_IDENTITY_MSK                1
 195      =6  #endif
 196      =6  
 197      =6  #ifndef V_ACTIVE_IDENTITY_LOG
 198      =6  #define V_ACTIVE_IDENTITY_LOG                0
 199      =6  #endif
 200      =6  
 201      =6  
 202      =6  #define DIAG_API_CALL_TYPE
 203      =6  #define DIAG_API_CALLBACK_TYPE
 204      =6  #define DIAG_INTERNAL_CALL_TYPE
 205      =6  #define DRV_API_CALL_TYPE
 206      =6  #define DRV_API_CALLBACK_TYPE
 207      =6  #define TP_API_CALL_TYPE
 208      =6  #define TP_API_CALLBACK_TYPE
 209      =6  #define TP_INTERNAL_CALL_TYPE
 210      =6  
 211      =6  /* -----------------------------------------------------------------------------
 212      =6      &&&~ Versions of Preconfig Files
 213      =6   ----------------------------------------------------------------------------- */
 214      =6  
 215      =6  #define VGEN_OEM_PRECONFIG_HMC_SLP5
 216      =6  #define VGEN_OEM_PRECONFIG_VERSION           0x0101
 217      =6  #define VGEN_OEM_PRECONFIG_RELEASE_VERSION   0x00
 218      =6  #define VGEN_USER_PRECONFIG_HMC_SLP5_HIGH_SPEED
 219      =6  #define VGEN_USER_PRECONFIG_VERSION          0x0000
 220      =6  #define VGEN_USER_PRECONFIG_RELEASE_VERSION  0x00
 221      =6  
 222      =6  
 223      =6  /* -----------------------------------------------------------------------------
 224      =6      &&&~ Optimization
 225      =6   ----------------------------------------------------------------------------- */
 226      =6  
 227      =6  #define V_ATOMIC_BIT_ACCESS_IN_BITFIELD      STD_OFF
 228      =6  #define V_ATOMIC_VARIABLE_ACCESS             16
 229      =6  
 230      =6  
 231      =6  
 232      =6  #ifndef VGEN_ENABLE_VSTDLIB
           =6 /* Diag_CanDesc requires VSTDLIB */
           =6 #define VGEN_ENABLE_VSTDLIB
           =6 #endif
 236      =6  
 237      =6  #ifndef C_CLIENT_HMC
 238      =6  #define C_CLIENT_HMC
 239      =6  #endif
 240      =6  
 241      =6  #ifndef __PGS__
 242      =6  #define __PGS__
 243      =6  #endif
 244      =6  
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 145 

 245      =6  /* -----------------------------------------------------------------------------
 246      =6      &&&~ Compatibility defines for ComSetCurrentECU
 247      =6   ----------------------------------------------------------------------------- */
 248      =6  
 249      =6  #ifndef kComNumberOfNodes
 250      =6  #define kComNumberOfNodes                    kVNumberOfIdentities
 251      =6  #endif
 252      =6  
 253      =6  #ifndef ComSetCurrentECU
 254      =6  #define ComSetCurrentECU                     VSetActiveIdentity
 255      =6  #endif
 256      =6  
 257      =6  #ifndef comMultipleECUCurrent
 258      =6  #define comMultipleECUCurrent                vActiveIdentityLog
 259      =6  #endif
 260      =6  
 261      =6  
 262      =6  
 263      =6  #define C_VERSION_REF_IMPLEMENTATION         0x150
 264      =6  
 265      =6  
 266      =6  #ifndef VGEN_ENABLE_VSTDLIB
           =6 /* DrvCan__baseRi15 requires VSTDLIB */
           =6 #define VGEN_ENABLE_VSTDLIB
           =6 #endif
 270      =6  
 271      =6  #ifndef VGEN_ENABLE_VSTDLIB
           =6 #define VGEN_ENABLE_VSTDLIB
           =6 #endif
 274      =6  
 275      =6  
 276      =6  #ifndef VGEN_ENABLE_VSTDLIB
           =6 /* TpMC requires VSTDLIB */
           =6 #define VGEN_ENABLE_VSTDLIB
           =6 #endif
 280      =6  
 281      =6  
 282      =6  
 283      =6  /* begin Fileversion check */
 284      =6  #ifndef SKIP_MAGIC_NUMBER
 285      =6  #ifdef MAGIC_NUMBER
           =6   #if MAGIC_NUMBER != 204819919
           =6       #error "The magic number of the generated file <Y:\CANGEN\v_cfg.h> is different. Please check time a
             -nd date of generated files!"
           =6   #endif
           =6 #else
 290      =6    #define MAGIC_NUMBER 204819919
 291      =6  #endif  /* MAGIC_NUMBER */
 292      =6  #endif  /* SKIP_MAGIC_NUMBER */
 293      =6  
 294      =6  /* end Fileversion check */
 295      =6  
 296      =6  #endif /* __V_CFG_H__ */
  49      =5  #define HW_ST10CCANCPUCANDLL_VERSION         0x0228
  50      =5  #define HW_ST10CCANCPUCANDLL_RELEASE_VERSION 0x00
  51      =5  
  52      =5  #define HW__BASECPUCANDLL_VERSION            0x0226
  53      =5  #define HW__BASECPUCANDLL_RELEASE_VERSION    0x01
  54      =5  
  55      =5  #define DRVCAN__BASEDLL_VERSION              0x0322
  56      =5  #define DRVCAN__BASEDLL_RELEASE_VERSION      0x01
  57      =5  
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 146 

  58      =5  #define DRVCAN__BASERI14DLL_VERSION          0x0209
  59      =5  #define DRVCAN__BASERI14DLL_RELEASE_VERSION  0x01
  60      =5  
  61      =5  #define DRVCAN__BASERI15DLL_VERSION          0x0105
  62      =5  #define DRVCAN__BASERI15DLL_RELEASE_VERSION  0x01
  63      =5  
  64      =5  #define DRVCAN__BASEHLLDLL_VERSION           0x0306
  65      =5  #define DRVCAN__BASEHLLDLL_RELEASE_VERSION   0x01
  66      =5  
  67      =5  #define DRVCAN__BASERI14HLLDLL_VERSION       0x0206
  68      =5  #define DRVCAN__BASERI14HLLDLL_RELEASE_VERSION 0x00
  69      =5  
  70      =5  #define DRVCAN__BASERI15HLLDLL_VERSION       0x0101
  71      =5  #define DRVCAN__BASERI15HLLDLL_RELEASE_VERSION 0x03
  72      =5  
  73      =5  #define CAN_DRV_ST10CCANDLL_VERSION          0x0223
  74      =5  #define CAN_DRV_ST10CCANDLL_RELEASE_VERSION  0x01
  75      =5  
  76      =5  
  77      =5  #define kCanNumberOfChannels                 1
  78      =5  #define kCanNumberOfHwChannels               1
  79      =5  #define kCanNumberOfPhysChannels             1
  80      =5  #define C_DISABLE_MEMCOPY_SUPPORT
  81      =5  #define C_DISABLE_OSEK_OS
  82      =5  #define C_DISABLE_VARIABLE_DLC
  83      =5  #define C_DISABLE_DLC_FAILED_FCT
  84      =5  #define C_DISABLE_VARIABLE_RX_DATALEN
  85      =5  #define C_DISABLE_MULTI_ECU_CONFIG
  86      =5  #define C_DISABLE_MULTI_ECU_PHYS
  87      =5  #define C_DISABLE_EXTENDED_ID
  88      =5  #define C_DISABLE_MIXED_ID
  89      =5  #define C_DISABLE_RECEIVE_FCT
  90      =5  
  91      =5  #define C_DISABLE_ECU_SWITCH_PASS
  92      =5  #define C_ENABLE_TRANSMIT_QUEUE
  93      =5  #define C_DISABLE_OVERRUN
  94      =5  #define C_DISABLE_INTCTRL_BY_APPL
  95      =5  #define C_DISABLE_COMMON_CAN
  96      =5  #define C_ENABLE_USER_CHECK
  97      =5  #define C_ENABLE_HARDWARE_CHECK
  98      =5  #define C_ENABLE_GEN_CHECK
  99      =5  #define C_ENABLE_INTERNAL_CHECK
 100      =5  #define C_DISABLE_DYN_RX_OBJECTS
 101      =5  #define C_DISABLE_DYN_TX_OBJECTS
 102      =5  #define C_DISABLE_DYN_TX_ID
 103      =5  #define C_DISABLE_DYN_TX_DLC
 104      =5  #define C_DISABLE_DYN_TX_DATAPTR
 105      =5  #define C_DISABLE_DYN_TX_PRETRANS_FCT
 106      =5  #define C_DISABLE_DYN_TX_CONF_FCT
 107      =5  #define C_DISABLE_EXTENDED_STATUS
 108      =5  #define C_ENABLE_TX_OBSERVE
 109      =5  #define C_DISABLE_HW_LOOP_TIMER
 110      =5  #define C_DISABLE_NOT_MATCHED_FCT
 111      =5  #define C_SECURITY_LEVEL                     30
 112      =5  
 113      =5  #define C_DISABLE_MULTICHANNEL_API
 114      =5  #define C_ENABLE_PART_OFFLINE
 115      =5  #define C_DISABLE_RANGE_0
 116      =5  #define C_DISABLE_RANGE_1
 117      =5  #define C_DISABLE_RANGE_2
 118      =5  #define C_DISABLE_RANGE_3
 119      =5  #define ApplCanBusOff                        NmBasicCanBusOff
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 147 

 120      =5  
 121      =5  #define kCanNumberOfTxObjects                1
 122      =5  #define kCanNumberOfTxStatObjects            1
 123      =5  #define kCanNumberOfTxDynObjects             0
 124      =5  #define kCanNumberOfRxObjects                8
 125      =5  #define kCanNumberOfRxStatFullCANObjects     8
 126      =5  #define kCanNumberOfRxStatBasicCANObjects    0
 127      =5  #define kCanNumberOfRxDynFullCANObjects      0
 128      =5  #define kCanNumberOfRxDynBasicCANObjects     0
 129      =5  #define kCanNumberOfRxDynObjects             0
 130      =5  #define kCanNumberOfRxStatObjects            8
 131      =5  #define kCanNumberOfConfFlags                0
 132      =5  #define kCanNumberOfIndFlags                 0
 133      =5  #define kCanNumberOfConfirmationFlags        0
 134      =5  #define kCanNumberOfIndicationFlags          0
 135      =5  #define kCanNumberOfInitObjects              1
 136      =5  #define kCanExtNumberOfInitObjects           0
 137      =5  #define kCanHwRxDynFullStartIndex            31
 138      =5  #define C_SEARCH_LINEAR
 139      =5  
 140      =5  #define C_ENABLE_RX_MSG_INDIRECTION
 141      =5  
 142      =5  #define C_DISABLE_CONFIRMATION_FLAG
 143      =5  #define C_DISABLE_INDICATION_FLAG
 144      =5  #define C_DISABLE_PRETRANSMIT_FCT
 145      =5  #define C_ENABLE_CONFIRMATION_FCT
 146      =5  #define C_ENABLE_INDICATION_FCT
 147      =5  #define C_ENABLE_PRECOPY_FCT
 148      =5  #define C_ENABLE_COPY_TX_DATA
 149      =5  #define C_ENABLE_COPY_RX_DATA
 150      =5  #define C_ENABLE_DLC_CHECK
 151      =5  #define C_DISABLE_DLC_CHECK_MIN_DATALEN
 152      =5  
 153      =5  #define C_ENABLE_GENERIC_PRECOPY
 154      =5  #define APPL_CAN_GENERIC_PRECOPY             IlCanGenericPrecopy
 155      =5  
 156      =5  #define C_SEND_GRP_NONE                      0x00
 157      =5  #define C_SEND_GRP_ALL                       0xFF
 158      =5  #define C_SEND_GRP_APPL                      0x01
 159      =5  #define C_SEND_GRP_NM                        0x02
 160      =5  #define C_SEND_GRP_DIAG                      0x04
 161      =5  #define C_SEND_GRP_IL                        0x08
 162      =5  #define C_SEND_GRP_TP                        0x10
 163      =5  #define C_SEND_GRP_USER5                     0x20
 164      =5  #define C_SEND_GRP_USER6                     0x40
 165      =5  #define C_SEND_GRP_USER7                     0x80
 166      =5  #define C_ENABLE_CAN_CANCEL_NOTIFICATION
 167      =5  #define APPL_CAN_CANCELNOTIFICATION          IlCanCancelNotification
 168      =5  
 169      =5  #define kCanPhysToLogChannelIndex_0
 170      =5  #define C_ENABLE_RX_FULLCAN_OBJECTS
 171      =5  #define C_DISABLE_RX_BASICCAN_OBJECTS
 172      =5  #define kCanNumberOfRxFullCANObjects         8
 173      =5  
 174      =5  #define kCanNumberOfRxBasicCANObjects        0
 175      =5  #define kCanNumberOfUsedRxBasicCANObjects    2
 176      =5  
 177      =5  #define kCanInitObj1                         0
 178      =5  #define C_DISABLE_TX_MASK_EXT_ID
 179      =5  #define C_DISABLE_RX_MASK_EXT_ID
 180      =5  #define C_MASK_EXT_ID                        0xFFFFFFFF
 181      =5  
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 148 

 182      =5  #define C_ENABLE_CAN_CAN_INTERRUPT_CONTROL
 183      =5  #define C_DISABLE_CAN_TX_CONF_FCT
 184      =5  
 185      =5  #define C_DISABLE_TX_POLLING
 186      =5  #define C_DISABLE_RX_BASICCAN_POLLING
 187      =5  #define C_DISABLE_RX_FULLCAN_POLLING
 188      =5  #define C_DISABLE_ERROR_POLLING
 189      =5  #define C_DISABLE_WAKEUP_POLLING
 190      =5  #define C_DISABLE_FULLCAN_OVERRUN
 191      =5  #define C_DISABLE_OSEK_OS_INTCAT2
 192      =5  #define C_DISABLE_COPY_RX_DATA_WITH_DLC
 193      =5  #define kCanTxQueueBytes                     1
 194      =5  #define kCanNumberOfMaxBasicCAN              1
 195      =5  #define kCanNumberOfHwObjPerBasicCan         2
 196      =5  #define C_DISABLE_CAN_RAM_CHECK
 197      =5  #define C_DISABLE_SLEEP_WAKEUP
 198      =5  #define C_DISABLE_CANCEL_IN_HW
 199      =5  #define C_DISABLE_ONLINE_OFFLINE_CALLBACK_FCT
 200      =5  
 201      =5  #define kCanChannel_Channel0                 0
 202      =5  #define C_DISABLE_INTCTRL_ADD_CAN_FCT
 203      =5  #if defined(C_SINGLE_RECEIVE_BUFFER) || defined(C_MULTIPLE_RECEIVE_BUFFER)
           =5 #error "DrvCan__baseRI1.5 doesn't support Single/Multiple Receive Buffer API for the callback 'ApplCanMsgR
             -eceived'!"
           =5 #endif
 206      =5  
 207      =5  #define C_DISABLE_RETRANSMIT
 208      =5  #define kCanNumberOfUsedCanTxIdTables        1
 209      =5  #define kCanNumberOfUsedCanRxIdTables        1
 210      =5  #define kCanHwTxStartIndex                   1
 211      =5  
 212      =5  #define kCanHwUnusedStartIndex               3
 213      =5  
 214      =5  #define kCanHwRxFullStartIndex               23
 215      =5  
 216      =5  #define kCanHwRxBasicStartIndex              31
 217      =5  
 218      =5  #define kCanNumberOfUsedTxCANObjects         2
 219      =5  
 220      =5  #define kCanNumberOfUnusedObjects            20
 221      =5  
 222      =5  #define kCanNumberOfTxDirectObjects          1
 223      =5  
 224      =5  #define C_ENABLE_TX_FULLCAN_OBJECTS
 225      =5  
 226      =5  
 227      =5  #define kCanHwTxNormalIndex                  2
 228      =5  
 229      =5  #define C_ENABLE_HW_OBJ_EXCEED_255_CFG
 230      =5  #define C_DISABLE_INDIVIDUAL_POLLING
 231      =5  #define kCanNumberOfHwObjIndivPolling        33
 232      =5  
 233      =5  #define kCanBasisAdr                         0xC0
 234      =5  #define kCanNumberOfMsgObjects               32
 235      =5  #define C_PHYS_CAN_CHANNEL_0                 0
 236      =5  #define kCanChannelIndex_0                   0
 237      =5  #define C_LOG_CAN_CHANNEL_0                  C_PHYS_CAN_CHANNEL_0
 238      =5  #define C_DISABLE_INT_OSCAT2
 239      =5  
 240      =5  #define C_DISABLE_WORK_AROUND_ERRATUM_3
 241      =5  
 242      =5  
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 149 

 243      =5  
 244      =5  /* begin Fileversion check */
 245      =5  #ifndef SKIP_MAGIC_NUMBER
 246      =5  #ifdef MAGIC_NUMBER
 247      =5    #if MAGIC_NUMBER != 204819919
           =5       #error "The magic number of the generated file <Y:\CANGEN\can_cfg.h> is different. Please check time
             - and date of generated files!"
           =5   #endif
 250      =5  #else
           =5   #define MAGIC_NUMBER 204819919
           =5 #endif  /* MAGIC_NUMBER */
 253      =5  #endif  /* SKIP_MAGIC_NUMBER */
 254      =5  
 255      =5  /* end Fileversion check */
 256      =5  
 257      =5  #endif /* __CAN_CFG_H__ */
  49      =4  #include "v_inc.h"
   1      =5  /* -----------------------------------------------------------------------------
   2      =5    Filename:    v_inc.h
   3      =5    Description: Toolversion: 05.00.51.01.30.02.86.01.00.00
   4      =5                 
   5      =5                 Serial Number: CBD1300286
   6      =5                 Customer Info: Hyundai Mobis Co., Ltd.
   7      =5                                Package: CBD Hmc SLP5 - CBD License f. HKMC
   8      =5                                Micro: C8051F582
   9      =5                                Compiler: Keil PK51
  10      =5                 
  11      =5                 
  12      =5                 Generator Fwk   : GENy 
  13      =5                 Generator Module: GenTool_GenyVcfgNameDecorator
  14      =5                 
  15      =5                 Configuration   : Y:\20150903_DiagCam_DE.gny
  16      =5                 
  17      =5                 ECU: 
  18      =5                         TargetSystem: Hw_Slc8051Cpu
  19      =5                         Compiler:     KEIL
  20      =5                         Derivates:    C8051F58x_59x
  21      =5                 
  22      =5                 Channel "Channel0":
  23      =5                         Databasefile: Y:\20150206_JF_DiagCamera_CAN_DB_R6(LangInfo).dbc
  24      =5                         Bussystem:    CAN
  25      =5                         Manufacturer: HMC
  26      =5                         Node:         PGS
  27      =5  
  28      =5    Generated by , 2015-10-19  18:50:07
  29      =5   ----------------------------------------------------------------------------- */
  30      =5  /* -----------------------------------------------------------------------------
  31      =5    C O P Y R I G H T
  32      =5   -------------------------------------------------------------------------------
  33      =5    Copyright (c) 2001-2011 by Vector Informatik GmbH. All rights reserved.
  34      =5   
  35      =5    This software is copyright protected and proprietary to Vector Informatik 
  36      =5    GmbH.
  37      =5    
  38      =5    Vector Informatik GmbH grants to you only those rights as set out in the 
  39      =5    license conditions.
  40      =5    
  41      =5    All other rights remain with Vector Informatik GmbH.
  42      =5   -------------------------------------------------------------------------------
  43      =5   ----------------------------------------------------------------------------- */
  44      =5  
  45      =5  #if !defined(__V_INC_H__)
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 150 

  46      =5  #define __V_INC_H__
  47      =5  
  48      =5  #include "can_inc.h"
   1      =6  /* STARTSINGLE_OF_MULTIPLE */
   2      =6  /* ***************************************************************************
   3      =6  | Project Name: CAN Driver
   4      =6  |    File Name: can_inc.h
   5      =6  |
   6      =6  |  Description: definition of can driver include files
   7      =6  |               Please adapt such that the compiler finds the following files:
   8      =6  |                            CAN_CFG.H
   9      =6  |                            CAN_DEF.H
  10      =6  |-----------------------------------------------------------------------------
  11      =6  |               C O P Y R I G H T
  12      =6  |-----------------------------------------------------------------------------
  13      =6  | Copyright (c) 2000-2006 by Vector Informatik GmbH.      All rights reserved.
  14      =6  |
  15      =6  | This software is copyright protected and proprietary 
  16      =6  | to Vector Informatik GmbH. Vector Informatik GmbH 
  17      =6  | grants to you only those rights as set out in the 
  18      =6  | license conditions. All other rights remain with 
  19      =6  | Vector Informatik GmbH.
  20      =6  |-----------------------------------------------------------------------------
  21      =6  |               A U T H O R   I D E N T I T Y
  22      =6  |-----------------------------------------------------------------------------
  23      =6  | Initials     Name                      Company
  24      =6  | --------     ---------------------     ------------------------------------
  25      =6  | Ht           Heike Honert              Vector Informatik GmbH
  26      =6  |-----------------------------------------------------------------------------
  27      =6  |               R E V I S I O N   H I S T O R Y
  28      =6  |-----------------------------------------------------------------------------
  29      =6  | Date         Ver  Author  Description
  30      =6  | ---------    ---  ------  --------------------------------------------------
  31      =6  | 08-Mai-01    1.0   Ht     creation
  32      =6  | 2003-01-28   1.1   Ht     protection from multiple include of this file
  33      =6  | 2006-03-23   1.2   Ht     include osek.h before can_def.h due to ISR-macro
  34      =6  |                           remove include of nm_cfg.h
  35      =6  | 2007-03-05   1.3   Ht     include v_par.h to support multiple ECU
  36      =6  | 2008-10-29   1.4   Ht     include cfg-files of higher layers
  37      =6  | 2010-06-21   1.5   Ht     support OSEK-OS
  38      =6  |************************************************************************** */
  39      =6  #ifndef _CAN_INC_H
  40      =6  #define _CAN_INC_H
  41      =6  
  42      =6  #include "can_cfg.h"               /* dependend configuration of the driver. */
   1      =7  /* -----------------------------------------------------------------------------
   2      =7    Filename:    can_cfg.h
   3      =7    Description: Toolversion: 05.00.51.01.30.02.86.01.00.00
   4      =7                 
   5      =7                 Serial Number: CBD1300286
   6      =7                 Customer Info: Hyundai Mobis Co., Ltd.
   7      =7                                Package: CBD Hmc SLP5 - CBD License f. HKMC
   8      =7                                Micro: C8051F582
   9      =7                                Compiler: Keil PK51
  10      =7                 
  11      =7                 
  12      =7                 Generator Fwk   : GENy 
  13      =7                 Generator Module: DrvCan__base
  14      =7                 
  15      =7                 Configuration   : Y:\20150903_DiagCam_DE.gny
  16      =7                 
  17      =7                 ECU: 
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 151 

  18      =7                         TargetSystem: Hw_Slc8051Cpu
  19      =7                         Compiler:     KEIL
  20      =7                         Derivates:    C8051F58x_59x
  21      =7                 
  22      =7                 Channel "Channel0":
  23      =7                         Databasefile: Y:\20150206_JF_DiagCamera_CAN_DB_R6(LangInfo).dbc
  24      =7                         Bussystem:    CAN
  25      =7                         Manufacturer: HMC
  26      =7                         Node:         PGS
  27      =7  
  28      =7    Generated by , 2015-10-19  18:50:07
  29      =7   ----------------------------------------------------------------------------- */
  30      =7  /* -----------------------------------------------------------------------------
  31      =7    C O P Y R I G H T
  32      =7   -------------------------------------------------------------------------------
  33      =7    Copyright (c) 2001-2011 by Vector Informatik GmbH. All rights reserved.
  34      =7   
  35      =7    This software is copyright protected and proprietary to Vector Informatik 
  36      =7    GmbH.
  37      =7    
  38      =7    Vector Informatik GmbH grants to you only those rights as set out in the 
  39      =7    license conditions.
  40      =7    
  41      =7    All other rights remain with Vector Informatik GmbH.
  42      =7   -------------------------------------------------------------------------------
  43      =7   ----------------------------------------------------------------------------- */
  44      =7  
  45      =7  #if !defined(__CAN_CFG_H__)
           =7 #define __CAN_CFG_H__
           =7 
           =7 #include "v_cfg.h"
           =7 #define HW_ST10CCANCPUCANDLL_VERSION         0x0228
           =7 #define HW_ST10CCANCPUCANDLL_RELEASE_VERSION 0x00
           =7 
           =7 #define HW__BASECPUCANDLL_VERSION            0x0226
           =7 #define HW__BASECPUCANDLL_RELEASE_VERSION    0x01
           =7 
           =7 #define DRVCAN__BASEDLL_VERSION              0x0322
           =7 #define DRVCAN__BASEDLL_RELEASE_VERSION      0x01
           =7 
           =7 #define DRVCAN__BASERI14DLL_VERSION          0x0209
           =7 #define DRVCAN__BASERI14DLL_RELEASE_VERSION  0x01
           =7 
           =7 #define DRVCAN__BASERI15DLL_VERSION          0x0105
           =7 #define DRVCAN__BASERI15DLL_RELEASE_VERSION  0x01
           =7 
           =7 #define DRVCAN__BASEHLLDLL_VERSION           0x0306
           =7 #define DRVCAN__BASEHLLDLL_RELEASE_VERSION   0x01
           =7 
           =7 #define DRVCAN__BASERI14HLLDLL_VERSION       0x0206
           =7 #define DRVCAN__BASERI14HLLDLL_RELEASE_VERSION 0x00
           =7 
           =7 #define DRVCAN__BASERI15HLLDLL_VERSION       0x0101
           =7 #define DRVCAN__BASERI15HLLDLL_RELEASE_VERSION 0x03
           =7 
           =7 #define CAN_DRV_ST10CCANDLL_VERSION          0x0223
           =7 #define CAN_DRV_ST10CCANDLL_RELEASE_VERSION  0x01
           =7 
           =7 
           =7 #define kCanNumberOfChannels                 1
           =7 #define kCanNumberOfHwChannels               1
           =7 #define kCanNumberOfPhysChannels             1
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 152 

           =7 #define C_DISABLE_MEMCOPY_SUPPORT
           =7 #define C_DISABLE_OSEK_OS
           =7 #define C_DISABLE_VARIABLE_DLC
           =7 #define C_DISABLE_DLC_FAILED_FCT
           =7 #define C_DISABLE_VARIABLE_RX_DATALEN
           =7 #define C_DISABLE_MULTI_ECU_CONFIG
           =7 #define C_DISABLE_MULTI_ECU_PHYS
           =7 #define C_DISABLE_EXTENDED_ID
           =7 #define C_DISABLE_MIXED_ID
           =7 #define C_DISABLE_RECEIVE_FCT
           =7 
           =7 #define C_DISABLE_ECU_SWITCH_PASS
           =7 #define C_ENABLE_TRANSMIT_QUEUE
           =7 #define C_DISABLE_OVERRUN
           =7 #define C_DISABLE_INTCTRL_BY_APPL
           =7 #define C_DISABLE_COMMON_CAN
           =7 #define C_ENABLE_USER_CHECK
           =7 #define C_ENABLE_HARDWARE_CHECK
           =7 #define C_ENABLE_GEN_CHECK
           =7 #define C_ENABLE_INTERNAL_CHECK
           =7 #define C_DISABLE_DYN_RX_OBJECTS
           =7 #define C_DISABLE_DYN_TX_OBJECTS
           =7 #define C_DISABLE_DYN_TX_ID
           =7 #define C_DISABLE_DYN_TX_DLC
           =7 #define C_DISABLE_DYN_TX_DATAPTR
           =7 #define C_DISABLE_DYN_TX_PRETRANS_FCT
           =7 #define C_DISABLE_DYN_TX_CONF_FCT
           =7 #define C_DISABLE_EXTENDED_STATUS
           =7 #define C_ENABLE_TX_OBSERVE
           =7 #define C_DISABLE_HW_LOOP_TIMER
           =7 #define C_DISABLE_NOT_MATCHED_FCT
           =7 #define C_SECURITY_LEVEL                     30
           =7 
           =7 #define C_DISABLE_MULTICHANNEL_API
           =7 #define C_ENABLE_PART_OFFLINE
           =7 #define C_DISABLE_RANGE_0
           =7 #define C_DISABLE_RANGE_1
           =7 #define C_DISABLE_RANGE_2
           =7 #define C_DISABLE_RANGE_3
           =7 #define ApplCanBusOff                        NmBasicCanBusOff
           =7 
           =7 #define kCanNumberOfTxObjects                1
           =7 #define kCanNumberOfTxStatObjects            1
           =7 #define kCanNumberOfTxDynObjects             0
           =7 #define kCanNumberOfRxObjects                8
           =7 #define kCanNumberOfRxStatFullCANObjects     8
           =7 #define kCanNumberOfRxStatBasicCANObjects    0
           =7 #define kCanNumberOfRxDynFullCANObjects      0
           =7 #define kCanNumberOfRxDynBasicCANObjects     0
           =7 #define kCanNumberOfRxDynObjects             0
           =7 #define kCanNumberOfRxStatObjects            8
           =7 #define kCanNumberOfConfFlags                0
           =7 #define kCanNumberOfIndFlags                 0
           =7 #define kCanNumberOfConfirmationFlags        0
           =7 #define kCanNumberOfIndicationFlags          0
           =7 #define kCanNumberOfInitObjects              1
           =7 #define kCanExtNumberOfInitObjects           0
           =7 #define kCanHwRxDynFullStartIndex            31
           =7 #define C_SEARCH_LINEAR
           =7 
           =7 #define C_ENABLE_RX_MSG_INDIRECTION
           =7 
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 153 

           =7 #define C_DISABLE_CONFIRMATION_FLAG
           =7 #define C_DISABLE_INDICATION_FLAG
           =7 #define C_DISABLE_PRETRANSMIT_FCT
           =7 #define C_ENABLE_CONFIRMATION_FCT
           =7 #define C_ENABLE_INDICATION_FCT
           =7 #define C_ENABLE_PRECOPY_FCT
           =7 #define C_ENABLE_COPY_TX_DATA
           =7 #define C_ENABLE_COPY_RX_DATA
           =7 #define C_ENABLE_DLC_CHECK
           =7 #define C_DISABLE_DLC_CHECK_MIN_DATALEN
           =7 
           =7 #define C_ENABLE_GENERIC_PRECOPY
           =7 #define APPL_CAN_GENERIC_PRECOPY             IlCanGenericPrecopy
           =7 
           =7 #define C_SEND_GRP_NONE                      0x00
           =7 #define C_SEND_GRP_ALL                       0xFF
           =7 #define C_SEND_GRP_APPL                      0x01
           =7 #define C_SEND_GRP_NM                        0x02
           =7 #define C_SEND_GRP_DIAG                      0x04
           =7 #define C_SEND_GRP_IL                        0x08
           =7 #define C_SEND_GRP_TP                        0x10
           =7 #define C_SEND_GRP_USER5                     0x20
           =7 #define C_SEND_GRP_USER6                     0x40
           =7 #define C_SEND_GRP_USER7                     0x80
           =7 #define C_ENABLE_CAN_CANCEL_NOTIFICATION
           =7 #define APPL_CAN_CANCELNOTIFICATION          IlCanCancelNotification
           =7 
           =7 #define kCanPhysToLogChannelIndex_0
           =7 #define C_ENABLE_RX_FULLCAN_OBJECTS
           =7 #define C_DISABLE_RX_BASICCAN_OBJECTS
           =7 #define kCanNumberOfRxFullCANObjects         8
           =7 
           =7 #define kCanNumberOfRxBasicCANObjects        0
           =7 #define kCanNumberOfUsedRxBasicCANObjects    2
           =7 
           =7 #define kCanInitObj1                         0
           =7 #define C_DISABLE_TX_MASK_EXT_ID
           =7 #define C_DISABLE_RX_MASK_EXT_ID
           =7 #define C_MASK_EXT_ID                        0xFFFFFFFF
           =7 
           =7 #define C_ENABLE_CAN_CAN_INTERRUPT_CONTROL
           =7 #define C_DISABLE_CAN_TX_CONF_FCT
           =7 
           =7 #define C_DISABLE_TX_POLLING
           =7 #define C_DISABLE_RX_BASICCAN_POLLING
           =7 #define C_DISABLE_RX_FULLCAN_POLLING
           =7 #define C_DISABLE_ERROR_POLLING
           =7 #define C_DISABLE_WAKEUP_POLLING
           =7 #define C_DISABLE_FULLCAN_OVERRUN
           =7 #define C_DISABLE_OSEK_OS_INTCAT2
           =7 #define C_DISABLE_COPY_RX_DATA_WITH_DLC
           =7 #define kCanTxQueueBytes                     1
           =7 #define kCanNumberOfMaxBasicCAN              1
           =7 #define kCanNumberOfHwObjPerBasicCan         2
           =7 #define C_DISABLE_CAN_RAM_CHECK
           =7 #define C_DISABLE_SLEEP_WAKEUP
           =7 #define C_DISABLE_CANCEL_IN_HW
           =7 #define C_DISABLE_ONLINE_OFFLINE_CALLBACK_FCT
           =7 
           =7 #define kCanChannel_Channel0                 0
           =7 #define C_DISABLE_INTCTRL_ADD_CAN_FCT
           =7 #if defined(C_SINGLE_RECEIVE_BUFFER) || defined(C_MULTIPLE_RECEIVE_BUFFER)
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 154 

           =7 #error "DrvCan__baseRI1.5 doesn't support Single/Multiple Receive Buffer API for the callback 'ApplCanMsgR
             -eceived'!"
           =7 #endif
           =7 
           =7 #define C_DISABLE_RETRANSMIT
           =7 #define kCanNumberOfUsedCanTxIdTables        1
           =7 #define kCanNumberOfUsedCanRxIdTables        1
           =7 #define kCanHwTxStartIndex                   1
           =7 
           =7 #define kCanHwUnusedStartIndex               3
           =7 
           =7 #define kCanHwRxFullStartIndex               23
           =7 
           =7 #define kCanHwRxBasicStartIndex              31
           =7 
           =7 #define kCanNumberOfUsedTxCANObjects         2
           =7 
           =7 #define kCanNumberOfUnusedObjects            20
           =7 
           =7 #define kCanNumberOfTxDirectObjects          1
           =7 
           =7 #define C_ENABLE_TX_FULLCAN_OBJECTS
           =7 
           =7 
           =7 #define kCanHwTxNormalIndex                  2
           =7 
           =7 #define C_ENABLE_HW_OBJ_EXCEED_255_CFG
           =7 #define C_DISABLE_INDIVIDUAL_POLLING
           =7 #define kCanNumberOfHwObjIndivPolling        33
           =7 
           =7 #define kCanBasisAdr                         0xC0
           =7 #define kCanNumberOfMsgObjects               32
           =7 #define C_PHYS_CAN_CHANNEL_0                 0
           =7 #define kCanChannelIndex_0                   0
           =7 #define C_LOG_CAN_CHANNEL_0                  C_PHYS_CAN_CHANNEL_0
           =7 #define C_DISABLE_INT_OSCAT2
           =7 
           =7 #define C_DISABLE_WORK_AROUND_ERRATUM_3
           =7 
           =7 
           =7 
           =7 /* begin Fileversion check */
           =7 #ifndef SKIP_MAGIC_NUMBER
           =7 #ifdef MAGIC_NUMBER
           =7   #if MAGIC_NUMBER != 204819919
           =7       #error "The magic number of the generated file <Y:\CANGEN\can_cfg.h> is different. Please check time
             - and date of generated files!"
           =7   #endif
           =7 #else
           =7   #define MAGIC_NUMBER 204819919
           =7 #endif  /* MAGIC_NUMBER */
           =7 #endif  /* SKIP_MAGIC_NUMBER */
           =7 
           =7 /* end Fileversion check */
           =7 
           =7 #endif /* __CAN_CFG_H__ */
  43      =6                                     /* configuration file.                   */
  44      =6  
  45      =6  #if defined( VGEN_ENABLE_TP_VW20 )
           =6  #include "tp20vcfg.h"             /* configuration file of transport layer */
           =6 #endif
  48      =6   
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 155 

  49      =6  #if defined ( VGEN_ENABLE_NM_OSEK_D )
           =6  #include "nm_cfg.h"               /* configuration file of NM DirOsek      */
           =6 #endif
  52      =6   
  53      =6  #if defined ( VGEN_ENABLE_NMHIGH )
           =6  #include "nmh_cfg.h"              /* configuration file of NM High         */
           =6 #endif
  56      =6  
  57      =6  #if defined( C_ENABLE_OSEK_OS )
           =6 # if defined(V_OSTYPE_OSEK)
           =6 #  include "osek.h"                 /* include of OSEK-Header */
           =6 # endif
           =6 # if defined(V_OSTYPE_AUTOSAR)
           =6 #  include "Os.h"
           =6 # endif
           =6 #endif
  65      =6  
  66      =6  #if defined( VGEN_GENY )
  67      =6  # include "v_par.h"                 /* some vector internal defines          */
   1      =7  /* -----------------------------------------------------------------------------
   2      =7    Filename:    v_par.h
   3      =7    Description: Toolversion: 05.00.51.01.30.02.86.01.00.00
   4      =7                 
   5      =7                 Serial Number: CBD1300286
   6      =7                 Customer Info: Hyundai Mobis Co., Ltd.
   7      =7                                Package: CBD Hmc SLP5 - CBD License f. HKMC
   8      =7                                Micro: C8051F582
   9      =7                                Compiler: Keil PK51
  10      =7                 
  11      =7                 
  12      =7                 Generator Fwk   : GENy 
  13      =7                 Generator Module: GenTool_GenyVcfgNameDecorator
  14      =7                 
  15      =7                 Configuration   : Y:\20150903_DiagCam_DE.gny
  16      =7                 
  17      =7                 ECU: 
  18      =7                         TargetSystem: Hw_Slc8051Cpu
  19      =7                         Compiler:     KEIL
  20      =7                         Derivates:    C8051F58x_59x
  21      =7                 
  22      =7                 Channel "Channel0":
  23      =7                         Databasefile: Y:\20150206_JF_DiagCamera_CAN_DB_R6(LangInfo).dbc
  24      =7                         Bussystem:    CAN
  25      =7                         Manufacturer: HMC
  26      =7                         Node:         PGS
  27      =7  
  28      =7    Generated by , 2015-10-19  18:50:07
  29      =7   ----------------------------------------------------------------------------- */
  30      =7  /* -----------------------------------------------------------------------------
  31      =7    C O P Y R I G H T
  32      =7   -------------------------------------------------------------------------------
  33      =7    Copyright (c) 2001-2011 by Vector Informatik GmbH. All rights reserved.
  34      =7   
  35      =7    This software is copyright protected and proprietary to Vector Informatik 
  36      =7    GmbH.
  37      =7    
  38      =7    Vector Informatik GmbH grants to you only those rights as set out in the 
  39      =7    license conditions.
  40      =7    
  41      =7    All other rights remain with Vector Informatik GmbH.
  42      =7   -------------------------------------------------------------------------------
  43      =7   ----------------------------------------------------------------------------- */
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 156 

  44      =7  
  45      =7  #if !defined(__V_PAR_H__)
  46      =7  #define __V_PAR_H__
  47      =7  
  48      =7  /* -----------------------------------------------------------------------------
  49      =7      &&&~ BaseEnv_PHF_Includes
  50      =7   ----------------------------------------------------------------------------- */
  51      =7  
  52      =7  #include "v_cfg.h"
   1      =8  /* -----------------------------------------------------------------------------
   2      =8    Filename:    v_cfg.h
   3      =8    Description: Toolversion: 05.00.51.01.30.02.86.01.00.00
   4      =8                 
   5      =8                 Serial Number: CBD1300286
   6      =8                 Customer Info: Hyundai Mobis Co., Ltd.
   7      =8                                Package: CBD Hmc SLP5 - CBD License f. HKMC
   8      =8                                Micro: C8051F582
   9      =8                                Compiler: Keil PK51
  10      =8                 
  11      =8                 
  12      =8                 Generator Fwk   : GENy 
  13      =8                 Generator Module: GenTool_GenyVcfgNameDecorator
  14      =8                 
  15      =8                 Configuration   : Y:\20150903_DiagCam_DE.gny
  16      =8                 
  17      =8                 ECU: 
  18      =8                         TargetSystem: Hw_Slc8051Cpu
  19      =8                         Compiler:     KEIL
  20      =8                         Derivates:    C8051F58x_59x
  21      =8                 
  22      =8                 Channel "Channel0":
  23      =8                         Databasefile: Y:\20150206_JF_DiagCamera_CAN_DB_R6(LangInfo).dbc
  24      =8                         Bussystem:    CAN
  25      =8                         Manufacturer: HMC
  26      =8                         Node:         PGS
  27      =8  
  28      =8    Generated by , 2015-10-19  18:50:07
  29      =8   ----------------------------------------------------------------------------- */
  30      =8  /* -----------------------------------------------------------------------------
  31      =8    C O P Y R I G H T
  32      =8   -------------------------------------------------------------------------------
  33      =8    Copyright (c) 2001-2011 by Vector Informatik GmbH. All rights reserved.
  34      =8   
  35      =8    This software is copyright protected and proprietary to Vector Informatik 
  36      =8    GmbH.
  37      =8    
  38      =8    Vector Informatik GmbH grants to you only those rights as set out in the 
  39      =8    license conditions.
  40      =8    
  41      =8    All other rights remain with Vector Informatik GmbH.
  42      =8   -------------------------------------------------------------------------------
  43      =8   ----------------------------------------------------------------------------- */
  44      =8  
  45      =8  #if !defined(__V_CFG_H__)
           =8 #define __V_CFG_H__
           =8 
           =8 #ifndef VGEN_GENY
           =8 #define VGEN_GENY
           =8 #endif
           =8 
           =8 #ifndef GENy
           =8 #define GENy
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 157 

           =8 #endif
           =8 
           =8 #ifndef SUPPLIER_CANBEDDED
           =8 #define SUPPLIER_CANBEDDED                   30
           =8 #endif
           =8 
           =8 /* -----------------------------------------------------------------------------
           =8     &&&~ Version
           =8  ----------------------------------------------------------------------------- */
           =8 
           =8 #ifndef VERSIONNUMBER
           =8 #define VERSIONNUMBER                        0x178
           =8 #endif
           =8 
           =8 
           =8 
           =8 /* -----------------------------------------------------------------------------
           =8     &&&~ General Switches
           =8  ----------------------------------------------------------------------------- */
           =8 
           =8 #ifndef V_OSTYPE_NONE
           =8 #define V_OSTYPE_NONE
           =8 #endif
           =8 
           =8 
           =8 
           =8 /* -----------------------------------------------------------------------------
           =8     &&&~ Processor specific
           =8  ----------------------------------------------------------------------------- */
           =8 
           =8 #ifndef C_CPUTYPE_8BIT
           =8 #define C_CPUTYPE_8BIT
           =8 #endif
           =8 
           =8 
           =8 #ifndef V_CPUTYPE_BITARRAY_16BIT
           =8 #define V_CPUTYPE_BITARRAY_16BIT
           =8 #endif
           =8 
           =8 
           =8 #ifndef C_CPUTYPE_BIGENDIAN
           =8 #define C_CPUTYPE_BIGENDIAN
           =8 #endif
           =8 
           =8 
           =8 #ifndef C_CPUTYPE_BITORDER_LSB2MSB
           =8 #define C_CPUTYPE_BITORDER_LSB2MSB
           =8 #endif
           =8 
           =8 
           =8 #ifndef V_DISABLE_USE_DUMMY_FUNCTIONS
           =8 #define V_DISABLE_USE_DUMMY_FUNCTIONS
           =8 #endif
           =8 
           =8 
           =8 #ifndef V_ENABLE_USE_DUMMY_STATEMENT
           =8 #define V_ENABLE_USE_DUMMY_STATEMENT
           =8 #endif
           =8 
           =8 
           =8 #ifndef C_COMP_KEIL_SLC8051_CCAN
           =8 #define C_COMP_KEIL_SLC8051_CCAN
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 158 

           =8 #endif
           =8 
           =8 
           =8 #ifndef V_CPU_SLC8051
           =8 #define V_CPU_SLC8051
           =8 #endif
           =8 
           =8 #ifndef V_COMP_KEIL
           =8 #define V_COMP_KEIL
           =8 #endif
           =8 
           =8 #ifndef V_COMP_KEIL_SLC8051
           =8 #define V_COMP_KEIL_SLC8051
           =8 #endif
           =8 
           =8 #ifndef V_PROCESSOR_C8051F58X_59X
           =8 #define V_PROCESSOR_C8051F58X_59X
           =8 #endif
           =8 
           =8 
           =8 #ifndef C_PROCESSOR_C8051F58X_59X
           =8 #define C_PROCESSOR_C8051F58X_59X
           =8 #endif
           =8 
           =8 
           =8 
           =8 
           =8 /* -----------------------------------------------------------------------------
           =8     &&&~ Used Modules
           =8  ----------------------------------------------------------------------------- */
           =8 
           =8 #define VGEN_ENABLE_DIAG_CANDESC_UDS
           =8 #ifndef VGEN_ENABLE_VSTDLIB
           =8 #define VGEN_ENABLE_VSTDLIB
           =8 #endif
           =8 
           =8 #ifndef VSTD_ENABLE_DEFAULT_INTCTRL
           =8 #define VSTD_ENABLE_DEFAULT_INTCTRL
           =8 #endif
           =8 
           =8 #ifndef VSTD_ENABLE_GLOBAL_LOCK
           =8 #define VSTD_ENABLE_GLOBAL_LOCK
           =8 #endif
           =8 
           =8 #ifndef VSTD_DISABLE_DEBUG_SUPPORT
           =8 #define VSTD_DISABLE_DEBUG_SUPPORT
           =8 #endif
           =8 
           =8 #ifndef VSTD_ENABLE_LIBRARY_FUNCTIONS
           =8 #define VSTD_ENABLE_LIBRARY_FUNCTIONS
           =8 #endif
           =8 
           =8 
           =8 #define VGEN_ENABLE_CAN_DRV
           =8 #define C_ENABLE_CAN_CHANNELS
           =8 #define V_BUSTYPE_CAN
           =8 #define VGEN_ENABLE_IL_VECTOR
           =8 #define VGEN_ENABLE_NM_BASIC
           =8 #define VGEN_ENABLE_TP_ISO_MC
           =8 
           =8 
           =8 #ifndef kVNumberOfIdentities
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 159 

           =8 #define kVNumberOfIdentities                 1
           =8 #endif
           =8 
           =8 #ifndef tVIdentityMsk
           =8 #define tVIdentityMsk                        vuint8
           =8 #endif
           =8 
           =8 #ifndef kVIdentityIdentity_0
           =8 #define kVIdentityIdentity_0                 (vuint8) 0
           =8 #endif
           =8 
           =8 #ifndef VSetActiveIdentity
           =8 #define VSetActiveIdentity(identityLog)
           =8 #endif
           =8 
           =8 #ifndef V_ACTIVE_IDENTITY_MSK
           =8 #define V_ACTIVE_IDENTITY_MSK                1
           =8 #endif
           =8 
           =8 #ifndef V_ACTIVE_IDENTITY_LOG
           =8 #define V_ACTIVE_IDENTITY_LOG                0
           =8 #endif
           =8 
           =8 
           =8 #define DIAG_API_CALL_TYPE
           =8 #define DIAG_API_CALLBACK_TYPE
           =8 #define DIAG_INTERNAL_CALL_TYPE
           =8 #define DRV_API_CALL_TYPE
           =8 #define DRV_API_CALLBACK_TYPE
           =8 #define TP_API_CALL_TYPE
           =8 #define TP_API_CALLBACK_TYPE
           =8 #define TP_INTERNAL_CALL_TYPE
           =8 
           =8 /* -----------------------------------------------------------------------------
           =8     &&&~ Versions of Preconfig Files
           =8  ----------------------------------------------------------------------------- */
           =8 
           =8 #define VGEN_OEM_PRECONFIG_HMC_SLP5
           =8 #define VGEN_OEM_PRECONFIG_VERSION           0x0101
           =8 #define VGEN_OEM_PRECONFIG_RELEASE_VERSION   0x00
           =8 #define VGEN_USER_PRECONFIG_HMC_SLP5_HIGH_SPEED
           =8 #define VGEN_USER_PRECONFIG_VERSION          0x0000
           =8 #define VGEN_USER_PRECONFIG_RELEASE_VERSION  0x00
           =8 
           =8 
           =8 /* -----------------------------------------------------------------------------
           =8     &&&~ Optimization
           =8  ----------------------------------------------------------------------------- */
           =8 
           =8 #define V_ATOMIC_BIT_ACCESS_IN_BITFIELD      STD_OFF
           =8 #define V_ATOMIC_VARIABLE_ACCESS             16
           =8 
           =8 
           =8 
           =8 #ifndef VGEN_ENABLE_VSTDLIB
           =8 /* Diag_CanDesc requires VSTDLIB */
           =8 #define VGEN_ENABLE_VSTDLIB
           =8 #endif
           =8 
           =8 #ifndef C_CLIENT_HMC
           =8 #define C_CLIENT_HMC
           =8 #endif
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 160 

           =8 
           =8 #ifndef __PGS__
           =8 #define __PGS__
           =8 #endif
           =8 
           =8 /* -----------------------------------------------------------------------------
           =8     &&&~ Compatibility defines for ComSetCurrentECU
           =8  ----------------------------------------------------------------------------- */
           =8 
           =8 #ifndef kComNumberOfNodes
           =8 #define kComNumberOfNodes                    kVNumberOfIdentities
           =8 #endif
           =8 
           =8 #ifndef ComSetCurrentECU
           =8 #define ComSetCurrentECU                     VSetActiveIdentity
           =8 #endif
           =8 
           =8 #ifndef comMultipleECUCurrent
           =8 #define comMultipleECUCurrent                vActiveIdentityLog
           =8 #endif
           =8 
           =8 
           =8 
           =8 #define C_VERSION_REF_IMPLEMENTATION         0x150
           =8 
           =8 
           =8 #ifndef VGEN_ENABLE_VSTDLIB
           =8 /* DrvCan__baseRi15 requires VSTDLIB */
           =8 #define VGEN_ENABLE_VSTDLIB
           =8 #endif
           =8 
           =8 #ifndef VGEN_ENABLE_VSTDLIB
           =8 #define VGEN_ENABLE_VSTDLIB
           =8 #endif
           =8 
           =8 
           =8 #ifndef VGEN_ENABLE_VSTDLIB
           =8 /* TpMC requires VSTDLIB */
           =8 #define VGEN_ENABLE_VSTDLIB
           =8 #endif
           =8 
           =8 
           =8 
           =8 /* begin Fileversion check */
           =8 #ifndef SKIP_MAGIC_NUMBER
           =8 #ifdef MAGIC_NUMBER
           =8   #if MAGIC_NUMBER != 204819919
           =8       #error "The magic number of the generated file <Y:\CANGEN\v_cfg.h> is different. Please check time a
             -nd date of generated files!"
           =8   #endif
           =8 #else
           =8   #define MAGIC_NUMBER 204819919
           =8 #endif  /* MAGIC_NUMBER */
           =8 #endif  /* SKIP_MAGIC_NUMBER */
           =8 
           =8 /* end Fileversion check */
           =8 
           =8 #endif /* __V_CFG_H__ */
  53      =7  #include "v_def.h"
   1      =8  /* STARTSINGLE_OF_MULTIPLE */
   2      =8  /*****************************************************************************
   3      =8  | Project Name: V E C T O R   -  Common module type definition header
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 161 

   4      =8  |    File Name: v_def.h
   5      =8  |
   6      =8  |  Description: Declares types and definitions common to all 
   7      =8  |               VECTOR CANbedded modules.
   8      =8  | 
   9      =8  |               Note:
  10      =8  |               =====
  11      =8  |               that some hardware dependent settings are included in this file.
  12      =8  |               Never mix up files with same namings but intended for 
  13      =8  |               other hardware platforms.
  14      =8  |
  15      =8  |
  16      =8  |-----------------------------------------------------------------------------
  17      =8  |               C O P Y R I G H T
  18      =8  |-----------------------------------------------------------------------------
  19      =8  | Copyright (c) 2013 by Vector Informatik GmbH.       All rights reserved.
  20      =8  |
  21      =8  | This software is copyright protected and proprietary 
  22      =8  | to Vector Informatik GmbH. Vector Informatik GmbH 
  23      =8  | grants to you only those rights as set out in the 
  24      =8  | license conditions. All other rights remain with 
  25      =8  | Vector Informatik GmbH.
  26      =8  |
  27      =8  |-----------------------------------------------------------------------------
  28      =8  |               A U T H O R   I D E N T I T Y
  29      =8  |-----------------------------------------------------------------------------
  30      =8  | Initials     Name                      Company
  31      =8  | --------     ---------------------     ------------------------------------
  32      =8  |   Hp         Armin Happel              Vector Informatik GmbH
  33      =8  |   Ht         Heike Honert              Vector Informatik GmbH
  34      =8  |   dH         Gunnar de Haan            Vector Informatik GmbH
  35      =8  |   Et         Thomas Ebert              Vector Informatik GmbH
  36      =8  |   Wr         Hans Waaser               Vector Informatik GmbH
  37      =8  |   Vg         Frank Voorburg            Vector CANtech, Inc.
  38      =8  |   Ds         Hussain Darwish           Vector CANtech, Inc.
  39      =8  |   RAP        Rebecca Pipkorn           Vector CANtech, Inc.
  40      =8  |   BWR        Brandon Root              Vector CANtech, Inc.
  41      =8  |   Ml         Patrick Markl             Vector Informatik GmbH
  42      =8  |   Pl         Georg Pfluegel            Vector Informatik GmbH
  43      =8  |   LS         Konrad Lazarus            Vector Informatik GmbH
  44      =8  |   Zw         Werner Ziegler            Vector Informatik GmbH
  45      =8  |   Bs         Thomas Balster            Vector Informatik GmbH
  46      =8  |   Stu        Bernd Stumpf              Vector Informatik GmbH
  47      =8  |   Pet        Thomas Petrus             Vector Informatik GmbH
  48      =8  |   To         Torsten Schmidt           Vector Informatik GmbH
  49      =8  |   Ap         Andreas Pick              Vector Informatik GmbH
  50      =8  |   Tri        Frank Triem               Vector Informatik GmbH
  51      =8  |   WM         Marco Wierer              Vector Informatik GmbH
  52      =8  |   Bir        Holger Birke              Vector Informatik GmbH
  53      =8  |   Ces        Senol Cendere             Vector Informatik GmbH
  54      =8  |   Ms         Gunnar Meiss              Vector Informatik GmbH
  55      =8  |   Ths        Thomas Sommer             Vector Informatik GmbH
  56      =8  |   Krt        Kerstin Thim              Vector Informatik GmbH
  57      =8  |   Fn         Matthias Fleischmann      Vector Informatik GmbH
  58      =8  |   Svh        Sven Hesselmann           Vector Informatik GmbH
  59      =8  |   Ard        Thomas Arnold             Vector Informatik GmbH
  60      =8  |   Her        Peter Herrmann            Vector Informatik GmbH
  61      =8  |   swk        Slawomir Wilk             Vector Informatik GmbH
  62      =8  |   Ou         Mihai Olariu              Vector Informatik GmbH
  63      =8  |   Tvi        Timo Vanoni               Vector Informatik GmbH
  64      =8  |   Kk         Karol Kostolny            Vector Informatik GmbH
  65      =8  |   Aj         Arthur Jendrusch          Vector Informatik GmbH
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 162 

  66      =8  |   vadaba     Abir Bazzi                Vector CANtech, Inc
  67      =8  |   Rna        Ruediger Naas             Vector Informatik GmbH
  68      =8  |   Eta        Edgar Tongoona            Vector Informatik GmbH
  69      =8  |   Rse        Robert Schelkle           Vector Informatik GmbH
  70      =8  |   Seu        Eugen Stripling           Vector Informatik GmbH
  71      =8  |   Was        Andreas Weinrauch         Vector Informatik GmbH
  72      =8  |   QPs        Quetty Palacios           Vector Informatik GmbH
  73      =8  |   Tkr        Torsten Kercher           Vector Informatik GmbH
  74      =8  |   Bmo        Bastian Molkenthin        Vector Informatik GmbH
  75      =8  |-----------------------------------------------------------------------------
  76      =8  |               R E V I S I O N   H I S T O R Y
  77      =8  |-----------------------------------------------------------------------------
  78      =8  | Date       Ver    Author  Description
  79      =8  | ---------  ----   ------  --------------------------------------------------
  80      =8  | 13-Mar-01  1.00    Hp     Creation
  81      =8  | 04-Apr-01  1.01    Ht     general rework 
  82      =8  | 05-Apr-01  1.02    dH     added Fujitsu FFMC16LX
  83      =8  | 05-Apr-01  1.03    HH     added COMP_GHS_V85X
  84      =8  | 11-Apr-01  1.04    Et     added LIN components
  85      =8  | 23-Apr-01  1.05    Si     corrections for C_COMP_IAR_78K0
  86      =8  |                           lint comments added
  87      =8  | 29-Mai-01  1.06    Pl     added ARM7 STMICRO
  88      =8  | 22-Jun-01  1.07    Ht     added ANSI CANoe
  89      =8  | 03-Jul-01          Wr     added C_COMP_OKI_CC665S
  90      =8  | 12-Jul-01          Et     support combination of "old" CAN driver and "new" LIN driver
  91      =8  | 13-Jul-01  1.08    Ht     error check for supported systems and switches added
  92      =8  | 16-Jul-01          dH     added C_COMP_HEW_SH7055 / C_COMP_HEW_H8S
  93      =8  | 17-Aug-01  1.09    Et     deleted keywords __near and __far for C_COMP_FUJITSU_8L
  94      =8  | 21-Aug-01  1.10    Ht/Vg  added C_COMP_DIABDATA_PPC
  95      =8  | 25-Aug-01  1.11    Ml     added #pragma MESSAGE DISABLE C1106 for Hiware HC08 compiler
  96      =8  | 06-Sep-01  1.12    Ht/Vg  added C_COMP_GNU_ST9
  97      =8  | 11-Sep-01  1.13    Fr     added C_COMP_ANSI_TMS_470
  98      =8  | 21-Sep-01  1.14    Pl     added C_COMP_MCP18_PIC_INT
  99      =8  | 25-Sep-01  1.15    Vg     added C_COMP_MICROTEC_MC376 and C_COMP_TASKING_MC376
 100      =8  | 28-Sep-01  1.16    Hp     added C_COMP_GHS_TX39 and C_COMP_TOSHIBA_TLC900
 101      =8  | 23-Oct-01  1.17    Js     added C_COMP_DIABDATA_MCORE
 102      =8  | 23-Oct-01  1.18    dH     changed ..._SH705X to ..._SH705X
 103      =8  | 05-Nov-01  1.19    dH     added M32R
 104      =8  | 19-Nov-01  1.20    Ht     added C_COMP_xxx_XC16X
 105      =8  | 22-Nov-01  1.21    dH     added C_COMP_IAR_H8S
 106      =8  | 11-Nov-01  1.22    Fz     added C_COMP_MITSUBISHI_M32C/C_COMP_NEC_V85X
 107      =8  | 19-Dec-01  1.23    dH     changed Fujitsu FFMC16LX
 108      =8  | 28-Jan-02  1.24    Ml     ESCAN00002160: added paging keywords for HC12
 109      =8  | 31-Jan-02  1.25    Pl     added C_COMP_KEIL_T89C51C
 110      =8  | 07-Mar-02  1.26    Vg/Rn  added C_COMP_METROWERKS_PPC
 111      =8  | 27-Mar-02  1.27    Fz     added C_COMP_IAR_V85X
 112      =8  | 09-Apr-02  1.28    Ht     addaption to LI 1.3
 113      =8  | 02-Apr-02  1.29    Ml     added C_COMP_METROWERKS_MGT5100
 114      =8  |                           added C_COMP_METROWERKS_DSP56F80X
 115      =8  | 13-May-02  1.30    LS     MEMORY_HUGE added for C_COMP_TASKING_C16X
 116      =8  | 21-May-02  1.31    Ml     canbittype for HC12 is now unsigned short
 117      =8  | 10-Jul-02  1.32    Ml     canbittype for HC12 changed to unsigned char
 118      =8  | 16-Jul-02  1.33a   Fz     canbittype for V850 changed to unsigend int
 119      =8  |                           _c_bits32 added  
 120      =8  | 31-Jul-02          Ts     added C_COMP_HEW_SH70XX_HCAN2
 121      =8  | 31-Jul-02  1.33    Ht     _c_bits16 added for C_CPUTYPE_BITORDER_MSB2LSB
 122      =8  | 31-Jul-02  1.34    Si     pc-lint comments for 78K0 changed
 123      =8  | 02-Aug-02  1.33    Sf     ESCAN00003192  Memory qualifier for M16C changed
 124      =8  | 08-Aug-02  1.34    Zw     ESCAN00003456  added STmicro ST7 (beCAN) / Hiware
 125      =8  | 18-Aug-02          Pet    ESCAN00003530  delete keyword near for HC08
 126      =8  | 06-Sep-02  1.35    Zw     ESCAN00003688: MEMORY_NEAR defined to nothing for ST7_beCAN
 127      =8  | 09-Sep-02  1.36    Bs     controller OKI MSM9225B (C_COMP_GHS_ARM7TM) added (needed for FBL)
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 163 

 128      =8  | 10-Sep-02  1.37    Ds     added C_COMP_COSMIC_ST7_BECAN
 129      =8  |                           and   C_COMP_HIWARE_ST7_BECAN
 130      =8  | 13-Sep-02  1.38    Ht     rework the module
 131      =8  | 17-Sep-02  1.39    Stu    add the C_COMP_NEC_78K0
 132      =8  | 17-Sep-02  1.40    Vg     ESCAN00003614 added __declspec() to place const 
 133      =8  |                           variables into ROM for Metrowerks
 134      =8  | 18-Sep-02  1.41    Stu    added C_COMP_NEC_78K0
 135      =8  | 07-Oct-02  1.42    dH     added C_COMP_GAIO_SH705X
 136      =8  | 11-Oct-02  1.43    dH     added C_COMP_FUJITSU_16LX_HL
 137      =8  | 14-Oct-02  1.44    Ml     changed vbittype for MGT5100 into unsigned short
 138      =8  | 14-Oct-02  1.45    Stu    changed vbittype for 78k0 into unsigned char
 139      =8  | 18-Oct-02  1.46    Pl     added C_COMP_TASKING_ST10_CCAN 
 140      =8  |                           added C_COMP_ARM_ST30_CCAN 
 141      =8  | 30-Oct-02  1.47    Ml     added C_COMP_ARM_470 and C_COMP_TI_470
 142      =8  | 06-Nov-02  1.48    Wr     added C_COMP_NATIONAL_CR16 
 143      =8  | 07-Nov-02  1.49    RAP    added C_COMP_DIABDATA_MPC823
 144      =8  |                    RAP    added C_COMP_GHS_STARFISH
 145      =8  | 14-Nov-02  1.50    An     corrected the banking defines for Cosmic and Hiware
 146      =8  | 27-Nov-02  1.50    Pl     added C_COMP_FUJITSU_FR50
 147      =8  | 02-Dec-02  1.51    Si     MEMORY_NEAR changed for C_COMP_NEC_78K0
 148      =8  | 11-Dec-02          Pet    added C_COMP_IAR_CEVF
 149      =8  | 18-Dec-02  1.52    Si     added C_COMP_NEC_78K0
 150      =8  | 04-Jan-03          Et     added memory qualifier for C_COMP_IAR_CEVF
 151      =8  | 22-Jan-03          Ap     added C_COMP_ARM_EASYCAN
 152      =8  | 28-Jan-03  1.53    Pl     added C_COMP_KEIL_ST10_CCAN
 153      =8  |                           delete C_COMP_ARM_ARM7STM
 154      =8  | 03-Apr-04  1.54    To     added C_COMP_METROWERKS_DSP5683X
 155      =8  |                    ZW     canbittype for CEVG is now unsigned char
 156      =8  |                    Hp     Add MEMORY_HUGE for XC16x
 157      =8  |                    Fz     added  C_COMP_IAR_CR16 and C_COMP_NATIONAL_CR16 changed
 158      =8  |                    Ml     added  C_COMP_TI_TMS320
 159      =8  | 2003-05-13 1.60    Ht     support V_MEMROM0
 160      =8  | 2003-05-14 1.61    Tri    added V_MEMROM0 definition for MGT5100
 161      =8  | 2003-05-15 1.62    Pl     added C_COMP_FUJITSU_FR60_CCAN
 162      =8  | 2003-05-20 1.63    WM     added near/far memory defines for C_COMP_HIWARE_12
 163      =8  | 2003-06-11 1.64    CB     MEMORY_HUGE added for C_COMP_TASKING_ST10_CCAN    
 164      =8  | 2003-06-18 1.65    Bir    added C_COMP_MICROCHIP_DSPIC30
 165      =8  | 2003-07-08 1.66    Bir    no local lint command
 166      =8  | 2003-08-15 1.67    Rr     changed MEMORY_FAR for M32C
 167      =8  | 2003-08-18 1.68    BWR    added support for MAC710X
 168      =8  | 2003-09-02 1.69    BWR    added support for MC332 with external Intel 82527 
 169      =8  | 2003-09-09 1.70    Bir    added C_COMP_TASKING_TRICORE_MULTICAN & C_COMP_GNU_TRICORE_MULTICAN
 170      =8  | 2003-10-30 1.71    RAP    added C_COMP_MICROCHIP_PIC18
 171      =8  | 2003-11-13 2.00    Ht     memory qualifier changed to new definition
 172      =8  | 2004-01-08 2.01    BWR    added support for MPC55XX 
 173      =8  | 2004-01-16 2.02    Ml     added cast macros
 174      =8  | 2004-01-22 2.03    dH     added C_COMP_HEW_SH2_HCAN1 and C_COMP_HEW_H8S_HCAN1
 175      =8  | 2004-02-13 2.04    WM     Added banking support for C_COMP_IAR_12
 176      =8  | 2004-02-18 2.05    RAP    Update for C_COMP_MICROCHIP_PIC18
 177      =8  | 2004-03-12 2.06    Ml     changed canbittype for TMS470
 178      =8  | 2004-03-13 2.07    dH     added C_COMP_HEW_H8TINY
 179      =8  | 2004-04-20 2.08    dH     added C_COMP_HEW_H8SX_HCAN1
 180      =8  | 2004-04-08 2.09    Rna    Memoryclassifier V_MEMROM0 and MEMORY_ROM for Metrowerks PPC changed
 181      =8  | 2004-05-14 2.10    Ms     added Release Version define
 182      =8  |                           added include for vstdlib.h
 183      =8  | 2004-05-18 2.11    Ml     changed plattform check to work in any case (NO_ELSE)
 184      =8  |                    Ml     added V_NULL
 185      =8  | 2004-06-17 2.12    Ms     changed C_COMP_SUPPORTED_PLATTFORM -> V_COMP_SUPPORTED_PLATTFORM
 186      =8  | 2004-06-26 2.13    RAP    added C_COMP_GHS_SJA2020
 187      =8  | 2004-06-30 2.14    Ml     added C_COMP_COSMIC_MCS12X_MSCAN12
 188      =8  | 2004-08-17 2.15    Pl     Memoryclassifier V_MEMROM0/1/2 for the C_COMP_TOSHIBA_TLC900 changed
 189      =8  | 2004-08-31 2.16    Ml     changed bitfieldtype for MCS12X
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 164 

 190      =8  | 2004-09-08 2.17    RAP    changed vbittype for C_COMP_GHS_SJA2020
 191      =8  | 2004-09-12 2.18    BWR    added C_COMP_GHS_PPC
 192      =8  | 2004-09-20 2.19    Ces    added C_COMP_GHS_ST30_CCAN
 193      =8  | 2004-09-27 2.20    Ms     -ESCAN00009636: Naming Conventions
 194      =8  | 2004-09-28 2.21    Bir    changed bitfieldtype for TriCore MultiCAN
 195      =8  | 2004-09-30 2.22    Ht     Review
 196      =8  | 2004-10-06 2.23    Ml     Added C_COMP_MTRWRKS_MCS12X_MSCAN12  
 197      =8  | 2004-10-27 2.24    Ml     changed V_ENABLE_VSTDLIB -> VGEN_ENABLE_VSTDLIB
 198      =8  | 2004-10-29 2.25    Pl     Added C_COMP_GHS_TX19
 199      =8  | 2004-11-05 2.26    Ml     Added C_COMP_COSMIC_MCS12X_MSCAN12 and C_COMP_COSMIC_MCS12_MSCAN12
 200      =8  | 2004-11-08 2.27    Et     support compiler option -fNP (C_COMP_MITSUBISHI_M32C)
 201      =8  | 2004-11-10 2.28    Ml     Added compatibility for VStdLib
 202      =8  | 2004-11-15 2.29    dH     new memoryclassifier for C_COMP_FUJITSU_16LX/C_COMP_FUJITSU_16LX_HL
 203      =8  | 2004-11-15 2.30    Ms     ESCAN00010228: Support C_COMP specific V_NULL definition
 204      =8  | 2004-11-19 2.31    Ml     bitfields for TMS470 are now int
 205      =8  |                    Ths    ESCAN00010435: Due to compatibility V_DEF_VERSION added
 206      =8  | 2005-01-31 2.32    Ml     Added C_COMP_IAR_TMS430_SCCHECC
 207      =8  | 2005-02-09 2.33    Ht     support V_NULL for C_COMP_KEIL_C5X5C
 208      =8  | 2005-03-10 2.34    Ces    Memory qualifier MEMORY_SADDR and MEMORY_NEAR for IAR 78K0 compiler
 209      =8  | 2005-03-22 2.35    Pl     support V_NULL for C_COMP_TASKING_ST10_CCAN
 210      =8  | 2005-03-22 2.36    Ces    support C_COMP_IAR_78K0_AFCAN
 211      =8  |                           support V_NULL for Tasking C16x/ST10, Mitsubishi M16C, IAR 78K0,
 212      =8  |                           Metrowerks DSP5683x and GreenHills ST30
 213      =8  | 2005-03-24 2.37    Krt    Set cast macros for M32C controller, to avoid compiler warnings
 214      =8  |                    Bir    support V_NULL for C_COMP_TASKING_C16X, C_COMP_TASKING_XC16X, C_COMP_GNU_TRICO
             -RE_MULTICAN
 215      =8  |                    Ces    MEMORY_NEAR corrections for IAR 78K0 AFCAN
 216      =8  | 2005-06-17 2.38    Ht     remove duplicated compiler switch
 217      =8  |                    dH     added C_COMP_HEW_SH2_RCAN
 218      =8  |                    Pl     added C_COMP_GNU_ST10_CCAN
 219      =8  |                    Ds     Added support for ADI Blackfin (BF5xx)
 220      =8  |                    Ml     Added QNX platforms
 221      =8  |                    Fz     MEMORY_HUGE changed for V85X IAR compiler in case tiny memory model
 222      =8  |                    Ht     default definition of NULL
 223      =8  | 2005-06-20 2.39    BWR    Added support for MAC7100 IAR compiler
 224      =8  |                    dH     changed bittype for C_COMP_HEW_SH2_RCAN to unsigned char
 225      =8  | 2005-08-24 2.40    Rna    position for NULL definitions moved to prevent redefinitions for HC12 cosmic (
             -string.h)
 226      =8  | 2005-10-05 2.41    Ces    adaptions for IAR compiler M16C
 227      =8  | 2005-10-14 2.42    Fn     added C_COMP_IAR_AVR_CANARY
 228      =8  |                    Ces    corrections for C_COMP_IAR_M16C
 229      =8  |                    Ces    added C_COMP_IAR_M32C
 230      =8  |                    Ces    added V_MEMROM3 for C_COMP_MITSUBISHI_M16C
 231      =8  | 2005-10-25 2.43    Ces    IAR M32C: MEMORY_ROM is always far const
 232      =8  | 2005-12-02 2.44    dH     added C_COMP_HEW_H8S_RCAN
 233      =8  |                    Fn     added C_COMP_MICROCHIP_PIC18 for V_NULL
 234      =8  |                    Ht     V_COMP_SUPPORTED_PLATTFORM changed to V_DEF_SUPPORTED_PLATFORM 
 235      =8  |                    Pl     added C_COMP_MATSUSHITA_MN103S_CCAN
 236      =8  |                    Svh    added C_COMP_TOSHIBA_TLCS870
 237      =8  |                    Ces    changed compiler version check of IAR M16C and IAR M32C
 238      =8  | 2005-12-20 2.45    Ml     Added C_COMP_METROWERKS_MGT5X00
 239      =8  |                    Ces    changed MEMORY_NORMAL for IAR M16C and IAR M32C
 240      =8  | 2006-01-27 2.46    Ml     ESCAN00014816: Added cast defines for MCS12x with comsic
 241      =8  |                    Ml     ESCAN00015045: Added support for constants in global pages
 242      =8  |                    Ml     Added C_COMP_MTRWRKS_MPC5X00
 243      =8  |                    Svh    Added C_COMP_ARM_ADUC703X
 244      =8  | 2006-02-08 2.47    Pl     Added C_COMP_IAR_ML67Q25XX_CCAN
 245      =8  | 2006-02-09         Ml     Changed check for XGate compiler
 246      =8  | 2006-02-10 2.48    Ces    Added #define V_NULL for MITSUBISHI M32C and MITSUBISHI M32R
 247      =8  | 2006-02-20 2.49    Ml     Changes for dependency builder to accept XGate compiler specific preprocessor
 248      =8  | 2006-03-28 2.50    Ard    Added C_COMP_ARM_OMAP
 249      =8  |                    Pl     Added C_COMP_TOSHIBA_TLCS900
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 165 

 250      =8  |                    Svh    Added C_COMP_HPINFOTECH_AVR_CANARY
 251      =8  | 2006-04-27 2.51    dH     added C_COMP_MATSUSHITA_MN101E_CCAN
 252      =8  |                    Ap     added C_COMP_HITECH_PIC18
 253      =8  |                    Fn     modifications for C_COMP_MICROCHIP_PIC18
 254      =8  |                    Ces    Added C_COMP_GHS_TX49 and C_COMP_NEC_78K0_AFCAN
 255      =8  | 2006-05-02 2.52    Ces    Change MEMORY_NEAR and MEMORY_SADDR for C_COMP_NEC_78K0_AFCAN
 256      =8  |                    Svh    Added C_COMP_IAR_ADUC703X
 257      =8  | 2006-05-19 2.53    Ces    Change MEMORY_NEAR for C_COMP_NEC_78K0_AFCAN
 258      =8  |                    Ces    Change define V_NULL for C_COMP_MITSUBISHI_M32R
 259      =8  | 2006-08-03 2.54    Her    Added type cast for C_COMP_: COSMIC_08/NEC_78K0_AFCAN/COSMIC_MCS12X_MSCAN12
 260      =8  |                    Fn     Added C_COMP_MICROCHIP_DSPIC33
 261      =8  |                    Ap     Added C_COMP_MTRWRKS_MCS08_MSCAN and C_COMP_COSMIC_MCS08_MSCAN
 262      =8  |                    BWR    Added C_COMP_GAIO_MPC55XX 
 263      =8  |                    Pl     Added C_COMP_FUJITSU_16FX_CCAN
 264      =8  | 2006-08-04 2.55    Ces    Added C_COMP_GHS_LPC2XXX
 265      =8  | 2006-08-09 2.56    Svh    Added V_MEMRAM1_NEAR for C_COMP_NEC_78K0
 266      =8  | 2006-08-13 2.57    Ml     Changed bitfield type for C_COMP_COSMIC_MCS08_MSCAN
 267      =8  |                    Pl     Added C_COMP_ARM_AVCCORE1_CCAN  
 268      =8  | 2006-08-30 2.58    Wr     Added C_COMP_GNU_VR55XX_AFCAN
 269      =8  |            2.58    Ml     Added C_COMP_DIABDATA_MPC5X00_MSCAN
 270      =8  | 2006-09-22 2.59    swk    Added C_COMP_KEIL_ST10_CCAN
 271      =8  |                    Ml     Changed bitfield type for C_COMP_COSMIC_MCS08_MSCAN back to vuint8
 272      =8  | 2006-10-23 2.60    BWR    Added C_COMP_GNU_MICROBLAZE_LOGICORECAN
 273      =8  |                    Ard    Added C_COMP_GHS_MAC710X
 274      =8  | 2006-10-23 2.61    Bir    Added C_COMP_TASKING_XC2000_MULTICAN
 275      =8  | 2006-11-14         Ml     Added function near/far qualifier for platform MCS12X
 276      =8  | 2006-11-20         BWR    Added C_COMP_METROWERKS_MPC55XX_FLEXCAN
 277      =8  |                           Added C_COMP_DIABDATA_MCORE_FLEXCAN
 278      =8  | 2006-11-20         Bir    changes for C_COMP_TASKING_XC2000_MULTICAN
 279      =8  | 2006-12-14         Pl     Added C_COMP_TI_TMS470_DCAN
 280      =8  | 2007-01-10         Bir    changes for C_COMP_TASKING_XC2000_MULTICAN
 281      =8  | 2007-01-11         Ces    Added C_COMP_IAR_MCS12_MSCAN12
 282      =8  | 2007-02-01 2.62    Svh    Added C_COMP_FUJITSU_8FX
 283      =8  | 2007-02-19 2.63    Ces    Added C_COMP_GHS_SAF7780_PELICAN
 284      =8  |                    Ces    Changed MEMORY_NORMAL for C_COMP_MITSUBISHI_M32C
 285      =8  | 2007-06-21 2.64    Ces    Changed MEMORY_NORMAL for C_COMP_MITSUBISHI_M16C
 286      =8  |                    Fn     Added C_COMP_IAR_R32C
 287      =8  |                    BWR    Added C_COMP_DIABDATA_MCF_FLEXCAN
 288      =8  |                    Awh    Added C_COMP_KEIL_XC16X 
 289      =8  |                    Ou     Changed vbittype for C_COMP_MTRWRKS_MCS12X_MSCAN12 to unsigned char, additiona
             -lly disabled warning C1106 for this compiler (see #pragma MESSAGE DISABLE C1106)
 290      =8  | 2007-09-07 2.65    Ou     Changed back vbittype for C_COMP_MTRWRKS_MCS12X_MSCAN12 to unsigned int
 291      =8  |                    Ard    Added C_COMP_GHS_TMS470
 292      =8  | 2007-09-28 2.66    Fn     Added C_COMP_COSMIC_ST79_BECAN3
 293      =8  |                    Ces    Added V_MEMROMx_NEAR and V_MEMROMx_FAR for C_COMP_IAR_M16C
 294      =8  |                           Added V_MEMROMx_NEAR and V_MEMROMx_FAR for C_COMP_IAR_M32C
 295      =8  |                           Use predefined compiler macros __VX__ and _C166 for C_COMP_TASKING_XC2000_MULT
             -ICAN
 296      =8  | 2007-10-24 2.67    Fn     Changed C_COMP_COSMIC_ST79_BECAN3 to C_COMP_COSMIC_STM8A_BECAN3
 297      =8  |                    Fn     Added C_COMP_RENESAS_R32C
 298      =8  | 2007-11-09 2.68    Wr     Added C_COMP_KEIL_SLC8051
 299      =8  | 2007-11-14 2.69    Svh    Added C_COMP_KEIL_ADUC703X
 300      =8  | 2007-11-27 2.70    Fn     Adapted rom qualifier for: C_COMP_RENESAS_R32C, C_COMP_IAR_R32C and C_COMP_MIC
             -ROCHIP_DSPIC33
 301      =8  |                    Ml     Added memory mapping defines for C_COMP_MTRWRKS_MCS12X_MSCAN12
 302      =8  | 2007-12-03 2.71    Ard    Added C_COMP_MICROSOFT_TMS320ARM
 303      =8  | 2008-01-14 2.72    Ou     Added memory mapping defines for C_COMP_MTRWRKS_MCS08_MSCAN and C_COMP_COSMIC_
             -MCS08_MSCAN
 304      =8  |                    Ces    Added C_COMP_GHS_MPC55XX and C_COMP_GHS_MPC55XX_FLEXCAN2
 305      =8  |                           Added C_COMP_GAIO_MPC55XX_FLEXCAN2
 306      =8  |                           Added C_COMP_DIABDATA_MPC55XX_FLEXCAN2
 307      =8  |                           Changed memory qualifier for IAR M16C and IAR M32C
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 166 

 308      =8  | 2008-02-19 2.73    Ces    Corrected V_NULL for DIABDATA_MPC55XX
 309      =8  | 2008-03-05 2.74    Pl     Added C_COMP_GNU_NIOS_DCAN
 310      =8  | 2008-03-12         Fn     Added V_MEMROM2_FAR and V_MEMROM2_NEAR for C_COMP_IAR_AVR_CANARY
 311      =8  | 2008-04-18         Ap     Added C_COMP_GNU_AVR_CANARY
 312      =8  | 2008-05-05 2.75    Bir    Possibility to change V_MEMROM2 for XC2000 (user config)
 313      =8  | 2008-05-05 2.76    Ou     Change the behavior for V_MEMROM3 on MCS12X (relevant just for Cosmic compiler
             -, global constants feature)
 314      =8  | 2008-05-06 2.77    Ces    Changed V_MEMRAM2_FAR for IAR compiler M16C/R8C
 315      =8  |                           Added P_MEM_ROM for IAR compiler M16C
 316      =8  |                    Ap     Added C_COMP_IAR_78K0R
 317      =8  | 2008-07-24 2.78    Ht     Memory qualifier for C_COMP_COSMIC_STM8A_BECAN3 added
 318      =8  | 2008-08-27 2.79    Ces    Adapt memory qualifier for C_COMP_MITSUBISHI_M16C and C_COMP_MITSUBISHI_M32C
 319      =8  | 2008-09-18 2.80    Ard    Added C_COMP_QCC_TMS320ARM
 320      =8  | 2008-10-15 2.81    Bir    Added C_COMP_GHS_TRICORE_MULTICAN
 321      =8  |                    BWR    Adapt memory qualifier for C_COMP_GNU_MPC5X00_MSCAN
 322      =8  | 2008-11-14 2.82    Pl     Added C_COMP_GNU_MB86R0X_CCAN
 323      =8  |                    Ou     V_MEMROMx have the default behavior for C_COMP_MICROCHIP_DSPIC33
 324      =8  | 2008-11-21 2.83    Ces    Added C_COMP_GNU_IMX_FLEXCAN2
 325      =8  |                           Added V_MEMROM2 for C_COMP_MITSUBISHI_M32C
 326      =8  | 2009-01-19 2.84    Ou     Change the behavior of data pointer buffers in order to meet the global data e
             -xpectations in case of C_COMP_COSMIC_MCS12X_MSCAN12
 327      =8  |                           Change the default behavior for V_MEMRAM1_FAR and V_MEMRAM3_FAR in case of C_C
             -OMP_COSMIC_MCS12X_MSCAN12
 328      =8  |                    Tvi    Added C_COMP_IAR_M16C_RCAN2 and C_COMP_RENESAS_M16C_RCAN2
 329      =8  | 2009-01-23 2.85    Ou     Adjust the behavior of V_MEMRAM1_FAR and V_MEMRAM3_FAR in case of C_COMP_COSMI
             -C_MCS12X_MSCAN12 in order to have an unified behavior
 330      =8  | 2009-01-29 2.86    Pl     For the TI_TMS470_DCAN changed vuint32 from unsigned long to unsigned int and 
             -vsint32 int from signed long to signed int
 331      =8  |                           Added C_COMP_GNU_ST30_CCAN
 332      =8  | 2009-02-18         Ou     Added C_COMP_MTRWRKS_MPC5X00_MSCAN
 333      =8  | 2009-03-19 2.87    Kk     Added C_COMP_GAIO_SH2_RCAN
 334      =8  |                    Pl     Some V_MEMROM and V_MEMRAM defines for the C_COMP_FUJITSU_16FX_CCAN added ( on
             -ly in the case VGEN_ENABLE_CANFBL is defined )
 335      =8  | 2009-03-25 2.88    Aj     Added C_COMP_ARM_TCC800X_CCAN
 336      =8  | 2009-07-08 2.89    Bir    Added Compiler abstraction like ASR
 337      =8  |                    Ou     Added C_COMP_KEIL_PSOC3_CANMODULE3
 338      =8  |                    Ces    Added C_COMP_METROWERKS_MPC55XX and C_COMP_METROWERKS_MPC55XX_FLEXCAN2
 339      =8  |                    Pl     For the TI_TMS470_DCAN changed back vuint32 from unsigned int to unsigned long
             - and vsint32 from signed int to signed long
 340      =8  |                           Reason is to be compatible with TI_TMS470 and with Platform_Types.h
 341      =8  | 2009-07-08 2.90    Bir    change Compiler abstraction "V_DEF_P2SFR_CAN"
 342      =8  |                    Ou     Rework the V_MEMROMx and V_MEMRAMx for C_COMP_KEIL_PSOC3_CANMODULE3
 343      =8  |                    Seg    Added C_COMP_ARM_TMS470_DCAN
 344      =8  |                    Ou     Added C_COMP_QCC_MPC5X00_MSCAN
 345      =8  | 2009-09-03 2.91    Bir    Added C_COMP_IAR_AVR32_CANIF
 346      =8  |                    Kk     Added C_COMP_RENESAS_SH4_RCAN
 347      =8  | 2009-09-04 2.92    Tvi    Added C_COMP_GHS_V85X_FCN
 348      =8  | 2009-10-06 2.93    Tvi    Added C_COMP_GHS_SH4_RCAN2
 349      =8  | 2009-10-16 2.94    Ou,Ht  Fixed V_NULL for C_COMP_KEIL_PSOC3_CANMODULE3, C_COMP_KEIL_C5X5C and
 350      =8  |                           C_COMP_KEIL_SLC8051
 351      =8  | 2009-10-27 2.95    Ou     Map the reentrant keyword to C_API_3 in case of C_COMP_KEIL_PSOC3_CANMODULE3
 352      =8  | 2009-10-30 2.96    Rna    Support C_COMP_ARM_STM32_BXCAN
 353      =8  | 2009-11-10 2.97    Ht     ESCAN00039030: Support V_MEMRAM2_FAR for XC2000 Tasking
 354      =8  |                    Seg    Support C_COMP_GNU_TX49
 355      =8  | 2009-11-20 2.98    Tvi    ESCAN00039020: Renesas: support "-fansi" option
 356      =8  |                    Ou     Fixed the standard memory qualifier definitions (vuintx/ vsintx) in combinatio
             -n with CAN-Driver for ASR
 357      =8  | 2009-11-23 2.98.01 Ht     correct COMMON_VDEF_RELEASE_VERSION 
 358      =8  | 2010-02-03 2.99    Tvi    ESCAN00039371: [M16C/R8C with RENESAS]: Warnings about incompatible pointer ty
             -pes for Compiler versions >= V5.45
 359      =8  |                    Ht     Support C_COMP_KEIL_SJA2020
 360      =8  | 2010-02-03 3.00.00 Ht     change version number 
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 167 

 361      =8  | 2010-03-02 3.01.00 Ou     Rework the V_MEMROMx and V_MEMRAMx for C_COMP_IAR_78K0R
 362      =8  |                    vadaba Added V_MEMROM0 to place const variables into ROM for C_COMP_METROWERKS_MPC55X
             -X_FLEXCAN2
 363      =8  | 2010-03-10 3.02.00 Tvi    ESCAN00041468: [SH4Rcan2 w. GHS] "-Ospace" leads to a runtime exception due to
             - incorrect bitfield access
 364      =8  |                    Kk     Added C_COMP_QCC_SH4_RCAN
 365      =8  |                    Kk     Added C_COMP_IAR_SH2_RCAN
 366      =8  | 2010-05-12 3.03.00 Pl     Added C_COMP_QCC_MB86R0X_CCAN
 367      =8  |                    Ces    Support C_COMP_GNU_MPC55XX and C_COMP_GNU_MPC55XX_FLEXCAN2 
 368      =8  | 2010-06-09 3.04.00 Tvi    Added C_COMP_NEC_78K0R
 369      =8  | 2010-07-01 3.05.00 Ht     Added support of MEMORY_HUGE for C_COMP_KEIL_C16X
 370      =8  | 2010-07-12 3.06.00 Ces    Support C_COMP_GHS_IMX_FLEXCAN2
 371      =8  |                    Tvi    ESCAN00044064: [R32C with RENESAS]: Warnings about incompatible pointer types 
             -for Compiler versions >= V1.02 r00
 372      =8  | 2010-09-06 3.07.00 Ces    ESCAN00044378: added check for V_NULL definiton if default is not used
 373      =8  |                    Tvi    Misra warning due to wrong characters in history removed
 374      =8  |                    Kk     Added C_COMP_ARM_TRITON_AFCAN
 375      =8  |                    Ap     Added C_PROCESSOR_R8C_XX to distinguish different derivatives 
 376      =8  | 2010-10-01 3.08.00 Tvi    Added C_COMP_RENESAS_V85X_FCN
 377      =8  | 2010-10-17 3.09.00 Bir    Added C_COMP_KEIL_XC800
 378      =8  | 2010-12-13 3.10.00 Tvi    Added C_COMP_RENESAS_78K0R
 379      =8  | 2011-01-28 3.11.00 Ht     M16C Compiler switch for Organi added
 380      =8  |                           Added C_COMP_GHS_SH2_RCAN
 381      =8  |                    Tvi    Changed V_MEMROM1 for C_COMP_RENESAS_78K0R when memory model MEDIUM is used
 382      =8  |                    Rna    Support TMS320(canbedded) with Geny
 383      =8  | 2011-02-25 3.12.00 Ces    Added C_COMP_ARM_TX03_TXCAN
 384      =8  |                    Pl     Added C_COMP_FUJITSU_FR81_CCAN
 385      =8  |                    Tkr    Added C_COMP_GHS_SH2_RCAN2A
 386      =8  | 2011-04-08 3.13.00 Ou     Added C_COMP_IAR_MCS12X_MSCAN12
 387      =8  |                    Tvi    Support C_PROCESSOR_R8C again (removed in 3.07.00)
 388      =8  |                    Aj     Added C_COMP_RENESAS_V85X_AFCAN
 389      =8  | 2011-05-20 3.14.00 Tvi    Added C_COMP_IAR_V85X_FCN
 390      =8  |                    Was    Added C_COMP_TI_TMS320C64X_HECCSCC
 391      =8  | 2011-05-31 3.15.00 Aj     Added C_COMP_GNU_SH2_RCAN
 392      =8  | 2011-07-11 3.16.00 Ht     replace V_NONE with V_STORAGE_NONE in case of V_CPU_TMS320ARM
 393      =8  | 2011-08-08 3.17.00 Pl     Added C_COMP_GHS_FCR4_CCAN
 394      =8  |                    Eta    Added C_COMP_IAR_ADUCM33X
 395      =8  | 2011-09-26 3.18.00 Aj     Added C_COMP_HEW_SH2_RCAN2
 396      =8  | 2011-11-24 3.19.00 Aj     Added C_COMP_ARM_AVNA_CCAN
 397      =8  | 2012-01-12 3.20.00 Rse    Added C_COMP_QCC_IMX_FLEXCAN2, C_COMP_GNU_IMX_FLEXCAN3, C_COMP_QCC_IMX_FLEXCAN
             -3, C_COMP_GHS_IMX_FLEXCAN3
 398      =8  | 2012-02-15 3.21.00 Aj     Added C_COMP_KEIL_FM3_CCAN
 399      =8  |                    Ht     Header changed
 400      =8  |                           remove C_COMP_MCP18_PIC_INT (old driver version)
 401      =8  |                    Tvi    Added C_COMP_RENESAS_SH4_RCAN2
 402      =8  | 2012-02-24 3.22.00 Tvi    Change VEMROM2_NEAR to __near for C_COMP_IAR_78K0R
 403      =8  | 2012-03-23 3.23.00 Ht     Add C_COMP_IAR_RL78_AFCAN
 404      =8  | 2012-03-30 3.24.00 bir    Add CAN_STATIC define for AutoSar4 compatible LL
 405      =8  | 2012-04-18 3.25.00 Seu    Added C_COMP_TASKING_XC800_MULTICAN
 406      =8  | 2012-06-18 3.26.00 Aj     Set vbittype=char for Sh4/Rcan2 in order to support littleendian
 407      =8  | 2012-08-01 3.27.00 Was    Added C_COMP_KEIL_XC2000_MULTICAN
 408      =8  | 2012-08-22 3.28.00 Pl     Added C_COMP_KEIL_SLC8051_CCAN, integration of C_COMP_KEIL_ switches
 409      =8  |                    QPs    Added C_COMP_RENESAS_RL78_AFCAN
 410      =8  | 2012-09-20 3.29.00 Rse    Added C_COMP_GNU_MPC5700_MCAN
 411      =8  | 2012-09-24 3.30.00 Tkr    Added C_COMP_GHS_RH850_RSCAN, C_COMP_HEW_SH2_RSCAN and C_COMP_GHS_SH2_RSCAN
 412      =8  | 2012-10-08 3.30.01 Was    ESCAN00061961: Compiler error: Using of V_MEMROM2_FAR and V_MEMROM2_NEAR leads
             - to an compile error (Keil compiler/ XC2000)
 413      =8  | 2012-11-06 3.31.00 Ht     ESCAN00062762: Remove function memory qualifier for 78K0R and RL78
 414      =8  | 2012-11-08 3.32.00 Pl     Added C_COMP_TI_TMS320ARM_DCAN
 415      =8  | 2012-12-12 3.33.00 Pl     Added C_COMP_QCC_TMS320ARM_DCAN
 416      =8  | 2012-12-18 3.34.00 Rna    Added C_COMP_IAR_STM32_BXCAN
 417      =8  |                    Bmo    Added C_COMP_KEIL_TLE986X
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 168 

 418      =8  | 2013-03-06 3.35.00 Rse    Added C_COMP_GHS_MPC5700_FLEXCAN3, C_COMP_DIABDATA_MPC5700_FLEXCAN3
 419      =8  |                    Rna    VUINTx_CAST for STM8A with Cosmic added
 420      =8  | 2013-03-26 3.36.00 Tkr    Added C_COMP_RENESAS_RL78_RSCAN
 421      =8  |                    Ht     improve RL78 and 78K0R
 422      =8  | 2013-04-02 3.37.00 Was    Added V_COMP_COSMIC_MCS12Z
 423      =8  | 2013-06-11 3.38.00 Ht     Replace C_COMP_xxx_MPC5700_yyy with V_COMP_xxx_MPC5700
 424      =8  |                           Replace C_COMP_xxx_IMX_yyyy with V_COMP_xxx_IMX
 425      =8  |                           Replace C_COMP_GHS_RH850_RSCAN with V_COMP_GHS_RH850
 426      =8  |                           Replace canbittype by vbittype in this file -> no change of API
 427      =8  |                    Was    Support IAR HCS12 Compiler Version 3.x
 428      =8  | 2013-06-21 3.38.01 Ht     Remove comment
 429      =8  | 2013-07-02 3.39.00 Tkr    Replace C_COMP_IAR_RL78_AFCAN with V_COMP_IAR_RL78
 430      =8  |                    Tkr    merge and adapt RL78 and 78K0R memory qualifier definitions for IAR compiler
 431      =8  |                           Replace C_COMP_RENESAS_RL78_xxx with V_COMP_RENESAS_RL78
 432      =8  | 2013-08-20 3.40.00 Pl     Added V_COMP_ARM_STA8088
 433      =8  |                    Tkr    Added V_COMP_DIABDATA_RH850
 434      =8  |                    Rse    Added V_COMP_GNU_VYBRID
 435      =8  |****************************************************************************/
 436      =8  
 437      =8  
 438      =8  
 439      =8  #ifndef  V_DEF_H
 440      =8  #define  V_DEF_H
 441      =8  
 442      =8  /***************************************************************************/
 443      =8  /* Version                  (abcd: Main version=ab, Sub Version=cd )       */
 444      =8  /***************************************************************************/
 445      =8  
 446      =8  /* ##V_CFG_MANAGEMENT ##CQProject : Common_Vdef CQComponent : Implementation */
 447      =8  #define COMMON_VDEF_VERSION            0x0340
 448      =8  #define COMMON_VDEF_RELEASE_VERSION    0x00
 449      =8  
 450      =8  /* compatibility for IL versions < 3.52 */
 451      =8  #define V_DEF_VERSION                  COMMON_VDEF_VERSION
 452      =8  
 453      =8  
 454      =8  /***************************************************************************/
 455      =8  /* Supported Systems                                                       */
 456      =8  /***************************************************************************/
 457      =8  #if defined( C_COMP_KEIL_SLC8051_CCAN )         
 458      =8      
 459      =8  # define V_DEF_SUPPORTED_PLATFORM
 460      =8  #endif
 461      =8  
 462      =8  
 463      =8  #if !defined V_DEF_SUPPORTED_PLATFORM
           =8 # error "driver not supported or C_COMP_xxx_yyy not defined"
           =8 #endif
 466      =8  
 467      =8  
 468      =8  
 469      =8  
 470      =8  /***************************************************************************/
 471      =8  /***************************************************************************/
 472      =8  /****  Hardware independent settings  **************************************/
 473      =8  /***************************************************************************/
 474      =8  /***************************************************************************/
 475      =8  /*--- standard memory qualifier definition --------------------------------*/
 476      =8  
 477      =8  /* 8-Bit qualifier */
 478      =8  #if !defined( vuint8 ) /* ASR compatibility */
 479      =8  typedef unsigned char  vuint8;
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 169 

 480      =8  #endif
 481      =8  #define canuint8 vuint8
 482      =8  
 483      =8  #if !defined( vsint8 ) /* ASR compatibility */
 484      =8  typedef signed char    vsint8;
 485      =8  #endif
 486      =8  #define cansint8 vsint8
 487      =8  
 488      =8  /* 16-Bit qualifier */
 489      =8  #if !defined( vuint16 ) /* ASR compatibility */
 490      =8  typedef unsigned short vuint16;
 491      =8  #endif
 492      =8  #define canuint16 vuint16
 493      =8  
 494      =8  #if !defined( vsint16 ) /* ASR compatibility */
 495      =8  typedef signed short   vsint16;
 496      =8  #endif
 497      =8  #define cansint16 vsint16
 498      =8  
 499      =8  
 500      =8  /* 32-Bit qualifier */
 501      =8  #if !defined( vuint32 ) /* ASR compatibility */
 502      =8  typedef unsigned long  vuint32;
 503      =8  #endif
 504      =8  #define canuint32 vuint32
 505      =8  
 506      =8  #if !defined( vsint32 ) /* ASR compatibility */
 507      =8  typedef signed long    vsint32;
 508      =8  #endif
 509      =8  #define cansint32 vsint32
 510      =8  
 511      =8  
 512      =8  
 513      =8  typedef unsigned char *TxDataPtr;              /* ptr to transmission data buffer */
 514      =8  typedef unsigned char *RxDataPtr;              /* ptr to receiving data buffer    */
 515      =8  
 516      =8  /***************************************************************************/
 517      =8  /*  Defines                                                                */
 518      =8  /***************************************************************************/
 519      =8  
 520      =8  
 521      =8  /***************************************************************************/
 522      =8  /***************************************************************************/
 523      =8  /****  Hardware/Compiler dependent settings   ******************************/
 524      =8  /***************************************************************************/
 525      =8  /***************************************************************************/
 526      =8  
 527      =8  /*  data type according to the CPU type */
 528      =8  #if defined( C_CPUTYPE_8BIT )
 529      =8  /* 8-Bit qualifier */
 530      =8  # ifndef vuintx
 531      =8  #  define vuintx vuint8
 532      =8  # endif
 533      =8  # ifndef vsintx
 534      =8  #  define vsintx vsint8
 535      =8  # endif
 536      =8  #else
           =8 # if defined( C_CPUTYPE_16BIT )
           =8 /* 16-Bit qualifier */
           =8 #  ifndef vuintx
           =8 #   define vuintx vuint16
           =8 #  endif
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 170 

           =8 #  ifndef vsintx
           =8 #   define vsintx vsint16
           =8 #  endif
           =8 # else
           =8 #  if defined( C_CPUTYPE_32BIT )
           =8 /* 32-Bit qualifier */
           =8 #   ifndef vuintx
           =8 #    define vuintx vuint32
           =8 #   endif
           =8 #   ifndef vsintx
           =8 #    define vsintx vsint32
           =8 #   endif
           =8 #  endif
           =8 # endif
           =8 #endif
 557      =8  
 558      =8  
 559      =8  /* qualifier for bitfield definition */
 560      =8  
 561      =8  #if defined( C_COMP_KEIL_SLC8051_CCAN )         
 562      =8  typedef unsigned char    vbittype;
 563      =8  #else
           =8 typedef unsigned int     vbittype;
           =8 #endif
 566      =8  #define canbittype       vbittype
 567      =8  
 568      =8  
 569      =8  
 570      =8  #if defined( C_SUPPORT_MIXED_CAN_LIN )
           =8   /* support combination of "old" CAN driver and "new" LIN driver */
           =8 #else
 573      =8  /* Structure for bit accessed memory.           */
 574      =8  /* The bit-order is hardware/compiler dependent */
 575      =8  #  if defined( C_CPUTYPE_BITORDER_LSB2MSB )
 576      =8  struct _c_bits8
 577      =8  {
 578      =8    vbittype  b0:1;  /* LSB-Bits (lower adr!) */
 579      =8    vbittype  b1:1;
 580      =8    vbittype  b2:1;
 581      =8    vbittype  b3:1;
 582      =8    vbittype  b4:1;
 583      =8    vbittype  b5:1;
 584      =8    vbittype  b6:1;
 585      =8    vbittype  b7:1;  /* MSB-Bits (higher address) unused */
 586      =8   };
 587      =8  
 588      =8  struct _c_bits16 
 589      =8  {
 590      =8    vbittype  b0:1;  /* lower adr */
 591      =8    vbittype  b1:1;
 592      =8    vbittype  b2:1;
 593      =8    vbittype  b3:1;
 594      =8    vbittype  b4:1;
 595      =8    vbittype  b5:1;
 596      =8    vbittype  b6:1;
 597      =8    vbittype  b7:1;
 598      =8  
 599      =8    vbittype  b10:1; /* higher adr */
 600      =8    vbittype  b11:1;
 601      =8    vbittype  b12:1;
 602      =8    vbittype  b13:1;
 603      =8    vbittype  b14:1;
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 171 

 604      =8    vbittype  b15:1;
 605      =8    vbittype  b16:1;
 606      =8    vbittype  b17:1;
 607      =8  };
 608      =8  
 609      =8  struct _c_bits32 
 610      =8  {
 611      =8    vbittype  b0:1;  /* lower adr */
 612      =8    vbittype  b1:1;
 613      =8    vbittype  b2:1;
 614      =8    vbittype  b3:1;
 615      =8    vbittype  b4:1;
 616      =8    vbittype  b5:1;
 617      =8    vbittype  b6:1;
 618      =8    vbittype  b7:1;
 619      =8  
 620      =8    vbittype  b10:1; /* mid low adr */
 621      =8    vbittype  b11:1;
 622      =8    vbittype  b12:1;
 623      =8    vbittype  b13:1;
 624      =8    vbittype  b14:1;
 625      =8    vbittype  b15:1;
 626      =8    vbittype  b16:1;
 627      =8    vbittype  b17:1;
 628      =8  
 629      =8    vbittype  b20:1; /* mid high adr */
 630      =8    vbittype  b21:1;
 631      =8    vbittype  b22:1;
 632      =8    vbittype  b23:1;
 633      =8    vbittype  b24:1;
 634      =8    vbittype  b25:1;
 635      =8    vbittype  b26:1;
 636      =8    vbittype  b27:1;
 637      =8  
 638      =8    vbittype  b30:1; /* higher adr */
 639      =8    vbittype  b31:1;
 640      =8    vbittype  b32:1;
 641      =8    vbittype  b33:1;
 642      =8    vbittype  b34:1;
 643      =8    vbittype  b35:1;
 644      =8    vbittype  b36:1;
 645      =8    vbittype  b37:1;
 646      =8  };
 647      =8  
 648      =8  # else /* MSB2LSB */
           =8 #  if defined( C_CPUTYPE_BITORDER_MSB2LSB )
           =8 struct _c_bits8         
           =8 {
           =8   vbittype  b7:1;  /* MSB-Bits (Higher addr!) */
           =8   vbittype  b6:1;
           =8   vbittype  b5:1;
           =8   vbittype  b4:1;
           =8   vbittype  b3:1;
           =8   vbittype  b2:1;
           =8   vbittype  b1:1;
           =8   vbittype  b0:1;  /* LSB-Bits (higher address) unused */
           =8 };
           =8 
           =8 struct _c_bits16 
           =8 {
           =8   vbittype  b7:1;   /* lower adr */
           =8   vbittype  b6:1;
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 172 

           =8   vbittype  b5:1;
           =8   vbittype  b4:1;
           =8   vbittype  b3:1;
           =8   vbittype  b2:1;
           =8   vbittype  b1:1;
           =8   vbittype  b0:1;
           =8 
           =8   vbittype  b17:1;  /* higher adr */
           =8   vbittype  b16:1;
           =8   vbittype  b15:1;
           =8   vbittype  b14:1;
           =8   vbittype  b13:1;
           =8   vbittype  b12:1;
           =8   vbittype  b11:1;
           =8   vbittype  b10:1;
           =8 };
           =8 
           =8 
           =8 struct _c_bits32 
           =8 {
           =8   vbittype  b7:1;   /* lower adr */
           =8   vbittype  b6:1;
           =8   vbittype  b5:1;
           =8   vbittype  b4:1;
           =8   vbittype  b3:1;
           =8   vbittype  b2:1;
           =8   vbittype  b1:1;
           =8   vbittype  b0:1;
           =8 
           =8   vbittype  b17:1;  /* mid low adr */
           =8   vbittype  b16:1;
           =8   vbittype  b15:1;
           =8   vbittype  b14:1;
           =8   vbittype  b13:1;
           =8   vbittype  b12:1;
           =8   vbittype  b11:1;
           =8   vbittype  b10:1;
           =8 
           =8   vbittype  b27:1;  /* mid high adr */
           =8   vbittype  b26:1;
           =8   vbittype  b25:1;
           =8   vbittype  b24:1;
           =8   vbittype  b23:1;
           =8   vbittype  b22:1;
           =8   vbittype  b21:1;
           =8   vbittype  b20:1;
           =8 
           =8   vbittype  b37:1;  /* higher adr */
           =8   vbittype  b36:1;
           =8   vbittype  b35:1;
           =8   vbittype  b34:1;
           =8   vbittype  b33:1;
           =8   vbittype  b32:1;
           =8   vbittype  b31:1;
           =8   vbittype  b30:1;
           =8 };
           =8 #  else
           =8 #  error "Bitorder unknown: C_CPUTYPE_BITORDER_MSB2LSB or C_CPUTYPE_BITORDER_LSB2MSB has to be defined"
           =8 #  endif /* C_CPUTYPE_BITORDER_MSB2LSB */
           =8 # endif  /* C_CPUTYPE_BITORDER_LSB2MSB */
 726      =8  #endif
 727      =8  
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 173 

 728      =8  
 729      =8  
 730      =8  
 731      =8  /***************************************************************************/
 732      =8  /* Memory qualifier                                                        */
 733      =8  /***************************************************************************/
 734      =8  
 735      =8  
 736      =8  
 737      =8  
 738      =8  
 739      =8  
 740      =8  
 741      =8  
 742      =8  #if defined( C_COMP_KEIL_SLC8051_CCAN )     
 743      =8  /* V_MEMROM0      is not used because of its position in case of pointers located in ROM, remains empty th
             -rough the compatibility macros */
 744      =8  /* V_MEMROM1_NEAR is not used, remains empty through the compatibility macros */
 745      =8  /* V_MEMROM1      is not used, remains empty through the compatibility macros */
 746      =8  /* V_MEMROM1_FAR  is not used, remains empty through the compatibility macros */
 747      =8  # define V_MEMROM2_NEAR const code
 748      =8  # define V_MEMROM2      const code
 749      =8  # define V_MEMROM2_FAR  const code
 750      =8  /* V_MEMROM3      is not used, remains empty through the compatibility macros */
 751      =8  /* V_MEMRAM0      is not used because of its position in case of pointers located in RAM, remains empty th
             -rough the compatibility macros */
 752      =8  /* V_MEMRAM1_NEAR is not used, remains empty through the compatibility macros */
 753      =8  /* V_MEMRAM1      is not used, remains empty through the compatibility macros */
 754      =8  /* V_MEMRAM1_FAR  is not used, remains empty through the compatibility macros */
 755      =8  # define V_MEMRAM2_NEAR idata
 756      =8  /* V_MEMRAM2 is the default memory area: "data", "pdata" or "xdata", remains empty through the compatibili
             -ty macros */
 757      =8  # define V_MEMRAM2_FAR  xdata
 758      =8  /* V_MEMRAM3_NEAR is not used, remains empty through the compatibility macros */
 759      =8  /* V_MEMRAM3      is not used, remains empty through the compatibility macros */
 760      =8  /* V_MEMRAM3_FAR  is not used, remains empty through the compatibility macros */
 761      =8  # define C_API_3 reentrant
 762      =8  #endif
 763      =8  
 764      =8  
 765      =8  #if defined ( VGEN_ENABLE_CANFBL ) 
           =8 #endif
 767      =8  
 768      =8  
 769      =8  
 770      =8  
 771      =8  
 772      =8  
 773      =8  
 774      =8  
 775      =8  
 776      =8  
 777      =8  
 778      =8  
 779      =8  
 780      =8  
 781      =8  
 782      =8  
 783      =8  
 784      =8  
 785      =8  
 786      =8  
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 174 

 787      =8  
 788      =8  
 789      =8  
 790      =8  
 791      =8  
 792      =8  #ifndef MEMORY_HUGE
 793      =8  #  define MEMORY_HUGE               /* no entry                         */
 794      =8  #endif
 795      =8  
 796      =8  
 797      =8  
 798      =8  
 799      =8  
 800      =8  
 801      =8  
 802      =8  
 803      =8  /* *********************** default defines - used to store permanent data ********************************
             -******** */
 804      =8  #ifndef V_MEMROM0
 805      =8  # define V_MEMROM0                  /* addition qualifier data access in ROM  */
 806      =8  #endif
 807      =8  
 808      =8  #ifndef V_MEMROM1_NEAR
 809      =8  # define V_MEMROM1_NEAR             /* fast data access in ROM */
 810      =8  #endif
 811      =8  
 812      =8  #ifndef V_MEMROM1
 813      =8  # define V_MEMROM1                 /* fast data access in ROM */
 814      =8  #endif
 815      =8  
 816      =8  #ifndef V_MEMROM1_FAR
 817      =8  # define V_MEMROM1_FAR             /* slow addressing mode in ROM */
 818      =8  #endif
 819      =8  
 820      =8  
 821      =8  #ifndef MEMORY_ROM_NEAR
 822      =8  # ifndef V_MEMROM2_NEAR
           =8 #  define V_MEMROM2_NEAR   const    /* fast data access in ROM */
           =8 # endif
 825      =8    /* compatibility for modules which use old definition of memory qualifer */
 826      =8  # define MEMORY_ROM_NEAR   V_MEMROM2_NEAR
 827      =8  #else
           =8 # define V_MEMROM2_NEAR    MEMORY_ROM_NEAR
           =8 #endif
 830      =8  
 831      =8  #ifndef MEMORY_ROM
 832      =8  # ifndef V_MEMROM2
           =8 #  define V_MEMROM2        const    /* fast data access in ROM */
           =8 # endif
 835      =8    /* compatibility for modules which use old definition of memory qualifer */
 836      =8  # define MEMORY_ROM        V_MEMROM2       
 837      =8  #else
           =8 # define V_MEMROM2         MEMORY_ROM
           =8 #endif
 840      =8  
 841      =8  #ifndef MEMORY_ROM_FAR
 842      =8  # ifndef V_MEMROM2_FAR
           =8 #  define V_MEMROM2_FAR    const    /* slow addressing mode in ROM */
           =8 # endif
 845      =8    /* compatibility for modules which use old definition of memory qualifer */
 846      =8  # define MEMORY_ROM_FAR    V_MEMROM2_FAR
 847      =8  #else
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 175 

           =8 # define V_MEMROM2_FAR     MEMORY_ROM_FAR
           =8 #endif
 850      =8  
 851      =8  #ifndef V_MEMROM3
 852      =8  # define V_MEMROM3        
 853      =8  #endif
 854      =8  
 855      =8  
 856      =8  /* *********************** default defines - used to store volatile data *********************************
             -******* */
 857      =8  #ifndef V_MEMRAM0
 858      =8  # define V_MEMRAM0                  /* addition qualifier data access in RAM  */
 859      =8  #endif
 860      =8  
 861      =8  #ifndef V_MEMRAM1_NEAR
 862      =8  # define V_MEMRAM1_NEAR             /* fast data access in RAM */
 863      =8  #endif
 864      =8  
 865      =8  #ifndef V_MEMRAM1
 866      =8  # define V_MEMRAM1                 /* fast data access in RAM */
 867      =8  #endif
 868      =8  
 869      =8  #ifndef V_MEMRAM1_FAR
 870      =8  # define V_MEMRAM1_FAR             /* slow addressing mode in RAM */
 871      =8  #endif
 872      =8  
 873      =8  
 874      =8  #ifndef MEMORY_NEAR
 875      =8  # ifndef V_MEMRAM2_NEAR
           =8 #  define V_MEMRAM2_NEAR           /* fast data access in RAM */
           =8 # endif
 878      =8    /* compatibility for modules which use old definition of memory qualifer */
 879      =8  # define MEMORY_NEAR   V_MEMRAM2_NEAR
 880      =8  #else
           =8 # define V_MEMRAM2_NEAR    MEMORY_NEAR
           =8 #endif
 883      =8  
 884      =8  #ifndef MEMORY_NORMAL
 885      =8  # ifndef V_MEMRAM2
 886      =8  #  define V_MEMRAM2                 /* fast data access in RAM */
 887      =8  # endif
 888      =8    /* compatibility for modules which use old definition of memory qualifer */
 889      =8  # define MEMORY_NORMAL   V_MEMRAM2       
 890      =8  #else
           =8 # define V_MEMRAM2           MEMORY_NORMAL
           =8 #endif
 893      =8  
 894      =8  #ifndef MEMORY_FAR
 895      =8  # ifndef V_MEMRAM2_FAR
           =8 #  define V_MEMRAM2_FAR            /* slow addressing mode in RAM */
           =8 # endif
 898      =8    /* compatibility for modules which use old definition of memory qualifer */
 899      =8  # define MEMORY_FAR    V_MEMRAM2_FAR
 900      =8  #else
           =8 # define V_MEMRAM2_FAR     MEMORY_FAR
           =8 #endif
 903      =8  
 904      =8  #ifndef V_MEMRAM3_NEAR
 905      =8  # define V_MEMRAM3_NEAR             /* fast data access in RAM */
 906      =8  #endif
 907      =8  
 908      =8  #ifndef V_MEMRAM3
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 176 

 909      =8  # define V_MEMRAM3                 /* fast data access in RAM */
 910      =8  #endif
 911      =8  
 912      =8  #ifndef V_MEMRAM3_FAR
 913      =8  # define V_MEMRAM3_FAR             /* slow addressing mode in RAM */
 914      =8  #endif
 915      =8  
 916      =8  
 917      =8  /* *********************** default defines - to cast results *********************************************
             -******* */
 918      =8  #if !defined(VUINT8_CAST)
 919      =8  # define VUINT8_CAST
 920      =8  #endif 
 921      =8  #if !defined(VSINT8_CAST)
 922      =8  # define VSINT8_CAST
 923      =8  #endif
 924      =8  #if !defined(VUINT16_CAST)
 925      =8  # define VUINT16_CAST
 926      =8  #endif
 927      =8  # if !defined(VSINT16_CAST)
 928      =8  # define VSINT16_CAST
 929      =8  #endif
 930      =8  #if !defined(CANBITTYPE_CAST)
 931      =8  # define CANBITTYPE_CAST
 932      =8  #endif
 933      =8  #if !defined(CANSINTCPUTYPE_CAST)
 934      =8  # define CANSINTCPUTYPE_CAST
 935      =8  #endif
 936      =8  #if !defined(CANUINTCPUTYPE_CAST)
 937      =8  # define CANUINTCPUTYPE_CAST
 938      =8  #endif
 939      =8  
 940      =8  /* ************************************************************************* */
 941      =8  /*  Common_VStdLib                                                           */
 942      =8  /* ************************************************************************* */
 943      =8  # if defined (VGEN_ENABLE_VSTDLIB) || defined (V_ENABLE_VSTDLIB)
 944      =8  #  include "vstdlib.h"
   1      =9  /* Kernbauer Version: 1.16 Konfiguration: VStdLib Erzeugungsgangnummer: 1 */
   2      =9  
   3      =9  
   4      =9  /*********************************************************************************************************
             -*************
   5      =9  | Project Name: vstdlib library
   6      =9  |    File Name: vstdlib_ll.h
   7      =9  |
   8      =9  |  Description        : lowlevel part of the implementation of standard 
   9      =9  |                       Vector functions.
  10      =9  |                       Slicon Labs C8051/ Cypress PSoC3 specific implementation
  11      =9  |                               
  12      =9  |---------------------------------------------------------------------------------------------------------
             --------------
  13      =9  |               C O P Y R I G H T
  14      =9  |---------------------------------------------------------------------------------------------------------
             --------------
  15      =9  |   Copyright 2009 (c) by Vector Informatik GmbH.     All rights reserved.
  16      =9  |
  17      =9  |   This software is copyright protected and proprietary to 
  18      =9  |   Vector Informatik GmbH. Vector Informatik GmbH grants to you 
  19      =9  |   only those rights as set out in the license conditions. All 
  20      =9  |   other rights remain with Vector Informatik GmbH.
  21      =9  |
  22      =9  |---------------------------------------------------------------------------------------------------------
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 177 

             --------------
  23      =9  |               A U T H O R   I D E N T I T Y
  24      =9  |---------------------------------------------------------------------------------------------------------
             --------------
  25      =9  | Initials     Name                      Company
  26      =9  | --------     ---------------------     -----------------------------------------------------------------
             --------------
  27      =9  | Ml           Patrick Markl             Vector Informatik GmbH
  28      =9  | Wr           Hans Waaser               Vector Informatik GmbH
  29      =9  | Ou           Mihai Olariu              Vector Informatik GmbH
  30      =9  |---------------------------------------------------------------------------------------------------------
             --------------
  31      =9  |               R E V I S I O N   H I S T O R Y
  32      =9  |---------------------------------------------------------------------------------------------------------
             --------------
  33      =9  | Date       Version   Author  Description
  34      =9  |----------  --------  ------  ---------------------------------------------------------------------------
             --------------
  35      =9  | 2007-10-15  01.00.00    Wr     - Creation
  36      =9  | 2009-07-13  01.01.00    Ou     - ESCAN00036373: Add platform PSoC3/ Keil
  37      =9  | 2012-09-13  01.02.00    Pl     - ESCAN00061393: Added platform C_COMP_KEIL_SLC8051_CCAN
  38      =9  |*********************************************************************************************************
             -***********/
  39      =9  
  40      =9  /*********************************************************************************************************
             -*************
  41      =9  |
  42      =9  | Project Name : vstdlib library
  43      =9  |    File Name : vstdlib_HL.h
  44      =9  |
  45      =9  |  Description : Highlevel part of the implementation of standard Vector functions
  46      =9  |                               
  47      =9  |---------------------------------------------------------------------------------------------------------
             --------------
  48      =9  |               C O P Y R I G H T
  49      =9  |---------------------------------------------------------------------------------------------------------
             --------------
  50      =9  |   Copyright (c) by Vector Informatik GmbH.     All rights reserved.
  51      =9  |
  52      =9  |   This software is copyright protected and proprietary to 
  53      =9  |   Vector Informatik GmbH. Vector Informatik GmbH grants to you 
  54      =9  |   only those rights as set out in the license conditions. All 
  55      =9  |   other rights remain with Vector Informatik GmbH.
  56      =9  |
  57      =9  |---------------------------------------------------------------------------------------------------------
             --------------
  58      =9  |               A U T H O R   I D E N T I T Y
  59      =9  |---------------------------------------------------------------------------------------------------------
             --------------
  60      =9  | Initials     Name                      Company
  61      =9  | --------     ---------------------     -----------------------------------------------------------------
             --------------
  62      =9  | Ml           Patrick Markl             Vector Informatik GmbH
  63      =9  | HH           Hartmut Hoerner           Vector Informatik GmbH
  64      =9  | Ms           Gunnar Meiss              Vector Informatik GmbH
  65      =9  | Et           Thomas Ebert              Vector Informatik GmbH
  66      =9  | Bus          Sabine Buecherl           Vector Informatik GmbH
  67      =9  | Hs           Hannes Haas               Vector Informatik GmbH
  68      =9  | BWR          Brandon Root              Vector CANtech Inc.
  69      =9  | Ard          Thomas Arnold             Vector Informatik GmbH
  70      =9  |---------------------------------------------------------------------------------------------------------
             --------------
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 178 

  71      =9  |               R E V I S I O N   H I S T O R Y
  72      =9  |---------------------------------------------------------------------------------------------------------
             --------------
  73      =9  | Date       Version   Author  Description
  74      =9  |----------  --------  ------  ---------------------------------------------------------------------------
             --------------
  75      =9  |2003-09-06  00.01.00    Ml     - Creation
  76      =9  |                        Ml     - Added HC12 Cosmic
  77      =9  |2003-10-07  00.02.00    Ml/HH  - v_lib input merged
  78      =9  |2004-04-10  00.03.00    Ml     - Added headerfile
  79      =9  |                        Ml     - Added HC08 Cosmic
  80      =9  |                        Ml     - removed channel dependence for assertions
  81      =9  |                        Ml     - Added function to retrieve the IRQ state
  82      =9  |                        Ml     - Added VSTD_FULL_LIB_SUPPORT switch
  83      =9  |2004-04-27  01.00.00    Ml     - resolved issues found in code inspection
  84      =9  |2004-05-17  01.01.00    Ml     - no changes
  85      =9  |                        Ml     - changed bugfix into releaseversion
  86      =9  |2004-05-18  01.02.00    Ms/HH  - changed memory qualifier concept
  87      =9  |2004-06-01  01.03.00    Ml     - no changes
  88      =9  |2004-08-06  01.04.00    Ml     - Added macros for local IRQ disable
  89      =9  |                               - Split of library into HL and LL
  90      =9  |2004-08-18  01.05.00    Ml     - Added function qualifier
  91      =9  |2004-09-06  01.06.00    Ml     - ESCAN00009316: fixed parameter type mismatch
  92      =9  |2004-09-27  01.07.00    Ml     - changed memcpy macros
  93      =9  |                        Ml     - changed namingconvention
  94      =9  |2004-09-29  01.08.00    Et     - ESCAN00009692: split VStdMemCpy in VStdRamMemCpy and VStdRomMemCpy   
  95      =9  |2004-10-01  01.09.00    Ml     - ESCAN00009731: usage of standard type qualifiers
  96      =9  |2004-10-26  01.10.00    Ml     - ESCAN00010000: LL parts are split into HW specific files
  97      =9  |2004-11-09  01.11.00    Ml     - no changes
  98      =9  |2004-11-15  01.12.00    Ml     - ESCAN00010533: Added optimized memory functions for HC08
  99      =9  |                        Ml     - ESCAN00010672: Added memory qualifier
 100      =9  |2005-01-24  01.13.00    Ml     - ESCAN00010670: Added memset
 101      =9  |2005-02-25  01.14.00    Ml     - ESCAN00011215  Added VStdInitPowerOn
 102      =9  |2005-04-26  01.15.00    Ml     - ESCAN00012047: Encapsulate VStdInitPowerOn
 103      =9  |            01.16.00    Ml     - ESCAN00012105: Change definition of VStdMemCpy
 104      =9  |2005-05-30  02.00.00    Ml     - ESCAN00013446: Development concept changed
 105      =9  |2005-09-12  02.01.00    Ml     - ESCAN00013512: Fixed Misra warnings
 106      =9  |2005-11-06  02.02.00    Ml     - ESCAN00014183: no changes
 107      =9  |2005-11-28  02.03.00    Ml     - Changed version defines
 108      =9  |                        Ml     - ESCAN00014428: VStdMemClr/Set are now internal functions
 109      =9  |                        Ml     - ESCAN00014409: Added casts for mem function defines
 110      =9  |2005-12-12  02.04.00    Ml/Bus - ESCAN00012774: insert comments for different resource categories
 111      =9  |2006-01-12  02.05.00    Ml     - ESCAN00014897: Changed interrupt handling
 112      =9  |2006-01-14  02.06.00    Ml     - ESCAN00014908: Adapted interrupt control handling for RI1.5
 113      =9  |2006-02-07  02.07.00    Ml     - Added VStdGetInterruptState
 114      =9  |                        Hs     - ESCAN00015802: compatibility defines added
 115      =9  |2006-05-09  02.08.00    Ces    - ESCAN00016289: Insert memory qualifier V_MEMROM3 to VStdRomMemCpy()
 116      =9  |2006-05-24  02.09.00    BWR    - ESCAN00016488: Compiler error in VStdSuspendAllInterrupts and VStdResume
             -AllInterrupts
 117      =9  |2006-07-16  02.10.00    Ml     - Changed return type of VStdGetInterruptState from uint8 to tVStdIrqState
             -Type
 118      =9  |2006-07-31  02.11.00    Ml     - ESCAN00017133: Changed assertion handling
 119      =9  |2006-08-04  02.12.00    Ml     - ESCAN00017188: Added compatibility for older copy functions
 120      =9  |2006-11-20  02.13.00    Ml     - Removed VStdGetInterruptState
 121      =9  |2006-12-07  02.14.00    Ml     - Changed switch names
 122      =9  |                        Ml     - ESCAN00018889: Fixed code inspection report findings
 123      =9  |                               - ESCAN00018880: added casts to memXXX macros
 124      =9  |2007-01-27  02.15.00    Ml,Ard - ESCAN00019251: VStdLib HL usable for RI1.4 and RI1.5
 125      =9  |2007-02-19  02.16.00    Ml     - ESCAN00019672: no changes
 126      =9  |                        Ml     - ESCAN00019674: Changed names of interrupt lock macros
 127      =9  |2007-05-10  02.17.00    Ml     - ESCAN00020705: no changes
 128      =9  |                        Ml     - ESCAN00020241: Cast of length parameter
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 179 

 129      =9  |2007-11-26  03.00.00    Ml     - ESCAN00024126: Support word and dword copy routines
 130      =9  |                        Ml     - ESCAN00024192: Default and specific implementations supported at the sam
             -e time
 131      =9  |2008-06-25  03.01.00    Ml     - ESCAN00023334: Added u suffix to the version numbers
 132      =9  |                        Ml     - ESCAN00018659: No changes
 133      =9  |                        Ml     - ESCAN00015501: Added compatibility to older version defines   
 134      =9  |2008-07-17  03.01.01    Ml     - ESCAN00027617: Added library version check support
 135      =9  |2008-07-23  03.02.00    Ml     - ESCAN00028605: old interrupt status is initialized by low level token
 136      =9  |2008-07-27  03.02.01    Ml     - ESCAN00028752: Include of MSR header according to naming convention
 137      =9  |2008-08-13  03.03.00    Ml     - ESCAN00029196: Encapsulated AUTOSAR library version check
 138      =9  |2008-12-08  03.03.01    Ml     - ESCAN00031855: Additional memcpy interfaces
 139      =9  |2009-06-30  03.04.00    Ml     - ESCAN00036089: Application must care about nested calls in case of user 
             -handling of locks
 140      =9  |                        Ml     - ESCAN00035049: Resolved extended version check include
 141      =9  |2009-10-15  03.05.00    Ml     - ESCAN00038482: Added additional function qualifier (VSTD_API_2)
 142      =9  |                        Ml     - ESCAN00038485: Added general OS header include.
 143      =9  |2009-10-19  03.05.01    Ml     - ESCAN00038485: Renamed the OS header include according to osCAN
 144      =9  |
 145      =9  |*********************************************************************************************************
             -************/
 146      =9  
 147      =9  #if !defined(_VSTDLIB_H_)
 148      =9  # define _VSTDLIB_H_
 149      =9  
 150      =9  /* Includes required in the header file */
 151      =9  
 152      =9  /*********************************************************************************************************
             -************/
 153      =9  /* Defines                                                                                                
             -           */
 154      =9  /*********************************************************************************************************
             -************/
 155      =9  
 156      =9  /* ##V_CFG_MANAGEMENT ##CQProject : VStdLib_Slc8051 CQComponent : Implementation */
 157      =9  #define VSTDLIB_SLC8051_VERSION         0x0102u
 158      =9  #define VSTDLIB_SLC8051_RELEASE_VERSION 0x00u
 159      =9  
 160      =9  /* ##V_CFG_MANAGEMENT ##CQProject : VStdLib__coreHll CQComponent : Implementation */
 161      =9  # define VSTDLIB__COREHLL_VERSION         0x0305u
 162      =9  # define VSTDLIB__COREHLL_RELEASE_VERSION 0x01u
 163      =9  
 164      =9  /* Introduced for comparibility with older VStdLib versions */
 165      =9  # define COMMON_VSTDLIB_VERSION             VSTDLIB__COREHLL_VERSION
 166      =9  # define COMMON_VSTDLIB_RELEASE_VERSION     VSTDLIB__COREHLL_RELEASE_VERSION
 167      =9  
 168      =9  #if defined(C_COMP_KEIL_SLC8051_CCAN) 
 169      =9  # if !(defined(VSTD_ENABLE_DEFAULT_INTCTRL) || \
 170      =9         defined(VSTD_ENABLE_OSEK_INTCTRL)    || \
 171      =9         defined(VSTD_ENABLE_APPL_INTCTRL))
           =9 #  define VSTD_ENABLE_DEFAULT_INTCTRL
           =9 # endif
 174      =9  #endif
 175      =9  
 176      =9  /* access to global interrupt enable flag */
 177      =9  sfr  VSTDLIB_IE         = 0xA8; 
 178      =9  sbit VSTDLIB_EA         = VSTDLIB_IE^7;
 179      =9  
 180      =9  #if defined(C_COMP_KEIL_SLC8051_CCAN) 
 181      =9  /* VSTD_API_2 for this function must be "reentrant" */
 182      =9  # define VSTD_API_2 reentrant
 183      =9  #endif
 184      =9  
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 180 

 185      =9  # if !defined(VSTD_API_0)
 186      =9  #  define VSTD_API_0
 187      =9  # endif
 188      =9  
 189      =9  # if !defined(VSTD_API_1)
 190      =9  #  define VSTD_API_1
 191      =9  # endif
 192      =9  
 193      =9  # if !defined(VSTD_API_2)
           =9 #  define VSTD_API_2
           =9 # endif
 196      =9  
 197      =9  # if !defined(VSTD_CALLBACK_0)
 198      =9  #  define VSTD_CALLBACK_0
 199      =9  # endif
 200      =9  
 201      =9  # if !defined(VSTD_CALLBACK_1)
 202      =9  #  define VSTD_CALLBACK_1
 203      =9  # endif
 204      =9  
 205      =9  #  if defined(VSTD_ENABLE_DEFAULT_INTCTRL) || \
 206      =9        defined(VSTD_ENABLE_OSEK_INTCTRL)    || \
 207      =9        defined(VSTD_ENABLE_APPL_INTCTRL)
 208      =9  #   define VSTD_ENABLE_INTCTRL_HANDLING
 209      =9  #   define VSTD_HL_ENABLE_SUPPORT_IRQ_FCT  /* compatibility for Autosar */
 210      =9  #   define VSTD_ENABLE_SUPPORT_IRQ_FCT
 211      =9  #  else
           =9 #   define VSTD_DISABLE_INTCTRL_HANDLING
           =9 #   define VSTD_HL_DISABLE_SUPPORT_IRQ_FCT  /* compatibility for Autosar */
           =9 #   define VSTD_DISABLE_SUPPORT_IRQ_FCT
           =9 #  endif
 216      =9  
 217      =9  # if !defined(VSTD_ENABLE_LIBRARY_FUNCTIONS) && !defined(VSTD_DISABLE_LIBRARY_FUNCTIONS)
           =9 #  define VSTD_ENABLE_LIBRARY_FUNCTIONS
           =9 # endif
 220      =9  
 221      =9  /*********************************************************************************************************
             -************/
 222      =9  /* Error codes for assertions                                                                             
             -           */
 223      =9  /*********************************************************************************************************
             -************/
 224      =9  # define kVStdErrorIntDisableTooOften        ((vuint8)0x01)
 225      =9  # define kVStdErrorIntRestoreTooOften        ((vuint8)0x02)
 226      =9  # define kVStdErrorMemClrInvalidParameter    ((vuint8)0x03)
 227      =9  # define kVStdErrorMemCpyInvalidParameter    ((vuint8)0x04)
 228      =9  # define kVStdErrorFunctionNotSupportedByHw  ((vuint8)0x05)
 229      =9  # define kVStdErrorMemSetInvalidParameter    ((vuint8)0x06)
 230      =9  # define kVStdErrorUnexpectedLockState       ((vuint8)0x07)
 231      =9  
 232      =9  
 233      =9  /*********************************************************************************************************
             -************/
 234      =9  /* Plattforms with optimized VStdLib support                                                              
             -           */
 235      =9  /*********************************************************************************************************
             -************/
 236      =9  #if defined(C_COMP_KEIL_SLC8051_CCAN) 
 237      =9  # define VSTD_HL_DISABLE_MEM_FCT_MAPPING    /* do not use the memory routines provided by the compiler */
 238      =9  # define VSTD_HL_ENABLE_SUPPORT_MEM_FCT     /* implement the memory routines */
 239      =9  #endif
 240      =9  
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 181 

 241      =9  /* in case of the standard implementation enable all functions */
 242      =9  # define VSTD_HL_USE_VSTD_MEMCLR
 243      =9  # define VSTD_HL_USE_VSTD_MEMSET
 244      =9  # define VSTD_HL_USE_VSTD_RAMMEMCPY
 245      =9  # define VSTD_HL_USE_VSTD_ROMMEMCPY
 246      =9  # define VSTD_HL_USE_VSTD_WORD_MEMCPY
 247      =9  # define VSTD_HL_USE_VSTD_DWORD_MEMCPY
 248      =9  
 249      =9  /*********************************************************************************************************
             -************/
 250      =9  /* Version check                                                                                          
             -           */
 251      =9  /*********************************************************************************************************
             -************/
 252      =9  /* ROM CATEGORY 4 START*/
 253      =9  V_MEMROM0 extern V_MEMROM1 vuint8 V_MEMROM2 kVStdMainVersion;
 254      =9  V_MEMROM0 extern V_MEMROM1 vuint8 V_MEMROM2 kVStdSubVersion;
 255      =9  V_MEMROM0 extern V_MEMROM1 vuint8 V_MEMROM2 kVStdReleaseVersion;
 256      =9  /* ROM CATEGORY 4 END*/
 257      =9  
 258      =9  /*********************************************************************************************************
             -************/
 259      =9  /* Function like macros                                                                                   
             -           */
 260      =9  /*********************************************************************************************************
             -************/
 261      =9  # define VStdLL_GlobalInterruptDisable(OldStatusPtr)                   {*OldStatusPtr = VSTDLIB_EA; VSTDLI
             -B_EA = 0;}
 262      =9  # define VStdLL_GlobalInterruptRestore(OldStatus)                      {VSTDLIB_EA = OldStatus;}
 263      =9  
 264      =9  /*********************************************************************************************************
             -************/
 265      =9  /* Types                                                                                                  
             -           */
 266      =9  /*********************************************************************************************************
             -************/
 267      =9  
 268      =9  typedef volatile vuint8 tVStdIrqStateType;
 269      =9  
 270      =9  /*********************************************************************************************************
             -************/
 271      =9  /* Defines                                                                                                
             -           */
 272      =9  /*********************************************************************************************************
             -************/
 273      =9  #  if defined(VSTD_ENABLE_INTCTRL_HANDLING)
 274      =9  #   if defined(VSTD_ENABLE_DEFAULT_INTCTRL)
 275      =9  #    define VStdDeclareGlobalInterruptOldStatus     tVStdIrqStateType localInterruptOldStatus;
 276      =9  #    define VStdPutGlobalInterruptOldStatus(x)      (localInterruptOldStatus = (x))
 277      =9  #    define VStdGetGlobalInterruptOldStatus(x)      ((x) = localInterruptOldStatus)
 278      =9  #    define VStdGlobalInterruptDisable()            VStdLL_GlobalInterruptDisable(&localInterruptOldStatus
             -)
 279      =9  #    define VStdGlobalInterruptRestore()            VStdLL_GlobalInterruptRestore(localInterruptOldStatus)
 280      =9  #   elif defined(VSTD_ENABLE_OSEK_INTCTRL)
           =9 #    define VStdDeclareGlobalInterruptOldStatus
           =9 #    define VStdPutGlobalInterruptOldStatus(x)
           =9 #    define VStdGetGlobalInterruptOldStatus(x)
           =9 #    if defined(osdOSEK2_1)
           =9 #     define VStdGlobalInterruptDisable()           OsSaveDisableGlobalNested()
           =9 #     define VStdGlobalInterruptRestore()           OsRestoreEnableGlobalNested()
           =9 #     define VStdSuspendAllInterrupts()             OsSaveDisableGlobalNested()
           =9 #     define VStdResumeAllInterrupts()              OsRestoreEnableGlobalNested()
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 182 

           =9 #    else
           =9 #     define VStdGlobalInterruptDisable()           SuspendAllInterrupts()
           =9 #     define VStdGlobalInterruptRestore()           ResumeAllInterrupts()
           =9 #     define VStdSuspendAllInterrupts()             SuspendAllInterrupts()
           =9 #     define VStdResumeAllInterrupts()              ResumeAllInterrupts()
           =9 #    endif
           =9 #   elif defined(VSTD_ENABLE_APPL_INTCTRL)
           =9 #    define VStdDeclareGlobalInterruptOldStatus
           =9 #    define VStdPutGlobalInterruptOldStatus(x)
           =9 #    define VStdGetGlobalInterruptOldStatus(x)
           =9 #    define VStdGlobalInterruptDisable()           VStdUserNestedDisable()
           =9 #    define VStdGlobalInterruptRestore()           VStdUserNestedRestore()
           =9 #    define VStdSuspendAllInterrupts()             VStdUserNestedDisable()
           =9 #    define VStdResumeAllInterrupts()              VStdUserNestedRestore()
           =9 #   else
           =9 #    error "Please check VStdLib interrupt configuration!"
           =9 #   endif
 306      =9  #   define VStdNestedGlobalInterruptDisable() VStdGlobalInterruptDisable()
 307      =9  #   define VStdNestedGlobalInterruptRestore() VStdGlobalInterruptRestore()
 308      =9  #  endif
 309      =9  
 310      =9  /* per default all memclr and memcpy functions are mapped on one routine which
 311      =9     does not support different memory models */
 312      =9  /* memset abstraction */
 313      =9  #  define VStdMemSet(d, p, l)                 VStdMemSetInternal((void*)(d), (p), (vuint16)(l))
 314      =9  #  define VStdMemNearSet(d, p, l)             VStdMemSetInternal((void*)(d), (p), (vuint16)(l))
 315      =9  #  define VStdMemFarSet(d, p, l)              VStdMemSetInternal((void*)(d), (p), (vuint16)(l))
 316      =9  
 317      =9  /* memclr abstraction */
 318      =9  #  define VStdMemClr(d, l)                    VStdMemClrInternal((void*)(d), (vuint16)(l))
 319      =9  #  define VStdMemNearClr(d, l)                VStdMemClrInternal((void*)(d), (vuint16)(l))
 320      =9  #  define VStdMemFarClr(d, l)                 VStdMemClrInternal((void*)(d), (vuint16)(l))
 321      =9  
 322      =9  /* memcpy abstraction */
 323      =9  #  define VStdMemCpyRamToRam(d, s, l)         VStdRamMemCpy((void*)(d), (void*)(s), (vuint16)(l))
 324      =9  #  define VStdMemCpyRomToRam(d, s, l)         VStdRomMemCpy((void*)(d), (V_MEMROM1 void V_MEMROM2 V_MEMROM
             -3 *)(s), (vuint16)(l))
 325      =9  
 326      =9  #  define VStdMemCpyRamToNearRam(d, s, l)     VStdRamMemCpy((d), (void*)(s), (l))
 327      =9  #  define VStdMemCpyRomToNearRam(d, s, l)     VStdRomMemCpy((d), (V_MEMROM1 void V_MEMROM2 V_MEMROM3 *)(s)
             -, (vuint16)(l))
 328      =9  
 329      =9  #  define VStdMemCpyRomToFarRam(d, s, l)      VStdRomMemCpy((d), (V_MEMROM1 void V_MEMROM2 V_MEMROM3 *)(s)
             -, (vuint16)(l))
 330      =9  
 331      =9  #  define VStdMemCpyRamToFarRam(d, s, l)      VStdRamMemCpy((d), (s), (vuint16)(l))
 332      =9  #  define VStdMemCpyFarRamToRam(d, s, l)      VStdRamMemCpy((d), (s), (vuint16)(l))
 333      =9  
 334      =9  #  define VStdMemCpyFarRamToFarRam(d, s, l)   VStdRamMemCpy((d), (s), (vuint16)(l))
 335      =9  #  define VStdMemCpyFarRomToFarRam(d, s, l)   VStdRomMemCpy((d), (s), (vuint16)(l))
 336      =9  
 337      =9  
 338      =9  
 339      =9  
 340      =9  /*********************************************************************************************************
             -************/
 341      =9  /* Compatibility                                                                                          
             -           */
 342      =9  /*********************************************************************************************************
             -************/
 343      =9  # define VStdMemCpy(d,s,l)     VStdMemCpyRamToRam((d),(s),(l))
 344      =9  
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 183 

 345      =9  # if defined(VSTD_HL_USE_VSTD_RAMMEMCPY)
 346      =9  # else
           =9 #  define VStdRamMemCpy(d,s,l) VStdMemCpyRamToRam((d),(s),(l))
           =9 # endif
 349      =9  
 350      =9  # if defined(VSTD_HL_USE_VSTD_ROMMEMCPY)
 351      =9  # else
           =9 #  define VStdRomMemCpy(d,s,l) VStdMemCpyRomToRam((d),(s),(l))
           =9 # endif
 354      =9  
 355      =9  /*********************************************************************************************************
             -************/
 356      =9  /* Prototypes of functions                                                                                
             -           */
 357      =9  /*********************************************************************************************************
             -************/
 358      =9  
 359      =9  /* initialization */
 360      =9  /* CODE CATEGORY 4 START*/
 361      =9  VSTD_API_0 void VSTD_API_1 VStdInitPowerOn(void);
 362      =9  /* CODE CATEGORY 4 END*/
 363      =9  /* function for moving data */
 364      =9  # if defined(VSTD_HL_USE_VSTD_MEMCLR)
 365      =9  /* CODE CATEGORY 1 START*/
 366      =9  VSTD_API_0 void VSTD_API_1 VStdMemClrInternal(void *pDest, vuint16 nCnt) VSTD_API_2;
 367      =9  /* CODE CATEGORY 1 END*/
 368      =9  # endif
 369      =9  # if defined(VSTD_HL_USE_VSTD_MEMSET)
 370      =9  /* CODE CATEGORY 1 START*/
 371      =9  VSTD_API_0 void VSTD_API_1 VStdMemSetInternal(void *pDest, vuint8 nPattern, vuint16 nCnt) VSTD_API_2;
 372      =9  /* CODE CATEGORY 1 END*/
 373      =9  # endif
 374      =9  # if defined(VSTD_HL_USE_VSTD_RAMMEMCPY)
 375      =9  /* CODE CATEGORY 1 START*/
 376      =9  VSTD_API_0 void VSTD_API_1 VStdRamMemCpy(void *pDest, void *pSrc, vuint16 nCnt) VSTD_API_2;
 377      =9  /* CODE CATEGORY 1 END*/
 378      =9  # endif
 379      =9  # if defined(VSTD_HL_USE_VSTD_ROMMEMCPY)
 380      =9  /* CODE CATEGORY 1 START*/
 381      =9  VSTD_API_0 void VSTD_API_1 VStdRomMemCpy(void *pDest, V_MEMROM1 void V_MEMROM2 V_MEMROM3 *pSrc, vuint16 nC
             -nt) VSTD_API_2;
 382      =9  /* CODE CATEGORY 1 END*/
 383      =9  # endif
 384      =9  
 385      =9  /* Declaration of additional memory manipulation functions */
 386      =9  
 387      =9  #  if defined(VSTD_ENABLE_INTCTRL_HANDLING)
 388      =9  
 389      =9  /* interrupt control functions */
 390      =9  #   if defined(VSTD_ENABLE_DEFAULT_INTCTRL)
 391      =9  /* CODE CATEGORY 1 START*/
 392      =9  VSTD_API_0 void VSTD_API_1 VStdSuspendAllInterrupts(void) VSTD_API_2;
 393      =9  /* CODE CATEGORY 1 END*/
 394      =9  /* CODE CATEGORY 1 START*/
 395      =9  VSTD_API_0 void VSTD_API_1 VStdResumeAllInterrupts(void) VSTD_API_2;
 396      =9  /* CODE CATEGORY 1 END*/
 397      =9  #   endif
 398      =9  
 399      =9  /* Declaration of additional Irq Support functions */
 400      =9  #  endif
 401      =9  
 402      =9  
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 184 

 403      =9  /*********************************************************************************************************
             -************/
 404      =9  /* Callback functions                                                                                     
             -           */
 405      =9  /*********************************************************************************************************
             -************/
 406      =9  # if defined(VSTD_ENABLE_DEBUG_SUPPORT)
           =9 /* CODE CATEGORY 4 START*/
           =9 VSTD_CALLBACK_0 void VSTD_CALLBACK_1 ApplVStdFatalError(vuint8 nErrorNumber);
           =9 /* CODE CATEGORY 4 END*/
           =9 # endif
 411      =9  
 412      =9  #endif
 413      =9  /************   Organi, Version 3.9.1 Vector-Informatik GmbH  ************/
 945      =8  # endif
 946      =8  
 947      =8  /* ************************************************************************* */
 948      =8  /*  V_NULL Definition                                                        */
 949      =8  /* ************************************************************************* */
 950      =8  
 951      =8  #if defined( C_COMP_KEIL_SLC8051_CCAN )           
 952      =8  # if !defined(V_NULL)    
 953      =8  #  define V_NULL 0
 954      =8  # endif
 955      =8  #endif
 956      =8  
 957      =8  
 958      =8  #if !defined(V_NULL)
           =8 # define V_NULL ((void*)0)
           =8 #endif
 961      =8  
 962      =8  
 963      =8  #ifndef NULL
           =8 # define NULL V_NULL
           =8 #endif
 966      =8  
 967      =8  
 968      =8  /*-----------------------------------------------------------------------------------------------*/
 969      =8  #if !defined(V_ENABLE_CAN_ASR_ABSTRACTION) && !defined(V_ENABLE_VSTDLIB_ASR_ABSTRACTION)
 970      =8  # define V_ENABLE_CBD_ABSTRACTION
 971      =8  # define STATIC                                          static /* MSR3 */
 972      =8  # define CAN_STATIC                                      static /* MSR4 */
 973      =8  # define AUTOMATIC
 974      =8  # if !defined(NULL_PTR)
 975      =8  #  define NULL_PTR                                        V_NULL
 976      =8  # endif
 977      =8  
 978      =8  #  define V_NONE       /* empty storage used instead of extern, static, volatile... */
 979      =8  
 980      =8  # if !defined( C_CALLBACK_1 )
 981      =8  #  define C_CALLBACK_1
 982      =8  # endif
 983      =8  # if !defined( C_CALLBACK_2 )
 984      =8  #  define C_CALLBACK_2
 985      =8  # endif
 986      =8  # if !defined( C_API_1 )
 987      =8  #  define C_API_1
 988      =8  # endif
 989      =8  # if !defined( C_API_2 )
 990      =8  #  define C_API_2
 991      =8  # endif
 992      =8  # if !defined( C_API_3 )
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 185 

           =8 #  define C_API_3
           =8 # endif
 995      =8  # define V_DEF_VAR(storage, vartype, memclass)                    V_MEMRAM0 storage V_MEMRAM1 vartype V_ME
             -MRAM2
 996      =8  # define V_DEF_VAR_NEAR(storage, vartype)                         V_MEMRAM0 storage V_MEMRAM1_NEAR vartype
             - V_MEMRAM2_NEAR
 997      =8  # define V_DEF_VAR_FAR(storage, vartype)                          V_MEMRAM0 storage V_MEMRAM1_FAR vartype 
             -V_MEMRAM2_FAR
 998      =8  # define V_DEF_VAR_TYPE(storage, vartype)                         typedef storage V_MEMRAM1 vartype V_MEMR
             -AM2
 999      =8  # define V_DEF_P2VAR(storage, ptrtype, memclass, ptrclass)        V_MEMRAM0 storage V_MEMRAM1 ptrtype V_ME
             -MRAM2 *
1000      =8  # define V_DEF_P2VAR_PARA(storage, ptrtype, memclass, ptrclass)   storage V_MEMRAM1 ptrtype V_MEMRAM2 *
1001      =8  # define V_DEF_P2VAR_TYPE(storage, ptrtype, ptrclass)             typedef storage V_MEMRAM1 ptrtype V_MEMR
             -AM2 *
1002      =8  /* platform specific order may be needed for MEMORY_CAN (position RAM1 or RAM2) */
1003      =8  # define V_DEF_P2SFR_CAN(storage, ptrtype, memclass)              V_MEMRAM0 storage V_MEMRAM1 ptrtype MEMO
             -RY_CAN *
1004      =8  # define V_DEF_P2SFR_CAN_TYPE(storage, ptrtype)                   typedef storage V_MEMRAM1 ptrtype MEMORY
             -_CAN *
1005      =8  /* --- */
1006      =8  # define V_DEF_CONSTP2VAR(storage, ptrtype, memclass, ptrclass)   V_MEMROM0 storage V_MEMRAM1 ptrtype V_ME
             -MRAM2 V_MEMRAM3 * V_MEMROM1 V_MEMROM2
1007      =8  # define V_DEF_CONST(storage, type, memclass)                     V_MEMROM0 storage V_MEMROM1 type V_MEMRO
             -M2
1008      =8  # define V_DEF_CONST_NEAR(storage, type)                          V_MEMROM0 storage V_MEMROM1_NEAR type V_
             -MEMROM2_NEAR
1009      =8  # define V_DEF_CONST_FAR(storage, type)                           V_MEMROM0 storage V_MEMROM1_FAR type V_M
             -EMROM2_FAR
1010      =8  # define V_DEF_CONST_TYPE(storage, type, memclass)                typedef storage V_MEMROM1 type V_MEMROM2
1011      =8  # define V_DEF_P2CONST(storage, ptrtype, memclass, ptrclass)      V_MEMRAM0 storage V_MEMROM1 ptrtype V_ME
             -MROM2 V_MEMROM3 * V_MEMRAM1 V_MEMRAM2
1012      =8  # define V_DEF_P2CONST_PARA(storage, ptrtype, memclass, ptrclass) storage V_MEMROM1 ptrtype V_MEMROM2 V_ME
             -MROM3 * V_MEMRAM1 V_MEMRAM2
1013      =8  # define V_DEF_P2CONST_TYPE(storage, ptrtype, ptrclass)           typedef storage V_MEMROM1 ptrtype V_MEMR
             -OM2 V_MEMROM3 *
1014      =8  # define V_DEF_CONSTP2CONST(storage, ptrtype, memclass, ptrclass) V_MEMROM0 storage V_MEMROM1 ptrtype V_ME
             -MROM2 V_MEMROM3 * V_MEMROM1 V_MEMROM2
1015      =8  # define V_DEF_FUNC(storage, rettype, memclass)                   storage rettype
1016      =8  # define V_DEF_FUNC_API(storage, rettype, memclass)               storage C_API_1 rettype C_API_2
1017      =8  # define V_DEF_FUNC_CBK(storage, rettype, memclass)               storage C_CALLBACK_1 rettype C_CALLBACK_
             -2
1018      =8  # define V_DEF_P2FUNC(storage, rettype, ptrclass, fctname)        storage C_CALLBACK_1 rettype (C_CALLBACK
             -_2 *fctname)
1019      =8  #endif
1020      =8  /*-----------------------------------------------------------------------------------------------*/
1021      =8  
1022      =8  #endif /* V_DEF_H */
1023      =8  
1024      =8  
1025      =8  /* STOPSINGLE_OF_MULTIPLE */
  54      =7  
  55      =7  
  56      =7  /* -----------------------------------------------------------------------------
  57      =7      &&&~ GENy Version Information
  58      =7   ----------------------------------------------------------------------------- */
  59      =7  
  60      =7  #define VGEN_DELIVERY_VERSION_BYTE_0         0x05
  61      =7  #define VGEN_DELIVERY_VERSION_BYTE_1         0x00
  62      =7  #define VGEN_DELIVERY_VERSION_BYTE_2         0x51
  63      =7  #define VGEN_DELIVERY_VERSION_BYTE_3         0x01
  64      =7  #define VGEN_DELIVERY_VERSION_BYTE_4         0x30
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 186 

  65      =7  #define VGEN_DELIVERY_VERSION_BYTE_5         0x02
  66      =7  #define VGEN_DELIVERY_VERSION_BYTE_6         0x86
  67      =7  #define VGEN_DELIVERY_VERSION_BYTE_7         0x01
  68      =7  #define VGEN_DELIVERY_VERSION_BYTE_8         0x00
  69      =7  #define VGEN_DELIVERY_VERSION_BYTE_9         0x00
  70      =7  #define kGENyVersionNumberOfBytes            10
  71      =7  /* ROM CATEGORY 4 START */
  72      =7  V_MEMROM0 extern  V_MEMROM1 vuint8 V_MEMROM2 kGENyVersion[kGENyVersionNumberOfBytes];
  73      =7  /* ROM CATEGORY 4 END */
  74      =7  
  75      =7  
  76      =7  
  77      =7  typedef struct tDBCVersionTag
  78      =7  {
  79      =7    vuint8 kYear;
  80      =7    vuint8 kMonth;
  81      =7    vuint8 kWeek;
  82      =7    vuint8 kDay;
  83      =7    vuint32 kNumber;
  84      =7  } tDBCVersion;
  85      =7  V_MEMROM0 extern  V_MEMROM1 tDBCVersion V_MEMROM2 kDBCVersion[1];
  86      =7  
  87      =7  /* begin Fileversion check */
  88      =7  #ifndef SKIP_MAGIC_NUMBER
  89      =7  #ifdef MAGIC_NUMBER
  90      =7    #if MAGIC_NUMBER != 204819919
           =7       #error "The magic number of the generated file <Y:\CANGEN\v_par.h> is different. Please check time a
             -nd date of generated files!"
           =7   #endif
  93      =7  #else
           =7   #define MAGIC_NUMBER 204819919
           =7 #endif  /* MAGIC_NUMBER */
  96      =7  #endif  /* SKIP_MAGIC_NUMBER */
  97      =7  
  98      =7  /* end Fileversion check */
  99      =7  
 100      =7  #endif /* __V_PAR_H__ */
  68      =6  #endif
  69      =6  
  70      =6  #include "can_def.h"               /* CAN driver header                     */
   1      =7  /* Kernbauer Version: 1.14 Konfiguration: can_driver Erzeugungsgangnummer: 1 */
   2      =7  
   3      =7  /* STARTSINGLE_OF_MULTIPLE */
   4      =7  
   5      =7  #ifndef  CAN_HL_H
   6      =7  # define  CAN_HL_H
   7      =7  
   8      =7  
   9      =7  /* KB begin CanLL_HeaderH */
  10      =7  /*****************************************************************************
  11      =7  | Project Name: C A N - D R I V E R
  12      =7  |    CBD: File Name: CAN_DEF.H
  13      =7  |    Asr: File Name: Can.h
  14      =7  |
  15      =7  |  Description: Application-Interface of the CAN-Driver
  16      =7  |               Declaration of functions, variables, and constants
  17      =7  |
  18      =7  |     Compiler: see module file
  19      =7  |
  20      =7  |-----------------------------------------------------------------------------
  21      =7  |               C O P Y R I G H T
  22      =7  |-----------------------------------------------------------------------------
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 187 

  23      =7  | Copyright (c) 1996-2012 by Vector Informatik GmbH.       All rights reserved.
  24      =7  |
  25      =7  | This software is copyright protected and proprietary 
  26      =7  | to Vector Informatik GmbH. Vector Informatik GmbH 
  27      =7  | grants to you only those rights as set out in the 
  28      =7  | license conditions. All other rights remain with 
  29      =7  | Vector Informatik GmbH.
  30      =7  |
  31      =7  |-----------------------------------------------------------------------------
  32      =7  |               A U T H O R   I D E N T I T Y
  33      =7  |-----------------------------------------------------------------------------
  34      =7  | Initials     Name                      Company
  35      =7  | --------     ---------------------     ------------------------------------
  36      =7  | Ht           Heike Honert              Vector Informatik GmbH
  37      =7  | Pl           Georg Pfluegel            Vector Informatik GmbH
  38      =7  | Kk           Karol Kostolny            Vector Informatik GmbH
  39      =7  | Aj           Arthur Jendrusch          Vector Informatik GmbH
  40      =7  |-----------------------------------------------------------------------------
  41      =7  |               R E V I S I O N   H I S T O R Y
  42      =7  |-----------------------------------------------------------------------------
  43      =7  | Date       Ver  Author  Description
  44      =7  | ---------  ---  ------ -- --------------------------------------------------
  45      =7  |
  46      =7  | 2001-04-18  1.0      Pl  - derived for ARM7 TDMI
  47      =7  | 2002-09-09  1.1      Pl  - change Baseadress of CAN-Cell
  48      =7  | 2002-11-12  1.20     Pl  - added ST10 C_CAN
  49      =7  |                          - support of LI 1.3 
  50      =7  | 2002-12-02  1.21     Pl  - ESCAN00004331: switch C_ENABLE_RX_BASICCAN_OBJECTS
  51      =7  |                            add to call of CanBasicCanMsgReceived in ISR.
  52      =7  |                            remove Warning: value of variable "localInterruptOldFlag"
  53      =7  |                            is undefined      
  54      =7  | 2003-02-25  1.22     Pl  - ESCAN00004697: Support Extended and Mixed ID and Keil Compiler 
  55      =7  |                          - ESCAN00004879, ESCAN00004889: Unused Objects are not initialized properly
  56      =7  |                          - ESCAN00004583, ESCAN00004589: The driver only supports up to 14 Direct Tx Obj
             -ects 
  57      =7  | 2003-03-25  1.23     Pl  - New Highlevelversion
  58      =7  |                          - Second Channel tested
  59      =7  | 2003-04-01  1.24     Pl  - added FR60Lite
  60      =7  |                          - support of LI 1.4  
  61      =7  | 2003-08-07  1.25     Pl  - ESCAN00006105: Change Structure tRxMsgObj to take care for 32Bit alignement  
             -                                               
  62      =7  |                          - ESCAN00006242: If the CAN-Controller is in the Error-Passive State,
  63      =7  |                                           CanLL_HwIsPassive can't monitor this
  64      =7  |                          - ESCAN00006282: The Interrupthandler has to be improved 
  65      =7  | 2004-01-20  1.25.01  Pl  - ESCAN00007207: macro CanLL_CanInterruptRestore(channel, mask):
  66      =7  |                                           the ICR register is not restored correctly
  67      =7  | 2004-07-26  1.26     Pl  - ESCAN00008948: Support of RI 1.4 for the ST10F27x
  68      =7  | 2004-10-28  1.26.01  Pl  - ESCAN00009984: In the Large-Model the driver don't work correct if 
  69      =7  |                                           class CNEAR is not located to 0xC000
  70      =7  |                          - ESCAN00010037: The use of CanCheckMemory has no effect
  71      =7  | 2005-03-23  1.27     Pl  - ESCAN00011351: misra complience, use of Highlevelversion 1.34
  72      =7  |                          - ESCAN00011621: If CanInit cancel a Transmitrequest and Tx-Polling is used,
  73      =7  |                                           there is still a call of the TxConfirmationfunction
  74      =7  |                          - ESCAN00011625: With the configuration Rx/Tx-Polling and Status-Interrupt the
  75      =7  |                                           Status-Interrupt is disabled
  76      =7  | 2005-04-06  1.28     Pl  - ESCAN00011737: Inside the Tx-Task there is a missing Interruptlock necessary 
             -      
  77      =7  |                          - ESCAN00011923: problems in the memory model large
  78      =7  | 2005-05-02  1.29     Pl  - ESCAN00012151: Support of 3.channel for the MB91016
  79      =7  |                          - ESCAN00011938: compile error: OSEK-OS support
  80      =7  | 2005-05-13  1.30     Pl  - ESCAN00012256: Support of GNU-Compiler for the ST10F27x
  81      =7  | 2005-07-28  1.31     Pl  - ESCAN00009530: Support Green Hills compiler for ST30
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 188 

  82      =7  |                          - ESCAN00013070: AVCCore added
  83      =7  | 2005-09-08  1.32     Pl  - ESCAN00012495: The compiler generate a warning because of the type of the def
             -ine
  84      =7  |                                           kRxOk and kTxOk
  85      =7  |                          - ESCAN00013468: Support Cancel in Hardware
  86      =7  |                          - ESCAN00012777: Reception of remote frame not blocked
  87      =7  |                          - ESCAN00013496: Change the Statuspolling
  88      =7  | 2005-10-25  1.33     Pl  - ESCAN00014049: Support of 128 Message-objects for the FR60 
  89      =7  | 2005-11-23  1.34     Pl  - ESCAN00014381: new platform MN103S added
  90      =7  | 2005-12-20  1.35     Pl  - ESCAN00014804: new platform ML67Q25xx added
  91      =7  |                          - ESCAN00014756: CANdrv may cause "illegal" CAN INTs
  92      =7  |                          - ESCAN00014506: CANdrv doesn't handle "illegal" CAN INTs
  93      =7  | 2006-03-09  1.36     Pl  - ESCAN00014989: Unconditional use of conditionally defined variables (linker e
             -rrors)
  94      =7  |                          - ESCAN00015382: support of individual polling
  95      =7  |                          - ESCAN00015610: support of dynamic Rx-Objects
  96      =7  |                          - ESCAN00015710: support of Cancel_In_Hardware for the FR60
  97      =7  |                          - ESCAN00015711: support of ARM compiler >= Version 2.0 (Realview) for the ST30
  98      =7  | 2006-03-23  1.37     Pl  - ESCAN00015803: dynamic BasicCAN message with standard ID is not received in a
             - mixed ID system
  99      =7  | 2006-03-28  1.38     Pl  - ESCAN00015851: support of RI 1.4 for ST30
 100      =7  | 2006-04-05  1.39     Pl  - ESCAN00015973: new platform MN101E added
 101      =7  | 2006-05-05  1.40     Pl  - ESCAN00016257: Support External Wakeup for the MN103S 
 102      =7  | 2006-06-27  1.41     Pl  - ESCAN00016709: Support of the Fj16Fx
 103      =7  |                          - ESCAN00016425: The macros CanTxWriteActId, CanTxWriteActExtId, CanTxWriteActD
             -LC don't work
 104      =7  |                          - ESCAN00016835: OKI ML67Q25xx: runtime issue when using function inlining by I
             -AR compiler
 105      =7  |                                           option "-s9" without "-no_inline"
 106      =7  | 2007-06-19  1.42     Pl  - ESCAN00020499: Support the new ST30 Derivat STA2058 with GNU complier
 107      =7  |                          - ESCAN00020068: Function CanGetStatus returns wrong status in case of error wa
             -rning
 108      =7  | 2008-01-16  1.43     Pl  - ESCAN00024007: Support MultipleConfiguration for the FR60
 109      =7  |                          - ESCAN00020713: Support static and dynamic acceptance masks for FullCAN receiv
             -e objects
 110      =7  |                          - ESCAN00021667: Wrong setting of receive mask in macro MK_RX_FULL_MASK_IDSTD1(
             -id)
 111      =7  |                          - ESCAN00022223: disable/restore CAN interrupts doesn't work correctly for mult
             -i channel configurations
 112      =7  |                          - ESCAN00023528: Struct members pChipMsgObj and pChipData added to the struct t
             -CanTxConfInfoStruct
 113      =7  | 2008-04-08  2.00     Pl  - ESCAN00028185: Support Autosar 3.0 for the Mb86r01 (Jade)
 114      =7  |                          - ESCAN00030391: Support Autosar 3.0 for the Fr60
 115      =7  | 2008-10-23  2.01     Pl  - ESCAN00030753: Smaller changes for the FR60 Autosar release
 116      =7  | 2008-10-23  2.02     Kk  - ESCAN00030850: Extension for MSR3.0 generator version checks (needed for ASR 
             -Highlevel version >= 3.3)
 117      =7  |                          - ESCAN00031289: Compiler error when Osek OS and category 2 interrupts are used
 118      =7  | 2008-11-24  2.03     Pl  - ESCAN00031502: Support CANbedded RI 1.5 for the Mb86r01
 119      =7  | 2008-12-15  2.04     Pl  - ESCAN00032036: Support Autosar 3.0 for the Fj16Fx
 120      =7  | 2009-04-03  2.05     Pl  - ESCAN00034375: Common CAN support for the FR60 platform
 121      =7  |                          - ESCAN00032273: Support new derivatives MB91F037 and MB91F038
 122      =7  |                          - ESCAN00032273: Call of CanCanInterruptDisable() and CanCanInterruptRestore() 
             -has no effect for some FR60 derivatives
 123      =7  | 2009-04-07  2.06     Aj  - ESCAN00034682: new platform TCC800x added
 124      =7  | 2009-01-08  2.07     Pl  - ESCAN00032459: Support Highend Features for the ST30/Sta2058
 125      =7  | 2009-09-17  2.08     Pl  - ESCAN00038124: Support compiler and memory abstraction for Autosar R7 with Fj
             -16Fx
 126      =7  | 2010-05-10  2.09     Pl  - ESCAN00042858: Support QNX for the Mb86r01 (Jade) Beta Release
 127      =7  | 2010-06-23  2.10     Pl  - ESCAN00043522: Support Autosar R9 with Fj16Fx 
 128      =7  |                      Pl  - ESCAN00033282: Missing prototype declaration: 'Can_CellIsr' leads to compiler
             - warnings
 129      =7  | 2010-07-23  2.11     Pl  - ESCAN00044242: Clearing of TransRequest, NewData and InterrPending has no eff
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 189 

             -ect
 130      =7  |                      Pl  - ESCAN00044243: Support of Context-switch for MB86R0x with QNX
 131      =7  |                      Pl  - ESCAN00044417: Support of derivative MB91F467S for the Fr60 AUTOSAR
 132      =7  |                      Pl  - ESCAN00038114: Interrupt 0 was not handled as an illegal interrupt
 133      =7  | 2010-11-12  2.12     Pl  - ESCAN00020068: Function CanGetStatus returns wrong status in case of error wa
             -rning
 134      =7  |                          - ESCAN00021559: the assertion inside the interrupt function don't work
 135      =7  |                          - ESCAN00021828: CanCanInterruptDisable do not disable the CAN-Interrupt
 136      =7  |                          - ESCAN00021173: Compiler warning due to double variable declaration 'localInte
             -rruptOldStatus'
 137      =7  |                          - ESCAN00024306: Compiler warning: Interrupt Function Not Found
 138      =7  |                          - ESCAN00020155: the interrupt functions for polling mode has to be disabled
 139      =7  |                          - ESCAN00020158: can-driver has handle the COER setting
 140      =7  |                          - ESCAN00026410: support of new Fj16Fx derivatives MB96F32X and MB96F35X added 
 141      =7  |                          - ESCAN00032941: support of new Fj16Fx derivatives MB96F38X added
 142      =7  |                          - ESCAN00036179: Function Can_CellIsr is not defined in special Configurations
 143      =7  |                          - ESCAN00046927: Support of RI 1.5 for the Fj16fx
 144      =7  |                          - ESCAN00047205: Support of new Fj16Fx derivatives MB96F31X and MB96F37X added
 145      =7  | 2011-01-05  2.13     Pl  - ESCAN00047858: Support of new platform FR81 with Softune compiler for Autosar
 146      =7  | 2011-03-15  2.14     Pl  - ESCAN00049271: Hardware issue "Data corruption by setting Init during transmi
             -ssion" fixed
 147      =7  |                          - ESCAN00049312: Support of new Fr60 derivative MB91F465B added
 148      =7  | 2011-05-11  2.15     Pl  - ESCAN00049297: Support of Highend Features for the Fr60
 149      =7  |                          - ESCAN00049298: Support CanRetransmit for the Fr60
 150      =7  |                          - ESCAN00050501: Return value of CanLL_TxIsHWObjFree is always kCanTrue
 151      =7  |                          - ESCAN00050829: Remove some compiler warnings
 152      =7  |                          - ESCAN00050831: The macro CanRxActualExtId do not work
 153      =7  | 2011-05-23  2.16     Pl  - ESCAN00049419: Support of MB96F65x for the Fj16Fx
 154      =7  | 2011-07-14  2.17     Pl  - ESCAN00052198: Support of the Fcr4 for Autosar
 155      =7  |                          - ESCAN00051819: Retransmit for the Fr60 do not work with C_MULTIPLE_RECEIVE_CH
             -ANNEL configurations
 156      =7  |                          - ESCAN00051906: Low-Level Message Transmit does not work on channels higher th
             -an a CommonCAN channel
 157      =7  | 2011-10-27  2.18     Pl  - ESCAN00053916: Configuration of COER is missing
 158      =7  |                          - ESCAN00054545: Autosar only: Pending confirmation requests will not be cleare
             -d by CanInit 
 159      =7  |                          - ESCAN00054546: Support of CanLL_CanInterruptDisable and CanLL_CanInterruptRes
             -tore for the Fcr4 
 160      =7  | 2011-11-08  2.19     Aj  - ESCAN00047857: [CBD]: Add support for AVN-A / C&S_Technology
 161      =7  | 2012-03-07  3.00     Pl  - ESCAN00055277: Support Autosar 4.0 for the Mn103s
 162      =7  |                          - ESCAN00057372: Support of MB96F61x for the Fj16Fx
 163      =7  |                          - ESCAN00057370: AR3-1698: Add MISRA justifications in source code for automati
             -c generation of MISRA reports
 164      =7  | 2012-07-23  3.01     Pl  - ESCAN00058631: compile error "undeclared identifier `VStdDeclareGlobalInterru
             -ptOldStatus'" occur
 165      =7  |                          - ESCAN00058794: The driver use a wrong Interrupt number for the CAN Interrupt 
             -with the derivative MB96F61X
 166      =7  |                          - ESCAN00056134: [CBD]: Add support for FM3 / Fujitsu
 167      =7  |                          - ESCAN00057475: [CBD]: Add support for FCR4 / Fujitsu
 168      =7  |                          - ESCAN00058597: Support platform Slc8051Fxx for Canbedded
 169      =7  |***************************************************************************/
 170      =7  /* KB end CanLL_HeaderH */
 171      =7  /* ***************************************************************************
 172      =7  |
 173      =7  |    ************    Version and change information of      **********        
 174      =7  |    ************    high level part only                   **********        
 175      =7  |
 176      =7  |    Please find the version number of the whole module in the previous 
 177      =7  |    File header.
 178      =7  |
 179      =7  |-----------------------------------------------------------------------------
 180      =7  |               A U T H O R   I D E N T I T Y
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 190 

 181      =7  |-----------------------------------------------------------------------------
 182      =7  | Initials     Name                      Company
 183      =7  | --------     ---------------------     ------------------------------------
 184      =7  | Ht           Heike Honert              Vector Informatik GmbH
 185      =7  | Pl           Georg Pfluegel            Vector Informatik GmbH
 186      =7  | Vg           Frank Voorburg            Vector CANtech, Inc.
 187      =7  | An           Ahmad Nasser              Vector CANtech, Inc.
 188      =7  | Ml           Patrick Markl             Vector Informatik GmbH
 189      =7  | Seu          Eugen Stripling           Vector Informatik GmbH
 190      =7  |-----------------------------------------------------------------------------
 191      =7  |               R E V I S I O N   H I S T O R Y
 192      =7  |-----------------------------------------------------------------------------
 193      =7  | Date       Ver  Author  Description
 194      =7  | ---------  ---  ------ -----------------------------------------------------
 195      =7  | ---------  ---  ------ -- --------------------------------------------------
 196      =7  | 24-Jan-01  0.02      Ht     - derived from C16x V3.3
 197      =7  | 18-Apr-01  1.00      Pl     - adaption for ARM7 TDMI
 198      =7  | 26-Apr-01  1.01      Ht     - adaption to LI 1.2
 199      =7  |                             - changed from code doupling to indexed
 200      =7  | 19-Jun-01            Ht     - define of CanSetActive/Passive changed
 201      =7  | 31-Oct-01  1.02      Ht     - support hash search
 202      =7  |                      Vg     - adaption for PowerPC
 203      =7  | 07-Nov-01  1.03      Ht     - remove some comments
 204      =7  | 12-Nov-01  1.04      Fz     - no changes
 205      =7  | 02-Jan-02  1.05      Ht     - ESCAN00002009: support of polling mode improved
 206      =7  | 12-Feb-02  1.06      Pl     - ESCAN00002279: - now it is possible to use only the error-task without the
             - tx-task
 207      =7  |                                              - support of the makro  REENTRANT
 208      =7  |                                              - support of the makro C_HL_ENABLE_RX_INFO_STRUCT_PTR
 209      =7  |                                              - For better performance for the T89C51C there is a switch-
             -case
 210      =7  |                                                instruction for direct call of the PreTransmitfunction
 211      =7  |                                              - insert Prototyp for CanErrorTask
 212      =7  | 18-Mai-02  1.07       Ht    - support Hash search with FullCAN controller
 213      =7  |                             - ESCAN00002707: Reception could went wrong if IL and Hash Search
 214      =7  |                             - ESCAN00002893: adaption to LI 1.3
 215      =7  | 29-Mai-02  1.08       Ht    - ESCAN00003028: Transmission could fail in Polling mode
 216      =7  |                             - ESCAN00003082: call Can_LL_TxEnd() in CanMsgTransmit()
 217      =7  |                             - ESCAN00003083: Hash search with extended ID
 218      =7  |                             - ESCAN00003084: Support C_COMP_METROWERKS_PPC
 219      =7  |                             - ESCAN00002164: Temporary vaiable "i" not defined in function CanBasicCanMs
             -gReceived
 220      =7  |                             - ESCAN00003085: support C_HL_ENABLE_IDTYPE_IN_ID
 221      =7  | 25-Jun     1.08.01    Vg    - Declared localInterruptOldFlag in CanRxTask()
 222      =7  |                             - Corrected call to CanWakeUp for multichannel
 223      =7  | 11-Jul-02  1.08.02    Ht    - ESCAN00003203: Hash Search routine does not work will with extended IDs
 224      =7  |                             - ESCAN00003205: Support of ranges could went wrong on some platforms
 225      =7  | 08-Aug-02  1.08.03    Ht    - ESCAN00003447: Transmission without databuffer and pretransmit-function 
 226      =7  | 08-Aug-02  1.08.04    An      no changes
 227      =7  | 09-Sep-02  1.09       Ht    - ESCAN00003837: code optimication with KernelBuilder 
 228      =7  | 2002-12-12 1.10       Ht    -                support Dummy functions for indirect function call 
 229      =7  | 2003-02-04 1.11       Ht    -                optimization for polling mode
 230      =7  |                       Fz    - ESCAN00004600: Flags changed for V850 aFCAN only
 231      =7  | 2003-03-19 1.12       Ht    - ESCAN00005153: Wrong number of Indication bytes for V850 aFCAN only
 232      =7  |                             - ESCAN00005152: optimization of CanInit() in case of Direct Tx Objects
 233      =7  |                             - ESCAN00005143: CompilerWarning about function prototype 
 234      =7  |                                              CanHL_ReceivedRxHandle() and CanHL_IndRxHandle
 235      =7  |                             - ESCAN00005130: Wrong result of Heash Search on second or higher channel   
             -            
 236      =7  | 2003-05-12 1.13       Ht    - ESCAN00005624: support CantxMsgDestroyed for multichannel system
 237      =7  |                             - ESCAN00005209: Support confirmation and indication flags for EasyCAN4
 238      =7  |                             - ESCAN00004721: Change data type of Handle in CanRxInfoStruct
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 191 

 239      =7  | 2003-06-18 1.20       Ht    - ESCAN00005908: support features of RI1.4
 240      =7  |                             - Support FJ16LX-Workaround for multichannel system
 241      =7  |                             - ESCAN00005671: Dynamic ID in extended ID system could fail
 242      =7  |                             - ESCAN00005863: Notification about cancelation failes in case of CanTxMsgDe
             -stroyed
 243      =7  | 2003-06-30 1.21       Ht   - ESCAN00006117: Common Confirmation Function: Write access to wrong memory l
             -ocation
 244      =7  |                            - ESCAN00006008: CanCanInterruptDisable in case of polling
 245      =7  |                            - ESCAN00006118: Optimization for Mixed ID and ID type in Own Register or ID 
             -type in ID Register
 246      =7  |                            - ESCAN00006063: Undesirable hardware dependency for 
 247      =7  |                                             CAN_HL (CanLL_RxBasicTxIdReceived)
 248      =7  | 2003-09-10 1.22       Ht   - ESCAN00006853: Support V_MEMROM0
 249      =7  |                            - ESCAN00006854: suppress some Compiler warnings
 250      =7  |                            - ESCAN00006856: support CanTask if only Wakeup in polling mode
 251      =7  |                            - ESCAN00006857: variable newDLC not defined in case of Variable DataLen
 252      =7  | 2003-10-14 1.23       Ht   - ESCAN00006858: support BrsTime for internal runtime measurement
 253      =7  |                            - ESCAN00006860: support Conditional Msg Receive
 254      =7  |                            - ESCAN00006865: support "Cancel in HW" with CanTask
 255      =7  |                            - ESCAN00006866: support Direct Tx Objects
 256      =7  |                            - ESCAN00007109: support new memory qualifier for const data and pointer to c
             -onst
 257      =7  | 2004-01-05 1.24       Ml   - ESCAN00007206: no changes
 258      =7  |                       Ml   - ESCAN00007254: several changes
 259      =7  | 2004-02-06 1.25       Ml   - ESCAN00007281: no changes
 260      =7  |                       Ml   - removed compiler warnings
 261      =7  | 2004-02-21 1.26       Ml   - ESCAN00007670: CAN RAM check
 262      =7  |                       Ml   - ESCAN00007671: no changes
 263      =7  |                       Ml   - ESCAN00007764: no changes
 264      =7  |                       Ml   - ESCAN00007681: no changes
 265      =7  |                       Ml   - ESCAN00007272: no changes
 266      =7  |                       Ml   - ESCAN00008064: encapsulated CanRxHashId in case of array dimension == 0
 267      =7  | 2004-04-16 1.27       Ml   - ESCAN00008204: Optimized CanRxActualId for different ID modes
 268      =7  |                       Ml   - ESCAN00008160: encapsulated functions declared by tool in case of multichan
             -nel
 269      =7  |                       Ml   - ESCAN00008266: changed name of parameter of function CanTxGetActHandle
 270      =7  |                       Fz   - ESCAN00008272: Compiler error due to missing array canPollingTaskActive
 271      =7  | 2004-05-10 1.28       Fz   - ESCAN00008328: Compiler error if cancel in hardware is active
 272      =7  |                            - ESCAN00008363: Hole closed when TX in interrupt and cancel in HW is used
 273      =7  |                            - ESCAN00008365: Switch C_ENABLE_APPLCANPREWAKEUP_FCT added
 274      =7  |                            - ESCAN00008391: Wrong parameter macro used in call of 
 275      =7  |                                             CanLL_WakeUpHandling
 276      =7  | 2004-05-24 1.29       Ht   - ESCAN00008441: Interrupt not restored in case of internal error if TX Polli
             -ng is used
 277      =7  | 2004-09-21 1.30       Ht   - ESCAN00008824: check of reference implementation version added
 278      =7  |                            - ESCAN00008825: No call of ApplCanMsgCancelNotification during CanInit()
 279      =7  |                            - ESCAN00008826: Support asssertions for "Conditional Message Received"  
 280      =7  |                       Ml   - ESCAN00008752: Added function qualifier macros
 281      =7  |                       Ht   - ESCAN00008823: compiler error due to array size 0
 282      =7  |                            - ESCAN00008977: label without instructions
 283      =7  |                            - ESCAN00009485: Message via Normal Tx Object will not be sent  
 284      =7  |                            - ESCAN00009497: support of CommonCAN and RX queue added
 285      =7  | 2004-09-28 1.31       Ht   - ESCAN00009703: unresolved functions CAN_POLLING_IRQ_DISABLE/RESTORE()
 286      =7  | 2004-11-25 1.32       Ht   - move fix for ESCAN00007671 to CAN-LL of DrvCan_MpcToucanHll
 287      =7  |                            - ESCAN00010350: Dynamic Tx messages are send always with Std. ID
 288      =7  |                            - ESCAN00010388: ApplCanMsgConfirmed will only be called if realy transmitted
 289      =7  |                       Ml   - ESCAN00009931: The HardwareLoopCheck should have a channelparameter in mult
             -ichannel systems.
 290      =7  |                            - ESCAN00010093: lint warning: function type inconsistent "CanCheckMemory"
 291      =7  |                        Ht  - ESCAN00010811: remove Misra and compiler warnings
 292      =7  |                            - ESCAN00010812: support Multi ECU
 293      =7  |                            - ESCAN00010526: CAN interrupts will be disabled accidently
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 192 

 294      =7  |                            - ESCAN00010584: ECU may crash or behave strange with Rx queue active
 295      =7  | 2005-01-20 1.33       Ht   - ESCAN00010877: ApplCanMsgTransmitConf() is called erronemous
 296      =7  | 2005-03-03 1.34       Ht   - ESCAN00011139: Improvement/Correction of C_ENABLE_MULTI_ECU_CONFIG
 297      =7  |                            - ESCAN00011511: avoid PC-Lint warnings
 298      =7  |                            - ESCAN00011512: copy DLC in case of variable Rx Datalen
 299      =7  |                            - ESCAN00010847: warning due to missing brakets in can_par.c at CanChannelObj
             -ect
 300      =7  | 2005-05-23 1.35       Ht   - ESCAN00012445: compiler error "V_MEMROMO undefined"in case of multi ECU
 301      =7  |                            - ESCAN00012350: Compiler Error "Illegal token channel"
 302      =7  | 2005-07-06 1.36       Ht   - ESCAN00012153: Compile Error: missing declaration of variable i
 303      =7  |                            - ESCAN00012460: Confirmation of LowLevel message will run into assertion (C_
             -ENABLE_MULTI_ECU_PHYS enabled)
 304      =7  |                            - support Testpoints for CanTestKit
 305      =7  | 2005-07-14 1.37       Ht   - ESCAN00012892: compile error due to missing logTxObjHandle
 306      =7  |                            - ESCAN00012998: Compile Error: missing declaration of txHandle in CanInit()
 307      =7  |                            - support Testpoints for CanTestKit for FullCAN controller
 308      =7  | 2005-10-05 1.38       Ht   - ESCAN00013597: Linker error: Undefined symbol 'CanHL_IndRxHandle'
 309      =7  | 2005-11-10 1.39.00    Ht   - ESCAN00014331: Compile error due to missing 'else' in function CanTransmit
 310      =7  | 2005-04-26 2.00.00    Ht   - ESCAN00016698: support RI1.5
 311      =7  |                            - ESCAN00014770: Cosmic compiler reports truncating assignement
 312      =7  |                            - ESCAN00016191: Compiler warning about unused variable in CanTxTask
 313      =7  | 2007-01-23 2.01.00    Ht   - ESCAN00017279: Usage of SingleGlobalInterruptDisable lead to assertion in O
             -SEK
 314      =7  |                            - ESCAN00017148: Compile error in higher layer due to missing declaration of 
             -CanTxMsgHandleToChannel
 315      =7  | 2007-03-14 2.02.00   Ht    - ESCAN00019825: error directives added and misra changes
 316      =7  |                            - ESCAN00019827: adaption to never version of VStdLib.
 317      =7  |                            - ESCAN00019619: V_CALLBACK_1 and V_CALLBACK_2 not defined
 318      =7  |                            - ESCAN00019953: Handling of FullCAN reception in interrupt instead of pollin
             -g or vice versa.
 319      =7  |                            - ESCAN00019958: CanDynTxObjSetId() or CanDynTxObjSetExtId() will run into as
             -sertion
 320      =7  | 2007-03-26 2.03.00  Ht     - ESCAN00019988: Compile warnings in can_drv.c
 321      =7  |                            - ESCAN00018831: polling mode: function prototype without function implemenat
             -ion (CanRxFullCANTask + CanRxBasicCANTask)
 322      =7  | 2007-04-20 2.04.00  dH     - ESCAN00020299: user assertion fired irregularly due to unknown parameter (i
             -n case of CommonCAN)
 323      =7  | 2007-05-02 2.05.00  Ht     - ESCAN00021069: Handling of canStatus improved, usage of preprocessor define
             -s unified
 324      =7  |                            - ESCAN00021070: support relocation of HW objects in case of Multiple configu
             -ration
 325      =7  |                            - ESCAN00021166: Compiler Warnings: canHwChannel & canReturnCode not used in 
             -CanGetStatus
 326      =7  |                            - ESCAN00021223: CanCanInterruptDisabled called during Sleepmode in CanWakeup
             -Task
 327      =7  |                            - ESCAN00022048: Parameter of ApplCancorruptMailbox is hardware channel inste
             -ad of logical channel - Error directive added
 328      =7  | 2007-11-12 2.06.00  Ht     - ESCAN00023188: support CAN Controller specific polling sequence for BasicCA
             -N objects
 329      =7  |                            - ESCAN00023208: Compile issue about undefined variable kCanTxQueuePadBits in
             - the CAN driver in Bit based Tx queue
 330      =7  | 2008-10-20 2.07.00  Ht     - ESCAN00023010: support disabled mailboxes in case of extended RAM check
 331      =7  |                            - ESCAN00025706: provide C_SUPPORTS_MULTI_ECU_PHYS
 332      =7  |                            - ESCAN00026120: compiler warnings found on DrvCan_V85xAfcanHll RI 1.5     ##
             -Ht: reviewed 2008-09-03
 333      =7  |                            - ESCAN00026322: ApplCanMsgNotMatched not called in special configuration
 334      =7  |                            - ESCAN00026413: Add possibility to reject remote frames received by FullCAN 
             -message objects
 335      =7  |                            - ESCAN00028758: CAN HL must support QNX
 336      =7  |                            - ESCAN00029788: CommonCAN for Driver which support only one Tx object improv
             -ed (CanInit()).
 337      =7  |                            - ESCAN00029889: Compiler warning about uninitialized variable canHwChannel i
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 193 

             -n CanCanInterruptDisable/Restore()
 338      =7  |                            - ESCAN00029891: Compiler warning: variable "rxHandle" was set but never used
 339      =7  |                            - ESCAN00029929: Support Extended ID Masking for Tx Fullcan messages 
 340      =7  |                            - ESCAN00030371: Improvements (assertions, misra)
 341      =7  |                            - ESCAN00027931: Wrong check of "queueBitPos" size
 342      =7  | 2009-04-08 2.08.00  Ht     - ESCAN00034492: no automatic remove of CanCanInterruptDisable/Restore
 343      =7  |                            - ESCAN00031816: CANRANGExIDTYPE can be removed and direct expression used
 344      =7  |                            - ESCAN00032027: CanMsgTransmit shall support tCanMsgTransmitStruct pointer a
             -ccesses to far RAM
 345      =7  |                            - ESCAN00034488: Postfix for unsigned const in perprocessor directives are no
             -t supported by all Compiler (ARM-Compiler 1.2)
 346      =7  | 2009-06-04 2.08.01  Ht     - ESCAN00035426: Compiler warning about truncation in CanGetStatus removed
 347      =7  | 2009-10-21 2.09.00  Ht     - ESCAN00036258: Compiler warning about "CanHL_ReceivedRxHandle" was declared
             - but never referenced
 348      =7  |                            - ESCAN00038642: Support reentrant functions for compiler with own keyword
 349      =7  |                            - ESCAN00038645: support new switch C_ENABLE_UPDATE_BASE_ADDRESS
 350      =7  | 2010-02-01 2.10.00  Ht     - ESCAN00036260: Support configuartion without static Tx messages and only on
             -e channel (remove compiler warning)
 351      =7  |                            - ESCAN00040478: Handle update of virtual CanBaseAdress in accordance to QNX 
             -documentation
 352      =7  |                            - ESCAN00039235: Compiler Warning: Narrowing or Signed-to-Unsigned type conve
             -rsion
 353      =7  | 2010-07-22 2.11.00  Ht     - ESCAN00044221: support Retransmit functionality for FBL
 354      =7  |                            - ESCAN00044222: internal changes: improve readability and
 355      =7  |                                             change CAN_CAN_INTERRUPT_... macros to avoid preprocessor er
             -rors for some compiler
 356      =7  |                            - ESCAN00044174: TxBitQueue only - compiler warning occurs about: condition i
             -s always true
 357      =7  | 2010-10-22 2.12.00  Ht - ESCAN00046326: support  C_COMP_KEIL_XC800 and  C_COMP_TI_TMS320
 358      =7  | 2011-05-17 2.13.00  Ht - ESCAN00048965: Add assertion check txMsgStruct for NULL-Pointer value in CanMsg
             -Transmit() API
 359      =7  |                        - ESCAN00050948: support retransmit macro if kCanHwTxStartIndex != 0.
 360      =7  | 2012-04-23 2.14.00  Ht - ESCAN00053779: Linker error: CanBaseAddressRequest() and CanBaseAddressActivate
             -() are not available
 361      =7  |                        - ESCAN00056617: remove brackets in macro CanInterruptDisable/Restore()
 362      =7  |                        - ESCAN00058520: support CommonCAN in combination with RAM check
 363      =7  |                        - ESCAN00058521: support C_COMP_KEIL_SLC8051_CCAN
 364      =7  |                        - ESCAN00058522: some  message will be not be received via BasicCAN if index sear
             -ch and multichannel are active
 365      =7  |                        - ESCAN00058104: compiler warning occurs about: comparison between signed and uns
             -igned
 366      =7  | 2012-04-23 2.14.01  Ht - ESCAN00058636: some BasicCAN messages will not be received with linear search
 367      =7  | 2012-05-11 2.15.00  Seu - ESCAN00058891: Add switch C_HL_ENABLE_PRETRANSMIT_SWITCH_COMMENT
 368      =7  | 2012-07-02 2.15.01  Ht  - ESCAN00058586: Compiler warning: comparison is always true due to limited rang
             -e of data type
 369      =7  |                         - ESCAN00059562: Compile error: Size of array CanRxMsgIndirection is zero if ind
             -ex search and no Rx FullCANs are used
 370      =7  |                         - ESCAN00059736: Compiler warning: pointless comparison of unsigned integer with
             - zero
 371      =7  |
 372      =7  |    ************    Version and change information of      **********        
 373      =7  |    ************    high level part only                   **********        
 374      =7  |
 375      =7  |    Please find the version number of the whole module in the previous 
 376      =7  |    File header.
 377      =7  |
 378      =7  |************************************************************************** */
 379      =7  
 380      =7  
 381      =7  /* *********************************************************************** */
 382      =7  /* Version                  (abcd: Main version ab Sub Version cd )        */
 383      =7  /* *********************************************************************** */
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 194 

 384      =7  /* KB begin CanLL_VersionH */
 385      =7  /* ##V_CFG_MANAGEMENT ##CQProject : DrvCan_St10CcanHll CQComponent : Implementation */
 386      =7  
 387      =7  #define DRVCAN_ST10CCANHLL_VERSION 0x0301
 388      =7  #define DRVCAN_ST10CCANHLL_RELEASE_VERSION 0x00
 389      =7  /* KB end CanLL_VersionH */
 390      =7  
 391      =7  
 392      =7  /* ##V_CFG_MANAGEMENT ##CQProject : DrvCan__coreHll CQComponent : Implementation */
 393      =7  # define DRVCAN__COREHLL_VERSION                 0x0215
 394      =7  # define DRVCAN__COREHLL_RELEASE_VERSION         0x01
 395      =7  
 396      =7  /* KB begin CanHL_TxQueueVersionH */
 397      =7  #define DRVCAN__HLLTXQUEUEBIT_VERSION 0x0106
 398      =7  #define DRVCAN__HLLTXQUEUEBIT_RELEASE_VERSION 0x04
 399      =7  /* KB end CanHL_TxQueueVersionH */
 400      =7  
 401      =7  /* *********************************************************************** */
 402      =7  /* Include                                                                 */
 403      =7  /* *********************************************************************** */
 404      =7  
 405      =7  # include "v_def.h"
   1      =8  /* STARTSINGLE_OF_MULTIPLE */
   2      =8  /*****************************************************************************
   3      =8  | Project Name: V E C T O R   -  Common module type definition header
   4      =8  |    File Name: v_def.h
   5      =8  |
   6      =8  |  Description: Declares types and definitions common to all 
   7      =8  |               VECTOR CANbedded modules.
   8      =8  | 
   9      =8  |               Note:
  10      =8  |               =====
  11      =8  |               that some hardware dependent settings are included in this file.
  12      =8  |               Never mix up files with same namings but intended for 
  13      =8  |               other hardware platforms.
  14      =8  |
  15      =8  |
  16      =8  |-----------------------------------------------------------------------------
  17      =8  |               C O P Y R I G H T
  18      =8  |-----------------------------------------------------------------------------
  19      =8  | Copyright (c) 2013 by Vector Informatik GmbH.       All rights reserved.
  20      =8  |
  21      =8  | This software is copyright protected and proprietary 
  22      =8  | to Vector Informatik GmbH. Vector Informatik GmbH 
  23      =8  | grants to you only those rights as set out in the 
  24      =8  | license conditions. All other rights remain with 
  25      =8  | Vector Informatik GmbH.
  26      =8  |
  27      =8  |-----------------------------------------------------------------------------
  28      =8  |               A U T H O R   I D E N T I T Y
  29      =8  |-----------------------------------------------------------------------------
  30      =8  | Initials     Name                      Company
  31      =8  | --------     ---------------------     ------------------------------------
  32      =8  |   Hp         Armin Happel              Vector Informatik GmbH
  33      =8  |   Ht         Heike Honert              Vector Informatik GmbH
  34      =8  |   dH         Gunnar de Haan            Vector Informatik GmbH
  35      =8  |   Et         Thomas Ebert              Vector Informatik GmbH
  36      =8  |   Wr         Hans Waaser               Vector Informatik GmbH
  37      =8  |   Vg         Frank Voorburg            Vector CANtech, Inc.
  38      =8  |   Ds         Hussain Darwish           Vector CANtech, Inc.
  39      =8  |   RAP        Rebecca Pipkorn           Vector CANtech, Inc.
  40      =8  |   BWR        Brandon Root              Vector CANtech, Inc.
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 195 

  41      =8  |   Ml         Patrick Markl             Vector Informatik GmbH
  42      =8  |   Pl         Georg Pfluegel            Vector Informatik GmbH
  43      =8  |   LS         Konrad Lazarus            Vector Informatik GmbH
  44      =8  |   Zw         Werner Ziegler            Vector Informatik GmbH
  45      =8  |   Bs         Thomas Balster            Vector Informatik GmbH
  46      =8  |   Stu        Bernd Stumpf              Vector Informatik GmbH
  47      =8  |   Pet        Thomas Petrus             Vector Informatik GmbH
  48      =8  |   To         Torsten Schmidt           Vector Informatik GmbH
  49      =8  |   Ap         Andreas Pick              Vector Informatik GmbH
  50      =8  |   Tri        Frank Triem               Vector Informatik GmbH
  51      =8  |   WM         Marco Wierer              Vector Informatik GmbH
  52      =8  |   Bir        Holger Birke              Vector Informatik GmbH
  53      =8  |   Ces        Senol Cendere             Vector Informatik GmbH
  54      =8  |   Ms         Gunnar Meiss              Vector Informatik GmbH
  55      =8  |   Ths        Thomas Sommer             Vector Informatik GmbH
  56      =8  |   Krt        Kerstin Thim              Vector Informatik GmbH
  57      =8  |   Fn         Matthias Fleischmann      Vector Informatik GmbH
  58      =8  |   Svh        Sven Hesselmann           Vector Informatik GmbH
  59      =8  |   Ard        Thomas Arnold             Vector Informatik GmbH
  60      =8  |   Her        Peter Herrmann            Vector Informatik GmbH
  61      =8  |   swk        Slawomir Wilk             Vector Informatik GmbH
  62      =8  |   Ou         Mihai Olariu              Vector Informatik GmbH
  63      =8  |   Tvi        Timo Vanoni               Vector Informatik GmbH
  64      =8  |   Kk         Karol Kostolny            Vector Informatik GmbH
  65      =8  |   Aj         Arthur Jendrusch          Vector Informatik GmbH
  66      =8  |   vadaba     Abir Bazzi                Vector CANtech, Inc
  67      =8  |   Rna        Ruediger Naas             Vector Informatik GmbH
  68      =8  |   Eta        Edgar Tongoona            Vector Informatik GmbH
  69      =8  |   Rse        Robert Schelkle           Vector Informatik GmbH
  70      =8  |   Seu        Eugen Stripling           Vector Informatik GmbH
  71      =8  |   Was        Andreas Weinrauch         Vector Informatik GmbH
  72      =8  |   QPs        Quetty Palacios           Vector Informatik GmbH
  73      =8  |   Tkr        Torsten Kercher           Vector Informatik GmbH
  74      =8  |   Bmo        Bastian Molkenthin        Vector Informatik GmbH
  75      =8  |-----------------------------------------------------------------------------
  76      =8  |               R E V I S I O N   H I S T O R Y
  77      =8  |-----------------------------------------------------------------------------
  78      =8  | Date       Ver    Author  Description
  79      =8  | ---------  ----   ------  --------------------------------------------------
  80      =8  | 13-Mar-01  1.00    Hp     Creation
  81      =8  | 04-Apr-01  1.01    Ht     general rework 
  82      =8  | 05-Apr-01  1.02    dH     added Fujitsu FFMC16LX
  83      =8  | 05-Apr-01  1.03    HH     added COMP_GHS_V85X
  84      =8  | 11-Apr-01  1.04    Et     added LIN components
  85      =8  | 23-Apr-01  1.05    Si     corrections for C_COMP_IAR_78K0
  86      =8  |                           lint comments added
  87      =8  | 29-Mai-01  1.06    Pl     added ARM7 STMICRO
  88      =8  | 22-Jun-01  1.07    Ht     added ANSI CANoe
  89      =8  | 03-Jul-01          Wr     added C_COMP_OKI_CC665S
  90      =8  | 12-Jul-01          Et     support combination of "old" CAN driver and "new" LIN driver
  91      =8  | 13-Jul-01  1.08    Ht     error check for supported systems and switches added
  92      =8  | 16-Jul-01          dH     added C_COMP_HEW_SH7055 / C_COMP_HEW_H8S
  93      =8  | 17-Aug-01  1.09    Et     deleted keywords __near and __far for C_COMP_FUJITSU_8L
  94      =8  | 21-Aug-01  1.10    Ht/Vg  added C_COMP_DIABDATA_PPC
  95      =8  | 25-Aug-01  1.11    Ml     added #pragma MESSAGE DISABLE C1106 for Hiware HC08 compiler
  96      =8  | 06-Sep-01  1.12    Ht/Vg  added C_COMP_GNU_ST9
  97      =8  | 11-Sep-01  1.13    Fr     added C_COMP_ANSI_TMS_470
  98      =8  | 21-Sep-01  1.14    Pl     added C_COMP_MCP18_PIC_INT
  99      =8  | 25-Sep-01  1.15    Vg     added C_COMP_MICROTEC_MC376 and C_COMP_TASKING_MC376
 100      =8  | 28-Sep-01  1.16    Hp     added C_COMP_GHS_TX39 and C_COMP_TOSHIBA_TLC900
 101      =8  | 23-Oct-01  1.17    Js     added C_COMP_DIABDATA_MCORE
 102      =8  | 23-Oct-01  1.18    dH     changed ..._SH705X to ..._SH705X
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 196 

 103      =8  | 05-Nov-01  1.19    dH     added M32R
 104      =8  | 19-Nov-01  1.20    Ht     added C_COMP_xxx_XC16X
 105      =8  | 22-Nov-01  1.21    dH     added C_COMP_IAR_H8S
 106      =8  | 11-Nov-01  1.22    Fz     added C_COMP_MITSUBISHI_M32C/C_COMP_NEC_V85X
 107      =8  | 19-Dec-01  1.23    dH     changed Fujitsu FFMC16LX
 108      =8  | 28-Jan-02  1.24    Ml     ESCAN00002160: added paging keywords for HC12
 109      =8  | 31-Jan-02  1.25    Pl     added C_COMP_KEIL_T89C51C
 110      =8  | 07-Mar-02  1.26    Vg/Rn  added C_COMP_METROWERKS_PPC
 111      =8  | 27-Mar-02  1.27    Fz     added C_COMP_IAR_V85X
 112      =8  | 09-Apr-02  1.28    Ht     addaption to LI 1.3
 113      =8  | 02-Apr-02  1.29    Ml     added C_COMP_METROWERKS_MGT5100
 114      =8  |                           added C_COMP_METROWERKS_DSP56F80X
 115      =8  | 13-May-02  1.30    LS     MEMORY_HUGE added for C_COMP_TASKING_C16X
 116      =8  | 21-May-02  1.31    Ml     canbittype for HC12 is now unsigned short
 117      =8  | 10-Jul-02  1.32    Ml     canbittype for HC12 changed to unsigned char
 118      =8  | 16-Jul-02  1.33a   Fz     canbittype for V850 changed to unsigend int
 119      =8  |                           _c_bits32 added  
 120      =8  | 31-Jul-02          Ts     added C_COMP_HEW_SH70XX_HCAN2
 121      =8  | 31-Jul-02  1.33    Ht     _c_bits16 added for C_CPUTYPE_BITORDER_MSB2LSB
 122      =8  | 31-Jul-02  1.34    Si     pc-lint comments for 78K0 changed
 123      =8  | 02-Aug-02  1.33    Sf     ESCAN00003192  Memory qualifier for M16C changed
 124      =8  | 08-Aug-02  1.34    Zw     ESCAN00003456  added STmicro ST7 (beCAN) / Hiware
 125      =8  | 18-Aug-02          Pet    ESCAN00003530  delete keyword near for HC08
 126      =8  | 06-Sep-02  1.35    Zw     ESCAN00003688: MEMORY_NEAR defined to nothing for ST7_beCAN
 127      =8  | 09-Sep-02  1.36    Bs     controller OKI MSM9225B (C_COMP_GHS_ARM7TM) added (needed for FBL)
 128      =8  | 10-Sep-02  1.37    Ds     added C_COMP_COSMIC_ST7_BECAN
 129      =8  |                           and   C_COMP_HIWARE_ST7_BECAN
 130      =8  | 13-Sep-02  1.38    Ht     rework the module
 131      =8  | 17-Sep-02  1.39    Stu    add the C_COMP_NEC_78K0
 132      =8  | 17-Sep-02  1.40    Vg     ESCAN00003614 added __declspec() to place const 
 133      =8  |                           variables into ROM for Metrowerks
 134      =8  | 18-Sep-02  1.41    Stu    added C_COMP_NEC_78K0
 135      =8  | 07-Oct-02  1.42    dH     added C_COMP_GAIO_SH705X
 136      =8  | 11-Oct-02  1.43    dH     added C_COMP_FUJITSU_16LX_HL
 137      =8  | 14-Oct-02  1.44    Ml     changed vbittype for MGT5100 into unsigned short
 138      =8  | 14-Oct-02  1.45    Stu    changed vbittype for 78k0 into unsigned char
 139      =8  | 18-Oct-02  1.46    Pl     added C_COMP_TASKING_ST10_CCAN 
 140      =8  |                           added C_COMP_ARM_ST30_CCAN 
 141      =8  | 30-Oct-02  1.47    Ml     added C_COMP_ARM_470 and C_COMP_TI_470
 142      =8  | 06-Nov-02  1.48    Wr     added C_COMP_NATIONAL_CR16 
 143      =8  | 07-Nov-02  1.49    RAP    added C_COMP_DIABDATA_MPC823
 144      =8  |                    RAP    added C_COMP_GHS_STARFISH
 145      =8  | 14-Nov-02  1.50    An     corrected the banking defines for Cosmic and Hiware
 146      =8  | 27-Nov-02  1.50    Pl     added C_COMP_FUJITSU_FR50
 147      =8  | 02-Dec-02  1.51    Si     MEMORY_NEAR changed for C_COMP_NEC_78K0
 148      =8  | 11-Dec-02          Pet    added C_COMP_IAR_CEVF
 149      =8  | 18-Dec-02  1.52    Si     added C_COMP_NEC_78K0
 150      =8  | 04-Jan-03          Et     added memory qualifier for C_COMP_IAR_CEVF
 151      =8  | 22-Jan-03          Ap     added C_COMP_ARM_EASYCAN
 152      =8  | 28-Jan-03  1.53    Pl     added C_COMP_KEIL_ST10_CCAN
 153      =8  |                           delete C_COMP_ARM_ARM7STM
 154      =8  | 03-Apr-04  1.54    To     added C_COMP_METROWERKS_DSP5683X
 155      =8  |                    ZW     canbittype for CEVG is now unsigned char
 156      =8  |                    Hp     Add MEMORY_HUGE for XC16x
 157      =8  |                    Fz     added  C_COMP_IAR_CR16 and C_COMP_NATIONAL_CR16 changed
 158      =8  |                    Ml     added  C_COMP_TI_TMS320
 159      =8  | 2003-05-13 1.60    Ht     support V_MEMROM0
 160      =8  | 2003-05-14 1.61    Tri    added V_MEMROM0 definition for MGT5100
 161      =8  | 2003-05-15 1.62    Pl     added C_COMP_FUJITSU_FR60_CCAN
 162      =8  | 2003-05-20 1.63    WM     added near/far memory defines for C_COMP_HIWARE_12
 163      =8  | 2003-06-11 1.64    CB     MEMORY_HUGE added for C_COMP_TASKING_ST10_CCAN    
 164      =8  | 2003-06-18 1.65    Bir    added C_COMP_MICROCHIP_DSPIC30
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 197 

 165      =8  | 2003-07-08 1.66    Bir    no local lint command
 166      =8  | 2003-08-15 1.67    Rr     changed MEMORY_FAR for M32C
 167      =8  | 2003-08-18 1.68    BWR    added support for MAC710X
 168      =8  | 2003-09-02 1.69    BWR    added support for MC332 with external Intel 82527 
 169      =8  | 2003-09-09 1.70    Bir    added C_COMP_TASKING_TRICORE_MULTICAN & C_COMP_GNU_TRICORE_MULTICAN
 170      =8  | 2003-10-30 1.71    RAP    added C_COMP_MICROCHIP_PIC18
 171      =8  | 2003-11-13 2.00    Ht     memory qualifier changed to new definition
 172      =8  | 2004-01-08 2.01    BWR    added support for MPC55XX 
 173      =8  | 2004-01-16 2.02    Ml     added cast macros
 174      =8  | 2004-01-22 2.03    dH     added C_COMP_HEW_SH2_HCAN1 and C_COMP_HEW_H8S_HCAN1
 175      =8  | 2004-02-13 2.04    WM     Added banking support for C_COMP_IAR_12
 176      =8  | 2004-02-18 2.05    RAP    Update for C_COMP_MICROCHIP_PIC18
 177      =8  | 2004-03-12 2.06    Ml     changed canbittype for TMS470
 178      =8  | 2004-03-13 2.07    dH     added C_COMP_HEW_H8TINY
 179      =8  | 2004-04-20 2.08    dH     added C_COMP_HEW_H8SX_HCAN1
 180      =8  | 2004-04-08 2.09    Rna    Memoryclassifier V_MEMROM0 and MEMORY_ROM for Metrowerks PPC changed
 181      =8  | 2004-05-14 2.10    Ms     added Release Version define
 182      =8  |                           added include for vstdlib.h
 183      =8  | 2004-05-18 2.11    Ml     changed plattform check to work in any case (NO_ELSE)
 184      =8  |                    Ml     added V_NULL
 185      =8  | 2004-06-17 2.12    Ms     changed C_COMP_SUPPORTED_PLATTFORM -> V_COMP_SUPPORTED_PLATTFORM
 186      =8  | 2004-06-26 2.13    RAP    added C_COMP_GHS_SJA2020
 187      =8  | 2004-06-30 2.14    Ml     added C_COMP_COSMIC_MCS12X_MSCAN12
 188      =8  | 2004-08-17 2.15    Pl     Memoryclassifier V_MEMROM0/1/2 for the C_COMP_TOSHIBA_TLC900 changed
 189      =8  | 2004-08-31 2.16    Ml     changed bitfieldtype for MCS12X
 190      =8  | 2004-09-08 2.17    RAP    changed vbittype for C_COMP_GHS_SJA2020
 191      =8  | 2004-09-12 2.18    BWR    added C_COMP_GHS_PPC
 192      =8  | 2004-09-20 2.19    Ces    added C_COMP_GHS_ST30_CCAN
 193      =8  | 2004-09-27 2.20    Ms     -ESCAN00009636: Naming Conventions
 194      =8  | 2004-09-28 2.21    Bir    changed bitfieldtype for TriCore MultiCAN
 195      =8  | 2004-09-30 2.22    Ht     Review
 196      =8  | 2004-10-06 2.23    Ml     Added C_COMP_MTRWRKS_MCS12X_MSCAN12  
 197      =8  | 2004-10-27 2.24    Ml     changed V_ENABLE_VSTDLIB -> VGEN_ENABLE_VSTDLIB
 198      =8  | 2004-10-29 2.25    Pl     Added C_COMP_GHS_TX19
 199      =8  | 2004-11-05 2.26    Ml     Added C_COMP_COSMIC_MCS12X_MSCAN12 and C_COMP_COSMIC_MCS12_MSCAN12
 200      =8  | 2004-11-08 2.27    Et     support compiler option -fNP (C_COMP_MITSUBISHI_M32C)
 201      =8  | 2004-11-10 2.28    Ml     Added compatibility for VStdLib
 202      =8  | 2004-11-15 2.29    dH     new memoryclassifier for C_COMP_FUJITSU_16LX/C_COMP_FUJITSU_16LX_HL
 203      =8  | 2004-11-15 2.30    Ms     ESCAN00010228: Support C_COMP specific V_NULL definition
 204      =8  | 2004-11-19 2.31    Ml     bitfields for TMS470 are now int
 205      =8  |                    Ths    ESCAN00010435: Due to compatibility V_DEF_VERSION added
 206      =8  | 2005-01-31 2.32    Ml     Added C_COMP_IAR_TMS430_SCCHECC
 207      =8  | 2005-02-09 2.33    Ht     support V_NULL for C_COMP_KEIL_C5X5C
 208      =8  | 2005-03-10 2.34    Ces    Memory qualifier MEMORY_SADDR and MEMORY_NEAR for IAR 78K0 compiler
 209      =8  | 2005-03-22 2.35    Pl     support V_NULL for C_COMP_TASKING_ST10_CCAN
 210      =8  | 2005-03-22 2.36    Ces    support C_COMP_IAR_78K0_AFCAN
 211      =8  |                           support V_NULL for Tasking C16x/ST10, Mitsubishi M16C, IAR 78K0,
 212      =8  |                           Metrowerks DSP5683x and GreenHills ST30
 213      =8  | 2005-03-24 2.37    Krt    Set cast macros for M32C controller, to avoid compiler warnings
 214      =8  |                    Bir    support V_NULL for C_COMP_TASKING_C16X, C_COMP_TASKING_XC16X, C_COMP_GNU_TRICO
             -RE_MULTICAN
 215      =8  |                    Ces    MEMORY_NEAR corrections for IAR 78K0 AFCAN
 216      =8  | 2005-06-17 2.38    Ht     remove duplicated compiler switch
 217      =8  |                    dH     added C_COMP_HEW_SH2_RCAN
 218      =8  |                    Pl     added C_COMP_GNU_ST10_CCAN
 219      =8  |                    Ds     Added support for ADI Blackfin (BF5xx)
 220      =8  |                    Ml     Added QNX platforms
 221      =8  |                    Fz     MEMORY_HUGE changed for V85X IAR compiler in case tiny memory model
 222      =8  |                    Ht     default definition of NULL
 223      =8  | 2005-06-20 2.39    BWR    Added support for MAC7100 IAR compiler
 224      =8  |                    dH     changed bittype for C_COMP_HEW_SH2_RCAN to unsigned char
 225      =8  | 2005-08-24 2.40    Rna    position for NULL definitions moved to prevent redefinitions for HC12 cosmic (
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 198 

             -string.h)
 226      =8  | 2005-10-05 2.41    Ces    adaptions for IAR compiler M16C
 227      =8  | 2005-10-14 2.42    Fn     added C_COMP_IAR_AVR_CANARY
 228      =8  |                    Ces    corrections for C_COMP_IAR_M16C
 229      =8  |                    Ces    added C_COMP_IAR_M32C
 230      =8  |                    Ces    added V_MEMROM3 for C_COMP_MITSUBISHI_M16C
 231      =8  | 2005-10-25 2.43    Ces    IAR M32C: MEMORY_ROM is always far const
 232      =8  | 2005-12-02 2.44    dH     added C_COMP_HEW_H8S_RCAN
 233      =8  |                    Fn     added C_COMP_MICROCHIP_PIC18 for V_NULL
 234      =8  |                    Ht     V_COMP_SUPPORTED_PLATTFORM changed to V_DEF_SUPPORTED_PLATFORM 
 235      =8  |                    Pl     added C_COMP_MATSUSHITA_MN103S_CCAN
 236      =8  |                    Svh    added C_COMP_TOSHIBA_TLCS870
 237      =8  |                    Ces    changed compiler version check of IAR M16C and IAR M32C
 238      =8  | 2005-12-20 2.45    Ml     Added C_COMP_METROWERKS_MGT5X00
 239      =8  |                    Ces    changed MEMORY_NORMAL for IAR M16C and IAR M32C
 240      =8  | 2006-01-27 2.46    Ml     ESCAN00014816: Added cast defines for MCS12x with comsic
 241      =8  |                    Ml     ESCAN00015045: Added support for constants in global pages
 242      =8  |                    Ml     Added C_COMP_MTRWRKS_MPC5X00
 243      =8  |                    Svh    Added C_COMP_ARM_ADUC703X
 244      =8  | 2006-02-08 2.47    Pl     Added C_COMP_IAR_ML67Q25XX_CCAN
 245      =8  | 2006-02-09         Ml     Changed check for XGate compiler
 246      =8  | 2006-02-10 2.48    Ces    Added #define V_NULL for MITSUBISHI M32C and MITSUBISHI M32R
 247      =8  | 2006-02-20 2.49    Ml     Changes for dependency builder to accept XGate compiler specific preprocessor
 248      =8  | 2006-03-28 2.50    Ard    Added C_COMP_ARM_OMAP
 249      =8  |                    Pl     Added C_COMP_TOSHIBA_TLCS900
 250      =8  |                    Svh    Added C_COMP_HPINFOTECH_AVR_CANARY
 251      =8  | 2006-04-27 2.51    dH     added C_COMP_MATSUSHITA_MN101E_CCAN
 252      =8  |                    Ap     added C_COMP_HITECH_PIC18
 253      =8  |                    Fn     modifications for C_COMP_MICROCHIP_PIC18
 254      =8  |                    Ces    Added C_COMP_GHS_TX49 and C_COMP_NEC_78K0_AFCAN
 255      =8  | 2006-05-02 2.52    Ces    Change MEMORY_NEAR and MEMORY_SADDR for C_COMP_NEC_78K0_AFCAN
 256      =8  |                    Svh    Added C_COMP_IAR_ADUC703X
 257      =8  | 2006-05-19 2.53    Ces    Change MEMORY_NEAR for C_COMP_NEC_78K0_AFCAN
 258      =8  |                    Ces    Change define V_NULL for C_COMP_MITSUBISHI_M32R
 259      =8  | 2006-08-03 2.54    Her    Added type cast for C_COMP_: COSMIC_08/NEC_78K0_AFCAN/COSMIC_MCS12X_MSCAN12
 260      =8  |                    Fn     Added C_COMP_MICROCHIP_DSPIC33
 261      =8  |                    Ap     Added C_COMP_MTRWRKS_MCS08_MSCAN and C_COMP_COSMIC_MCS08_MSCAN
 262      =8  |                    BWR    Added C_COMP_GAIO_MPC55XX 
 263      =8  |                    Pl     Added C_COMP_FUJITSU_16FX_CCAN
 264      =8  | 2006-08-04 2.55    Ces    Added C_COMP_GHS_LPC2XXX
 265      =8  | 2006-08-09 2.56    Svh    Added V_MEMRAM1_NEAR for C_COMP_NEC_78K0
 266      =8  | 2006-08-13 2.57    Ml     Changed bitfield type for C_COMP_COSMIC_MCS08_MSCAN
 267      =8  |                    Pl     Added C_COMP_ARM_AVCCORE1_CCAN  
 268      =8  | 2006-08-30 2.58    Wr     Added C_COMP_GNU_VR55XX_AFCAN
 269      =8  |            2.58    Ml     Added C_COMP_DIABDATA_MPC5X00_MSCAN
 270      =8  | 2006-09-22 2.59    swk    Added C_COMP_KEIL_ST10_CCAN
 271      =8  |                    Ml     Changed bitfield type for C_COMP_COSMIC_MCS08_MSCAN back to vuint8
 272      =8  | 2006-10-23 2.60    BWR    Added C_COMP_GNU_MICROBLAZE_LOGICORECAN
 273      =8  |                    Ard    Added C_COMP_GHS_MAC710X
 274      =8  | 2006-10-23 2.61    Bir    Added C_COMP_TASKING_XC2000_MULTICAN
 275      =8  | 2006-11-14         Ml     Added function near/far qualifier for platform MCS12X
 276      =8  | 2006-11-20         BWR    Added C_COMP_METROWERKS_MPC55XX_FLEXCAN
 277      =8  |                           Added C_COMP_DIABDATA_MCORE_FLEXCAN
 278      =8  | 2006-11-20         Bir    changes for C_COMP_TASKING_XC2000_MULTICAN
 279      =8  | 2006-12-14         Pl     Added C_COMP_TI_TMS470_DCAN
 280      =8  | 2007-01-10         Bir    changes for C_COMP_TASKING_XC2000_MULTICAN
 281      =8  | 2007-01-11         Ces    Added C_COMP_IAR_MCS12_MSCAN12
 282      =8  | 2007-02-01 2.62    Svh    Added C_COMP_FUJITSU_8FX
 283      =8  | 2007-02-19 2.63    Ces    Added C_COMP_GHS_SAF7780_PELICAN
 284      =8  |                    Ces    Changed MEMORY_NORMAL for C_COMP_MITSUBISHI_M32C
 285      =8  | 2007-06-21 2.64    Ces    Changed MEMORY_NORMAL for C_COMP_MITSUBISHI_M16C
 286      =8  |                    Fn     Added C_COMP_IAR_R32C
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 199 

 287      =8  |                    BWR    Added C_COMP_DIABDATA_MCF_FLEXCAN
 288      =8  |                    Awh    Added C_COMP_KEIL_XC16X 
 289      =8  |                    Ou     Changed vbittype for C_COMP_MTRWRKS_MCS12X_MSCAN12 to unsigned char, additiona
             -lly disabled warning C1106 for this compiler (see #pragma MESSAGE DISABLE C1106)
 290      =8  | 2007-09-07 2.65    Ou     Changed back vbittype for C_COMP_MTRWRKS_MCS12X_MSCAN12 to unsigned int
 291      =8  |                    Ard    Added C_COMP_GHS_TMS470
 292      =8  | 2007-09-28 2.66    Fn     Added C_COMP_COSMIC_ST79_BECAN3
 293      =8  |                    Ces    Added V_MEMROMx_NEAR and V_MEMROMx_FAR for C_COMP_IAR_M16C
 294      =8  |                           Added V_MEMROMx_NEAR and V_MEMROMx_FAR for C_COMP_IAR_M32C
 295      =8  |                           Use predefined compiler macros __VX__ and _C166 for C_COMP_TASKING_XC2000_MULT
             -ICAN
 296      =8  | 2007-10-24 2.67    Fn     Changed C_COMP_COSMIC_ST79_BECAN3 to C_COMP_COSMIC_STM8A_BECAN3
 297      =8  |                    Fn     Added C_COMP_RENESAS_R32C
 298      =8  | 2007-11-09 2.68    Wr     Added C_COMP_KEIL_SLC8051
 299      =8  | 2007-11-14 2.69    Svh    Added C_COMP_KEIL_ADUC703X
 300      =8  | 2007-11-27 2.70    Fn     Adapted rom qualifier for: C_COMP_RENESAS_R32C, C_COMP_IAR_R32C and C_COMP_MIC
             -ROCHIP_DSPIC33
 301      =8  |                    Ml     Added memory mapping defines for C_COMP_MTRWRKS_MCS12X_MSCAN12
 302      =8  | 2007-12-03 2.71    Ard    Added C_COMP_MICROSOFT_TMS320ARM
 303      =8  | 2008-01-14 2.72    Ou     Added memory mapping defines for C_COMP_MTRWRKS_MCS08_MSCAN and C_COMP_COSMIC_
             -MCS08_MSCAN
 304      =8  |                    Ces    Added C_COMP_GHS_MPC55XX and C_COMP_GHS_MPC55XX_FLEXCAN2
 305      =8  |                           Added C_COMP_GAIO_MPC55XX_FLEXCAN2
 306      =8  |                           Added C_COMP_DIABDATA_MPC55XX_FLEXCAN2
 307      =8  |                           Changed memory qualifier for IAR M16C and IAR M32C
 308      =8  | 2008-02-19 2.73    Ces    Corrected V_NULL for DIABDATA_MPC55XX
 309      =8  | 2008-03-05 2.74    Pl     Added C_COMP_GNU_NIOS_DCAN
 310      =8  | 2008-03-12         Fn     Added V_MEMROM2_FAR and V_MEMROM2_NEAR for C_COMP_IAR_AVR_CANARY
 311      =8  | 2008-04-18         Ap     Added C_COMP_GNU_AVR_CANARY
 312      =8  | 2008-05-05 2.75    Bir    Possibility to change V_MEMROM2 for XC2000 (user config)
 313      =8  | 2008-05-05 2.76    Ou     Change the behavior for V_MEMROM3 on MCS12X (relevant just for Cosmic compiler
             -, global constants feature)
 314      =8  | 2008-05-06 2.77    Ces    Changed V_MEMRAM2_FAR for IAR compiler M16C/R8C
 315      =8  |                           Added P_MEM_ROM for IAR compiler M16C
 316      =8  |                    Ap     Added C_COMP_IAR_78K0R
 317      =8  | 2008-07-24 2.78    Ht     Memory qualifier for C_COMP_COSMIC_STM8A_BECAN3 added
 318      =8  | 2008-08-27 2.79    Ces    Adapt memory qualifier for C_COMP_MITSUBISHI_M16C and C_COMP_MITSUBISHI_M32C
 319      =8  | 2008-09-18 2.80    Ard    Added C_COMP_QCC_TMS320ARM
 320      =8  | 2008-10-15 2.81    Bir    Added C_COMP_GHS_TRICORE_MULTICAN
 321      =8  |                    BWR    Adapt memory qualifier for C_COMP_GNU_MPC5X00_MSCAN
 322      =8  | 2008-11-14 2.82    Pl     Added C_COMP_GNU_MB86R0X_CCAN
 323      =8  |                    Ou     V_MEMROMx have the default behavior for C_COMP_MICROCHIP_DSPIC33
 324      =8  | 2008-11-21 2.83    Ces    Added C_COMP_GNU_IMX_FLEXCAN2
 325      =8  |                           Added V_MEMROM2 for C_COMP_MITSUBISHI_M32C
 326      =8  | 2009-01-19 2.84    Ou     Change the behavior of data pointer buffers in order to meet the global data e
             -xpectations in case of C_COMP_COSMIC_MCS12X_MSCAN12
 327      =8  |                           Change the default behavior for V_MEMRAM1_FAR and V_MEMRAM3_FAR in case of C_C
             -OMP_COSMIC_MCS12X_MSCAN12
 328      =8  |                    Tvi    Added C_COMP_IAR_M16C_RCAN2 and C_COMP_RENESAS_M16C_RCAN2
 329      =8  | 2009-01-23 2.85    Ou     Adjust the behavior of V_MEMRAM1_FAR and V_MEMRAM3_FAR in case of C_COMP_COSMI
             -C_MCS12X_MSCAN12 in order to have an unified behavior
 330      =8  | 2009-01-29 2.86    Pl     For the TI_TMS470_DCAN changed vuint32 from unsigned long to unsigned int and 
             -vsint32 int from signed long to signed int
 331      =8  |                           Added C_COMP_GNU_ST30_CCAN
 332      =8  | 2009-02-18         Ou     Added C_COMP_MTRWRKS_MPC5X00_MSCAN
 333      =8  | 2009-03-19 2.87    Kk     Added C_COMP_GAIO_SH2_RCAN
 334      =8  |                    Pl     Some V_MEMROM and V_MEMRAM defines for the C_COMP_FUJITSU_16FX_CCAN added ( on
             -ly in the case VGEN_ENABLE_CANFBL is defined )
 335      =8  | 2009-03-25 2.88    Aj     Added C_COMP_ARM_TCC800X_CCAN
 336      =8  | 2009-07-08 2.89    Bir    Added Compiler abstraction like ASR
 337      =8  |                    Ou     Added C_COMP_KEIL_PSOC3_CANMODULE3
 338      =8  |                    Ces    Added C_COMP_METROWERKS_MPC55XX and C_COMP_METROWERKS_MPC55XX_FLEXCAN2
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 200 

 339      =8  |                    Pl     For the TI_TMS470_DCAN changed back vuint32 from unsigned int to unsigned long
             - and vsint32 from signed int to signed long
 340      =8  |                           Reason is to be compatible with TI_TMS470 and with Platform_Types.h
 341      =8  | 2009-07-08 2.90    Bir    change Compiler abstraction "V_DEF_P2SFR_CAN"
 342      =8  |                    Ou     Rework the V_MEMROMx and V_MEMRAMx for C_COMP_KEIL_PSOC3_CANMODULE3
 343      =8  |                    Seg    Added C_COMP_ARM_TMS470_DCAN
 344      =8  |                    Ou     Added C_COMP_QCC_MPC5X00_MSCAN
 345      =8  | 2009-09-03 2.91    Bir    Added C_COMP_IAR_AVR32_CANIF
 346      =8  |                    Kk     Added C_COMP_RENESAS_SH4_RCAN
 347      =8  | 2009-09-04 2.92    Tvi    Added C_COMP_GHS_V85X_FCN
 348      =8  | 2009-10-06 2.93    Tvi    Added C_COMP_GHS_SH4_RCAN2
 349      =8  | 2009-10-16 2.94    Ou,Ht  Fixed V_NULL for C_COMP_KEIL_PSOC3_CANMODULE3, C_COMP_KEIL_C5X5C and
 350      =8  |                           C_COMP_KEIL_SLC8051
 351      =8  | 2009-10-27 2.95    Ou     Map the reentrant keyword to C_API_3 in case of C_COMP_KEIL_PSOC3_CANMODULE3
 352      =8  | 2009-10-30 2.96    Rna    Support C_COMP_ARM_STM32_BXCAN
 353      =8  | 2009-11-10 2.97    Ht     ESCAN00039030: Support V_MEMRAM2_FAR for XC2000 Tasking
 354      =8  |                    Seg    Support C_COMP_GNU_TX49
 355      =8  | 2009-11-20 2.98    Tvi    ESCAN00039020: Renesas: support "-fansi" option
 356      =8  |                    Ou     Fixed the standard memory qualifier definitions (vuintx/ vsintx) in combinatio
             -n with CAN-Driver for ASR
 357      =8  | 2009-11-23 2.98.01 Ht     correct COMMON_VDEF_RELEASE_VERSION 
 358      =8  | 2010-02-03 2.99    Tvi    ESCAN00039371: [M16C/R8C with RENESAS]: Warnings about incompatible pointer ty
             -pes for Compiler versions >= V5.45
 359      =8  |                    Ht     Support C_COMP_KEIL_SJA2020
 360      =8  | 2010-02-03 3.00.00 Ht     change version number 
 361      =8  | 2010-03-02 3.01.00 Ou     Rework the V_MEMROMx and V_MEMRAMx for C_COMP_IAR_78K0R
 362      =8  |                    vadaba Added V_MEMROM0 to place const variables into ROM for C_COMP_METROWERKS_MPC55X
             -X_FLEXCAN2
 363      =8  | 2010-03-10 3.02.00 Tvi    ESCAN00041468: [SH4Rcan2 w. GHS] "-Ospace" leads to a runtime exception due to
             - incorrect bitfield access
 364      =8  |                    Kk     Added C_COMP_QCC_SH4_RCAN
 365      =8  |                    Kk     Added C_COMP_IAR_SH2_RCAN
 366      =8  | 2010-05-12 3.03.00 Pl     Added C_COMP_QCC_MB86R0X_CCAN
 367      =8  |                    Ces    Support C_COMP_GNU_MPC55XX and C_COMP_GNU_MPC55XX_FLEXCAN2 
 368      =8  | 2010-06-09 3.04.00 Tvi    Added C_COMP_NEC_78K0R
 369      =8  | 2010-07-01 3.05.00 Ht     Added support of MEMORY_HUGE for C_COMP_KEIL_C16X
 370      =8  | 2010-07-12 3.06.00 Ces    Support C_COMP_GHS_IMX_FLEXCAN2
 371      =8  |                    Tvi    ESCAN00044064: [R32C with RENESAS]: Warnings about incompatible pointer types 
             -for Compiler versions >= V1.02 r00
 372      =8  | 2010-09-06 3.07.00 Ces    ESCAN00044378: added check for V_NULL definiton if default is not used
 373      =8  |                    Tvi    Misra warning due to wrong characters in history removed
 374      =8  |                    Kk     Added C_COMP_ARM_TRITON_AFCAN
 375      =8  |                    Ap     Added C_PROCESSOR_R8C_XX to distinguish different derivatives 
 376      =8  | 2010-10-01 3.08.00 Tvi    Added C_COMP_RENESAS_V85X_FCN
 377      =8  | 2010-10-17 3.09.00 Bir    Added C_COMP_KEIL_XC800
 378      =8  | 2010-12-13 3.10.00 Tvi    Added C_COMP_RENESAS_78K0R
 379      =8  | 2011-01-28 3.11.00 Ht     M16C Compiler switch for Organi added
 380      =8  |                           Added C_COMP_GHS_SH2_RCAN
 381      =8  |                    Tvi    Changed V_MEMROM1 for C_COMP_RENESAS_78K0R when memory model MEDIUM is used
 382      =8  |                    Rna    Support TMS320(canbedded) with Geny
 383      =8  | 2011-02-25 3.12.00 Ces    Added C_COMP_ARM_TX03_TXCAN
 384      =8  |                    Pl     Added C_COMP_FUJITSU_FR81_CCAN
 385      =8  |                    Tkr    Added C_COMP_GHS_SH2_RCAN2A
 386      =8  | 2011-04-08 3.13.00 Ou     Added C_COMP_IAR_MCS12X_MSCAN12
 387      =8  |                    Tvi    Support C_PROCESSOR_R8C again (removed in 3.07.00)
 388      =8  |                    Aj     Added C_COMP_RENESAS_V85X_AFCAN
 389      =8  | 2011-05-20 3.14.00 Tvi    Added C_COMP_IAR_V85X_FCN
 390      =8  |                    Was    Added C_COMP_TI_TMS320C64X_HECCSCC
 391      =8  | 2011-05-31 3.15.00 Aj     Added C_COMP_GNU_SH2_RCAN
 392      =8  | 2011-07-11 3.16.00 Ht     replace V_NONE with V_STORAGE_NONE in case of V_CPU_TMS320ARM
 393      =8  | 2011-08-08 3.17.00 Pl     Added C_COMP_GHS_FCR4_CCAN
 394      =8  |                    Eta    Added C_COMP_IAR_ADUCM33X
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 201 

 395      =8  | 2011-09-26 3.18.00 Aj     Added C_COMP_HEW_SH2_RCAN2
 396      =8  | 2011-11-24 3.19.00 Aj     Added C_COMP_ARM_AVNA_CCAN
 397      =8  | 2012-01-12 3.20.00 Rse    Added C_COMP_QCC_IMX_FLEXCAN2, C_COMP_GNU_IMX_FLEXCAN3, C_COMP_QCC_IMX_FLEXCAN
             -3, C_COMP_GHS_IMX_FLEXCAN3
 398      =8  | 2012-02-15 3.21.00 Aj     Added C_COMP_KEIL_FM3_CCAN
 399      =8  |                    Ht     Header changed
 400      =8  |                           remove C_COMP_MCP18_PIC_INT (old driver version)
 401      =8  |                    Tvi    Added C_COMP_RENESAS_SH4_RCAN2
 402      =8  | 2012-02-24 3.22.00 Tvi    Change VEMROM2_NEAR to __near for C_COMP_IAR_78K0R
 403      =8  | 2012-03-23 3.23.00 Ht     Add C_COMP_IAR_RL78_AFCAN
 404      =8  | 2012-03-30 3.24.00 bir    Add CAN_STATIC define for AutoSar4 compatible LL
 405      =8  | 2012-04-18 3.25.00 Seu    Added C_COMP_TASKING_XC800_MULTICAN
 406      =8  | 2012-06-18 3.26.00 Aj     Set vbittype=char for Sh4/Rcan2 in order to support littleendian
 407      =8  | 2012-08-01 3.27.00 Was    Added C_COMP_KEIL_XC2000_MULTICAN
 408      =8  | 2012-08-22 3.28.00 Pl     Added C_COMP_KEIL_SLC8051_CCAN, integration of C_COMP_KEIL_ switches
 409      =8  |                    QPs    Added C_COMP_RENESAS_RL78_AFCAN
 410      =8  | 2012-09-20 3.29.00 Rse    Added C_COMP_GNU_MPC5700_MCAN
 411      =8  | 2012-09-24 3.30.00 Tkr    Added C_COMP_GHS_RH850_RSCAN, C_COMP_HEW_SH2_RSCAN and C_COMP_GHS_SH2_RSCAN
 412      =8  | 2012-10-08 3.30.01 Was    ESCAN00061961: Compiler error: Using of V_MEMROM2_FAR and V_MEMROM2_NEAR leads
             - to an compile error (Keil compiler/ XC2000)
 413      =8  | 2012-11-06 3.31.00 Ht     ESCAN00062762: Remove function memory qualifier for 78K0R and RL78
 414      =8  | 2012-11-08 3.32.00 Pl     Added C_COMP_TI_TMS320ARM_DCAN
 415      =8  | 2012-12-12 3.33.00 Pl     Added C_COMP_QCC_TMS320ARM_DCAN
 416      =8  | 2012-12-18 3.34.00 Rna    Added C_COMP_IAR_STM32_BXCAN
 417      =8  |                    Bmo    Added C_COMP_KEIL_TLE986X
 418      =8  | 2013-03-06 3.35.00 Rse    Added C_COMP_GHS_MPC5700_FLEXCAN3, C_COMP_DIABDATA_MPC5700_FLEXCAN3
 419      =8  |                    Rna    VUINTx_CAST for STM8A with Cosmic added
 420      =8  | 2013-03-26 3.36.00 Tkr    Added C_COMP_RENESAS_RL78_RSCAN
 421      =8  |                    Ht     improve RL78 and 78K0R
 422      =8  | 2013-04-02 3.37.00 Was    Added V_COMP_COSMIC_MCS12Z
 423      =8  | 2013-06-11 3.38.00 Ht     Replace C_COMP_xxx_MPC5700_yyy with V_COMP_xxx_MPC5700
 424      =8  |                           Replace C_COMP_xxx_IMX_yyyy with V_COMP_xxx_IMX
 425      =8  |                           Replace C_COMP_GHS_RH850_RSCAN with V_COMP_GHS_RH850
 426      =8  |                           Replace canbittype by vbittype in this file -> no change of API
 427      =8  |                    Was    Support IAR HCS12 Compiler Version 3.x
 428      =8  | 2013-06-21 3.38.01 Ht     Remove comment
 429      =8  | 2013-07-02 3.39.00 Tkr    Replace C_COMP_IAR_RL78_AFCAN with V_COMP_IAR_RL78
 430      =8  |                    Tkr    merge and adapt RL78 and 78K0R memory qualifier definitions for IAR compiler
 431      =8  |                           Replace C_COMP_RENESAS_RL78_xxx with V_COMP_RENESAS_RL78
 432      =8  | 2013-08-20 3.40.00 Pl     Added V_COMP_ARM_STA8088
 433      =8  |                    Tkr    Added V_COMP_DIABDATA_RH850
 434      =8  |                    Rse    Added V_COMP_GNU_VYBRID
 435      =8  |****************************************************************************/
 436      =8  
 437      =8  
 438      =8  
 439      =8  #ifndef  V_DEF_H
           =8 #define  V_DEF_H
           =8 
           =8 /***************************************************************************/
           =8 /* Version                  (abcd: Main version=ab, Sub Version=cd )       */
           =8 /***************************************************************************/
           =8 
           =8 /* ##V_CFG_MANAGEMENT ##CQProject : Common_Vdef CQComponent : Implementation */
           =8 #define COMMON_VDEF_VERSION            0x0340
           =8 #define COMMON_VDEF_RELEASE_VERSION    0x00
           =8 
           =8 /* compatibility for IL versions < 3.52 */
           =8 #define V_DEF_VERSION                  COMMON_VDEF_VERSION
           =8 
           =8 
           =8 /***************************************************************************/
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 202 

           =8 /* Supported Systems                                                       */
           =8 /***************************************************************************/
           =8 #if defined( C_COMP_KEIL_SLC8051_CCAN )         
           =8     
           =8 # define V_DEF_SUPPORTED_PLATFORM
           =8 #endif
           =8 
           =8 
           =8 #if !defined V_DEF_SUPPORTED_PLATFORM
           =8 # error "driver not supported or C_COMP_xxx_yyy not defined"
           =8 #endif
           =8 
           =8 
           =8 
           =8 
           =8 /***************************************************************************/
           =8 /***************************************************************************/
           =8 /****  Hardware independent settings  **************************************/
           =8 /***************************************************************************/
           =8 /***************************************************************************/
           =8 /*--- standard memory qualifier definition --------------------------------*/
           =8 
           =8 /* 8-Bit qualifier */
           =8 #if !defined( vuint8 ) /* ASR compatibility */
           =8 typedef unsigned char  vuint8;
           =8 #endif
           =8 #define canuint8 vuint8
           =8 
           =8 #if !defined( vsint8 ) /* ASR compatibility */
           =8 typedef signed char    vsint8;
           =8 #endif
           =8 #define cansint8 vsint8
           =8 
           =8 /* 16-Bit qualifier */
           =8 #if !defined( vuint16 ) /* ASR compatibility */
           =8 typedef unsigned short vuint16;
           =8 #endif
           =8 #define canuint16 vuint16
           =8 
           =8 #if !defined( vsint16 ) /* ASR compatibility */
           =8 typedef signed short   vsint16;
           =8 #endif
           =8 #define cansint16 vsint16
           =8 
           =8 
           =8 /* 32-Bit qualifier */
           =8 #if !defined( vuint32 ) /* ASR compatibility */
           =8 typedef unsigned long  vuint32;
           =8 #endif
           =8 #define canuint32 vuint32
           =8 
           =8 #if !defined( vsint32 ) /* ASR compatibility */
           =8 typedef signed long    vsint32;
           =8 #endif
           =8 #define cansint32 vsint32
           =8 
           =8 
           =8 
           =8 typedef unsigned char *TxDataPtr;              /* ptr to transmission data buffer */
           =8 typedef unsigned char *RxDataPtr;              /* ptr to receiving data buffer    */
           =8 
           =8 /***************************************************************************/
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 203 

           =8 /*  Defines                                                                */
           =8 /***************************************************************************/
           =8 
           =8 
           =8 /***************************************************************************/
           =8 /***************************************************************************/
           =8 /****  Hardware/Compiler dependent settings   ******************************/
           =8 /***************************************************************************/
           =8 /***************************************************************************/
           =8 
           =8 /*  data type according to the CPU type */
           =8 #if defined( C_CPUTYPE_8BIT )
           =8 /* 8-Bit qualifier */
           =8 # ifndef vuintx
           =8 #  define vuintx vuint8
           =8 # endif
           =8 # ifndef vsintx
           =8 #  define vsintx vsint8
           =8 # endif
           =8 #else
           =8 # if defined( C_CPUTYPE_16BIT )
           =8 /* 16-Bit qualifier */
           =8 #  ifndef vuintx
           =8 #   define vuintx vuint16
           =8 #  endif
           =8 #  ifndef vsintx
           =8 #   define vsintx vsint16
           =8 #  endif
           =8 # else
           =8 #  if defined( C_CPUTYPE_32BIT )
           =8 /* 32-Bit qualifier */
           =8 #   ifndef vuintx
           =8 #    define vuintx vuint32
           =8 #   endif
           =8 #   ifndef vsintx
           =8 #    define vsintx vsint32
           =8 #   endif
           =8 #  endif
           =8 # endif
           =8 #endif
           =8 
           =8 
           =8 /* qualifier for bitfield definition */
           =8 
           =8 #if defined( C_COMP_KEIL_SLC8051_CCAN )         
           =8 typedef unsigned char    vbittype;
           =8 #else
           =8 typedef unsigned int     vbittype;
           =8 #endif
           =8 #define canbittype       vbittype
           =8 
           =8 
           =8 
           =8 #if defined( C_SUPPORT_MIXED_CAN_LIN )
           =8   /* support combination of "old" CAN driver and "new" LIN driver */
           =8 #else
           =8 /* Structure for bit accessed memory.           */
           =8 /* The bit-order is hardware/compiler dependent */
           =8 #  if defined( C_CPUTYPE_BITORDER_LSB2MSB )
           =8 struct _c_bits8
           =8 {
           =8   vbittype  b0:1;  /* LSB-Bits (lower adr!) */
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 204 

           =8   vbittype  b1:1;
           =8   vbittype  b2:1;
           =8   vbittype  b3:1;
           =8   vbittype  b4:1;
           =8   vbittype  b5:1;
           =8   vbittype  b6:1;
           =8   vbittype  b7:1;  /* MSB-Bits (higher address) unused */
           =8  };
           =8 
           =8 struct _c_bits16 
           =8 {
           =8   vbittype  b0:1;  /* lower adr */
           =8   vbittype  b1:1;
           =8   vbittype  b2:1;
           =8   vbittype  b3:1;
           =8   vbittype  b4:1;
           =8   vbittype  b5:1;
           =8   vbittype  b6:1;
           =8   vbittype  b7:1;
           =8 
           =8   vbittype  b10:1; /* higher adr */
           =8   vbittype  b11:1;
           =8   vbittype  b12:1;
           =8   vbittype  b13:1;
           =8   vbittype  b14:1;
           =8   vbittype  b15:1;
           =8   vbittype  b16:1;
           =8   vbittype  b17:1;
           =8 };
           =8 
           =8 struct _c_bits32 
           =8 {
           =8   vbittype  b0:1;  /* lower adr */
           =8   vbittype  b1:1;
           =8   vbittype  b2:1;
           =8   vbittype  b3:1;
           =8   vbittype  b4:1;
           =8   vbittype  b5:1;
           =8   vbittype  b6:1;
           =8   vbittype  b7:1;
           =8 
           =8   vbittype  b10:1; /* mid low adr */
           =8   vbittype  b11:1;
           =8   vbittype  b12:1;
           =8   vbittype  b13:1;
           =8   vbittype  b14:1;
           =8   vbittype  b15:1;
           =8   vbittype  b16:1;
           =8   vbittype  b17:1;
           =8 
           =8   vbittype  b20:1; /* mid high adr */
           =8   vbittype  b21:1;
           =8   vbittype  b22:1;
           =8   vbittype  b23:1;
           =8   vbittype  b24:1;
           =8   vbittype  b25:1;
           =8   vbittype  b26:1;
           =8   vbittype  b27:1;
           =8 
           =8   vbittype  b30:1; /* higher adr */
           =8   vbittype  b31:1;
           =8   vbittype  b32:1;
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 205 

           =8   vbittype  b33:1;
           =8   vbittype  b34:1;
           =8   vbittype  b35:1;
           =8   vbittype  b36:1;
           =8   vbittype  b37:1;
           =8 };
           =8 
           =8 # else /* MSB2LSB */
           =8 #  if defined( C_CPUTYPE_BITORDER_MSB2LSB )
           =8 struct _c_bits8         
           =8 {
           =8   vbittype  b7:1;  /* MSB-Bits (Higher addr!) */
           =8   vbittype  b6:1;
           =8   vbittype  b5:1;
           =8   vbittype  b4:1;
           =8   vbittype  b3:1;
           =8   vbittype  b2:1;
           =8   vbittype  b1:1;
           =8   vbittype  b0:1;  /* LSB-Bits (higher address) unused */
           =8 };
           =8 
           =8 struct _c_bits16 
           =8 {
           =8   vbittype  b7:1;   /* lower adr */
           =8   vbittype  b6:1;
           =8   vbittype  b5:1;
           =8   vbittype  b4:1;
           =8   vbittype  b3:1;
           =8   vbittype  b2:1;
           =8   vbittype  b1:1;
           =8   vbittype  b0:1;
           =8 
           =8   vbittype  b17:1;  /* higher adr */
           =8   vbittype  b16:1;
           =8   vbittype  b15:1;
           =8   vbittype  b14:1;
           =8   vbittype  b13:1;
           =8   vbittype  b12:1;
           =8   vbittype  b11:1;
           =8   vbittype  b10:1;
           =8 };
           =8 
           =8 
           =8 struct _c_bits32 
           =8 {
           =8   vbittype  b7:1;   /* lower adr */
           =8   vbittype  b6:1;
           =8   vbittype  b5:1;
           =8   vbittype  b4:1;
           =8   vbittype  b3:1;
           =8   vbittype  b2:1;
           =8   vbittype  b1:1;
           =8   vbittype  b0:1;
           =8 
           =8   vbittype  b17:1;  /* mid low adr */
           =8   vbittype  b16:1;
           =8   vbittype  b15:1;
           =8   vbittype  b14:1;
           =8   vbittype  b13:1;
           =8   vbittype  b12:1;
           =8   vbittype  b11:1;
           =8   vbittype  b10:1;
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 206 

           =8 
           =8   vbittype  b27:1;  /* mid high adr */
           =8   vbittype  b26:1;
           =8   vbittype  b25:1;
           =8   vbittype  b24:1;
           =8   vbittype  b23:1;
           =8   vbittype  b22:1;
           =8   vbittype  b21:1;
           =8   vbittype  b20:1;
           =8 
           =8   vbittype  b37:1;  /* higher adr */
           =8   vbittype  b36:1;
           =8   vbittype  b35:1;
           =8   vbittype  b34:1;
           =8   vbittype  b33:1;
           =8   vbittype  b32:1;
           =8   vbittype  b31:1;
           =8   vbittype  b30:1;
           =8 };
           =8 #  else
           =8 #  error "Bitorder unknown: C_CPUTYPE_BITORDER_MSB2LSB or C_CPUTYPE_BITORDER_LSB2MSB has to be defined"
           =8 #  endif /* C_CPUTYPE_BITORDER_MSB2LSB */
           =8 # endif  /* C_CPUTYPE_BITORDER_LSB2MSB */
           =8 #endif
           =8 
           =8 
           =8 
           =8 
           =8 /***************************************************************************/
           =8 /* Memory qualifier                                                        */
           =8 /***************************************************************************/
           =8 
           =8 
           =8 
           =8 
           =8 
           =8 
           =8 
           =8 
           =8 #if defined( C_COMP_KEIL_SLC8051_CCAN )     
           =8 /* V_MEMROM0      is not used because of its position in case of pointers located in ROM, remains empty th
             -rough the compatibility macros */
           =8 /* V_MEMROM1_NEAR is not used, remains empty through the compatibility macros */
           =8 /* V_MEMROM1      is not used, remains empty through the compatibility macros */
           =8 /* V_MEMROM1_FAR  is not used, remains empty through the compatibility macros */
           =8 # define V_MEMROM2_NEAR const code
           =8 # define V_MEMROM2      const code
           =8 # define V_MEMROM2_FAR  const code
           =8 /* V_MEMROM3      is not used, remains empty through the compatibility macros */
           =8 /* V_MEMRAM0      is not used because of its position in case of pointers located in RAM, remains empty th
             -rough the compatibility macros */
           =8 /* V_MEMRAM1_NEAR is not used, remains empty through the compatibility macros */
           =8 /* V_MEMRAM1      is not used, remains empty through the compatibility macros */
           =8 /* V_MEMRAM1_FAR  is not used, remains empty through the compatibility macros */
           =8 # define V_MEMRAM2_NEAR idata
           =8 /* V_MEMRAM2 is the default memory area: "data", "pdata" or "xdata", remains empty through the compatibili
             -ty macros */
           =8 # define V_MEMRAM2_FAR  xdata
           =8 /* V_MEMRAM3_NEAR is not used, remains empty through the compatibility macros */
           =8 /* V_MEMRAM3      is not used, remains empty through the compatibility macros */
           =8 /* V_MEMRAM3_FAR  is not used, remains empty through the compatibility macros */
           =8 # define C_API_3 reentrant
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 207 

           =8 #endif
           =8 
           =8 
           =8 #if defined ( VGEN_ENABLE_CANFBL ) 
           =8 #endif
           =8 
           =8 
           =8 
           =8 
           =8 
           =8 
           =8 
           =8 
           =8 
           =8 
           =8 
           =8 
           =8 
           =8 
           =8 
           =8 
           =8 
           =8 
           =8 
           =8 
           =8 
           =8 
           =8 
           =8 
           =8 
           =8 #ifndef MEMORY_HUGE
           =8 #  define MEMORY_HUGE               /* no entry                         */
           =8 #endif
           =8 
           =8 
           =8 
           =8 
           =8 
           =8 
           =8 
           =8 
           =8 /* *********************** default defines - used to store permanent data ********************************
             -******** */
           =8 #ifndef V_MEMROM0
           =8 # define V_MEMROM0                  /* addition qualifier data access in ROM  */
           =8 #endif
           =8 
           =8 #ifndef V_MEMROM1_NEAR
           =8 # define V_MEMROM1_NEAR             /* fast data access in ROM */
           =8 #endif
           =8 
           =8 #ifndef V_MEMROM1
           =8 # define V_MEMROM1                 /* fast data access in ROM */
           =8 #endif
           =8 
           =8 #ifndef V_MEMROM1_FAR
           =8 # define V_MEMROM1_FAR             /* slow addressing mode in ROM */
           =8 #endif
           =8 
           =8 
           =8 #ifndef MEMORY_ROM_NEAR
           =8 # ifndef V_MEMROM2_NEAR
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 208 

           =8 #  define V_MEMROM2_NEAR   const    /* fast data access in ROM */
           =8 # endif
           =8   /* compatibility for modules which use old definition of memory qualifer */
           =8 # define MEMORY_ROM_NEAR   V_MEMROM2_NEAR
           =8 #else
           =8 # define V_MEMROM2_NEAR    MEMORY_ROM_NEAR
           =8 #endif
           =8 
           =8 #ifndef MEMORY_ROM
           =8 # ifndef V_MEMROM2
           =8 #  define V_MEMROM2        const    /* fast data access in ROM */
           =8 # endif
           =8   /* compatibility for modules which use old definition of memory qualifer */
           =8 # define MEMORY_ROM        V_MEMROM2       
           =8 #else
           =8 # define V_MEMROM2         MEMORY_ROM
           =8 #endif
           =8 
           =8 #ifndef MEMORY_ROM_FAR
           =8 # ifndef V_MEMROM2_FAR
           =8 #  define V_MEMROM2_FAR    const    /* slow addressing mode in ROM */
           =8 # endif
           =8   /* compatibility for modules which use old definition of memory qualifer */
           =8 # define MEMORY_ROM_FAR    V_MEMROM2_FAR
           =8 #else
           =8 # define V_MEMROM2_FAR     MEMORY_ROM_FAR
           =8 #endif
           =8 
           =8 #ifndef V_MEMROM3
           =8 # define V_MEMROM3        
           =8 #endif
           =8 
           =8 
           =8 /* *********************** default defines - used to store volatile data *********************************
             -******* */
           =8 #ifndef V_MEMRAM0
           =8 # define V_MEMRAM0                  /* addition qualifier data access in RAM  */
           =8 #endif
           =8 
           =8 #ifndef V_MEMRAM1_NEAR
           =8 # define V_MEMRAM1_NEAR             /* fast data access in RAM */
           =8 #endif
           =8 
           =8 #ifndef V_MEMRAM1
           =8 # define V_MEMRAM1                 /* fast data access in RAM */
           =8 #endif
           =8 
           =8 #ifndef V_MEMRAM1_FAR
           =8 # define V_MEMRAM1_FAR             /* slow addressing mode in RAM */
           =8 #endif
           =8 
           =8 
           =8 #ifndef MEMORY_NEAR
           =8 # ifndef V_MEMRAM2_NEAR
           =8 #  define V_MEMRAM2_NEAR           /* fast data access in RAM */
           =8 # endif
           =8   /* compatibility for modules which use old definition of memory qualifer */
           =8 # define MEMORY_NEAR   V_MEMRAM2_NEAR
           =8 #else
           =8 # define V_MEMRAM2_NEAR    MEMORY_NEAR
           =8 #endif
           =8 
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 209 

           =8 #ifndef MEMORY_NORMAL
           =8 # ifndef V_MEMRAM2
           =8 #  define V_MEMRAM2                 /* fast data access in RAM */
           =8 # endif
           =8   /* compatibility for modules which use old definition of memory qualifer */
           =8 # define MEMORY_NORMAL   V_MEMRAM2       
           =8 #else
           =8 # define V_MEMRAM2           MEMORY_NORMAL
           =8 #endif
           =8 
           =8 #ifndef MEMORY_FAR
           =8 # ifndef V_MEMRAM2_FAR
           =8 #  define V_MEMRAM2_FAR            /* slow addressing mode in RAM */
           =8 # endif
           =8   /* compatibility for modules which use old definition of memory qualifer */
           =8 # define MEMORY_FAR    V_MEMRAM2_FAR
           =8 #else
           =8 # define V_MEMRAM2_FAR     MEMORY_FAR
           =8 #endif
           =8 
           =8 #ifndef V_MEMRAM3_NEAR
           =8 # define V_MEMRAM3_NEAR             /* fast data access in RAM */
           =8 #endif
           =8 
           =8 #ifndef V_MEMRAM3
           =8 # define V_MEMRAM3                 /* fast data access in RAM */
           =8 #endif
           =8 
           =8 #ifndef V_MEMRAM3_FAR
           =8 # define V_MEMRAM3_FAR             /* slow addressing mode in RAM */
           =8 #endif
           =8 
           =8 
           =8 /* *********************** default defines - to cast results *********************************************
             -******* */
           =8 #if !defined(VUINT8_CAST)
           =8 # define VUINT8_CAST
           =8 #endif 
           =8 #if !defined(VSINT8_CAST)
           =8 # define VSINT8_CAST
           =8 #endif
           =8 #if !defined(VUINT16_CAST)
           =8 # define VUINT16_CAST
           =8 #endif
           =8 # if !defined(VSINT16_CAST)
           =8 # define VSINT16_CAST
           =8 #endif
           =8 #if !defined(CANBITTYPE_CAST)
           =8 # define CANBITTYPE_CAST
           =8 #endif
           =8 #if !defined(CANSINTCPUTYPE_CAST)
           =8 # define CANSINTCPUTYPE_CAST
           =8 #endif
           =8 #if !defined(CANUINTCPUTYPE_CAST)
           =8 # define CANUINTCPUTYPE_CAST
           =8 #endif
           =8 
           =8 /* ************************************************************************* */
           =8 /*  Common_VStdLib                                                           */
           =8 /* ************************************************************************* */
           =8 # if defined (VGEN_ENABLE_VSTDLIB) || defined (V_ENABLE_VSTDLIB)
           =8 #  include "vstdlib.h"
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 210 

           =8 # endif
           =8 
           =8 /* ************************************************************************* */
           =8 /*  V_NULL Definition                                                        */
           =8 /* ************************************************************************* */
           =8 
           =8 #if defined( C_COMP_KEIL_SLC8051_CCAN )           
           =8 # if !defined(V_NULL)    
           =8 #  define V_NULL 0
           =8 # endif
           =8 #endif
           =8 
           =8 
           =8 #if !defined(V_NULL)
           =8 # define V_NULL ((void*)0)
           =8 #endif
           =8 
           =8 
           =8 #ifndef NULL
           =8 # define NULL V_NULL
           =8 #endif
           =8 
           =8 
           =8 /*-----------------------------------------------------------------------------------------------*/
           =8 #if !defined(V_ENABLE_CAN_ASR_ABSTRACTION) && !defined(V_ENABLE_VSTDLIB_ASR_ABSTRACTION)
           =8 # define V_ENABLE_CBD_ABSTRACTION
           =8 # define STATIC                                          static /* MSR3 */
           =8 # define CAN_STATIC                                      static /* MSR4 */
           =8 # define AUTOMATIC
           =8 # if !defined(NULL_PTR)
           =8 #  define NULL_PTR                                        V_NULL
           =8 # endif
           =8 
           =8 #  define V_NONE       /* empty storage used instead of extern, static, volatile... */
           =8 
           =8 # if !defined( C_CALLBACK_1 )
           =8 #  define C_CALLBACK_1
           =8 # endif
           =8 # if !defined( C_CALLBACK_2 )
           =8 #  define C_CALLBACK_2
           =8 # endif
           =8 # if !defined( C_API_1 )
           =8 #  define C_API_1
           =8 # endif
           =8 # if !defined( C_API_2 )
           =8 #  define C_API_2
           =8 # endif
           =8 # if !defined( C_API_3 )
           =8 #  define C_API_3
           =8 # endif
           =8 # define V_DEF_VAR(storage, vartype, memclass)                    V_MEMRAM0 storage V_MEMRAM1 vartype V_ME
             -MRAM2
           =8 # define V_DEF_VAR_NEAR(storage, vartype)                         V_MEMRAM0 storage V_MEMRAM1_NEAR vartype
             - V_MEMRAM2_NEAR
           =8 # define V_DEF_VAR_FAR(storage, vartype)                          V_MEMRAM0 storage V_MEMRAM1_FAR vartype 
             -V_MEMRAM2_FAR
           =8 # define V_DEF_VAR_TYPE(storage, vartype)                         typedef storage V_MEMRAM1 vartype V_MEMR
             -AM2
           =8 # define V_DEF_P2VAR(storage, ptrtype, memclass, ptrclass)        V_MEMRAM0 storage V_MEMRAM1 ptrtype V_ME
             -MRAM2 *
           =8 # define V_DEF_P2VAR_PARA(storage, ptrtype, memclass, ptrclass)   storage V_MEMRAM1 ptrtype V_MEMRAM2 *
           =8 # define V_DEF_P2VAR_TYPE(storage, ptrtype, ptrclass)             typedef storage V_MEMRAM1 ptrtype V_MEMR
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 211 

             -AM2 *
           =8 /* platform specific order may be needed for MEMORY_CAN (position RAM1 or RAM2) */
           =8 # define V_DEF_P2SFR_CAN(storage, ptrtype, memclass)              V_MEMRAM0 storage V_MEMRAM1 ptrtype MEMO
             -RY_CAN *
           =8 # define V_DEF_P2SFR_CAN_TYPE(storage, ptrtype)                   typedef storage V_MEMRAM1 ptrtype MEMORY
             -_CAN *
           =8 /* --- */
           =8 # define V_DEF_CONSTP2VAR(storage, ptrtype, memclass, ptrclass)   V_MEMROM0 storage V_MEMRAM1 ptrtype V_ME
             -MRAM2 V_MEMRAM3 * V_MEMROM1 V_MEMROM2
           =8 # define V_DEF_CONST(storage, type, memclass)                     V_MEMROM0 storage V_MEMROM1 type V_MEMRO
             -M2
           =8 # define V_DEF_CONST_NEAR(storage, type)                          V_MEMROM0 storage V_MEMROM1_NEAR type V_
             -MEMROM2_NEAR
           =8 # define V_DEF_CONST_FAR(storage, type)                           V_MEMROM0 storage V_MEMROM1_FAR type V_M
             -EMROM2_FAR
           =8 # define V_DEF_CONST_TYPE(storage, type, memclass)                typedef storage V_MEMROM1 type V_MEMROM2
           =8 # define V_DEF_P2CONST(storage, ptrtype, memclass, ptrclass)      V_MEMRAM0 storage V_MEMROM1 ptrtype V_ME
             -MROM2 V_MEMROM3 * V_MEMRAM1 V_MEMRAM2
           =8 # define V_DEF_P2CONST_PARA(storage, ptrtype, memclass, ptrclass) storage V_MEMROM1 ptrtype V_MEMROM2 V_ME
             -MROM3 * V_MEMRAM1 V_MEMRAM2
           =8 # define V_DEF_P2CONST_TYPE(storage, ptrtype, ptrclass)           typedef storage V_MEMROM1 ptrtype V_MEMR
             -OM2 V_MEMROM3 *
           =8 # define V_DEF_CONSTP2CONST(storage, ptrtype, memclass, ptrclass) V_MEMROM0 storage V_MEMROM1 ptrtype V_ME
             -MROM2 V_MEMROM3 * V_MEMROM1 V_MEMROM2
           =8 # define V_DEF_FUNC(storage, rettype, memclass)                   storage rettype
           =8 # define V_DEF_FUNC_API(storage, rettype, memclass)               storage C_API_1 rettype C_API_2
           =8 # define V_DEF_FUNC_CBK(storage, rettype, memclass)               storage C_CALLBACK_1 rettype C_CALLBACK_
             -2
           =8 # define V_DEF_P2FUNC(storage, rettype, ptrclass, fctname)        storage C_CALLBACK_1 rettype (C_CALLBACK
             -_2 *fctname)
           =8 #endif
           =8 /*-----------------------------------------------------------------------------------------------*/
           =8 
           =8 #endif /* V_DEF_H */
1023      =8  
1024      =8  
1025      =8  /* STOPSINGLE_OF_MULTIPLE */
 406      =7  
 407      =7  /* *********************************************************************** */
 408      =7  /* Defines                                                                 */
 409      =7  /* *********************************************************************** */
 410      =7  
 411      =7  /* *********************************************************************** */
 412      =7  /* Default switches                                                        */
 413      =7  /* Automatic define settings, depending on user configuration in can_cfg.h */
 414      =7  /* *********************************************************************** */
 415      =7  # if defined( C_ENABLE_MULTICHANNEL_API )
           =7 #  define C_MULTIPLE_RECEIVE_CHANNEL
           =7 #  define MULTIPLE_RECEIVE_CHANNEL
           =7 # else
 419      =7  #  define C_SINGLE_RECEIVE_CHANNEL
 420      =7  # endif
 421      =7  
 422      =7  # if ( kCanNumberOfTxObjects > 0 )
 423      =7  #  if !(defined( C_ENABLE_CAN_TRANSMIT ) || defined( C_DISABLE_CAN_TRANSMIT ))
 424      =7  #   define C_ENABLE_CAN_TRANSMIT
 425      =7  #  endif
 426      =7  # endif
 427      =7  
 428      =7  # if !(defined( C_ENABLE_OFFLINE ) || defined( C_DISABLE_OFFLINE ))
 429      =7  #  define C_ENABLE_OFFLINE
 430      =7  # endif
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 212 

 431      =7  
 432      =7  # if !(defined( C_ENABLE_STOP ) || defined( C_DISABLE_STOP ))
 433      =7  #  define C_ENABLE_STOP
 434      =7  # endif
 435      =7  
 436      =7  # if !(defined( C_ENABLE_CAN_CAN_INTERRUPT_CONTROL ) || defined( C_DISABLE_CAN_CAN_INTERRUPT_CONTROL ))
           =7 #  define C_ENABLE_CAN_CAN_INTERRUPT_CONTROL
           =7 # endif
 439      =7  
 440      =7  # if !(defined( C_ENABLE_CAN_CANCEL_TRANSMIT ) || defined( C_DISABLE_CAN_CANCEL_TRANSMIT ))
 441      =7  #  if defined( C_ENABLE_CAN_TRANSMIT )
 442      =7  #   define C_ENABLE_CAN_CANCEL_TRANSMIT
 443      =7  #  endif
 444      =7  # endif
 445      =7  
 446      =7  # if !defined( kCanNumberOfHwChannels )
           =7 /* compatibility for older tool versions */
           =7 #  define kCanNumberOfHwChannels                 kCanNumberOfChannels
           =7 # endif
 450      =7  
 451      =7  /* KB begin CanLL_DefaultSwitches */
 452      =7  #define C_HL_DISABLE_OVERRUN_IN_STATUS
 453      =7  
 454      =7  #define C_HL_DISABLE_HW_RANGES_FILTER
 455      =7  
 456      =7  #define C_HL_ENABLE_IDTYPE_IN_ID
 457      =7  
 458      =7  
 459      =7  #if defined (C_HL_ENABLE_IDTYPE_IN_ID)
 460      =7  /* Specify the ID tables which contain the ID type */
 461      =7  # define C_LL_RX_IDTYPE_TABLE      CanRxId0
 462      =7  # define C_LL_TX_IDTYPE_TABLE      CanTxId0
 463      =7  #endif
 464      =7  
 465      =7  
 466      =7  #define C_HL_DISABLE_DUMMY_FCT_CALL
 467      =7  
 468      =7  
 469      =7  #define C_HL_DISABLE_TX_MSG_DESTROYED
 470      =7  
 471      =7  
 472      =7  #define C_HL_ENABLE_CANCEL_IN_HW_TASK
 473      =7  
 474      =7  
 475      =7  #define C_HL_DISABLE_HW_EXIT_TRANSMIT 
 476      =7  
 477      =7  #define C_HL_ENABLE_LAST_INIT_OBJ     
 478      =7  
 479      =7  #define C_HL_ENABLE_CAN_IRQ_DISABLE   
 480      =7  
 481      =7  #define C_HL_DISABLE_ADJUST_RXHANDLE  
 482      =7  /* 
 483      =7  The define kCanNumberOfMsgObjects adjusts how many message objects the hardware supports
 484      =7  */
 485      =7  #if defined ( C_COMP_KEIL_SLC8051_CCAN )
 486      =7  # if !defined ( kCanNumberOfMsgObjects )
           =7 #  define kCanNumberOfMsgObjects 32
           =7 # endif
 489      =7  #endif
 490      =7  
 491      =7  /* 
 492      =7  This define adjust the bit-access to the hardware register of the can-cell
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 213 

 493      =7  */
 494      =7  #if defined ( C_COMP_KEIL_SLC8051_CCAN )
 495      =7  # define C_LL_8BIT_CAN_ACCESS
 496      =7  #endif
 497      =7  
 498      =7  
 499      =7  /* 
 500      =7  This define adjust the byte-access to the hardware register of the can-cell
 501      =7  */
 502      =7  
 503      =7  #if defined ( C_COMP_KEIL_SLC8051_CCAN )
 504      =7  # define C_LL_SFR_MAPPED_CANCELL
 505      =7  #endif
 506      =7  
 507      =7  /* 
 508      =7  This define adjust the access to some variables
 509      =7  */
 510      =7  #if defined ( C_COMP_KEIL_SLC8051_CCAN )
 511      =7  # define C_LL_16BIT_OPTIMATED_ACCESS
 512      =7  #endif
 513      =7  
 514      =7  /* 
 515      =7  Adjust a can-cell with a 16 bit empty space between the 16 bit register
 516      =7  */
 517      =7  
 518      =7  /*
 519      =7  Specify for which configuration the CAN interrupt states (locked, unlocked) have to be pre served after Ca
             -nInit(), Can_ControllerInit() call
 520      =7  */
 521      =7  
 522      =7  
 523      =7  
 524      =7  #define C_HL_ENABLE_REJECT_UNWANTED_IDTYPE
 525      =7  
 526      =7  #define C_HL_DISABLE_REJECT_REMOTE_FRAME
 527      =7  
 528      =7  #define C_HL_DISABLE_REJECT_REMOTE_FRAME_FULLCAN
 529      =7  
 530      =7  #define C_HL_DISABLE_COPROCESSOR_SUPPORT
 531      =7  
 532      =7  
 533      =7  
 534      =7  # if !( defined (C_DISABLE_DRIVER_STATUS))
 535      =7  #  define C_ENABLE_DRIVER_STATUS
 536      =7  # endif
 537      =7  
 538      =7  #define C_HL_DISABLE_RETRANSMIT_FCT
 539      =7  
 540      =7  #define C_HL_ENABLE_RETRANSMIT_CONF_ISR
 541      =7  
 542      =7  #if defined( C_COMP_KEIL_SLC8051_CCAN )
 543      =7  #define C_HL_ENABLE_AVOID_REENTRANT_APPLCANCANCELNOTIFICATION
 544      =7  #else
           =7 #define C_HL_DISABLE_AVOID_REENTRANT_APPLCANCANCELNOTIFICATION
           =7 #endif
 547      =7  
 548      =7  #if defined( C_COMP_KEIL_SLC8051_CCAN )
 549      =7  /* use no RxInfoStruct pointer for better performance */
 550      =7  # define C_HL_DISABLE_RX_INFO_STRUCT_PTR
 551      =7  #endif
 552      =7  
 553      =7  
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 214 

 554      =7  /* KB end CanLL_DefaultSwitches */
 555      =7  
 556      =7  
 557      =7  
 558      =7  # if defined( C_ENABLE_TX_POLLING )
           =7 #  if !(defined( C_ENABLE_ERROR_POLLING )  || defined( C_DISABLE_ERROR_POLLING ))
           =7 #   define C_ENABLE_ERROR_POLLING 
           =7 #  endif
           =7 # endif
 563      =7  
 564      =7  # if !(defined( C_ENABLE_TASK_RECURSION_CHECK ) || defined( C_DISABLE_TASK_RECURSION_CHECK ))
 565      =7  #  define C_ENABLE_TASK_RECURSION_CHECK
 566      =7  # endif
 567      =7  
 568      =7  # if defined( C_ENABLE_MULTI_ECU_PHYS )
           =7 #  define C_SUPPORTS_MULTI_ECU_PHYS
           =7 # endif
 571      =7  
 572      =7  /* *********************************************************************** */
 573      =7  /* return values                                                           */
 574      =7  /* *********************************************************************** */
 575      =7  
 576      =7  /* return values for precopy-routines */
 577      =7  # define kCanNoCopyData                          ((vuint8)0x00)
 578      =7  # define kCanCopyData                            ((vuint8)0x01)
 579      =7  
 580      =7  /* Bitmask of return value of CanGetStatus() */
 581      =7  # define kCanTxOff                               ((vuint8)0x00)
 582      =7  # define kCanStatusInit                          ((vuint8)0x00)
 583      =7  # define kCanTxOn                                ((vuint8)0x01)
 584      =7  # define kCanTxNotOn                             ((vuint8)0xFE)              /* internal use only */
 585      =7  # define kCanHwIsStop                            ((vuint8)0x02)
 586      =7  # define kCanHwIsInit                            ((vuint8)0x04)
 587      =7  # define kCanHwIsInconsistent                    ((vuint8)0x08)              /* used of for common CAN */
 588      =7  # define kCanHwIsWarning                         ((vuint8)0x10)
 589      =7  # define kCanHwIsPassive                         ((vuint8)0x20)
 590      =7  # define kCanHwIsBusOff                          ((vuint8)0x40)
 591      =7  # define kCanHwIsSleep                           ((vuint8)0x80)
 592      =7  
 593      =7  /* CanTransmit return values ----------------------------------------------- */
 594      =7  # define kCanTxFailed                            ((vuint8)0x00)  /* Tx path switched off or no sending pos
             -sible */
 595      =7  # define kCanTxOk                                ((vuint8)0x01)  /* msg transmitted or in queue           
             -      */
 596      =7  # define kCanTxPartOffline                       ((vuint8)0x02)  /* Tx path switched part off or          
             - */
 597      =7  # define kCanCommunicationDisabled               ((vuint8)0x03)  /* if application has disabled com after 
             -memory check */
 598      =7  
 599      =7  # if defined( C_DRV_INTERNAL )
           =7 #  define kCanTxNotify                           ((vuint8)0x05)  /* internal returncode only - not used fo
             -r the API */
           =7 # endif
 602      =7  
 603      =7  /* CanGetDynTxObj return values ----------------------------------------------- */
 604      =7  # define kCanNoTxDynObjAvailable                 ((CanTransmitHandle)0xFFFFFFFFU)
 605      =7  
 606      =7  /* CanReleaseDynTxObj return values ------------------------------------------- */
 607      =7  # define kCanDynReleased                         ((vuint8)0x00)
 608      =7  # define kCanDynNotReleased                      ((vuint8)0x01)
 609      =7  
 610      =7  /* generel return values */
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 215 

 611      =7  # define kCanFailed                              ((vuint8)0x00)
 612      =7  # define kCanOk                                  ((vuint8)0x01)
 613      =7  # define kCanNotSupported                        ((vuint8)0x02)
 614      =7  
 615      =7  # define kCanFalse                               ((vuint8)0x00)
 616      =7  # define kCanTrue                                ((vuint8)0x01)
 617      =7  
 618      =7  /* results of CAN RAM check */
 619      =7  # define kCanRamCheckFailed                      ((vuint8)0x00)
 620      =7  # define kCanRamCheckOk                          ((vuint8)0x01)
 621      =7  # define kCanDisableCommunication                ((vuint8)0x00)
 622      =7  # define kCanEnableCommunication                 ((vuint8)0x01)
 623      =7  
 624      =7  
 625      =7  /* KB begin CanLL_ReturnValuesH */
 626      =7  /* return values of CanRxActualIdType */
 627      =7  # define kCanIdTypeStd                           (0x0000U)
 628      =7  # define kCanIdTypeExt                           (0x4000U)
 629      =7  
 630      =7  /* return values of CanGetDriverStatus */
 631      =7  #define kCanDriverBusoff        0x01u             /* CAN driver is in recovery phase after bus off */ 
 632      =7  #define kCanDriverBusoffInit    0x02u             /* Driver finished recovery and needs to be initialized 
             -*/
 633      =7  #define kCanDriverNormal        0x03u             /* Driver completed recovery and is in normal mode */ 
 634      =7  /* KB end CanLL_ReturnValuesH */
 635      =7  
 636      =7  /* *********************************************************************** */
 637      =7  /* parameter values                                                        */
 638      =7  /* *********************************************************************** */
 639      =7  /* parameters for partial offline */
 640      =7  # define kCanTxPartInit                          ((vuint8)0x00)
 641      =7  
 642      =7  /* paramater for assertions */
 643      =7  # define kCanAllChannels                         ((CanChannelHandle)0xFFU)
 644      =7  /* used for generated tables */
 645      =7  # define kCanChannelNotUsed                      ((CanChannelHandle)0xFFU)
 646      =7  
 647      =7  /* canRxHandle does not contain a certain message handle or entry in table is not used */
 648      =7  # define kCanRxHandleNotUsed                     ((CanReceiveHandle)  0xFFFFFFFFU)
 649      =7  # define kCanTxHandleNotUsed                     ((CanTransmitHandle) 0xFFFFFFFFU)
 650      =7  
 651      =7  # if defined( C_DRV_INTERNAL )
           =7 #  define kCanRxHandleRange0                     ((CanReceiveHandle)  0xFFFFFFF0U)
           =7 #  define kCanRxHandleRange1                     ((CanReceiveHandle)  0xFFFFFFF1U)
           =7 #  define kCanRxHandleRange2                     ((CanReceiveHandle)  0xFFFFFFF2U)
           =7 #  define kCanRxHandleRange3                     ((CanReceiveHandle)  0xFFFFFFF3U)
           =7 
           =7 /* entries for generated table CanHwMsgTransmitIndex[], CanHwTxNormalIndex[] - unused in case of CommonCan
             - */
           =7 /* table entry does not contain a HW object assignment */
           =7 #  define kCanObjectHandleNotUsed                ((CanObjectHandle)0xFFU)
           =7 # endif
 661      =7  
 662      =7  /* status of transmit objects */
 663      =7  # define kCanBufferFree                         ((CanTransmitHandle)0xFFFFFFFFU)   /* mark a transmit obje
             -ct is free */
 664      =7  # define kCanBufferCancel                       ((CanTransmitHandle)0xFFFFFFFEU)   /* mark a transmit obje
             -ct as canceled */
 665      =7  # define kCanBufferMsgDestroyed                 ((CanTransmitHandle)0xFFFFFFFDU)   /* mark a transmit obje
             -ct as destroyed */
 666      =7  # define kCanBufferMsgTransmit                  ((CanTransmitHandle)0xFFFFFFFCU)   /* mark a transmit obje
             -ct as used by CanMsgTransmit */
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 216 

 667      =7  # define kCanBufferRetransmit                   ((CanTransmitHandle)0xFFFFFFFBU)   /* mark a transmit obje
             -ct as used by CanRetransmit */
 668      =7  /* valid transmit message handle:   0x0 to kCanNumberOfTxObjects   */
 669      =7  
 670      =7  /* KB begin CanLL_ParameterValuesH */
 671      =7  /* parameter for ApplCanTimerStart(),-End(), -Loop()*/
 672      =7  /* index has to start with 0, continues numbers have to be used. Gabs are not 
 673      =7     allowed! */
 674      =7  
 675      =7  #define kCanLoopIrqReq                  0x00
 676      =7  #define kCanLoopBusyReq                 0x01
 677      =7  #define kCanLoopUnlockReq               0x02
 678      =7  #define kCanLoopLockReq                 0x03
 679      =7  
 680      =7  /* KB end CanLL_ParameterValuesH */
 681      =7  
 682      =7  /* *********************************************************************** */
 683      =7  /* macros                                                                  */
 684      =7  /* *********************************************************************** */
 685      =7  
 686      =7  # if defined( C_SINGLE_RECEIVE_CHANNEL ) 
 687      =7  #  define CAN_CHANNEL_CANTYPE_ONLY               void                                 /* PRQA S 3460 */
 688      =7  #  define CAN_CHANNEL_CANTYPE_FIRST
 689      =7  #  define CAN_CHANNEL_CANTYPE_LOCAL         
 690      =7  #  define CAN_CHANNEL_CANPARA_ONLY
 691      =7  #  define CAN_CHANNEL_CANPARA_FIRST
 692      =7  #  define CAN_HW_CHANNEL_CANTYPE_ONLY            void                                 /* PRQA S 3460 */
 693      =7  #  define CAN_HW_CHANNEL_CANTYPE_FIRST
 694      =7  #  define CAN_HW_CHANNEL_CANTYPE_LOCAL
 695      =7  #  define CAN_HW_CHANNEL_CANPARA_ONLY
 696      =7  #  define CAN_HW_CHANNEL_CANPARA_FIRST
 697      =7  # else
           =7 #  define CAN_CHANNEL_CANTYPE_ONLY               CanChannelHandle channel
           =7 #  define CAN_CHANNEL_CANTYPE_FIRST              CanChannelHandle channel,
           =7 #  define CAN_CHANNEL_CANTYPE_LOCAL              CanChannelHandle channel;             /* PRQA S 3412 */
           =7 #  define CAN_CHANNEL_CANPARA_ONLY               channel
           =7 #  define CAN_CHANNEL_CANPARA_FIRST              channel,
           =7 #  define CAN_HW_CHANNEL_CANTYPE_ONLY            CanChannelHandle canHwChannel
           =7 #  define CAN_HW_CHANNEL_CANTYPE_FIRST           CanChannelHandle canHwChannel,
           =7 #  define CAN_HW_CHANNEL_CANTYPE_LOCAL           CanChannelHandle canHwChannel;        /* PRQA S 3412 */
           =7 #  define CAN_HW_CHANNEL_CANPARA_ONLY            canHwChannel
           =7 #  define CAN_HW_CHANNEL_CANPARA_FIRST           canHwChannel,
           =7 # endif
 709      =7  
 710      =7  # if defined( C_DRV_INTERNAL )
           =7 /* macros to fill struct elements RangeMask and RangeCode of type tCanChannelObject - used by generation t
             -ool only */
           =7 #  if (kCanNumberOfUsedCanRxIdTables == 1)
           =7 #   define MK_RX_RANGE_MASK_IDSTD(i)             {MK_RX_RANGE_MASK_IDSTD0(i)}
           =7 #   define MK_RX_RANGE_CODE_IDSTD(i)             {MK_RX_RANGE_CODE_IDSTD0(i)}
           =7 #  endif
           =7 #  if (kCanNumberOfUsedCanRxIdTables == 2)
           =7 #   define MK_RX_RANGE_MASK_IDSTD(i)             {MK_RX_RANGE_MASK_IDSTD0(i), MK_RX_RANGE_MASK_IDSTD1(i)}
           =7 #   define MK_RX_RANGE_CODE_IDSTD(i)             {MK_RX_RANGE_CODE_IDSTD0(i), MK_RX_RANGE_CODE_IDSTD1(i)}
           =7 #  endif
           =7 #  if (kCanNumberOfUsedCanRxIdTables == 3)
           =7 #   define MK_RX_RANGE_MASK_IDSTD(i)             {MK_RX_RANGE_MASK_IDSTD0(i), MK_RX_RANGE_MASK_IDSTD1(i), 
             -MK_RX_RANGE_MASK_IDSTD2(i)}
           =7 #   define MK_RX_RANGE_CODE_IDSTD(i)             {MK_RX_RANGE_CODE_IDSTD0(i), MK_RX_RANGE_CODE_IDSTD1(i), 
             -MK_RX_RANGE_CODE_IDSTD2(i)}
           =7 #  endif
           =7 #  if (kCanNumberOfUsedCanRxIdTables == 4)
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 217 

           =7 #   define MK_RX_RANGE_MASK_IDSTD(i)             {MK_RX_RANGE_MASK_IDSTD0(i), MK_RX_RANGE_MASK_IDSTD1(i), 
             -MK_RX_RANGE_MASK_IDSTD2(i), MK_RX_RANGE_MASK_IDSTD3(i)}
           =7 #   define MK_RX_RANGE_CODE_IDSTD(i)             {MK_RX_RANGE_CODE_IDSTD0(i), MK_RX_RANGE_CODE_IDSTD1(i), 
             -MK_RX_RANGE_CODE_IDSTD2(i), MK_RX_RANGE_CODE_IDSTD3(i)}
           =7 #  endif
           =7 #  if (kCanNumberOfUsedCanRxIdTables == 5)
           =7 #   define MK_RX_RANGE_MASK_IDSTD(i)             {MK_RX_RANGE_MASK_IDSTD0(i), MK_RX_RANGE_MASK_IDSTD1(i), 
             -MK_RX_RANGE_MASK_IDSTD2(i), MK_RX_RANGE_MASK_IDSTD3(i), MK_RX_RANGE_MASK_IDSTD4(i)}
           =7 #   define MK_RX_RANGE_CODE_IDSTD(i)             {MK_RX_RANGE_CODE_IDSTD0(i), MK_RX_RANGE_CODE_IDSTD1(i), 
             -MK_RX_RANGE_CODE_IDSTD2(i), MK_RX_RANGE_CODE_IDSTD3(i), MK_RX_RANGE_CODE_IDSTD4(i)}
           =7 #  endif
           =7 
           =7 #  if (kCanNumberOfUsedCanRxIdTables == 1)
           =7 #   define MK_RX_RANGE_MASK_IDEXT(i)             {MK_RX_RANGE_MASK_IDEXT0(i)}
           =7 #   define MK_RX_RANGE_CODE_IDEXT(i)             {MK_RX_RANGE_CODE_IDEXT0(i)}
           =7 #  endif
           =7 #  if (kCanNumberOfUsedCanRxIdTables == 2)
           =7 #   define MK_RX_RANGE_MASK_IDEXT(i)             {MK_RX_RANGE_MASK_IDEXT0(i), MK_RX_RANGE_MASK_IDEXT1(i)}
           =7 #   define MK_RX_RANGE_CODE_IDEXT(i)             {MK_RX_RANGE_CODE_IDEXT0(i), MK_RX_RANGE_CODE_IDEXT1(i)}
           =7 #  endif
           =7 #  if (kCanNumberOfUsedCanRxIdTables == 3)
           =7 #   define MK_RX_RANGE_MASK_IDEXT(i)             {MK_RX_RANGE_MASK_IDEXT0(i), MK_RX_RANGE_MASK_IDEXT1(i), 
             -MK_RX_RANGE_MASK_IDEXT2(i)}
           =7 #   define MK_RX_RANGE_CODE_IDEXT(i)             {MK_RX_RANGE_CODE_IDEXT0(i), MK_RX_RANGE_CODE_IDEXT1(i), 
             -MK_RX_RANGE_CODE_IDEXT2(i)}
           =7 #  endif
           =7 #  if (kCanNumberOfUsedCanRxIdTables == 4)
           =7 #   define MK_RX_RANGE_MASK_IDEXT(i)             {MK_RX_RANGE_MASK_IDEXT0(i), MK_RX_RANGE_MASK_IDEXT1(i), 
             -MK_RX_RANGE_MASK_IDEXT2(i), MK_RX_RANGE_MASK_IDEXT3(i)}
           =7 #   define MK_RX_RANGE_CODE_IDEXT(i)             {MK_RX_RANGE_CODE_IDEXT0(i), MK_RX_RANGE_CODE_IDEXT1(i), 
             -MK_RX_RANGE_CODE_IDEXT2(i), MK_RX_RANGE_CODE_IDEXT3(i)}
           =7 #  endif
           =7 #  if (kCanNumberOfUsedCanRxIdTables == 5)
           =7 #   define MK_RX_RANGE_MASK_IDEXT(i)             {MK_RX_RANGE_MASK_IDEXT0(i), MK_RX_RANGE_MASK_IDEXT1(i), 
             -MK_RX_RANGE_MASK_IDEXT2(i), MK_RX_RANGE_MASK_IDEXT3(i), MK_RX_RANGE_MASK_IDEXT4(i)}
           =7 #   define MK_RX_RANGE_CODE_IDEXT(i)             {MK_RX_RANGE_CODE_IDEXT0(i), MK_RX_RANGE_CODE_IDEXT1(i), 
             -MK_RX_RANGE_CODE_IDEXT2(i), MK_RX_RANGE_CODE_IDEXT3(i), MK_RX_RANGE_CODE_IDEXT4(i)}
           =7 #  endif
           =7 # endif
 754      =7  
 755      =7  /* calculate size of cond/ind-flags */
 756      =7  #  define kCanNumberOfConfBytes                  ((kCanNumberOfConfFlags + 7)/8)
 757      =7  # define kCanNumberOfConfWords                   ((kCanNumberOfConfFlags + 15)/16)
 758      =7  # define kCanNumberOfConfDWords                  ((kCanNumberOfConfFlags + 31)/32)
 759      =7  #  define kCanNumberOfIndBytes                   ((kCanNumberOfIndFlags + 7)/8)
 760      =7  # define kCanNumberOfIndWords                    ((kCanNumberOfIndFlags + 15)/16)
 761      =7  # define kCanNumberOfIndDWords                   ((kCanNumberOfIndFlags + 31)/32)
 762      =7  
 763      =7  /* Macros for CAN message access within ApplCanMsgReceived() or PreCopy() function */
 764      =7  
 765      =7  # if defined( C_ENABLE_EXTENDED_ID )
           =7 #  if defined( C_ENABLE_MIXED_ID )
           =7 #   define CanRxActualId(rxStruct)               ((CanRxActualIdType(rxStruct) == kCanIdTypeExt) ?      \
           =7                                                  CanRxActualExtId(rxStruct) : ((vuint32)CanRxActualStdId(r
             -xStruct)))      /* returns vuint32 */
           =7 #  else
           =7 #   define CanRxActualId(rxStruct)               (CanRxActualExtId(rxStruct))             /* returns vuint
             -32 */
           =7 #  endif
           =7 # else
 773      =7  #  define CanRxActualId(rxStruct)                (CanRxActualStdId(rxStruct))             /* returns vuint
             -16 */
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 218 

 774      =7  # endif
 775      =7  
 776      =7  /* Macros for CAN Status */
 777      =7  # define CanHwIsOk(state)                        (((state) & (kCanHwIsWarning |     \
 778      =7                                                      kCanHwIsPassive |     \
 779      =7                                                      kCanHwIsBusOff) )    ? 0 : 1)
 780      =7  # define CanHwIsWarning(state)                   (((state) & kCanHwIsWarning)      ? 1 : 0)
 781      =7  # define CanHwIsPassive(state)                   (((state) & kCanHwIsPassive)      ? 1 : 0)
 782      =7  # define CanHwIsBusOff(state)                    (((state) & kCanHwIsBusOff)       ? 1 : 0)
 783      =7  # define CanHwIsWakeup(state)                    (((state) & kCanHwIsSleep)        ? 0 : 1)
 784      =7  # define CanHwIsSleep(state)                     (((state) & kCanHwIsSleep)        ? 1 : 0)
 785      =7  # define CanHwIsStop(state)                      (((state) & kCanHwIsStop)         ? 1 : 0)
 786      =7  # define CanHwIsStart(state)                     (((state) & kCanHwIsStop)         ? 0 : 1)
 787      =7  # define CanIsOnline(state)                      (((state) & kCanTxOn)             ? 1 : 0)
 788      =7  # define CanIsOffline(state)                     (((state) & kCanTxOn)             ? 0 : 1)
 789      =7  # define CanHwIsInconsistent(state)              (((state) & kCanHwIsInconsistent) ? 1 : 0)
 790      =7  
 791      =7  
 792      =7  
 793      =7  #  if defined( C_DRV_INTERNAL )
           =7 #   define CanGetTxId0(i)                        (CanTxId0[i])
           =7 #   define CanGetTxId1(i)                        (CanTxId1[i])
           =7 #   define CanGetTxId2(i)                        (CanTxId2[i])
           =7 #   define CanGetTxId3(i)                        (CanTxId3[i])
           =7 #   define CanGetTxId4(i)                        (CanTxId4[i])
           =7 #   if defined( C_ENABLE_EXTENDED_ID )
           =7 #    if defined( C_ENABLE_MIXED_ID )
           =7 #     if defined( C_HL_ENABLE_IDTYPE_IN_ID )
           =7 #      define CanGetTxIdType(i)                  (C_LL_TX_IDTYPE_TABLE[i] & kCanIdTypeExt)
           =7 #     else
           =7 #       define CanGetTxIdType(i)                 (CanTxIdType[i] & kCanIdTypeExt)
           =7 #     endif
           =7 #    else
           =7 #     define CanGetTxIdType(i)                   (kCanIdTypeExt)
           =7 #    endif
           =7 #   else
           =7 #    define CanGetTxIdType(i)                    (kCanIdTypeStd)
           =7 #   endif
           =7 #  endif /* C_DRV_INTERNAL */
 813      =7  
 814      =7  #  define CanGetTxDlc(i)                         (CanTxDLC[i])
 815      =7  #  define CanGetTxDataPtr(i)                     (CanTxDataPtr[i])
 816      =7  #  define CanGetConfirmationOffset(i)            (CanConfirmationOffset[i])
 817      =7  #  define CanGetConfirmationMask(i)              (CanConfirmationMask[i])
 818      =7  #   define CanGetTxHwObj(i)                      (CanTxHwObj[i])
 819      =7  #  define CanGetTxSendMask(i)                    (CanTxSendMask[i])
 820      =7  #  define CanGetApplPreTransmitPtr(i)            (CanTxApplPreTransmitPtr[i])
 821      =7  #  define CanGetApplConfirmationPtr(i)           (CanTxApplConfirmationPtr[i])
 822      =7  #  define CanGetChannelOfTxObj(i)                (CanTxMsgHandleToChannel[i])
 823      =7  
 824      =7  #  if defined( C_DRV_INTERNAL )
           =7 #   define CanGetRxId0(i)                        (CanRxId0[i])
           =7 #   define CanGetRxId1(i)                        (CanRxId1[i])
           =7 #   define CanGetRxId2(i)                        (CanRxId2[i])
           =7 #   define CanGetRxId3(i)                        (CanRxId3[i])
           =7 #   define CanGetRxId4(i)                        (CanRxId4[i])
           =7 #   if defined( C_ENABLE_EXTENDED_ID )
           =7 #    if defined( C_ENABLE_MIXED_ID )
           =7 #     if defined( C_HL_ENABLE_IDTYPE_IN_ID )
           =7 #      define CanGetRxIdType(i)                  (C_LL_RX_IDTYPE_TABLE[i] & kCanIdTypeExt)
           =7 #     else
           =7 #      define CanGetRxIdType(i)                  (CanRxIdType[i] & kCanIdTypeExt)
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 219 

           =7 #     endif
           =7 #    else
           =7 #     define CanGetRxIdType(i)                   (kCanIdTypeExt)
           =7 #    endif
           =7 #   else
           =7 #    define CanGetRxIdType(i)                    (kCanIdTypeStd)
           =7 #   endif
           =7 #  endif /* C_DRV_INTERNAL */
 844      =7  
 845      =7  #  define CanGetRxDataLen(i)                     (CanRxDataLen[i])
 846      =7  #  define CanGetRxMinDataLen(i)                  (CanRxMinDataLen[i])
 847      =7  #  define CanGetRxDataPtr(i)                     (CanRxDataPtr[i])
 848      =7  #  define CanGetIndicationOffset(i)              (CanIndicationOffset[i])
 849      =7  #  define CanGetIndicationMask(i)                (CanIndicationMask[i])
 850      =7  #  define CanGetApplPrecopyPtr(i)                (CanRxApplPrecopyPtr[i])
 851      =7  #  define CanGetApplIndicationPtr(i)             (CanRxApplIndicationPtr[i])
 852      =7  
 853      =7  # if defined( C_ENABLE_CONFIRMATION_FCT ) && \
 854      =7      defined( C_ENABLE_DYN_TX_OBJECTS )  && \
 855      =7      defined( C_ENABLE_TRANSMIT_QUEUE )
           =7   /* set confirmation active for CanReleaseDynTxObj() */
           =7 #  if defined( C_SINGLE_RECEIVE_CHANNEL ) 
           =7 #   define CanConfirmStart(txHandle)             {confirmHandle[0] = (txHandle);}                 /* PRQA 
             -S 3458 */
           =7 #   define CanConfirmEnd()                       {confirmHandle[0] = kCanTxHandleNotUsed;}        /* PRQA 
             -S 3458 */
           =7 #  else
           =7 #   define CanConfirmStart(channel, txHandle)    {confirmHandle[channel] = (txHandle);}           /* PRQA 
             -S 3458 */
           =7 #   define CanConfirmEnd(channel)                {confirmHandle[channel] = kCanTxHandleNotUsed;}  /* PRQA 
             -S 3458 */
           =7 #  endif
           =7 # endif
 865      =7  
 866      =7  # if defined( C_ENABLE_PART_OFFLINE )
 867      =7  #  if defined( C_SINGLE_RECEIVE_CHANNEL ) 
 868      =7  #   define CanPartOffline(sendGroup)             (CanSetPartOffline( sendGroup))
 869      =7  #   define CanPartOnline(sendGroup)              (CanSetPartOnline( (vuint8)~(vuint8)(sendGroup)) )
 870      =7  #  else
           =7 #   define CanPartOffline(channel, sendGroup)    (CanSetPartOffline((channel), (sendGroup)))
           =7 #   define CanPartOnline(channel,  sendGroup)    (CanSetPartOnline((channel), (vuint8)~(vuint8)(sendGroup)
             -) )
           =7 #  endif
 874      =7  # else
           =7 #  if defined( C_SINGLE_RECEIVE_CHANNEL ) 
           =7 #   define CanPartOffline(sendGroup)
           =7 #   define CanPartOnline(sendGroup)
           =7 #  else
           =7 #   define CanPartOffline(channel, sendGroup)
           =7 #   define CanPartOnline(channel, sendGroup)
           =7 #  endif
           =7 # endif
 883      =7  
 884      =7  /* provide interface for interrupt disable and restore functions */
 885      =7  # define CanGlobalInterruptDisable               VStdSuspendAllInterrupts
 886      =7  # define CanGlobalInterruptRestore               VStdResumeAllInterrupts
 887      =7  
 888      =7  # if ( C_SECURITY_LEVEL == 0 )
           =7 #  define CanDeclareGlobalInterruptOldStatus
           =7 #  define CanPutGlobalInterruptOldStatus(x)
           =7 #  define CanGetGlobalInterruptOldStatus(x)
           =7 #  define CanNestedGlobalInterruptDisable()
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 220 

           =7 #  define CanNestedGlobalInterruptRestore()
           =7 # else  /* C_SECURITY_LEVEL == 0 */
 895      =7  #  define CanDeclareGlobalInterruptOldStatus     VStdDeclareGlobalInterruptOldStatus
 896      =7  #  define CanPutGlobalInterruptOldStatus(x)      VStdPutGlobalInterruptOldStatus(x)
 897      =7  #  define CanGetGlobalInterruptOldStatus(x)      VStdGetGlobalInterruptOldStatus(x)
 898      =7  #  if (VSTDLIB__COREHLL_VERSION  <  0x0216 )
           =7 #   define CanNestedGlobalInterruptDisable()      VStdNestedGlobalInterruptDisable()
           =7 #   define CanNestedGlobalInterruptRestore()      VStdNestedGlobalInterruptRestore()
           =7 #  else
 902      =7  #   define CanNestedGlobalInterruptDisable()      VStdGlobalInterruptDisable()
 903      =7  #   define CanNestedGlobalInterruptRestore()      VStdGlobalInterruptRestore()
 904      =7  #  endif
 905      =7  # endif /* C_SECURITY_LEVEL == 0 */
 906      =7  
 907      =7  
 908      =7  /* provide support for multiple callbacks */
 909      =7  #if !defined( APPL_CAN_GENERIC_PRECOPY )
           =7 # define APPL_CAN_GENERIC_PRECOPY                          ApplCanGenericPrecopy
           =7 #endif
 912      =7  #if !defined( APPL_CAN_TX_CONFIRMATION )
 913      =7  # define APPL_CAN_TX_CONFIRMATION                          ApplCanTxConfirmation
 914      =7  #endif
 915      =7  #if !defined( APPL_CAN_MSGTRANSMITCONF )
 916      =7  # define APPL_CAN_MSGTRANSMITCONF                          ApplCanMsgTransmitConf
 917      =7  #endif
 918      =7  #if !defined( APPL_CAN_MSGTRANSMITINIT )
 919      =7  # define APPL_CAN_MSGTRANSMITINIT                          ApplCanMsgTransmitInit
 920      =7  #endif
 921      =7  #if !defined( APPL_CAN_ONLINE )
 922      =7  # define APPL_CAN_ONLINE                                   ApplCanOnline
 923      =7  #endif
 924      =7  #if !defined( APPL_CAN_OFFLINE )
 925      =7  # define APPL_CAN_OFFLINE                                  ApplCanOffline
 926      =7  #endif
 927      =7  #if !defined( APPL_CAN_MSGRECEIVED )
 928      =7  # define APPL_CAN_MSGRECEIVED                              ApplCanMsgReceived
 929      =7  #endif
 930      =7  #if !defined( APPL_CAN_CANCELNOTIFICATION )
           =7 # define APPL_CAN_CANCELNOTIFICATION                       ApplCanCancelNotification
           =7 #endif
 933      =7  #if !defined( APPL_CAN_MSGCANCELNOTIFICATION )
 934      =7  # define APPL_CAN_MSGCANCELNOTIFICATION                    ApplCanMsgCancelNotification
 935      =7  #endif
 936      =7  
 937      =7  /* KB begin CanHL_TxQueueMacrosH */
 938      =7  
 939      =7  
 940      =7  #if defined( C_CPUTYPE_8BIT )
 941      =7  # define kCanTxQueueSize      kCanTxQueueBytes
 942      =7  #endif
 943      =7  /* KB end CanHL_TxQueueMacrosH */
 944      =7  /* KB begin CanLL_MacrosH */
 945      =7  #if defined(C_ENABLE_HW_LOOP_TIMER)
           =7 
           =7 # define CanDeclareTimerResult       vuint8 canTimerResult;
           =7 # define WHILE_CONDITON(x)           while((x) && (canTimerResult != 0))
           =7 
           =7 #  define APPLCANTIMERSTART(x)       ApplCanTimerStart(CAN_CHANNEL_CANPARA_FIRST x)
           =7 #  define CANTIMERRESULT_UPDATE(x)   canTimerResult = ApplCanTimerLoop(CAN_CHANNEL_CANPARA_FIRST x)
           =7 #  define APPLCANTIMEREND(x)         ApplCanTimerEnd(CAN_CHANNEL_CANPARA_FIRST x)
           =7 
           =7 
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 221 

           =7 #else
 956      =7  
 957      =7  #  define CanDeclareTimerResult
 958      =7  #  define APPLCANTIMERSTART(x)
 959      =7  #  define CANTIMERRESULT_UPDATE(x)
 960      =7  #  define WHILE_CONDITON(x)          while(x)
 961      =7  #  define APPLCANTIMEREND(x)
 962      =7  
 963      =7  #endif
 964      =7  
 965      =7  #if defined( C_LL_SFR_MAPPED_CANCELL )
 966      =7  #define CANCN         CAN0CN                                         /* CAN Control Register Low Byte    *
             -/
 967      =7  #define CANSTAT       CAN0STAT                                       /* Status Register Low Byte         *
             -/
 968      =7  #define CANERRL       CAN0ERRL                                       /* Error Counter Low Byte           *
             -/
 969      =7  #define CANERRH       CAN0ERRH                                       /* Error Counter High Byte          *
             -/
 970      =7  #define CANBTL        CAN0BTL                                        /* Bit Timing Register Low Byte     *
             -/
 971      =7  #define CANBTH        CAN0BTH                                        /* Bit Timing Register High Byte    *
             -/
 972      =7  #define CANIIDL       CAN0IIDL                                       /* Interrupt Register Low Byte      *
             -/
 973      =7  #define CANIIDH       CAN0IIDH                                       /* Interrupt Register High Byte     *
             -/
 974      =7  #define CANTST        CAN0TST                                        /* Test Register Low Byte           *
             -/
 975      =7  #define CANBRPE       CAN0BRPE                                       /* BRP Extension Register Low Byte  *
             -/
 976      =7  #define CANTR1L       CAN0TR1L                                       /* Transmission Request 1 Low Byte  *
             -/
 977      =7  #define CANTR1H       CAN0TR1H                                       /* Transmission Request 1 High Byte *
             -/
 978      =7  #define CANTR2L       CAN0TR2L                                       /* Transmission Request 2 Low Byte  *
             -/
 979      =7  #define CANTR2H       CAN0TR2H                                       /* Transmission Request 2 High Byte *
             -/
 980      =7  #define CANND1L       CAN0ND1L                                       /* New Data 1 Low Byte              *
             -/
 981      =7  #define CANND1H       CAN0ND1H                                       /* New Data 1 High Byte             *
             -/
 982      =7  #define CANND2L       CAN0ND2L                                       /* New Data 2 Low Byte              *
             -/
 983      =7  #define CANND2H       CAN0ND2H                                       /* New Data 2 High Byte             *
             -/
 984      =7  #define CANIP1L       CAN0IP1L                                       /* Interrupt Pending 1 Low Byte     *
             -/
 985      =7  #define CANIP1H       CAN0IP1H                                       /* Interrupt Pending 1 High Byte    *
             -/
 986      =7  #define CANIP2L       CAN0IP2L                                       /* Interrupt Pending 2 Low Byte     *
             -/
 987      =7  #define CANIP2H       CAN0IP2H                                       /* Interrupt Pending 2 High Byte    *
             -/
 988      =7  #define CANMV1L       CAN0MV1L                                       /* Message Valid 1 Low Byte         *
             -/
 989      =7  #define CANMV1H       CAN0MV1H                                       /* Message Valid 1 High Byte        *
             -/
 990      =7  #define CANMV2L       CAN0MV2L                                       /* Message Valid 2 Low Byte         *
             -/
 991      =7  #define CANMV2H       CAN0MV2H                                       /* Message Valid 2 High Byte        *
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 222 

             -/
 992      =7  #define CANIF1CRL     CAN0IF1CRL                                     /* IF1 Command Request Low Byte     *
             -/
 993      =7  #define CANIF1CRH     CAN0IF1CRH                                     /* IF1 Command Request High Byte    *
             -/
 994      =7  #define CANIF1CML     CAN0IF1CML                                     /* IF1 Command Mask Low Byte        *
             -/
 995      =7  #define CANIF1CMH     CAN0IF1CMH                                     /* IF1 Command Mask High Byte       *
             -/
 996      =7  #define CANIF1M1L     CAN0IF1M1L                                     /* IF1 Mask 1 Low Byte              *
             -/
 997      =7  #define CANIF1M1H     CAN0IF1M1H                                     /* IF1 Mask 1 High Byte             *
             -/
 998      =7  #define CANIF1M2L     CAN0IF1M2L                                     /* IF1 Mask 2 Low Byte              *
             -/
 999      =7  #define CANIF1M2H     CAN0IF1M2H                                     /* IF1 Mask 2 High Byte             *
             -/
1000      =7  #define CANIF1A1L     CAN0IF1A1L                                     /* IF1 Arbitration 1 Low Byte       *
             -/
1001      =7  #define CANIF1A1H     CAN0IF1A1H                                     /* IF1 Arbitration 1 High Byte      *
             -/
1002      =7  #define CANIF1A2L     CAN0IF1A2L                                     /* IF1 Arbitration 2 Low Byte       *
             -/
1003      =7  #define CANIF1A2H     CAN0IF1A2H                                     /* IF1 Arbitration 2 High Byte      *
             -/
1004      =7  #define CANIF1MCL     CAN0IF1MCL                                     /* IF1 Message Control Low Byte     *
             -/
1005      =7  #define CANIF1MCH     CAN0IF1MCH                                     /* IF1 Message Control High Byte    *
             -/
1006      =7  #define CANIF1DA1L    CAN0IF1DA1L                                    /* IF1 Data A 1 Low Byte            *
             -/
1007      =7  #define CANIF1DA1H    CAN0IF1DA1H                                    /* IF1 Data A 1 High Byte           *
             -/
1008      =7  #define CANIF1DA2L    CAN0IF1DA2L                                    /* IF1 Data A 2 Low Byte            *
             -/
1009      =7  #define CANIF1DA2H    CAN0IF1DA2H                                    /* IF1 Data A 2 High Byte           *
             -/
1010      =7  #define CANIF1DB1L    CAN0IF1DB1L                                    /* IF1 Data B 1 Low Byte            *
             -/
1011      =7  #define CANIF1DB1H    CAN0IF1DB1H                                    /* IF1 Data B 1 High Byte           *
             -/
1012      =7  #define CANIF1DB2L    CAN0IF1DB2L                                    /* IF1 Data B 2 Low Byte            *
             -/
1013      =7  #define CANIF1DB2H    CAN0IF1DB2H                                    /* IF1 Data B 2 High Byte           *
             -/
1014      =7  #define CANIF2CRL     CAN0IF2CRL                                     /* IF2 Command Request Low Byte     *
             -/
1015      =7  #define CANIF2CRH     CAN0IF2CRH                                     /* IF2 Command Request High Byte    *
             -/
1016      =7  #define CANIF2CML     CAN0IF2CML                                     /* IF2 Command Mask Low Byte        *
             -/
1017      =7  #define CANIF2CMH     CAN0IF2CMH                                     /* IF2 Command Mask High Byte       *
             -/
1018      =7  #define CANIF2M1L     CAN0IF2M1L                                     /* IF2 Mask 1 Low Byte              *
             -/
1019      =7  #define CANIF2M1H     CAN0IF2M1H                                     /* IF2 Mask 1 High Byte             *
             -/
1020      =7  #define CANIF2M2L     CAN0IF2M2L                                     /* IF2 Mask 2 Low Byte              *
             -/
1021      =7  #define CANIF2M2H     CAN0IF2M2H                                     /* IF2 Mask 2 High Byte             *
             -/
1022      =7  #define CANIF2A1L     CAN0IF2A1L                                     /* IF2 Arbitration 1 Low Byte       *
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 223 

             -/
1023      =7  #define CANIF2A1H     CAN0IF2A1H                                     /* IF2 Arbitration 1 High Byte      *
             -/
1024      =7  #define CANIF2A2L     CAN0IF2A2L                                     /* IF2 Arbitration 2 Low Byte       *
             -/
1025      =7  #define CANIF2A2H     CAN0IF2A2H                                     /* IF2 Arbitration 2 High Byte      *
             -/
1026      =7  #define CANIF2MCL     CAN0IF2MCL                                     /* IF2 Message Control Low Byte     *
             -/
1027      =7  #define CANIF2MCH     CAN0IF2MCH                                     /* IF2 Message Control High Byte    *
             -/
1028      =7  #define CANIF2DA1L    CAN0IF2DA1L                                    /* IF2 Data A 1 Low Byte            *
             -/
1029      =7  #define CANIF2DA1H    CAN0IF2DA1H                                    /* IF2 Data A 1 High Byte           *
             -/
1030      =7  #define CANIF2DA2L    CAN0IF2DA2L                                    /* IF2 Data A 2 Low Byte            *
             -/
1031      =7  #define CANIF2DA2H    CAN0IF2DA2H                                    /* IF2 Data A 2 High Byte           *
             -/
1032      =7  #define CANIF2DB1L    CAN0IF2DB1L                                    /* IF2 Data B 1 Low Byte            *
             -/
1033      =7  #define CANIF2DB1H    CAN0IF2DB1H                                    /* IF2 Data B 1 High Byte           *
             -/
1034      =7  #define CANIF2DB2L    CAN0IF2DB2L                                    /* IF2 Data B 2 Low Byte            *
             -/
1035      =7  #define CANIF2DB2H    CAN0IF2DB2H                                    /* IF2 Data B 2 High Byte           *
             -/
1036      =7  #define CANCFG        CAN0CFG                                        /* CAN0 Clock Configuration         *
             -/
1037      =7  #endif
1038      =7  
1039      =7  
1040      =7  # if defined( C_ENABLE_VARIABLE_DLC )
           =7 /* mask to keep some bits unchanged in the DLC for use with variable DLC */
           =7 /*  - bit remaining unchanged should be masked with 1 e.g. id type or direction (difference between MK_TX_
             -DLC and MK_TX_DLC_EXT?) */
           =7 #define CanLL_DlcMask            0x00
           =7 #endif
1045      =7  
1046      =7  
1047      =7  
1048      =7  /* macros to set DLC and ID in rx-,tx-structures ---------------------------*/
1049      =7  /* MK... macros are used by the generation tool to fill the rx and tx structures */
1050      =7  /* In case the IDE bit is located in the ID registers, this bit has to be handled as must match.
1051      =7     In general, this is done by setting the IDE bit to 0 in the .._MASK_.. macros.
1052      =7  */
1053      =7  
1054      =7  #define MK_RX_RANGE_MASK_IDSTD0(id)     (MK_STDID0(id))
1055      =7  #define MK_RX_RANGE_MASK_IDSTD1(id)     (0)
1056      =7  /* macros with postfix 2-4 not used */
1057      =7  
1058      =7  #define MK_RX_RANGE_CODE_IDSTD0(id)     (MK_STDID0(id))
1059      =7  #define MK_RX_RANGE_CODE_IDSTD1(id)     (0)
1060      =7  /* macros with postfix 2-4 not used */
1061      =7  
1062      =7  #define MK_RX_RANGE_MASK_IDEXT0(id)     ((vuint16) ((((vuint32)(id) & 0xFFFF0000ul) >> 16) & 0x1FFFu))
1063      =7  #define MK_RX_RANGE_MASK_IDEXT1(id)     (MK_EXTID1(id))
1064      =7  /* macros with postfix 2-4 not used */
1065      =7  
1066      =7  #define MK_RX_RANGE_CODE_IDEXT0(id)     (MK_EXTID0(id))
1067      =7  #define MK_RX_RANGE_CODE_IDEXT1(id)     (MK_EXTID1(id))
1068      =7  /* macros with postfix 2-4 not used */
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 224 

1069      =7  
1070      =7  
1071      =7  
1072      =7  #define MK_STDID0(id)                   (((0x3FFF & (id)) << 2) & 0x1FFCu)
1073      =7  #define MK_STDID1(id)                   (0)
1074      =7  
1075      =7  
1076      =7  #define MK_EXTID0(id)                   ((vuint16) ((((vuint32) (id) & 0xFFFF0000ul) >> 16) & 0x1FFFu) | 0
             -x4000u)
1077      =7  #define MK_EXTID1(id)                   ((vuint16) (id))
1078      =7  
1079      =7  
1080      =7  
1081      =7  
1082      =7  /* Message Configuration Register:
1083      =7   * Example C16x:
1084      =7   * DLC3 DLC2 DLC1 DLC0 Dir Xtd 0 0
1085      =7   *                      |   |+------------- 0: standard ID; 1: exended ID
1086      =7   *                      +------------------ 0: receive    ; 1: transmit
1087      =7  */
1088      =7  #define C_RX_DIR             (0x0000)      
1089      =7  #define C_TX_DIR             (0x2000)
1090      =7  
1091      =7  #define MK_TX_DLC(dlc)       (dlc)
1092      =7  #define MK_TX_DLC_EXT(dlc)   (dlc)
1093      =7  
1094      =7  #define XT_TX_DLC(dlc)       ((dlc)&0xF)       /* return code has to be vuint8 */
1095      =7  
1096      =7  
1097      =7  # if defined( C_SINGLE_RECEIVE_CHANNEL )
1098      =7  /* Bus-Off functions */
1099      =7  #  define CanResetBusOffStart(a)  (CanInit(a))
1100      =7  #  define CanResetBusOffEnd(a)
1101      =7  
1102      =7  /* Bus-Sleep functions */
1103      =7  #  define CanResetBusSleep(a)     (CanInit(a))
1104      =7  # else
           =7 /* Bus-Off functions */
           =7 #  define CanResetBusOffStart(ch,a)  (CanInit((ch),(a)))
           =7 #  define CanResetBusOffEnd(ch,a)
           =7   
           =7 /* Bus-Sleep functions */
           =7 #  define CanResetBusSleep(ch,a)     (CanInit((ch),(a)))
           =7 # endif
1112      =7  
1113      =7  
1114      =7  /* The macros CanRxActualIdRawx() have to provide the register context of the ID registers.
1115      =7     It is not necessary to mask any bits. These macros are for internal use only and masking
1116      =7     will be done in can_hls.c
1117      =7  */
1118      =7  
1119      =7  #if defined( C_CPUTYPE_BIGENDIAN )
1120      =7  # if defined( C_ENABLE_EXTENDED_ID )
           =7 #  define CanRxActualIdRaw0(rxStruct)       (((vuint16) *((CanChipReg16Ptr) (rxStruct->pChipMsgObj    ))) 
             -& 0x5FFF)
           =7 #  define CanRxActualIdRaw1(rxStruct)       ( (vuint16) *((CanChipReg16Ptr) (rxStruct->pChipMsgObj + 2))) 
             -      
           =7 #  define CanRxActualIdRaw2(rxStruct)       0
           =7 #  define CanRxActualIdRaw3(rxStruct)       0
           =7 #  define CanRxActualIdRaw4(rxStruct)       0
           =7 # else
1127      =7  #  define CanRxActualIdRaw0(rxStruct)       ((vuint16) (*((CanChipReg16Ptr) (rxStruct->pChipMsgObj))) & 0x
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 225 

             -5FFC)
1128      =7  #  define CanRxActualIdRaw1(rxStruct)       0
1129      =7  #  define CanRxActualIdRaw2(rxStruct)       0
1130      =7  #  define CanRxActualIdRaw3(rxStruct)       0
1131      =7  #  define CanRxActualIdRaw4(rxStruct)       0
1132      =7  # endif
1133      =7  #endif
1134      =7  
1135      =7  
1136      =7  #if defined( C_CPUTYPE_BIGENDIAN )
1137      =7  /* Macros for CAN message access within ApplCanMsgReceived() or PreCopy() function */
1138      =7  # define CanRxActualStdId(rxStruct)         ((((vuint16) (*((CanChipReg16Ptr)((rxStruct)->pChipMsgObj)))) 
             ->> 2) & 0x7FFu)
1139      =7  # define CanRxActualExtId(rxStruct)         (((((vuint32)(*((CanChipReg16Ptr)((rxStruct)->pChipMsgObj))))<
             -<16) & 0x1FFFFFFFul) | (((vuint32)(*((CanChipReg16Ptr)((rxStruct)->pChipMsgObj+2)))) & 0x1FFFFFFFul))
1140      =7  # define CanRxActualData(rxStruct,i)        (((vuint8)   (*((CanChipRegPtr)((rxStruct)->pChipMsgObj + 6 + 
             -(i))))))
1141      =7  # define CanRxActualDLC(rxStruct)           (((vuint8)   (*((CanChipRegPtr)((rxStruct)->pChipMsgObj + 5)))
             -) & 0x000Fu)    
1142      =7  # define CanRxActualIdType(rxStruct)        (((vuint16)  (*((CanChipReg16Ptr)((rxStruct)->pChipMsgObj)))) 
             -& kCanIdTypeExt)
1143      =7  #endif
1144      =7  
1145      =7  #if defined( C_ENABLE_EXTENDED_ID )
           =7 # if defined( C_CPUTYPE_BIGENDIAN )
           =7 #  define CanRxActualIdExtHi(rxStruct)      (((vuint8)   (*((CanChipRegPtr)((rxStruct)->pChipMsgObj    )))
             -) & 0x1Fu)
           =7 #  define CanRxActualIdExtMidHi(rxStruct)   (((vuint8)   (*((CanChipRegPtr)((rxStruct)->pChipMsgObj + 1)))
             -)        )
           =7 #  define CanRxActualIdExtMidLo(rxStruct)   (((vuint8)   (*((CanChipRegPtr)((rxStruct)->pChipMsgObj + 2)))
             -)        )
           =7 #  define CanRxActualIdExtLo(rxStruct)      (((vuint8)   (*((CanChipRegPtr)((rxStruct)->pChipMsgObj + 3)))
             -)        )
           =7 # endif
           =7 #endif
1153      =7                                                  
1154      =7  
1155      =7  #if defined( C_CPUTYPE_BIGENDIAN )
1156      =7  # if !defined( C_COMP_KEIL_SLC8051_CCAN )
           =7 #  if defined( C_SINGLE_RECEIVE_CHANNEL )
           =7     #define CanRxActualErrorCounter()            (*(CanChipRegPtr)   (kCanBasisAdr + 4)) 
           =7     #define CanTxActualErrorCounter()            (*(CanChipRegPtr)   (kCanBasisAdr + 5)) 
           =7     #define CanBitTiming()                       (*(CanChipReg16Ptr) (kCanBasisAdr + 6))
           =7     #define CanBRP_Reg()                         (*(CanChipReg16Ptr) (kCanBasisAdr + 12)) 
           =7 #  else
           =7     #define CanRxActualErrorCounter(channel)     (*(CanChipRegPtr) (CanBasisAdr[channel] + 4))
           =7     #define CanTxActualErrorCounter(channel)     (*(CanChipRegPtr) (CanBasisAdr[channel] + 5))
           =7     #define CanBitTiming(channel)                (*(CanChipReg16Ptr) (CanBasisAdr[channel] + 6))
           =7     #define CanBRP_Reg(channel)                  (*(CanChipReg16Ptr) (CanBasisAdr[channel] + 12))
           =7 #  endif
           =7 # endif
1169      =7  #endif
1170      =7       
1171      =7  /* Macros for CAN message access within PreTransmit() function */
1172      =7  
1173      =7  
1174      =7  #if defined( C_CPUTYPE_BIGENDIAN )
1175      =7  # if defined( C_ENABLE_EXTENDED_ID )
           =7 #define CanTxWriteActExtId(txStruct,id)  { *((CanChipReg32Ptr) ((txStruct).pChipData - 6))  = ( (vuint32)(
             -id)       ) | 0xE0000000ul;}
           =7 #define CanTxWriteActId(txStruct,id)     { *((CanChipReg32Ptr) ((txStruct).pChipData - 6))  = ( (vuint32)(
             -id) << 18 ) | 0xA0000000ul;}  
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 226 

           =7 # else
1179      =7  #define CanTxWriteActId(txStruct,id)     { *((CanChipReg16Ptr) ((txStruct).pChipData - 6))  = ( (vuint16)(
             -id) <<  2 ) | 0xA000u;}                         
1180      =7  # endif
1181      =7  # define CanTxWriteActDLC(txStruct,dlc)  {*(((CanChipReg16Ptr) ((txStruct).pChipData)) - 1) = ( (*((CanChi
             -pReg16Ptr)((txStruct).pChipData - 1)) & 0xFFF0u) | (dlc) ); }                        
1182      =7  #endif
1183      =7  
1184      =7  
1185      =7  /* Macros to fill variables of the type tCanMsgTransmitStruct */
1186      =7  #define CanMsgTransmitSetStdId(pCanMsgTransmitStruct, id)                 { (pCanMsgTransmitStruct)->IdRaw
             -    = MK_STDID0(id); }
1187      =7  #define CanMsgTransmitSetExtId(pCanMsgTransmitStruct, id)                 { (pCanMsgTransmitStruct)->IdRaw
             -Ext = (vuint16)(MK_EXTID1(id)); \
1188      =7                                                                              (pCanMsgTransmitStruct)->IdRaw
             -    = (vuint16)(MK_EXTID0(id)); }
1189      =7  #define CanMsgTransmitSetDlc(pCanMsgTransmitStruct, dlc)                  { (pCanMsgTransmitStruct)->DlcRa
             -w   = MK_TX_DLC(dlc); }
1190      =7  #define CanMsgTransmitSetData(pCanMsgTransmitStruct, dataByte, msgData)   { (pCanMsgTransmitStruct)->DataF
             -ld[(dataByte)] = (msgData); }
1191      =7  
1192      =7  
1193      =7  
1194      =7  /* macros for buffer access */
1195      =7  #define StartRxReadSync()                 (VStdSuspendAllInterrupts())
1196      =7  #define EndRxReadSync()                   (VStdResumeAllInterrupts())
1197      =7  
1198      =7  #define StartRxWriteSync()                (VStdSuspendAllInterrupts())
1199      =7  #define EndRxWriteSync()                  (VStdResumeAllInterrupts())
1200      =7  
1201      =7  #define StartTxReadSync()
1202      =7  #define EndTxReadSync()
1203      =7  
1204      =7  #define StartTxWriteSync()                (VStdSuspendAllInterrupts())
1205      =7  #define EndTxWriteSync()                  (VStdResumeAllInterrupts())
1206      =7  
1207      =7  #define StartRxWriteCANSync() 
1208      =7  #define EndRxWriteCANSync()   
1209      =7  
1210      =7  #define StartRxReadCANSync()  
1211      =7  #define EndRxReadCANSync()    
1212      =7  
1213      =7  #define StartRxFullCANReadSync(Obj)       (VStdSuspendAllInterrupts())
1214      =7  #define EndRxFullCANReadSync(Obj)         (VStdResumeAllInterrupts())
1215      =7  
1216      =7  #define StartRxFullCANWriteSync(obj)      (VStdSuspendAllInterrupts())
1217      =7  #define EndRxFullCANWriteSync(obj)        (VStdResumeAllInterrupts())
1218      =7  
1219      =7  /* macros for flag access */
1220      =7  #define CanStartFlagWriteSync()
1221      =7  #define CanEndFlagWriteSync()
1222      =7  
1223      =7  
1224      =7  
1225      =7  /* KB end CanLL_MacrosH */
1226      =7  
1227      =7  
1228      =7  /* *********************************************************************** */
1229      =7  /* error codes                                                             */
1230      =7  /* *********************************************************************** */
1231      =7  /* error numbers for User Assertions 0x00-0x1f - hardware independed */
1232      =7  # define kErrorTxDlcTooLarge                     ((vuint8)0x01)
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 227 

1233      =7  # define kErrorTxHdlTooLarge                     ((vuint8)0x02)
1234      =7  # define kErrorIntRestoreTooOften                ((vuint8)0x03)
1235      =7  # define kErrorIntDisableTooOften                ((vuint8)0x04)
1236      =7  # define kErrorChannelHdlTooLarge                ((vuint8)0x05)
1237      =7  # define kErrorInitObjectHdlTooLarge             ((vuint8)0x06)
1238      =7  # define kErrorTxHwHdlTooLarge                   ((vuint8)0x07)
1239      =7  # define kErrorHwObjNotInPolling                 ((vuint8)0x08)
1240      =7  # define kErrorHwHdlTooSmall                     ((vuint8)0x09)
1241      =7  # define kErrorHwHdlTooLarge                     ((vuint8)0x0A)
1242      =7  
1243      =7  # define kErrorAccessedInvalidDynObj             ((vuint8)0x0B)
1244      =7  # define kErrorAccessedStatObjAsDyn              ((vuint8)0x0C)
1245      =7  # define kErrorDynObjReleased                    ((vuint8)0x0D)
1246      =7  
1247      =7  # define kErrorPollingTaskRecursion              ((vuint8)0x0E)
1248      =7  # define kErrorDisabledChannel                   ((vuint8)0x0F)
1249      =7  # define kErrorDisabledTxMessage                 ((vuint8)0x10)
1250      =7  # define kErrorDisabledCanInt                    ((vuint8)0x11)
1251      =7  
1252      =7  # define kErrorCanSleep                          ((vuint8)0x12)
1253      =7  # define kErrorCanOnline                         ((vuint8)0x13)
1254      =7  # define kErrorCanStop                           ((vuint8)0x14)
1255      =7  # define kErrorWrongMask                         ((vuint8)0x15)
1256      =7  # define kErrorWrongId                           ((vuint8)0x16)
1257      =7  # define kErrorNullPointerParameter              ((vuint8)0x17)
1258      =7  /* KB begin CanLL_ErrorCodesUserH */
1259      =7  /* error numbers for User Assertions 0x20-0x3f - hardware depended */
1260      =7  
1261      =7  /* KB end CanLL_ErrorCodesUserH */
1262      =7  
1263      =7  /* error numbers for Gentool Assertions 0x40-0x5f */
1264      =7  # define kErrorTxROMDLCTooLarge                  ((vuint8)0x40)
1265      =7  # define kErrorWrongHwTxObjHandle                ((vuint8)0x41)
1266      =7  # define kErrorHwToLogTxObjCalculation           ((vuint8)0x42)
1267      =7  
1268      =7  /* KB begin CanLL_ErrorCodesGentoolH */
1269      =7  /* error numbers for Gentool Assertions 0x60-0x7f - hardware depended */
1270      =7  # define kErrorToManyFullCanObjects              ((vuint8)0x63)
1271      =7  /* KB end CanLL_ErrorCodesGentoolH */
1272      =7  
1273      =7  /* error numbers for Hardware Assertions 0x80-0x9f */
1274      =7  # define kErrorTxBufferBusy                      ((vuint8)0x80)
1275      =7  
1276      =7  /* KB begin CanLL_ErrorCodesHardwareH */
1277      =7  /* error numbers for Hardware Assertions 0xa0-0xbf - hardware depended */
1278      =7  #define kErrorRxHwBufferBusy        0xa0
1279      =7  #define kErrorTxHwBufferBusy        0xa1
1280      =7  
1281      =7  /* KB end CanLL_ErrorCodesHardwareH */
1282      =7  
1283      =7  /* error numbers for Internal Assertions 0xc0-0xdf */
1284      =7  # define kErrorTxHandleWrong                     ((vuint8)0xC0)
1285      =7  # define kErrorInternalTxHdlTooLarge             ((vuint8)0xC1)
1286      =7  # define kErrorRxHandleWrong                     ((vuint8)0xC2)        
1287      =7  # define kErrorTxObjHandleWrong                  ((vuint8)0xC3)
1288      =7  # define kErrorReleasedUnusedDynObj              ((vuint8)0xC4)
1289      =7  # define kErrorTxQueueTooManyHandle              ((vuint8)0xC5)
1290      =7  # define kErrorInternalChannelHdlTooLarge        ((vuint8)0xC6)
1291      =7  # define kErrorInternalDisabledChannel           ((vuint8)0xC7)
1292      =7  # define kErrorInternalDisabledTxMessage         ((vuint8)0xC8)
1293      =7  
1294      =7  /* KB begin CanLL_ErrorCodesInternalH */
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 228 

1295      =7  /* error numbers for Internal Assertions 0xe0-0xff - hardware depended */
1296      =7  # define kErrorIllIrptNumber                     ((vuint8)0xe2)
1297      =7  # define kErrorStatNotInPolling                  ((vuint8)0xe3)
1298      =7  # define kErrorRxBasicNotInPolling               ((vuint8)0xe4)
1299      =7  # define kErrorRxFullNotInPolling                ((vuint8)0xe5)
1300      =7  # define kErrorTxNotInPolling                    ((vuint8)0xe6)
1301      =7  
1302      =7  /* KB end CanLL_ErrorCodesInternalH */
1303      =7  
1304      =7  /* *********************************************************************** */
1305      =7  /* DummyFunction                                                           */
1306      =7  /* *********************************************************************** */
1307      =7  # if defined( C_DRV_INTERNAL )
           =7 #  define CAN_RECEIVE_FCT_DUMMY                  ApplCanRxStructPtrDummy
           =7 #  define CAN_RANGE_FCT_DUMMY                    ApplCanRxStructPtrDummy
           =7 #  define CAN_BUSOFF_FCT_DUMMY                   ApplCanChannelDummy
           =7 #  if defined( C_HL_ENABLE_DUMMY_FCT_CALL )
           =7 #   define CAN_INDICATION_FCT_DUMMY              ApplCanRxHandleDummy
           =7 #   define CAN_PRECOPY_FCT_DUMMY                 ApplCanRxStructPtrDummy
           =7 #   define CAN_CONFIRMATION_FCT_DUMMY            ApplCanTxHandleDummy
           =7 #   define CAN_PRETRANSMIT_FCT_DUMMY             ApplCanTxStructDummy
           =7 #  else
           =7 #   define CAN_INDICATION_FCT_DUMMY              V_NULL
           =7 #   define CAN_PRECOPY_FCT_DUMMY                 V_NULL
           =7 #   define CAN_CONFIRMATION_FCT_DUMMY            V_NULL
           =7 #   define CAN_PRETRANSMIT_FCT_DUMMY             V_NULL
           =7 #  endif
           =7 # endif
1323      =7  
1324      =7  # if defined( C_NO_COMPATIBILITY )
           =7 # else
1326      =7  /* *********************************************************************** */
1327      =7  /* compatibility defines                                                   */
1328      =7  /* *********************************************************************** */
1329      =7  
1330      =7  #  define CAN_TX_DLC(i)                          (CanGetTxDlc(i))            
1331      =7  #  define CAN_TX_DATA_PTR(i)                     (CanGetTxDataPtr(i))         
1332      =7  #  define CAN_CONFIRMATION_OFFSET(i)             (CanGetConfirmationOffset(i))
1333      =7  #  define CAN_CONFIRMATION_MASK(i)               (CanGetConfirmationMask(i))
1334      =7  
1335      =7  #  define CAN_RX_DATA_LEN(i)                     (CanGetRxDataLen(i))
1336      =7  #  define CAN_RX_DATA_PTR(i)                     (CanGetRxDataPtr(i))
1337      =7  #  define CAN_INDICATION_OFFSET(i)               (CanGetIndicationOffset(i))
1338      =7  #  define CAN_INDICATION_MASK(i)                 (CanGetIndicationMask(i))
1339      =7  
1340      =7  #  define CanInterruptDisable()                  VStdSuspendAllInterrupts()
1341      =7  #  define CanInterruptRestore()                  VStdResumeAllInterrupts()
1342      =7  
1343      =7  #  define ApplCanReceiveDummy0                   ApplCanRxStructPtrDummy
1344      =7  #  define ApplCanReceiveDummy1                   ApplCanChannelDummy
1345      =7  
1346      =7  #  define CanGetTxDirectMsg                      (CanGetTxHwObj)
1347      =7  
1348      =7  #  define canRxDlcRam                            (canVariableRxDataLen)
1349      =7  
1350      =7  #  define CAN_START_INDEX_INIT_OBJ(i)            (CanInitObjectStartIndex[i])
1351      =7  #  define CAN_START_INDEX_TX_OBJ(i)              (CanTxStartIndex[i])
1352      =7  #  define CAN_START_INDEX_RX_OBJ(i)              (CanRxStartIndex[i])
1353      =7  
1354      =7  #  if !defined( VGEN_GENY )
           =7 #   if defined( C_ENABLE_RANGE_EXTENDED_ID )
           =7 #    define MK_RX_RANGE_MASK0(id)                (MK_RX_RANGE_MASK_IDEXT0(id))
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 229 

           =7 #    define MK_RX_RANGE_MASK1(id)                (MK_RX_RANGE_MASK_IDEXT1(id))
           =7 #    define MK_RX_RANGE_MASK2(id)                (MK_RX_RANGE_MASK_IDEXT2(id))
           =7 #    define MK_RX_RANGE_MASK3(id)                (MK_RX_RANGE_MASK_IDEXT3(id))
           =7 #    define MK_RX_RANGE_MASK4(id)                (MK_RX_RANGE_MASK_IDEXT4(id))
           =7 
           =7 #    define MK_RX_RANGE_CODE0(id)                (MK_RX_RANGE_CODE_IDEXT0(id))
           =7 #    define MK_RX_RANGE_CODE1(id)                (MK_RX_RANGE_CODE_IDEXT1(id))
           =7 #    define MK_RX_RANGE_CODE2(id)                (MK_RX_RANGE_CODE_IDEXT2(id))
           =7 #    define MK_RX_RANGE_CODE3(id)                (MK_RX_RANGE_CODE_IDEXT3(id))
           =7 #    define MK_RX_RANGE_CODE4(id)                (MK_RX_RANGE_CODE_IDEXT4(id))
           =7 #   else
           =7 #    define MK_RX_RANGE_MASK0(id)                (MK_RX_RANGE_MASK_IDSTD0(id))
           =7 #    define MK_RX_RANGE_MASK1(id)                (MK_RX_RANGE_MASK_IDSTD1(id))
           =7 #    define MK_RX_RANGE_MASK2(id)                (MK_RX_RANGE_MASK_IDSTD2(id))
           =7 #    define MK_RX_RANGE_MASK3(id)                (MK_RX_RANGE_MASK_IDSTD3(id))
           =7 #    define MK_RX_RANGE_MASK4(id)                (MK_RX_RANGE_MASK_IDSTD4(id))
           =7 
           =7 #    define MK_RX_RANGE_CODE0(id)                (MK_RX_RANGE_CODE_IDSTD0(id))
           =7 #    define MK_RX_RANGE_CODE1(id)                (MK_RX_RANGE_CODE_IDSTD1(id))
           =7 #    define MK_RX_RANGE_CODE2(id)                (MK_RX_RANGE_CODE_IDSTD2(id))
           =7 #    define MK_RX_RANGE_CODE3(id)                (MK_RX_RANGE_CODE_IDSTD3(id))
           =7 #    define MK_RX_RANGE_CODE4(id)                (MK_RX_RANGE_CODE_IDSTD4(id))
           =7 #   endif
           =7 #  endif
1381      =7  /* KB begin CanLL_CompatibilityDefinesH */
1382      =7  /* KB end CanLL_CompatibilityDefinesH */
1383      =7  
1384      =7  /* *********************************************************************** */
1385      =7  /* end of compatibility defines                                            */
1386      =7  /* *********************************************************************** */
1387      =7  # endif /* C_NO_COMPATIBILITY */
1388      =7  
1389      =7  /* *********************************************************************** */
1390      =7  /* Memory qualifier                                                        */
1391      =7  /* *********************************************************************** */
1392      =7  /* KB begin CanLL_MemoryQualifier */
1393      =7  /* memory qualifier for the CAN controller registers */
1394      =7  
1395      =7  
1396      =7  
1397      =7  
1398      =7  #if defined ( C_COMP_KEIL_SLC8051_CCAN )
1399      =7  
1400      =7  /* memory qualifier for the CAN contoller registers */
1401      =7  # define MEMORY_CAN
1402      =7  
1403      =7  /* memory qualifier for bit variables */
1404      =7  # define MEMORY_BIT
1405      =7  
1406      =7  #endif
1407      =7  /* KB end CanLL_MemoryQualifier */
1408      =7  
1409      =7  /* *********************************************************************** */
1410      =7  /* data types                                                              */
1411      =7  /* *********************************************************************** */
1412      =7  
1413      =7  /* KB begin CanHL_TxQueueDataTypesH */
1414      =7  /* declare data type for the queue */
1415      =7  #if defined( C_CPUTYPE_8BIT )
1416      =7  typedef vuint8  tCanQueueElementType;
1417      =7  #endif
1418      =7  
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 230 

1419      =7  #if !defined( tCanTxQueuePadBits )
1420      =7  # define tCanTxQueuePadBits vuint8
1421      =7  #endif
1422      =7  /* KB end CanHL_TxQueueDataTypesH */
1423      =7  /* KB begin CanLL_DataTypesH */
1424      =7  
1425      =7  /* ptr to msgObj & data on chip used in precopy function */
1426      =7  V_DEF_P2SFR_CAN_TYPE(volatile, vuint8)  CanChipDataPtr;
1427      =7  V_DEF_P2SFR_CAN_TYPE(volatile, vuint8)  CanChipMsgPtr;
1428      =7  V_DEF_P2SFR_CAN_TYPE(volatile, vuint8)  CanChipRegPtr;
1429      =7  
1430      =7  V_DEF_P2SFR_CAN_TYPE(volatile, vuint16)  CanChipReg16Ptr;
1431      =7  V_DEF_P2SFR_CAN_TYPE(volatile, vuint32)  CanChipReg32Ptr;
1432      =7  
1433      =7  V_DEF_P2VAR_TYPE(volatile, vuint8, INT_CTRL) CanIntCtrl8Ptr;
1434      =7  V_DEF_P2VAR_TYPE(volatile, vuint16, INT_CTRL) CanIntCtrl16Ptr;
1435      =7  
1436      =7  # if defined( C_LL_8BIT_CAN_ACCESS )
1437      =7  /* data types for driver function parameters */
1438      =7  /* the types of CanInitHandle, CanChannelHandle and CanObjectHandle depends
1439      =7     on the compiler and controller - what generates effective code */
1440      =7  typedef vuint8            CanInitHandle;
1441      =7  typedef vuint8            CanChannelHandle;
1442      =7  /* CanObjectHandle has to be unsigned! */
1443      =7  typedef vuint8            CanObjectHandle;
1444      =7  # else
           =7 /* data types for driver function parameters */
           =7 /* the types of CanInitHandle, CanChannelHandle and CanObjectHandle depends
           =7    on the compiler and controller - what generates effective code */
           =7 typedef vuint16           CanInitHandle;
           =7 typedef vuint16           CanChannelHandle;
           =7 /* CanObjectHandle has to be unsigned! */
           =7 typedef vuint16           CanObjectHandle;
           =7 #endif
1453      =7  
1454      =7  typedef vuint16           CanTransmitHandle;
1455      =7  typedef vuint16           CanReceiveHandle;
1456      =7  
1457      =7  /* define datatype of local signed variables for message handles */
1458      =7  
1459      =7  #if defined( C_CPUTYPE_8BIT ) && (kCanNumberOfTxObjects > 128)
           =7 typedef vsint16 CanSignedTxHandle;
           =7 #else
1462      =7  typedef vsintx CanSignedTxHandle;
1463      =7  #endif
1464      =7  
1465      =7  #if defined( C_CPUTYPE_8BIT ) && (kCanNumberOfRxObjects > 128)
           =7 typedef vsint16 CanSignedRxHandle;
           =7 #else
1468      =7  # if defined( C_CPUTYPE_8BIT ) && defined( C_SEARCH_HASH )
           =7 #  if (((kHashSearchListCountEx + kHashSearchListCountEx - 1) > 128) ||\
           =7        ((kHashSearchListCount   + kHashSearchListCount   - 1) > 128) )
           =7 typedef vsint16 CanSignedRxHandle;
           =7 #  else
           =7 typedef vsintx CanSignedRxHandle;
           =7 #  endif
           =7 # else
1476      =7  typedef vsintx CanSignedRxHandle;
1477      =7  # endif
1478      =7  #endif
1479      =7  
1480      =7  /* up to 5 tables can be defined for the transmission ID. The type and how 
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 231 

1481      =7     many tables are needed depends on the CPU bus type and on the ID registers 
1482      =7     of the CAN controller. E.g. a CPU with a 16-Bit bus and 2 byte ID registers 
1483      =7     for standard ID needs 1 table and tCanRxId0 of type vuint16. The same CPU
1484      =7     with 5 byte ID registers for extended ID needs in this case 3 tables and
1485      =7     tCanRxId0 = vuint16, tCanRxId1 = vuint16 and tCanRxId2 = vuint16. */
1486      =7  typedef vuint16         tCanTxId0;
1487      =7  #if defined( C_ENABLE_EXTENDED_ID )
           =7 typedef vuint16         tCanTxId1;
           =7 #endif
1490      =7  
1491      =7  /* unused by this driver: 
1492      =7  typedef vuint8          tCanTxId2;
1493      =7  typedef vuint8          tCanTxId3;
1494      =7  typedef vuint8          tCanTxId4;
1495      =7  */
1496      =7  
1497      =7  /* type of variable for ID type kCanIdTypeExt or kCanIdTypeStd will be assigned to 
1498      =7     a variable of this type */
1499      =7  typedef vuint16          tCanIdType;
1500      =7  
1501      =7  /* up to 3 tables can be defined for the reception ID. The type and how many
1502      =7     tables are needed depends on the CPU bus type and on the ID registers of
1503      =7     the CAN controller. E.g. a CPU with a 16-Bit bus and 2 byte ID registers 
1504      =7     for standard ID needs 1 table and tCanRxId0 of type vuint16. The same CPU
1505      =7     with 5 byte ID registers for extended ID needs in this case 3 tables and 
1506      =7     tCanRxId0 = vuint16, tCanRxId1 = vuint16 and tCanRxId2 = vuint16. */
1507      =7  
1508      =7  typedef vuint16          tCanRxId0;
1509      =7  
1510      =7  #if defined( C_ENABLE_EXTENDED_ID )
           =7 typedef vuint16          tCanRxId1;
           =7 #endif
1513      =7  
1514      =7  /* unused by this driver: 
1515      =7  typedef vuint16          tCanRxId2;
1516      =7  typedef vuint16          tCanRxId3;
1517      =7  typedef vuint16          tCanRxId4;
1518      =7  */
1519      =7  
1520      =7  
1521      =7  /* type of the variable, in which the old status of the interrupt flag or
1522      =7     level is stored */
1523      =7  #if defined( C_COMP_KEIL_SLC8051_CCAN )
1524      =7  typedef unsigned char  tCanHLIntOld;
1525      =7  /* this type could also be a struct if more than one variable is necessary */
1526      =7  typedef unsigned char  tCanLLCanIntOld;
1527      =7  #endif
1528      =7  
1529      =7  
1530      =7  
1531      =7  
1532      =7  
1533      =7  
1534      =7  
1535      =7  /* stucture of the CAN message object used by CanMsgTransmit() and RxQueue */
1536      =7  
1537      =7  #if defined( C_CPUTYPE_BIGENDIAN )
1538      =7  typedef struct
1539      =7  {
1540      =7    vuint16     IdRaw;        
1541      =7    vuint16     IdRawExt;
1542      =7    vuint8      reserved;
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 232 

1543      =7    vuint8      DlcRaw;
1544      =7    vuint8      DataFld[8];
1545      =7  } tCanMsgTransmitStruct;
1546      =7  #endif
1547      =7  
1548      =7  
1549      =7  /* Type of Buffer for txMsgObj */
1550      =7  typedef volatile struct
1551      =7  {
1552      =7    union {                        /* Identifier                 */
1553      =7      vuint8   id[4];              /* address Id as  8 Bit       */
1554      =7      vuint16  Id[2];              /* address Id as 16 Bit       */
1555      =7      vuint32  ulId;               /* address Id as 32 Bit       */
1556      =7    } Id;
1557      =7  
1558      =7    vuint16    Dlc;                /* Message Control Register   */
1559      =7  
1560      =7    union {                        /* 8 Byte Data                */
1561      =7      vuint8   ucData[8];          /* address Data as  8 Bit     */
1562      =7      vuint16  uiData[4];          /* address Data as 16 Bit     */
1563      =7    } Data;
1564      =7  
1565      =7  } tTxMsgObj;
1566      =7  
1567      =7  /* Type of Buffer for rxMsgObj */
1568      =7  typedef volatile struct
1569      =7  {
1570      =7    union {                        /* Identifier                 */
1571      =7      vuint16  Id[2];              /* address Id as 16 Bit       */
1572      =7      vuint32  ulId;               /* address Id as 32 Bit       */
1573      =7    } Id;
1574      =7  
1575      =7    vuint16  Dlc;                  /* Message Control Register   */
1576      =7    vuint16  Data[4];              /* Data                       */
1577      =7    vuint16  MessageCntrl;         /* Status of Rx-Object        */
1578      =7  
1579      =7  } tRxMsgObj;
1580      =7  /* KB end CanLL_DataTypesH */
1581      =7  
1582      =7  typedef struct 
1583      =7  {
1584      =7    CanChipDataPtr     pChipData;
1585      =7    CanTransmitHandle  Handle;
1586      =7  /* CPU-specific part */
1587      =7    /* KB begin CanLL_tCanTxInfoStruct */
1588      =7    /* KB end CanLL_tCanTxInfoStruct */
1589      =7  } tCanTxInfoStruct;
1590      =7  
1591      =7  /* ##RI-1.10 Common Callbackfunction in TxInterrupt */
1592      =7  typedef struct 
1593      =7  {
1594      =7    CanChannelHandle   Channel;
1595      =7    CanTransmitHandle  Handle;
1596      =7  /* CPU-specific part */
1597      =7    /* KB begin CanLL_tCanTxConfInfoStruct */
1598      =7    CanChipMsgPtr     pChipMsgObj;
1599      =7    CanChipDataPtr    pChipData;
1600      =7    /* KB end CanLL_tCanTxConfInfoStruct */
1601      =7  } tCanTxConfInfoStruct;
1602      =7  
1603      =7  typedef struct 
1604      =7  {
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 233 

1605      =7    CanChannelHandle  Channel;
1606      =7    CanChipMsgPtr     pChipMsgObj;
1607      =7    CanChipDataPtr    pChipData;
1608      =7    CanReceiveHandle  Handle;
1609      =7  /* CPU-specific part */
1610      =7    /* KB begin CanLL_tCanRxInfoStruct */
1611      =7    /* KB end CanLL_tCanRxInfoStruct */
1612      =7  } tCanRxInfoStruct;
1613      =7  
1614      =7  typedef tCanRxInfoStruct          *CanRxInfoStructPtr;
1615      =7  typedef tCanTxInfoStruct          CanTxInfoStruct;
1616      =7  /* ##RI-1.10 Common Callbackfunction in TxInterrupt */
1617      =7  typedef tCanTxConfInfoStruct      *CanTxInfoStructPtr;
1618      =7  
1619      =7  /* types of application functions called by driver --------------------------- */
1620      =7  typedef C_CALLBACK_1 vuint8   (C_CALLBACK_2 *ApplCanMsgRcvFct)    (CanRxInfoStructPtr rxStruct);
1621      =7  typedef C_CALLBACK_1 vuint8   (C_CALLBACK_2 *ApplRangeFct)        (CanRxInfoStructPtr rxStruct);
1622      =7  typedef C_CALLBACK_1 vuint8   (C_CALLBACK_2 *ApplPrecopyFct)      (CanRxInfoStructPtr rxStruct);
1623      =7  typedef C_CALLBACK_1 void     (C_CALLBACK_2 *ApplIndicationFct)   (CanReceiveHandle rxObject);
1624      =7  typedef C_CALLBACK_1 void     (C_CALLBACK_2 *ApplConfirmationFct) (CanTransmitHandle txObject);
1625      =7  typedef C_CALLBACK_1 vuint8   (C_CALLBACK_2 *ApplPreTransmitFct)  (CanTxInfoStruct txStruct);
1626      =7  typedef C_CALLBACK_1 void     (C_CALLBACK_2 *ApplChannelFct)      (CAN_CHANNEL_CANTYPE_ONLY);
1627      =7  
1628      =7  typedef struct
1629      =7  {
1630      =7    tCanRxId0           Id0;
1631      =7  # if (kCanNumberOfUsedCanRxIdTables > 1)
           =7   tCanRxId1           Id1;
           =7 # endif
1634      =7  # if (kCanNumberOfUsedCanRxIdTables > 2)
           =7   tCanRxId2           Id2;
           =7 # endif     
1637      =7  # if (kCanNumberOfUsedCanRxIdTables > 3)
           =7   tCanRxId3           Id3;
           =7 # endif
1640      =7  # if (kCanNumberOfUsedCanRxIdTables > 4)
           =7   tCanRxId4           Id4;
           =7 # endif
1643      =7  } tCanStructRxIdType;
1644      =7  
1645      =7  # if defined( C_DRV_INTERNAL )
           =7 typedef struct
           =7 {
           =7   ApplChannelFct      ApplCanWakeUpFct; 
           =7   ApplCanMsgRcvFct    ApplCanMsgReceivedFct;
           =7   ApplRangeFct        ApplCanRangeFct[4];
           =7   ApplChannelFct      ApplCanBusOffFct;
           =7   ApplConfirmationFct ApplCanCancelNotificationFct;
           =7   ApplChannelFct      ApplCanMsgTransmitCancelNotifyFct;
           =7   tCanStructRxIdType  RangeMask[4];
           =7   tCanStructRxIdType  RangeCode[4];
           =7   vuint16             RangeActiveFlag;
           =7   tCanIdType          RangeIdType[4];
           =7 } tCanChannelObject;
           =7 # endif
1660      =7  
1661      =7  
1662      =7  /* datatypes for indication and confirmation flags */
1663      =7  # if defined( C_ENABLE_CONFIRMATION_FLAG )
           =7 union CanConfirmationBits                                 
           =7 {    /* PRQA S 0750 */
           =7   vuint8         _c[kCanNumberOfConfBytes];
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 234 

           =7 #  if defined( V_CPUTYPE_BITARRAY_32BIT )
           =7 #   if kCanNumberOfConfFlags > 16
           =7   struct _c_bits32 w[kCanNumberOfConfDWords];
           =7 #   elif kCanNumberOfConfFlags > 8
           =7   struct _c_bits16 w[kCanNumberOfConfWords];
           =7 #   else
           =7   struct _c_bits8  w[1];
           =7 #   endif
           =7 #  else
           =7 #   if kCanNumberOfConfFlags > 8
           =7   struct _c_bits16 w[kCanNumberOfConfWords];
           =7 #   else
           =7   struct _c_bits8  w[1];
           =7 #   endif
           =7 #  endif
           =7 }; 
           =7 # endif
1684      =7  
1685      =7  
1686      =7  # if defined( C_ENABLE_INDICATION_FLAG )
           =7 union CanIndicationBits                                  
           =7 {    /* PRQA S 0750 */
           =7   vuint8         _c[kCanNumberOfIndBytes];
           =7 #  if defined( V_CPUTYPE_BITARRAY_32BIT )
           =7 #   if kCanNumberOfIndFlags > 16
           =7   struct _c_bits32 w[kCanNumberOfIndDWords];
           =7 #   elif kCanNumberOfIndFlags > 8
           =7   struct _c_bits16 w[kCanNumberOfIndWords];
           =7 #   else
           =7   struct _c_bits8  w[1];
           =7 #   endif
           =7 #  else
           =7 #   if kCanNumberOfIndFlags > 8
           =7   struct _c_bits16 w[kCanNumberOfIndWords];
           =7 #   else
           =7   struct _c_bits8 w[1];
           =7 #   endif
           =7 #  endif
           =7 };
           =7 # endif
1707      =7  
1708      =7  
1709      =7  
1710      =7  /* *********************************************************************** */
1711      =7  /* External Declarations                                                   */
1712      =7  /* *********************************************************************** */
1713      =7  
1714      =7  /*  CAN driver version */
1715      =7  /* ROM CATEGORY 4 START */
1716      =7  V_MEMROM0 extern V_MEMROM1 vuint8 V_MEMROM2 kCanMainVersion;
1717      =7  V_MEMROM0 extern V_MEMROM1 vuint8 V_MEMROM2 kCanSubVersion;
1718      =7  V_MEMROM0 extern V_MEMROM1 vuint8 V_MEMROM2 kCanBugFixVersion;
1719      =7  /* ROM CATEGORY 4 END */
1720      =7  
1721      =7  
1722      =7  
1723      =7  # if defined( C_ENABLE_PRECOPY_FCT )
1724      =7  /* RAM CATEGORY 1 START */
1725      =7  extern volatile CanReceiveHandle canRxHandle[kCanNumberOfChannels];
1726      =7  /* RAM CATEGORY 1 END */
1727      =7  # endif
1728      =7  
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 235 

1729      =7  # if defined( C_ENABLE_CONFIRMATION_FLAG )
           =7 /* RAM CATEGORY 1 START */
           =7 V_MEMRAM0 extern volatile V_MEMRAM1_NEAR union CanConfirmationBits V_MEMRAM2_NEAR CanConfirmationFlags;   
             -           /* PRQA S 0759 */
           =7 /* RAM CATEGORY 1 END */
           =7 # endif
1734      =7  
1735      =7  # if defined( C_ENABLE_INDICATION_FLAG )
           =7 /* RAM CATEGORY 1 START */
           =7 V_MEMRAM0 extern volatile V_MEMRAM1_NEAR union CanIndicationBits   V_MEMRAM2_NEAR CanIndicationFlags;     
             -           /* PRQA S 0759 */
           =7 /* RAM CATEGORY 1 END */
           =7 # endif
1740      =7  
1741      =7  
1742      =7  # if defined( C_ENABLE_CONFIRMATION_FCT ) && \
1743      =7      defined( C_ENABLE_DYN_TX_OBJECTS )  && \
1744      =7      defined( C_ENABLE_TRANSMIT_QUEUE )
           =7 /* RAM CATEGORY 3 START */
           =7 extern CanTransmitHandle          confirmHandle[kCanNumberOfChannels];
           =7 /* RAM CATEGORY 3 END */
           =7 # endif
1749      =7  
1750      =7  /* ##RI1.4 - 3.31: Dynamic Receive DLC */
1751      =7  # if defined( C_ENABLE_VARIABLE_RX_DATALEN )
           =7 #  if ( kCanNumberOfRxObjects > 0 )
           =7 /* RAM CATEGORY 1 START */
           =7 extern volatile vuint8 canVariableRxDataLen[kCanNumberOfRxObjects];
           =7 /* RAM CATEGORY 1 END */
           =7 #  endif
           =7 # endif
1758      =7  
1759      =7  /* RAM CATEGORY 1 START */
1760      =7  extern CanChipDataPtr canRDSRxPtr[kCanNumberOfChannels];
1761      =7  /* RAM CATEGORY 1 END */
1762      =7  /* RAM CATEGORY 1 START */
1763      =7  extern CanChipDataPtr canRDSTxPtr[kCanNumberOfUsedTxCANObjects];
1764      =7  /* RAM CATEGORY 1 END */
1765      =7  
1766      =7  
1767      =7  
1768      =7  /* KB begin CanLL_ExternDeclarationH */
1769      =7  /* KB end CanLL_ExternDeclarationH */
1770      =7  
1771      =7  /* *********************************************************************** */
1772      =7  /* Data structures filled with data by parameter generating tool           */
1773      =7  /* *********************************************************************** */
1774      =7  
1775      =7  # if defined( C_DRV_INTERNAL )
           =7 /* structures for init and common objects ----------------------- */
           =7 #  if defined( C_SINGLE_RECEIVE_CHANNEL )
           =7 #  else
           =7 /* ROM CATEGORY 1 START */
           =7 V_MEMROM0 extern V_MEMROM1 tCanChannelObject   V_MEMROM2 CanChannelObject[kCanNumberOfChannels];
           =7 /* ROM CATEGORY 1 END */
           =7 /* ROM CATEGORY 4 START */
           =7 V_MEMROM0 extern V_MEMROM1 vuint8              V_MEMROM2 CanInitObjectStartIndex[kCanNumberOfChannels+1];
           =7 /* ROM CATEGORY 4 END */
           =7 /* ROM CATEGORY 1 START */
           =7 V_MEMROM0 extern V_MEMROM1 CanTransmitHandle   V_MEMROM2 CanTxDynRomStartIndex[kCanNumberOfChannels];
           =7 /* ROM CATEGORY 1 END */
           =7 /* ROM CATEGORY 1 START */
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 236 

           =7 V_MEMROM0 extern V_MEMROM1 CanTransmitHandle   V_MEMROM2 CanTxDynRamStartIndex[kCanNumberOfChannels+1];
           =7 /* ROM CATEGORY 1 END */
           =7 /* ROM CATEGORY 1 START */
           =7 V_MEMROM0 extern V_MEMROM1 CanReceiveHandle    V_MEMROM2 CanRxBasicStartIndex[kCanNumberOfChannels+1];
           =7 /* ROM CATEGORY 1 END */
           =7 /* ROM CATEGORY 1 START */
           =7 V_MEMROM0 extern V_MEMROM1 CanReceiveHandle    V_MEMROM2 CanRxFullStartIndex[kCanNumberOfHwChannels+1];
           =7 /* ROM CATEGORY 1 END */
           =7 /* ROM CATEGORY 2 START */
           =7 V_MEMROM0 extern V_MEMROM1 CanObjectHandle     V_MEMROM2 CanLogHwTxStartIndex[kCanNumberOfHwChannels+1];
           =7 /* ROM CATEGORY 2 END */
           =7 
           =7 /* ROM CATEGORY 2 START */
           =7 V_MEMROM0 extern V_MEMROM1 CanObjectHandle     V_MEMROM2 CanHwTxStartIndex[kCanNumberOfHwChannels];
           =7 /* ROM CATEGORY 2 END */
           =7 /* ROM CATEGORY 1 START */
           =7 V_MEMROM0 extern V_MEMROM1 CanObjectHandle     V_MEMROM2 CanHwRxFullStartIndex[kCanNumberOfHwChannels];
           =7 /* ROM CATEGORY 1 END */
           =7 /* ROM CATEGORY 1 START */
           =7 V_MEMROM0 extern V_MEMROM1 CanObjectHandle     V_MEMROM2 CanHwRxBasicStartIndex[kCanNumberOfHwChannels];
           =7 /* ROM CATEGORY 1 END */
           =7 /* ROM CATEGORY 4 START */
           =7 V_MEMROM0 extern V_MEMROM1 CanObjectHandle     V_MEMROM2 CanHwUnusedStartIndex[kCanNumberOfHwChannels];
           =7 /* ROM CATEGORY 4 END */
           =7 /* ROM CATEGORY 2 START */
           =7 V_MEMROM0 extern V_MEMROM1 CanObjectHandle     V_MEMROM2 CanHwTxStopIndex[kCanNumberOfHwChannels];
           =7 /* ROM CATEGORY 2 END */
           =7 /* ROM CATEGORY 1 START */
           =7 V_MEMROM0 extern V_MEMROM1 CanObjectHandle     V_MEMROM2 CanHwRxFullStopIndex[kCanNumberOfHwChannels];
           =7 /* ROM CATEGORY 1 END */
           =7 /* ROM CATEGORY 1 START */
           =7 V_MEMROM0 extern V_MEMROM1 CanObjectHandle     V_MEMROM2 CanHwRxBasicStopIndex[kCanNumberOfHwChannels];
           =7 /* ROM CATEGORY 1 END */
           =7 /* ROM CATEGORY 4 START */
           =7 V_MEMROM0 extern V_MEMROM1 CanObjectHandle     V_MEMROM2 CanHwUnusedStopIndex[kCanNumberOfHwChannels];
           =7 /* ROM CATEGORY 4 END */
           =7 
           =7 /* ROM CATEGORY 1 START */
           =7 V_MEMROM0 extern V_MEMROM1 CanObjectHandle     V_MEMROM2 CanHwMsgTransmitIndex[kCanNumberOfHwChannels];
           =7 /* ROM CATEGORY 1 END */
           =7 /* ROM CATEGORY 1 START */
           =7 V_MEMROM0 extern V_MEMROM1 CanObjectHandle     V_MEMROM2 CanHwTxNormalIndex[kCanNumberOfHwChannels];
           =7 /* ROM CATEGORY 1 END */
           =7 /* ROM CATEGORY 1 START */
           =7 V_MEMROM0 extern V_MEMROM1 vsintx              V_MEMROM2 CanTxOffsetHwToLog[kCanNumberOfHwChannels];
           =7 /* ROM CATEGORY 1 END */
           =7 
           =7 
           =7 #  endif  /* C_SINGLE_RECEIVE_CHANNEL */
           =7 
           =7 
           =7 
           =7 
           =7 
           =7 # endif /* C_DRV_INTERNAL */
1844      =7  
1845      =7  # if defined( C_SINGLE_RECEIVE_CHANNEL )
1846      =7  # else
           =7 /* ROM CATEGORY 1 START */
           =7 V_MEMROM0 extern V_MEMROM1 CanTransmitHandle   V_MEMROM2 CanTxStartIndex[kCanNumberOfChannels+1];
           =7 /* ROM CATEGORY 1 END */ 
           =7 /* ROM CATEGORY 2 START */ 
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 237 

           =7 V_MEMROM0 extern V_MEMROM1 CanReceiveHandle    V_MEMROM2 CanRxStartIndex[kCanNumberOfChannels+1];
           =7 /* ROM CATEGORY 2 END */
           =7 # endif
1854      =7  
1855      =7  /* ROM generated */
1856      =7  
1857      =7  # if ( kCanNumberOfTxObjects > 0 )
1858      =7  #   if defined( C_DRV_INTERNAL )
           =7 /* structures for transmit objects ----------------------- */
           =7 /* ROM CATEGORY 1 START */ 
           =7 V_MEMROM0 extern V_MEMROM1 tCanTxId0 V_MEMROM2       CanTxId0[kCanNumberOfTxObjects];  
           =7 #    if (kCanNumberOfUsedCanTxIdTables > 1)
           =7 V_MEMROM0 extern V_MEMROM1 tCanTxId1 V_MEMROM2       CanTxId1[kCanNumberOfTxObjects];  
           =7 #    endif
           =7 #    if (kCanNumberOfUsedCanTxIdTables > 2)
           =7 V_MEMROM0 extern V_MEMROM1 tCanTxId2 V_MEMROM2       CanTxId2[kCanNumberOfTxObjects];  
           =7 #    endif
           =7 #    if (kCanNumberOfUsedCanTxIdTables > 3)
           =7 V_MEMROM0 extern V_MEMROM1 tCanTxId3 V_MEMROM2       CanTxId3[kCanNumberOfTxObjects];  
           =7 #    endif
           =7 #    if (kCanNumberOfUsedCanTxIdTables > 4)
           =7 V_MEMROM0 extern V_MEMROM1 tCanTxId4 V_MEMROM2       CanTxId4[kCanNumberOfTxObjects];  
           =7 #    endif
           =7 
           =7 #    if defined( C_ENABLE_MIXED_ID )
           =7 #    endif
           =7 /* ROM CATEGORY 1 END */
           =7 #   endif /* C_DRV_INTERNAL */
1879      =7  
1880      =7  /* ROM CATEGORY 2 START */
1881      =7  #   if defined( C_ENABLE_PART_OFFLINE )
1882      =7  V_MEMROM0 extern V_MEMROM1 vuint8 V_MEMROM2          CanTxSendMask[kCanNumberOfTxObjects];
1883      =7  #   endif
1884      =7  /* ROM CATEGORY 2 END */
1885      =7  
1886      =7  /* ROM CATEGORY 1 START */
1887      =7  V_MEMROM0 extern V_MEMROM1 vuint8 V_MEMROM2          CanTxDLC[kCanNumberOfTxObjects];
1888      =7  V_MEMROM0 extern V_MEMROM1 TxDataPtr V_MEMROM2       CanTxDataPtr[kCanNumberOfTxObjects];
1889      =7  
1890      =7  #   if defined( C_ENABLE_CONFIRMATION_FLAG )
           =7 V_MEMROM0 extern V_MEMROM1 vuint8 V_MEMROM2          CanConfirmationOffset[kCanNumberOfTxObjects];
           =7 V_MEMROM0 extern V_MEMROM1 vuint8 V_MEMROM2          CanConfirmationMask[kCanNumberOfTxObjects];
           =7 #   endif
1894      =7  #   if defined( C_ENABLE_CONFIRMATION_FCT )
1895      =7  V_MEMROM0 extern V_MEMROM1 ApplConfirmationFct V_MEMROM2 CanTxApplConfirmationPtr[kCanNumberOfTxObjects];
1896      =7  #   endif
1897      =7  #   if defined( C_ENABLE_PRETRANSMIT_FCT )
           =7 V_MEMROM0 extern V_MEMROM1 ApplPreTransmitFct  V_MEMROM2 CanTxApplPreTransmitPtr[kCanNumberOfTxObjects];
           =7 #   endif
1900      =7  /* ROM CATEGORY 1 END */
1901      =7  
1902      =7  #   if defined( C_ENABLE_TX_FULLCAN_OBJECTS )
1903      =7  /* ROM CATEGORY 2 START */
1904      =7  V_MEMROM0 extern V_MEMROM1 vuint8 V_MEMROM2          CanTxHwObj[kCanNumberOfTxObjects];
1905      =7  /* ROM CATEGORY 2 END */
1906      =7  #   endif
1907      =7  
1908      =7  #   if defined( C_SINGLE_RECEIVE_CHANNEL )
1909      =7  #   else
           =7 #    if ( kCanNumberOfTxObjects > 0 )
           =7 /* ROM CATEGORY 2 START */
           =7 V_MEMROM0 extern V_MEMROM1 CanChannelHandle    V_MEMROM2 CanTxMsgHandleToChannel[kCanNumberOfTxObjects];
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 238 

           =7 /* ROM CATEGORY 2 END */
           =7 #    endif
           =7 #   endif /* C_SINGLE_RECEIVE_CHANNEL */ 
1916      =7  
1917      =7  #   if defined( C_ENABLE_MULTI_ECU_PHYS )
           =7 /* ROM CATEGORY 4 START */
           =7 V_MEMROM0 extern V_MEMROM1 tVIdentityMsk V_MEMROM2      CanTxIdentityAssignment[kCanNumberOfTxObjects];
           =7 /* ROM CATEGORY 4 END */
           =7 #   endif
1922      =7  
1923      =7  
1924      =7  #  if defined( C_ENABLE_TRANSMIT_QUEUE )
1925      =7  /* KB begin CanHL_TxQueueGeneratedStructureH */
1926      =7  #if defined( C_MULTIPLE_RECEIVE_CHANNEL )
           =7 /* ROM CATEGORY 1 START */
           =7 /* pad bits added before the current channel position */
           =7 V_MEMROM0 extern  V_MEMROM1 tCanTxQueuePadBits V_MEMROM2 CanTxQueuePadBits[kCanNumberOfChannels];
           =7 
           =7 /* start / stop indices for the element search */
           =7 V_MEMROM0 extern V_MEMROM1 CanSignedTxHandle V_MEMROM2 CanTxQueueStartIndex[kCanNumberOfChannels + 1];
           =7 /* ROM CATEGORY 1 END */
           =7 #endif
1935      =7  /* KB end CanHL_TxQueueGeneratedStructureH */
1936      =7  #  endif
1937      =7  
1938      =7  # endif /* ( kCanNumberOfTxObjects > 0 ) */
1939      =7  
1940      =7  /* structures for basic and full can receive objects ----------------------- */
1941      =7  
1942      =7  # if ( kCanNumberOfRxObjects > 0 )
1943      =7  #  if defined( C_DRV_INTERNAL )
           =7 /* ROM CATEGORY 1 START */
           =7 #   if defined( C_SEARCH_HASH ) 
           =7 #    if defined( C_ENABLE_RX_FULLCAN_OBJECTS )
           =7 V_MEMROM0 extern V_MEMROM1 tCanRxId0 V_MEMROM2       CanRxId0[kCanNumberOfRxFullCANObjects];  
           =7 #     if (kCanNumberOfUsedCanRxIdTables > 1)
           =7 V_MEMROM0 extern V_MEMROM1 tCanRxId1 V_MEMROM2       CanRxId1[kCanNumberOfRxFullCANObjects];  
           =7 #     endif
           =7 #     if (kCanNumberOfUsedCanRxIdTables > 2)
           =7 V_MEMROM0 extern V_MEMROM1 tCanRxId2 V_MEMROM2       CanRxId2[kCanNumberOfRxFullCANObjects];  
           =7 #     endif
           =7 #     if (kCanNumberOfUsedCanRxIdTables > 3)
           =7 V_MEMROM0 extern V_MEMROM1 tCanRxId3 V_MEMROM2       CanRxId3[kCanNumberOfRxFullCANObjects];  
           =7 #     endif
           =7 #     if (kCanNumberOfUsedCanRxIdTables > 4)
           =7 V_MEMROM0 extern V_MEMROM1 tCanRxId4 V_MEMROM2       CanRxId4[kCanNumberOfRxFullCANObjects];  
           =7 #     endif
           =7 
           =7 #     if defined( C_ENABLE_MIXED_ID )
           =7 #      if defined( C_HL_ENABLE_IDTYPE_IN_ID )
           =7 #      else
           =7 V_MEMROM0 extern V_MEMROM1 tCanIdType V_MEMROM2      CanRxIdType[kCanNumberOfRxFullCANObjects];
           =7 #      endif
           =7 #     endif
           =7 #    endif /* C_ENABLE_RX_FULLCAN_OBJECTS */
           =7 #   else   /* C_SEARCH_HASH */
           =7 V_MEMROM0 extern V_MEMROM1 tCanRxId0 V_MEMROM2       CanRxId0[kCanNumberOfRxObjects];  
           =7 #    if (kCanNumberOfUsedCanRxIdTables > 1)
           =7 V_MEMROM0 extern V_MEMROM1 tCanRxId1 V_MEMROM2       CanRxId1[kCanNumberOfRxObjects];  
           =7 #    endif
           =7 #    if (kCanNumberOfUsedCanRxIdTables > 2)
           =7 V_MEMROM0 extern V_MEMROM1 tCanRxId2 V_MEMROM2       CanRxId2[kCanNumberOfRxObjects];  
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 239 

           =7 #    endif
           =7 #    if (kCanNumberOfUsedCanRxIdTables > 3)
           =7 V_MEMROM0 extern V_MEMROM1 tCanRxId3 V_MEMROM2       CanRxId3[kCanNumberOfRxObjects];  
           =7 #    endif
           =7 #    if (kCanNumberOfUsedCanRxIdTables > 4)
           =7 V_MEMROM0 extern V_MEMROM1 tCanRxId4 V_MEMROM2       CanRxId4[kCanNumberOfRxObjects];  
           =7 #    endif
           =7 
           =7 #    if defined( C_ENABLE_MIXED_ID )
           =7 #     if defined( C_HL_ENABLE_IDTYPE_IN_ID )
           =7 #     else
           =7 V_MEMROM0 extern V_MEMROM1 tCanIdType V_MEMROM2      CanRxIdType[kCanNumberOfRxObjects];
           =7 #     endif
           =7 #    endif
           =7 #   endif  /* C_SEARCH_HASH */
           =7 
           =7 
           =7 #   if defined( C_SEARCH_HASH )
           =7 V_MEMROM0 extern V_MEMROM1 CanReceiveHandle V_MEMROM2     CanRxMsgIndirection[kHashSearchListCount + kHash
             -SearchListCountEx + kCanNumberOfRxFullCANObjects];
           =7 #   else
           =7 #     if defined( C_ENABLE_RX_MSG_INDIRECTION )
           =7 V_MEMROM0 extern V_MEMROM1 CanReceiveHandle V_MEMROM2     CanRxMsgIndirection[kCanNumberOfRxObjects];
           =7 #     endif
           =7 #   endif
           =7 
           =7 #   if defined( C_SEARCH_HASH )
           =7 #    if defined( C_ENABLE_EXTENDED_ID )
           =7 #     if( kHashSearchListCountEx > 0)
           =7 V_MEMROM0 extern V_MEMROM1 vuint32 V_MEMROM2              CanRxHashIdEx[kHashSearchListCountEx];
           =7 #     endif /* (kHashSearchListCountEx > 0) */
           =7 #     if defined( C_ENABLE_MIXED_ID )
           =7 #      if( kHashSearchListCount > 0)
           =7 V_MEMROM0 extern V_MEMROM1 vuint16 V_MEMROM2              CanRxHashId[kHashSearchListCount];
           =7 #      endif
           =7 #     endif
           =7 #    else
           =7 #     if( kHashSearchListCount > 0)
           =7 V_MEMROM0 extern V_MEMROM1 vuint16 V_MEMROM2              CanRxHashId[kHashSearchListCount];
           =7 #     endif 
           =7 #    endif
           =7 #   endif
           =7 
           =7 #   if defined( C_ENABLE_MULTI_ECU_PHYS )
           =7 V_MEMROM0 extern V_MEMROM1 tVIdentityMsk V_MEMROM2           CanRxIdentityAssignment[kCanNumberOfRxObjects
             -];
           =7 #   endif
           =7 
           =7 /* ROM CATEGORY 1 END */
           =7 
           =7 /* ROM CATEGORY 4 START */
           =7 #   if defined( C_ENABLE_MULTIPLE_BASICCAN ) && \
           =7        defined( C_ENABLE_GEN_CHECK )
           =7 V_MEMROM0 extern V_MEMROM1 vuint8 V_MEMROM2               CanNumberOfBasicCAN[kCanNumberOfChannels];
           =7 #   endif
           =7 /* ROM CATEGORY 4 END */
           =7 
           =7 #  endif /* C_DRV_INTERNAL */
2031      =7  
2032      =7  /* ROM CATEGORY 1 START */
2033      =7  V_MEMROM0 extern V_MEMROM1 vuint8               V_MEMROM2 CanRxDataLen[kCanNumberOfRxObjects];
2034      =7  #   if defined( C_ENABLE_DLC_CHECK_MIN_DATALEN )
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 240 

           =7 V_MEMROM0 extern V_MEMROM1 vuint8               V_MEMROM2 CanRxMinDataLen[kCanNumberOfRxObjects];
           =7 #   endif
2037      =7  V_MEMROM0 extern V_MEMROM1 RxDataPtr            V_MEMROM2 CanRxDataPtr[kCanNumberOfRxObjects];
2038      =7  
2039      =7  #   if defined( C_ENABLE_PRECOPY_FCT )
2040      =7  V_MEMROM0 extern V_MEMROM1 ApplPrecopyFct       V_MEMROM2 CanRxApplPrecopyPtr[kCanNumberOfRxObjects];
2041      =7  #   endif
2042      =7  #   if defined( C_ENABLE_INDICATION_FLAG )
           =7 V_MEMROM0 extern V_MEMROM1 vuint8               V_MEMROM2 CanIndicationOffset[kCanNumberOfRxObjects];
           =7 V_MEMROM0 extern V_MEMROM1 vuint8               V_MEMROM2 CanIndicationMask[kCanNumberOfRxObjects];
           =7 #   endif
2046      =7  #   if defined( C_ENABLE_INDICATION_FCT )
2047      =7  V_MEMROM0 extern V_MEMROM1 ApplIndicationFct    V_MEMROM2 CanRxApplIndicationPtr[kCanNumberOfRxObjects];
2048      =7  #   endif
2049      =7  /* ROM CATEGORY 1 END */
2050      =7  # endif /* ( kCanNumberOfRxObjects > 0 ) */
2051      =7  
2052      =7  
2053      =7  /* KB begin CanLL_GeneratedStructureH */
2054      =7  /* structure used on initialization CAN chip ------------------------------- */
2055      =7  /* ROM CATEGORY 4 START */
2056      =7  V_DEF_CONST(extern, vuint16, CONST_PBCFG) CanInitBitTiming[]; 
2057      =7  V_DEF_CONST(extern, vuint16, CONST_PBCFG) CanInitBRP_Reg[];
2058      =7  
2059      =7  #if defined( C_ENABLE_RX_BASICCAN_OBJECTS )
           =7 V_DEF_CONST(extern, vuint16, CONST_PBCFG) CanInitBasicCod1[kCanNumberOfInitObjects+kCanExtNumberOfInitObje
             -cts][kCanNumberOfMaxBasicCAN]; 
           =7 V_DEF_CONST(extern, vuint16, CONST_PBCFG) CanInitBasicCod2[kCanNumberOfInitObjects+kCanExtNumberOfInitObje
             -cts][kCanNumberOfMaxBasicCAN]; 
           =7 V_DEF_CONST(extern, vuint16, CONST_PBCFG) CanInitBasicMsk1[kCanNumberOfInitObjects+kCanExtNumberOfInitObje
             -cts][kCanNumberOfMaxBasicCAN];
           =7 V_DEF_CONST(extern, vuint16, CONST_PBCFG) CanInitBasicMsk2[kCanNumberOfInitObjects+kCanExtNumberOfInitObje
             -cts][kCanNumberOfMaxBasicCAN];
           =7 #endif
2065      =7  
2066      =7  #if defined (C_SINGLE_RECEIVE_CHANNEL )
2067      =7  #else
           =7 extern  V_MEMROM0 V_MEMROM1 CanChipRegPtr V_MEMROM2 CanBasisAdr[];
           =7 extern  V_MEMROM0 V_MEMROM1 vuint32 V_MEMROM2 CanIntMask[];
           =7 #endif
2071      =7  
2072      =7  /* ROM CATEGORY 4 END*/
2073      =7  
2074      =7  #if defined( C_ENABLE_RX_FULLCAN_MASKS )
           =7 V_DEF_CONST(extern, tCanRxId0, CONST_PBCFG) CanRxFullCanMasks0[];
           =7 # if defined( C_ENABLE_EXTENDED_ID )
           =7 V_DEF_CONST(extern, tCanRxId1, CONST_PBCFG) CanRxFullCanMasks1[];
           =7 # endif
           =7 V_DEF_CONST(extern, vuint8, CONST_PBCFG) CanRxFullCanMaskIndirection[];
           =7 #endif
2081      =7  
2082      =7  
2083      =7  /* KB end CanLL_GeneratedStructureH */
2084      =7  
2085      =7  /* *********************************************************************** */
2086      =7  /* Callback functions                                                      */
2087      =7  /* *********************************************************************** */
2088      =7  
2089      =7  # if defined( C_ENABLE_INTCTRL_ADD_CAN_FCT )
           =7 /* CODE CATEGORY 1 START */
           =7 C_CALLBACK_1 void C_CALLBACK_2 ApplCanAddCanInterruptRestore(CanChannelHandle channel) C_API_3;
           =7 /* CODE CATEGORY 1 END */
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 241 

           =7 /* CODE CATEGORY 1 START */
           =7 C_CALLBACK_1 void C_CALLBACK_2 ApplCanAddCanInterruptDisable(CanChannelHandle channel) C_API_3;
           =7 /* CODE CATEGORY 1 END */
           =7 # endif
2097      =7  
2098      =7  # if defined( C_ENABLE_HARDWARE_CHECK ) || \
2099      =7      defined( C_ENABLE_USER_CHECK )     || \
2100      =7      defined( C_ENABLE_GEN_CHECK )      || \
2101      =7      defined( C_ENABLE_INTERNAL_CHECK ) 
2102      =7  /* CODE CATEGORY 4 START */ 
2103      =7  C_CALLBACK_1 void C_CALLBACK_2 ApplCanFatalError(CAN_CHANNEL_CANTYPE_FIRST vuint8 errorNumber) C_API_3;
2104      =7  /* CODE CATEGORY 4 END */
2105      =7  # endif
2106      =7  
2107      =7  # if defined( C_SINGLE_RECEIVE_CHANNEL )
2108      =7  /* these two functions are declared by the tool in case of multichannel */
2109      =7  /* CODE CATEGORY 4 START */ 
2110      =7  C_CALLBACK_1 void C_CALLBACK_2 ApplCanBusOff(CAN_CHANNEL_CANTYPE_ONLY);
2111      =7  /* CODE CATEGORY 4 END */
2112      =7  /* CODE CATEGORY 4 START */ 
2113      =7  C_CALLBACK_1 void C_CALLBACK_2 ApplCanWakeUp(CAN_CHANNEL_CANTYPE_ONLY);
2114      =7  /* CODE CATEGORY 4 END */
2115      =7  # endif
2116      =7  # if defined( C_ENABLE_APPLCANPREWAKEUP_FCT )
           =7 /* CODE CATEGORY 4 START */ 
           =7 C_CALLBACK_1 void C_CALLBACK_2 ApplCanPreWakeUp(CAN_CHANNEL_CANTYPE_ONLY);
           =7 /* CODE CATEGORY 4 END */
           =7 # endif
2121      =7  # if defined( C_ENABLE_OVERRUN )
           =7 /* CODE CATEGORY 4 START */ 
           =7 C_CALLBACK_1 void C_CALLBACK_2 ApplCanOverrun ( CAN_CHANNEL_CANTYPE_ONLY );
           =7 /* CODE CATEGORY 4 END */
           =7 # endif
2126      =7  # if defined( C_ENABLE_FULLCAN_OVERRUN )
           =7 /* CODE CATEGORY 4 START */ 
           =7 C_CALLBACK_1 void C_CALLBACK_2 ApplCanFullCanOverrun ( CAN_CHANNEL_CANTYPE_ONLY );
           =7 /* CODE CATEGORY 4 END */
           =7 # endif
2131      =7  
2132      =7  /* Range precopy/ generic precopy functions ****************************** */
2133      =7  # if defined( C_SINGLE_RECEIVE_CHANNEL )
2134      =7  #  if defined( C_ENABLE_RANGE_0 )
           =7 /* CODE CATEGORY 1 START */
           =7 C_CALLBACK_1 vuint8 C_CALLBACK_2 ApplCanRange0Precopy( CanRxInfoStructPtr rxStruct );
           =7 /* CODE CATEGORY 1 END */
           =7 #  endif
2139      =7  #  if defined( C_ENABLE_RANGE_1 )
           =7 /* CODE CATEGORY 1 START */
           =7 C_CALLBACK_1 vuint8 C_CALLBACK_2 ApplCanRange1Precopy( CanRxInfoStructPtr rxStruct );
           =7 /* CODE CATEGORY 1 END */
           =7 #  endif
2144      =7  #  if defined( C_ENABLE_RANGE_2 )
           =7 /* CODE CATEGORY 1 START */
           =7 C_CALLBACK_1 vuint8 C_CALLBACK_2 ApplCanRange2Precopy( CanRxInfoStructPtr rxStruct );
           =7 /* CODE CATEGORY 1 END */
           =7 #  endif
2149      =7  #  if defined( C_ENABLE_RANGE_3 )
           =7 /* CODE CATEGORY 1 START */
           =7 C_CALLBACK_1 vuint8 C_CALLBACK_2 ApplCanRange3Precopy( CanRxInfoStructPtr rxStruct );
           =7 /* CODE CATEGORY 1 END */
           =7 #  endif
2154      =7  # endif
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 242 

2155      =7  
2156      =7  # if defined( C_ENABLE_COND_RECEIVE_FCT )
           =7 /* CODE CATEGORY 1 START */
           =7 C_CALLBACK_1 void C_CALLBACK_2 ApplCanMsgCondReceived  ( CanRxInfoStructPtr rxStruct );
           =7 /* CODE CATEGORY 1 END */
           =7 # endif
2161      =7  
2162      =7  # if defined( C_ENABLE_CAN_RAM_CHECK )
           =7 #  if defined( C_ENABLE_NOTIFY_CORRUPT_MAILBOX )
           =7 /* CODE CATEGORY 4 START */
           =7 C_CALLBACK_1 void C_CALLBACK_2 ApplCanCorruptMailbox(CAN_CHANNEL_CANTYPE_FIRST CanObjectHandle hwObjHandle
             -);
           =7 /* CODE CATEGORY 4 END */
           =7 #  endif  /* defined( C_ENABLE_NOTIFY_CORRUPT_MAILBOX ) */
           =7 /* CODE CATEGORY 4 START */
           =7 C_CALLBACK_1 vuint8 C_CALLBACK_2 ApplCanMemCheckFailed(CAN_CHANNEL_CANTYPE_ONLY);
           =7 /* CODE CATEGORY 4 END */
           =7 # endif  /* defined ( C_ENABLE_CAN_RAM_CHECK ) */
2172      =7  
2173      =7  # if defined( C_SINGLE_RECEIVE_CHANNEL )
2174      =7  #  if defined( C_ENABLE_RECEIVE_FCT )
           =7 /* in case of multiple CAN channels this function is declared by the tool */
           =7 /* CODE CATEGORY 1 START */
           =7 C_CALLBACK_1 vuint8 C_CALLBACK_2 APPL_CAN_MSGRECEIVED(CanRxInfoStructPtr rxStruct);
           =7 /* CODE CATEGORY 1 END */
           =7 #  endif
2180      =7  # endif
2181      =7  
2182      =7  /* ##RI1.4 - 2.7: Callbackfunction-DLC-Check */
2183      =7  # if defined( C_ENABLE_DLC_FAILED_FCT )
           =7 /* CODE CATEGORY 4 START */
           =7 C_CALLBACK_1 void C_CALLBACK_2 ApplCanMsgDlcFailed( CanRxInfoStructPtr rxStruct ); 
           =7 /* CODE CATEGORY 4 END */ 
           =7 # endif  /* C_ENABLE_DLC_FAILED_FCT */
2188      =7  
2189      =7  # if defined( C_ENABLE_GENERIC_PRECOPY )
2190      =7  /* CODE CATEGORY 1 START */
2191      =7  C_CALLBACK_1 vuint8 C_CALLBACK_2 APPL_CAN_GENERIC_PRECOPY( CanRxInfoStructPtr rxStruct );
2192      =7  /* CODE CATEGORY 1 END */
2193      =7  # endif
2194      =7  
2195      =7  # if defined( C_ENABLE_NOT_MATCHED_FCT )
           =7 /* CODE CATEGORY 1 START */
           =7 C_CALLBACK_1 void C_CALLBACK_2 ApplCanMsgNotMatched( CanRxInfoStructPtr rxStruct );
           =7 /* CODE CATEGORY 1 END */
           =7 # endif
2200      =7  
2201      =7  # if defined( C_ENABLE_CAN_TX_CONF_FCT )
           =7 /* ##RI-1.10 Common Callbackfunction in TxInterrupt */
           =7 /* CODE CATEGORY 1 START */
           =7 C_CALLBACK_1 void C_CALLBACK_2 APPL_CAN_TX_CONFIRMATION(CanTxInfoStructPtr txStruct);
           =7 /* CODE CATEGORY 1 END */
           =7 # endif
2207      =7  
2208      =7  # if defined( C_ENABLE_TX_OBSERVE )
2209      =7  /* CODE CATEGORY 1 START */
2210      =7  C_CALLBACK_1 void C_CALLBACK_2 ApplCanTxObjStart( CAN_CHANNEL_CANTYPE_FIRST CanObjectHandle txHwObject );
2211      =7  /* CODE CATEGORY 1 END */
2212      =7  /* CODE CATEGORY 1 START */
2213      =7  C_CALLBACK_1 void C_CALLBACK_2 ApplCanTxObjConfirmed( CAN_CHANNEL_CANTYPE_FIRST CanObjectHandle txHwObject
             - );
2214      =7  /* CODE CATEGORY 1 END */
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 243 

2215      =7  /* CODE CATEGORY 4 START */
2216      =7  C_CALLBACK_1 void C_CALLBACK_2 ApplCanInit( CAN_CHANNEL_CANTYPE_FIRST CanObjectHandle txHwObjectFirstUsed,
             - CanObjectHandle txHwObjectFirstUnused);
2217      =7  /* CODE CATEGORY 4 END */
2218      =7  # endif
2219      =7  
2220      =7  # if defined( C_ENABLE_HW_LOOP_TIMER )
           =7 /* CODE CATEGORY 2 START */
           =7 C_CALLBACK_1 void     C_CALLBACK_2 ApplCanTimerStart(CAN_CHANNEL_CANTYPE_FIRST vuint8 source);
           =7 /* CODE CATEGORY 2 END */
           =7 /* CODE CATEGORY 2 START */
           =7 C_CALLBACK_1 vuint8 C_CALLBACK_2 ApplCanTimerLoop (CAN_CHANNEL_CANTYPE_FIRST vuint8 source);
           =7 /* CODE CATEGORY 2 END */
           =7 /* CODE CATEGORY 2 START */
           =7 C_CALLBACK_1 void     C_CALLBACK_2 ApplCanTimerEnd  (CAN_CHANNEL_CANTYPE_FIRST vuint8 source);
           =7 /* CODE CATEGORY 2 END */
           =7 # endif
2231      =7  
2232      =7  
2233      =7  # if defined( C_SINGLE_RECEIVE_CHANNEL )
2234      =7  /* in case of multichannel these two functions are declared by the tool */
2235      =7  #  if defined( C_ENABLE_CAN_CANCEL_NOTIFICATION )
2236      =7  /* CODE CATEGORY 3 START */
2237      =7  C_CALLBACK_1 void C_CALLBACK_2 APPL_CAN_CANCELNOTIFICATION( CanTransmitHandle txHandle );
2238      =7  /* CODE CATEGORY 3 END */
2239      =7  #  endif
2240      =7  # endif
2241      =7  
2242      =7  
2243      =7  # if defined( C_MULTIPLE_RECEIVE_CHANNEL )
           =7 /* CODE CATEGORY 3 START */
           =7 C_CALLBACK_1 void C_CALLBACK_2 ApplCanChannelDummy( CanChannelHandle channel );
           =7 /* CODE CATEGORY 3 END */
           =7 # endif
2248      =7  # if defined( C_MULTIPLE_RECEIVE_CHANNEL ) || \
2249      =7      defined( C_HL_ENABLE_DUMMY_FCT_CALL )
           =7 /* CODE CATEGORY 1 START */
           =7 C_CALLBACK_1 void C_CALLBACK_2 ApplCanTxHandleDummy( CanTransmitHandle txHandle );
           =7 /* CODE CATEGORY 1 END */
           =7 /* CODE CATEGORY 1 START */
           =7 C_CALLBACK_1 vuint8 C_CALLBACK_2 ApplCanRxStructPtrDummy( CanRxInfoStructPtr rxStruct );
           =7 /* CODE CATEGORY 1 END */
           =7 # endif
2257      =7  # if defined( C_HL_ENABLE_DUMMY_FCT_CALL )
           =7 /* CODE CATEGORY 1 START */
           =7 C_CALLBACK_1 void C_CALLBACK_2 ApplCanRxHandleDummy( CanReceiveHandle rxHandle );
           =7 /* CODE CATEGORY 1 END */
           =7 /* CODE CATEGORY 1 START */
           =7 C_CALLBACK_1 vuint8 C_CALLBACK_2 ApplCanTxStructDummy( CanTxInfoStruct txStruct );
           =7 /* CODE CATEGORY 1 END */
           =7 # endif
2265      =7  # if defined( C_ENABLE_ONLINE_OFFLINE_CALLBACK_FCT )
           =7 /* CODE CATEGORY 4 START */
           =7 C_CALLBACK_1 void C_CALLBACK_2 APPL_CAN_OFFLINE( CAN_CHANNEL_CANTYPE_ONLY );
           =7 /* CODE CATEGORY 4 END */
           =7 /* CODE CATEGORY 4 START */
           =7 C_CALLBACK_1 void C_CALLBACK_2 APPL_CAN_ONLINE( CAN_CHANNEL_CANTYPE_ONLY );
           =7 /* CODE CATEGORY 4 END */
           =7 # endif
2273      =7  
2274      =7  # if defined (C_ENABLE_CAN_CAN_INTERRUPT_CONTROL) &&\
2275      =7       defined (C_ENABLE_OSEK_CAN_INTCTRL)
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 244 

           =7 /* CODE CATEGORY 1 START */
           =7 C_API_1 void C_API_2 OsCanCanInterruptDisable( CAN_HW_CHANNEL_CANTYPE_ONLY ) C_API_3;
           =7 /* CODE CATEGORY 1 END */
           =7 /* CODE CATEGORY 1 START */
           =7 C_API_1 void C_API_2 OsCanCanInterruptRestore( CAN_HW_CHANNEL_CANTYPE_ONLY ) C_API_3;
           =7 /* CODE CATEGORY 1 END */
           =7 # endif
2283      =7  
2284      =7  /* KB begin CanLL_CallBackFunctionsH */
2285      =7  /* CODE CATEGORY 1 START*/
2286      =7  #if defined( C_ENABLE_CANCEL_IN_HW )
           =7 V_DEF_FUNC_CBK(V_NONE, void, APPL_CODE)   ApplCanTxCancelInHwStart(CanObjectHandle txHwObject);
           =7 V_DEF_FUNC_CBK(V_NONE, vuint8, APPL_CODE) ApplCanTxCancelInHwConfirmed(CanObjectHandle txHwObject); 
           =7 #endif
2290      =7  /* CODE CATEGORY 1 END*/
2291      =7  /* KB end CanLL_CallBackFunctionsH */
2292      =7  
2293      =7  /* *********************************************************************** */
2294      =7  /* function prototypes                                                     */
2295      =7  /* *********************************************************************** */
2296      =7  
2297      =7  #  if defined( C_ENABLE_PRETRANSMIT_FCT )
           =7 /* CODE CATEGORY 2 START */
           =7 C_API_1 vuint8 C_API_2 PreTransmit_switch(CanTransmitHandle txHandle, CanTxInfoStruct txStruct) C_API_3;
           =7 /* CODE CATEGORY 2 END */
           =7 #  endif
2302      =7  /* CODE CATEGORY 4 START */
2303      =7  C_API_1 void C_API_2 CanInitPowerOn( void );
2304      =7  /* CODE CATEGORY 4 END */
2305      =7  /* CODE CATEGORY 4 START */
2306      =7  C_API_1 void C_API_2 CanInit( CAN_CHANNEL_CANTYPE_FIRST CanInitHandle initObject );
2307      =7  /* CODE CATEGORY 4 END */
2308      =7  
2309      =7  # if defined( C_ENABLE_CAN_TRANSMIT )
2310      =7  /* CODE CATEGORY 2 START */
2311      =7  C_API_1 vuint8 C_API_2 CanTransmit(CanTransmitHandle txHandle) C_API_3;
2312      =7  /* CODE CATEGORY 2 END */
2313      =7  #  if defined( C_ENABLE_VARIABLE_DLC )
           =7 /* CODE CATEGORY 2 START */
           =7 C_API_1 vuint8 C_API_2 CanTransmitVarDLC( CanTransmitHandle txHandle, vuint8 dlc) C_API_3;
           =7 /* CODE CATEGORY 2 END */
           =7 #  endif
2318      =7  /* CODE CATEGORY 3 START */
2319      =7  C_API_1 void C_API_2 CanCancelTransmit( CanTransmitHandle txHandle );
2320      =7  /* CODE CATEGORY 3 END */
2321      =7  # endif
2322      =7  
2323      =7  
2324      =7  # if defined( C_ENABLE_OFFLINE )
2325      =7  /* CODE CATEGORY 4 START */
2326      =7  C_API_1 void C_API_2 CanOnline( CAN_CHANNEL_CANTYPE_ONLY );           /* switch CanStatus to On */
2327      =7  /* CODE CATEGORY 4 END */
2328      =7  /* CODE CATEGORY 4 START */
2329      =7  C_API_1 void C_API_2 CanOffline( CAN_CHANNEL_CANTYPE_ONLY ) C_API_3;
2330      =7  /* CODE CATEGORY 4 END */
2331      =7  # endif
2332      =7  
2333      =7  # if defined( C_ENABLE_PART_OFFLINE )
2334      =7  /* CODE CATEGORY 4 START */
2335      =7  C_API_1 void C_API_2 CanSetPartOffline( CAN_CHANNEL_CANTYPE_FIRST vuint8 sendGroup);
2336      =7  /* CODE CATEGORY 4 END */
2337      =7  /* CODE CATEGORY 4 START */
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 245 

2338      =7  C_API_1 void C_API_2 CanSetPartOnline( CAN_CHANNEL_CANTYPE_FIRST vuint8 invSendGroup);
2339      =7  /* CODE CATEGORY 4 END */
2340      =7  /* CODE CATEGORY 4 START */
2341      =7  C_API_1 vuint8 C_API_2 CanGetPartMode( CAN_CHANNEL_CANTYPE_ONLY );
2342      =7  /* CODE CATEGORY 4 END */
2343      =7  # endif
2344      =7  
2345      =7  /* CODE CATEGORY 3 START */
2346      =7  C_API_1 vuint8 C_API_2 CanGetStatus( CAN_CHANNEL_CANTYPE_ONLY ) C_API_3;
2347      =7  /* CODE CATEGORY 3 END */
2348      =7  
2349      =7  /* CanSleep functions */
2350      =7  /* CODE CATEGORY 4 START */
2351      =7  C_API_1 vuint8 C_API_2 CanSleep( CAN_CHANNEL_CANTYPE_ONLY );
2352      =7  /* CODE CATEGORY 4 END */
2353      =7  /* CODE CATEGORY 4 START */
2354      =7  C_API_1 vuint8 C_API_2 CanWakeUp( CAN_CHANNEL_CANTYPE_ONLY );
2355      =7  /* CODE CATEGORY 4 END */
2356      =7  
2357      =7  # if defined( C_ENABLE_ECU_SWITCH_PASS )
           =7 /* CODE CATEGORY 4 START */
           =7 C_API_1 void C_API_2 CanSetActive(  CAN_CHANNEL_CANTYPE_ONLY );
           =7 /* CODE CATEGORY 4 END */
           =7 /* CODE CATEGORY 4 START */
           =7 C_API_1 void C_API_2 CanSetPassive( CAN_CHANNEL_CANTYPE_ONLY );
           =7 /* CODE CATEGORY 4 END */
           =7 # else
2365      =7  #  if defined( C_MULTIPLE_RECEIVE_CHANNEL )
           =7 #   define    CanSetActive( channel )            /* remove calls to setActive/Passive */
           =7 #   define    CanSetPassive( channel )
           =7 #  else
2369      =7  #   define    CanSetActive( )                    /* remove calls to setActive/Passive */
2370      =7  #   define    CanSetPassive( )
2371      =7  #  endif
2372      =7  # endif
2373      =7  
2374      =7  # if defined( C_ENABLE_STOP )
2375      =7  /* CODE CATEGORY 4 START */
2376      =7  C_API_1 vuint8 C_API_2 CanStart( CAN_CHANNEL_CANTYPE_ONLY );
2377      =7  /* CODE CATEGORY 4 END */
2378      =7  /* CODE CATEGORY 4 START */
2379      =7  C_API_1 vuint8 C_API_2 CanStop( CAN_CHANNEL_CANTYPE_ONLY );
2380      =7  /* CODE CATEGORY 4 END */
2381      =7  # endif
2382      =7  
2383      =7  # if defined (C_ENABLE_CAN_CAN_INTERRUPT_CONTROL)
2384      =7  /* CODE CATEGORY 1 START */
2385      =7  C_API_1 void C_API_2 CanCanInterruptDisable( CAN_CHANNEL_CANTYPE_ONLY ) C_API_3;
2386      =7  /* CODE CATEGORY 1 END */
2387      =7  /* CODE CATEGORY 1 START */
2388      =7  C_API_1 void C_API_2 CanCanInterruptRestore( CAN_CHANNEL_CANTYPE_ONLY ) C_API_3;
2389      =7  /* CODE CATEGORY 1 END */
2390      =7  # endif
2391      =7  
2392      =7  # if defined( C_ENABLE_TX_POLLING ) || \
2393      =7      defined( C_ENABLE_RX_FULLCAN_POLLING )  || \
2394      =7      defined( C_ENABLE_RX_BASICCAN_POLLING ) || \
2395      =7      defined( C_ENABLE_ERROR_POLLING ) || \
2396      =7      defined( C_ENABLE_WAKEUP_POLLING ) || \
2397      =7      (defined( C_HL_ENABLE_CANCEL_IN_HW_TASK ) && defined( C_ENABLE_CANCEL_IN_HW ))
           =7 /* CODE CATEGORY 2 START */
           =7 C_API_1 void C_API_2 CanTask(void);
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 246 

           =7 /* CODE CATEGORY 2 END */
           =7 # endif
2402      =7  # if defined( C_ENABLE_TX_POLLING ) || \
2403      =7      (defined( C_HL_ENABLE_CANCEL_IN_HW_TASK )  && defined( C_ENABLE_CANCEL_IN_HW ))
           =7 /* CODE CATEGORY 2 START */
           =7 C_API_1 void C_API_2 CanTxTask( CAN_CHANNEL_CANTYPE_ONLY ) C_API_3;
           =7 /* CODE CATEGORY 2 END */
           =7 # endif
2408      =7  # if defined( C_ENABLE_ERROR_POLLING )
           =7 /* CODE CATEGORY 2 START */
           =7 C_API_1 void C_API_2 CanErrorTask( CAN_CHANNEL_CANTYPE_ONLY );
           =7 /* CODE CATEGORY 2 END */
           =7 # endif
2413      =7  # if defined( C_ENABLE_SLEEP_WAKEUP )
           =7 #  if defined( C_ENABLE_WAKEUP_POLLING )
           =7 /* CODE CATEGORY 2 START */
           =7 C_API_1 void C_API_2 CanWakeUpTask(CAN_CHANNEL_CANTYPE_ONLY);
           =7 /* CODE CATEGORY 2 END */
           =7 #  endif
           =7 # endif
2420      =7  #if defined( C_ENABLE_RX_FULLCAN_OBJECTS ) && \
2421      =7      defined( C_ENABLE_RX_FULLCAN_POLLING )  
           =7 /* CODE CATEGORY 2 START */
           =7 C_API_1 void C_API_2 CanRxFullCANTask(CAN_CHANNEL_CANTYPE_ONLY) C_API_3;
           =7 /* CODE CATEGORY 2 END */
           =7 # endif
2426      =7  #if defined( C_ENABLE_RX_BASICCAN_POLLING ) && \
2427      =7      defined( C_ENABLE_RX_BASICCAN_OBJECTS )
           =7 /* CODE CATEGORY 2 START */
           =7 C_API_1 void C_API_2 CanRxBasicCANTask(CAN_CHANNEL_CANTYPE_ONLY) C_API_3;
           =7 /* CODE CATEGORY 2 END */
           =7 # endif
2432      =7  
2433      =7  
2434      =7  # if defined( C_ENABLE_DYN_TX_OBJECTS )
           =7 /* CODE CATEGORY 3 START */
           =7 C_API_1 CanTransmitHandle C_API_2 CanGetDynTxObj(CanTransmitHandle txHandle ) C_API_3;
           =7 /* CODE CATEGORY 3 END */
           =7 /* CODE CATEGORY 3 START */
           =7 C_API_1 vuint8          C_API_2 CanReleaseDynTxObj(CanTransmitHandle txHandle) C_API_3;
           =7 /* CODE CATEGORY 3 END */
           =7 
           =7 #  if defined( C_ENABLE_DYN_TX_ID )
           =7 #   if !defined( C_ENABLE_EXTENDED_ID ) ||\
           =7      defined( C_ENABLE_MIXED_ID )
           =7 /* CODE CATEGORY 2 START */
           =7 C_API_1 void C_API_2 CanDynTxObjSetId(CanTransmitHandle txHandle, vuint16 id) C_API_3;
           =7 /* CODE CATEGORY 2 END */
           =7 #   endif
           =7 #   if defined( C_ENABLE_EXTENDED_ID )
           =7 /* CODE CATEGORY 2 START */
           =7 C_API_1 void C_API_2 CanDynTxObjSetExtId(CanTransmitHandle txHandle, vuint16 idExtHi, vuint16 idExtLo) C_A
             -PI_3;
           =7 /* CODE CATEGORY 2 END */
           =7 #   endif
           =7 #  endif
           =7 #  if defined( C_ENABLE_DYN_TX_DLC )
           =7 /* CODE CATEGORY 2 START */
           =7 C_API_1 void C_API_2 CanDynTxObjSetDlc(CanTransmitHandle txHandle, vuint8 dlc) C_API_3;
           =7 /* CODE CATEGORY 2 END */
           =7 #  endif
           =7 #  if defined( C_ENABLE_DYN_TX_DATAPTR )
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 247 

           =7 /* CODE CATEGORY 2 START */
           =7 C_API_1 void C_API_2 CanDynTxObjSetDataPtr(CanTransmitHandle txHandle, void* pData) C_API_3;
           =7 /* CODE CATEGORY 2 END */
           =7 #  endif
           =7 
           =7 
           =7 # endif /* defined( C_ENABLE_DYN_TX_OBJECTS ) */
2468      =7  
2469      =7  # if defined( C_ENABLE_TX_MASK_EXT_ID )
           =7 /* CODE CATEGORY 4 START */
           =7 C_API_1 void C_API_2 CanSetTxIdExtHi( CAN_CHANNEL_CANTYPE_FIRST  vuint8 mask );
           =7 /* CODE CATEGORY 4 END */
           =7 /* CODE CATEGORY 4 START */
           =7 C_API_1 void C_API_2 CanSetTxIdExtMidHi( CAN_CHANNEL_CANTYPE_FIRST  vuint8 mask );
           =7 /* CODE CATEGORY 4 END */
           =7 /* CODE CATEGORY 4 START */
           =7 C_API_1 void C_API_2 CanSetTxIdExtMidLo( CAN_CHANNEL_CANTYPE_FIRST  vuint8 mask );
           =7 /* CODE CATEGORY 4 END */
           =7 /* CODE CATEGORY 4 START */
           =7 C_API_1 void C_API_2 CanSetTxIdExtLo( CAN_CHANNEL_CANTYPE_FIRST  vuint8 mask );
           =7 /* CODE CATEGORY 4 END */
           =7 # endif
2483      =7  
2484      =7  # if defined( C_ENABLE_TX_OBSERVE )
2485      =7  /* CODE CATEGORY 3 START */
2486      =7  C_API_1 CanTransmitHandle C_API_2 CanTxGetActHandle( CanObjectHandle logicalTxHdl ) C_API_3;
2487      =7  /* CODE CATEGORY 3 END */
2488      =7  # endif
2489      =7  
2490      =7  # if defined( C_ENABLE_COND_RECEIVE_FCT )
           =7 /* CODE CATEGORY 3 START */
           =7 C_API_1 void     C_API_2 CanSetMsgReceivedCondition( CAN_CHANNEL_CANTYPE_ONLY );
           =7 /* CODE CATEGORY 3 END */
           =7 /* CODE CATEGORY 3 START */
           =7 C_API_1 void     C_API_2 CanResetMsgReceivedCondition( CAN_CHANNEL_CANTYPE_ONLY );
           =7 /* CODE CATEGORY 3 END */
           =7 /* CODE CATEGORY 3 START */
           =7 C_API_1 vuint8 C_API_2 CanGetMsgReceivedCondition( CAN_CHANNEL_CANTYPE_ONLY );
           =7 /* CODE CATEGORY 3 END */
           =7 # endif
2501      =7  
2502      =7  
2503      =7  /* Additional API for QNX */
2504      =7  #if defined(C_ENABLE_UPDATE_BASE_ADDRESS)
           =7 /* CODE CATEGORY 4 START */
           =7 C_API_1 void C_API_2 CanBaseAddressRequest(CAN_CHANNEL_CANTYPE_ONLY);
           =7 /* CODE CATEGORY 4 END */
           =7 /* CODE CATEGORY 4 START */
           =7 C_API_1 void C_API_2 CanBaseAddressActivate(CAN_CHANNEL_CANTYPE_ONLY);
           =7 /* CODE CATEGORY 4 END */
           =7 #endif
2512      =7  
2513      =7  
2514      =7  
2515      =7  /* KB begin CanLL_FunctionPrototypesH */
2516      =7  #if defined( C_ENABLE_MEMCOPY_SUPPORT )
           =7 /* CODE CATEGORY 1 START */
           =7 V_DEF_FUNC_API(V_NONE, void, CODE) CanCopyToCan(CanChipDataPtr dst, V_DEF_P2VAR_PARA(V_NONE, void, AUTOMAT
             -IC, APPL_VAR) src, vuint8 len);
           =7 /* CODE CATEGORY 1 END */
           =7 /* CODE CATEGORY 1 START */
           =7 V_DEF_FUNC_API(V_NONE, void, CODE) CanCopyFromCan(V_DEF_P2VAR_PARA(V_NONE, void, AUTOMATIC, APPL_VAR) dst,
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 248 

             - CanChipDataPtr src, vuint8 len);
           =7 /* CODE CATEGORY 1 END */
           =7 #endif
2524      =7  
2525      =7  #if defined ( C_COMP_KEIL_SLC8051_CCAN )
2526      =7  /* CODE CATEGORY 4 START*/
2527      =7  C_API_1 vuint8 C_API_2 CanRxActualErrorCounter(CAN_CHANNEL_CANTYPE_ONLY) C_API_3;
2528      =7  /* CODE CATEGORY 1 END */
2529      =7  /* CODE CATEGORY 4 START*/
2530      =7  C_API_1 vuint8 C_API_2 CanTxActualErrorCounter(CAN_CHANNEL_CANTYPE_ONLY) C_API_3;
2531      =7  /* CODE CATEGORY 1 END */
2532      =7  /* CODE CATEGORY 4 START*/
2533      =7  C_API_1 vuint8 C_API_2 CanLL_HwIsStop(CAN_CHANNEL_CANTYPE_ONLY) C_API_3;   
2534      =7  /* CODE CATEGORY 1 END */
2535      =7  /* CODE CATEGORY 4 START*/
2536      =7  C_API_1 vuint8 C_API_2 CanLL_HwIsPassive(CAN_CHANNEL_CANTYPE_ONLY) C_API_3;   
2537      =7  /* CODE CATEGORY 1 END */
2538      =7  /* CODE CATEGORY 4 START*/
2539      =7  C_API_1 vuint8 C_API_2 CanLL_HwIsWarning(CAN_CHANNEL_CANTYPE_ONLY) C_API_3;  
2540      =7  /* CODE CATEGORY 1 END */
2541      =7  #endif
2542      =7  
2543      =7  /* KB end CanLL_FunctionPrototypesH */
2544      =7  /* KB begin CanLL_FunctionPrototypesISRH */
2545      =7  
2546      =7  /* Possibility to disable the prototypes of interrupt service routines in the driver header file */
2547      =7  # if !(defined( C_ENABLE_ISR_PROTOTYPE) || defined( C_DISABLE_ISR_PROTOTYPE ))
2548      =7  #  define C_ENABLE_ISR_PROTOTYPE
2549      =7  # endif
2550      =7  
2551      =7  /* CODE CATEGORY 1 START */
2552      =7  /* CODE CATEGORY 1 END */
2553      =7  
2554      =7  #if defined (C_ENABLE_ISR_PROTOTYPE)
2555      =7  # if defined(C_ENABLE_OSEK_OS)&&\
2556      =7       defined(C_ENABLE_OSEK_OS_INTCAT2)
           =7 /* ISR prototypes must be provided by OSEK header file */
           =7 # else
2559      =7  #  if ((defined( C_ENABLE_RX_BASICCAN_OBJECTS ) && !defined( C_ENABLE_RX_BASICCAN_POLLING )) || \
2560      =7         (defined( C_ENABLE_RX_FULLCAN_OBJECTS )  && !defined( C_ENABLE_RX_FULLCAN_POLLING  )) || \
2561      =7          !defined( C_ENABLE_TX_POLLING )        || \
2562      =7          !defined( C_ENABLE_ERROR_POLLING )     ||\
2563      =7          !defined( C_ENABLE_WAKEUP_POLLING ))        /* ISR necessary; no pure polling configuration */
2564      =7  #  if defined( kCanPhysToLogChannelIndex_0 )
2565      =7  /* CODE CATEGORY 1 START */
2566      =7  /* CODE CATEGORY 1 END */
2567      =7  #  endif
2568      =7  #  endif /* no pure polling configuration */
2569      =7  # endif
2570      =7  #endif /* if defined (C_ENABLE_ISR_PROTOTYPE) */
2571      =7  
2572      =7  /* KB end CanLL_FunctionPrototypesISRH */
2573      =7  
2574      =7  #endif /* CAN_DEF_H */
2575      =7  
2576      =7  /* End of channel */
2577      =7  
2578      =7  
2579      =7  
  71      =6  
  72      =6  
  73      =6  /* Include Register header of used controller derivative */
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 249 

  74      =6  #endif /* _CAN_INC_H */
  75      =6  /* STOPSINGLE_OF_MULTIPLE */
  49      =5  
  50      =5  #include "v_cfg.h"
   1      =6  /* -----------------------------------------------------------------------------
   2      =6    Filename:    v_cfg.h
   3      =6    Description: Toolversion: 05.00.51.01.30.02.86.01.00.00
   4      =6                 
   5      =6                 Serial Number: CBD1300286
   6      =6                 Customer Info: Hyundai Mobis Co., Ltd.
   7      =6                                Package: CBD Hmc SLP5 - CBD License f. HKMC
   8      =6                                Micro: C8051F582
   9      =6                                Compiler: Keil PK51
  10      =6                 
  11      =6                 
  12      =6                 Generator Fwk   : GENy 
  13      =6                 Generator Module: GenTool_GenyVcfgNameDecorator
  14      =6                 
  15      =6                 Configuration   : Y:\20150903_DiagCam_DE.gny
  16      =6                 
  17      =6                 ECU: 
  18      =6                         TargetSystem: Hw_Slc8051Cpu
  19      =6                         Compiler:     KEIL
  20      =6                         Derivates:    C8051F58x_59x
  21      =6                 
  22      =6                 Channel "Channel0":
  23      =6                         Databasefile: Y:\20150206_JF_DiagCamera_CAN_DB_R6(LangInfo).dbc
  24      =6                         Bussystem:    CAN
  25      =6                         Manufacturer: HMC
  26      =6                         Node:         PGS
  27      =6  
  28      =6    Generated by , 2015-10-19  18:50:07
  29      =6   ----------------------------------------------------------------------------- */
  30      =6  /* -----------------------------------------------------------------------------
  31      =6    C O P Y R I G H T
  32      =6   -------------------------------------------------------------------------------
  33      =6    Copyright (c) 2001-2011 by Vector Informatik GmbH. All rights reserved.
  34      =6   
  35      =6    This software is copyright protected and proprietary to Vector Informatik 
  36      =6    GmbH.
  37      =6    
  38      =6    Vector Informatik GmbH grants to you only those rights as set out in the 
  39      =6    license conditions.
  40      =6    
  41      =6    All other rights remain with Vector Informatik GmbH.
  42      =6   -------------------------------------------------------------------------------
  43      =6   ----------------------------------------------------------------------------- */
  44      =6  
  45      =6  #if !defined(__V_CFG_H__)
           =6 #define __V_CFG_H__
           =6 
           =6 #ifndef VGEN_GENY
           =6 #define VGEN_GENY
           =6 #endif
           =6 
           =6 #ifndef GENy
           =6 #define GENy
           =6 #endif
           =6 
           =6 #ifndef SUPPLIER_CANBEDDED
           =6 #define SUPPLIER_CANBEDDED                   30
           =6 #endif
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 250 

           =6 
           =6 /* -----------------------------------------------------------------------------
           =6     &&&~ Version
           =6  ----------------------------------------------------------------------------- */
           =6 
           =6 #ifndef VERSIONNUMBER
           =6 #define VERSIONNUMBER                        0x178
           =6 #endif
           =6 
           =6 
           =6 
           =6 /* -----------------------------------------------------------------------------
           =6     &&&~ General Switches
           =6  ----------------------------------------------------------------------------- */
           =6 
           =6 #ifndef V_OSTYPE_NONE
           =6 #define V_OSTYPE_NONE
           =6 #endif
           =6 
           =6 
           =6 
           =6 /* -----------------------------------------------------------------------------
           =6     &&&~ Processor specific
           =6  ----------------------------------------------------------------------------- */
           =6 
           =6 #ifndef C_CPUTYPE_8BIT
           =6 #define C_CPUTYPE_8BIT
           =6 #endif
           =6 
           =6 
           =6 #ifndef V_CPUTYPE_BITARRAY_16BIT
           =6 #define V_CPUTYPE_BITARRAY_16BIT
           =6 #endif
           =6 
           =6 
           =6 #ifndef C_CPUTYPE_BIGENDIAN
           =6 #define C_CPUTYPE_BIGENDIAN
           =6 #endif
           =6 
           =6 
           =6 #ifndef C_CPUTYPE_BITORDER_LSB2MSB
           =6 #define C_CPUTYPE_BITORDER_LSB2MSB
           =6 #endif
           =6 
           =6 
           =6 #ifndef V_DISABLE_USE_DUMMY_FUNCTIONS
           =6 #define V_DISABLE_USE_DUMMY_FUNCTIONS
           =6 #endif
           =6 
           =6 
           =6 #ifndef V_ENABLE_USE_DUMMY_STATEMENT
           =6 #define V_ENABLE_USE_DUMMY_STATEMENT
           =6 #endif
           =6 
           =6 
           =6 #ifndef C_COMP_KEIL_SLC8051_CCAN
           =6 #define C_COMP_KEIL_SLC8051_CCAN
           =6 #endif
           =6 
           =6 
           =6 #ifndef V_CPU_SLC8051
           =6 #define V_CPU_SLC8051
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 251 

           =6 #endif
           =6 
           =6 #ifndef V_COMP_KEIL
           =6 #define V_COMP_KEIL
           =6 #endif
           =6 
           =6 #ifndef V_COMP_KEIL_SLC8051
           =6 #define V_COMP_KEIL_SLC8051
           =6 #endif
           =6 
           =6 #ifndef V_PROCESSOR_C8051F58X_59X
           =6 #define V_PROCESSOR_C8051F58X_59X
           =6 #endif
           =6 
           =6 
           =6 #ifndef C_PROCESSOR_C8051F58X_59X
           =6 #define C_PROCESSOR_C8051F58X_59X
           =6 #endif
           =6 
           =6 
           =6 
           =6 
           =6 /* -----------------------------------------------------------------------------
           =6     &&&~ Used Modules
           =6  ----------------------------------------------------------------------------- */
           =6 
           =6 #define VGEN_ENABLE_DIAG_CANDESC_UDS
           =6 #ifndef VGEN_ENABLE_VSTDLIB
           =6 #define VGEN_ENABLE_VSTDLIB
           =6 #endif
           =6 
           =6 #ifndef VSTD_ENABLE_DEFAULT_INTCTRL
           =6 #define VSTD_ENABLE_DEFAULT_INTCTRL
           =6 #endif
           =6 
           =6 #ifndef VSTD_ENABLE_GLOBAL_LOCK
           =6 #define VSTD_ENABLE_GLOBAL_LOCK
           =6 #endif
           =6 
           =6 #ifndef VSTD_DISABLE_DEBUG_SUPPORT
           =6 #define VSTD_DISABLE_DEBUG_SUPPORT
           =6 #endif
           =6 
           =6 #ifndef VSTD_ENABLE_LIBRARY_FUNCTIONS
           =6 #define VSTD_ENABLE_LIBRARY_FUNCTIONS
           =6 #endif
           =6 
           =6 
           =6 #define VGEN_ENABLE_CAN_DRV
           =6 #define C_ENABLE_CAN_CHANNELS
           =6 #define V_BUSTYPE_CAN
           =6 #define VGEN_ENABLE_IL_VECTOR
           =6 #define VGEN_ENABLE_NM_BASIC
           =6 #define VGEN_ENABLE_TP_ISO_MC
           =6 
           =6 
           =6 #ifndef kVNumberOfIdentities
           =6 #define kVNumberOfIdentities                 1
           =6 #endif
           =6 
           =6 #ifndef tVIdentityMsk
           =6 #define tVIdentityMsk                        vuint8
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 252 

           =6 #endif
           =6 
           =6 #ifndef kVIdentityIdentity_0
           =6 #define kVIdentityIdentity_0                 (vuint8) 0
           =6 #endif
           =6 
           =6 #ifndef VSetActiveIdentity
           =6 #define VSetActiveIdentity(identityLog)
           =6 #endif
           =6 
           =6 #ifndef V_ACTIVE_IDENTITY_MSK
           =6 #define V_ACTIVE_IDENTITY_MSK                1
           =6 #endif
           =6 
           =6 #ifndef V_ACTIVE_IDENTITY_LOG
           =6 #define V_ACTIVE_IDENTITY_LOG                0
           =6 #endif
           =6 
           =6 
           =6 #define DIAG_API_CALL_TYPE
           =6 #define DIAG_API_CALLBACK_TYPE
           =6 #define DIAG_INTERNAL_CALL_TYPE
           =6 #define DRV_API_CALL_TYPE
           =6 #define DRV_API_CALLBACK_TYPE
           =6 #define TP_API_CALL_TYPE
           =6 #define TP_API_CALLBACK_TYPE
           =6 #define TP_INTERNAL_CALL_TYPE
           =6 
           =6 /* -----------------------------------------------------------------------------
           =6     &&&~ Versions of Preconfig Files
           =6  ----------------------------------------------------------------------------- */
           =6 
           =6 #define VGEN_OEM_PRECONFIG_HMC_SLP5
           =6 #define VGEN_OEM_PRECONFIG_VERSION           0x0101
           =6 #define VGEN_OEM_PRECONFIG_RELEASE_VERSION   0x00
           =6 #define VGEN_USER_PRECONFIG_HMC_SLP5_HIGH_SPEED
           =6 #define VGEN_USER_PRECONFIG_VERSION          0x0000
           =6 #define VGEN_USER_PRECONFIG_RELEASE_VERSION  0x00
           =6 
           =6 
           =6 /* -----------------------------------------------------------------------------
           =6     &&&~ Optimization
           =6  ----------------------------------------------------------------------------- */
           =6 
           =6 #define V_ATOMIC_BIT_ACCESS_IN_BITFIELD      STD_OFF
           =6 #define V_ATOMIC_VARIABLE_ACCESS             16
           =6 
           =6 
           =6 
           =6 #ifndef VGEN_ENABLE_VSTDLIB
           =6 /* Diag_CanDesc requires VSTDLIB */
           =6 #define VGEN_ENABLE_VSTDLIB
           =6 #endif
           =6 
           =6 #ifndef C_CLIENT_HMC
           =6 #define C_CLIENT_HMC
           =6 #endif
           =6 
           =6 #ifndef __PGS__
           =6 #define __PGS__
           =6 #endif
           =6 
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 253 

           =6 /* -----------------------------------------------------------------------------
           =6     &&&~ Compatibility defines for ComSetCurrentECU
           =6  ----------------------------------------------------------------------------- */
           =6 
           =6 #ifndef kComNumberOfNodes
           =6 #define kComNumberOfNodes                    kVNumberOfIdentities
           =6 #endif
           =6 
           =6 #ifndef ComSetCurrentECU
           =6 #define ComSetCurrentECU                     VSetActiveIdentity
           =6 #endif
           =6 
           =6 #ifndef comMultipleECUCurrent
           =6 #define comMultipleECUCurrent                vActiveIdentityLog
           =6 #endif
           =6 
           =6 
           =6 
           =6 #define C_VERSION_REF_IMPLEMENTATION         0x150
           =6 
           =6 
           =6 #ifndef VGEN_ENABLE_VSTDLIB
           =6 /* DrvCan__baseRi15 requires VSTDLIB */
           =6 #define VGEN_ENABLE_VSTDLIB
           =6 #endif
           =6 
           =6 #ifndef VGEN_ENABLE_VSTDLIB
           =6 #define VGEN_ENABLE_VSTDLIB
           =6 #endif
           =6 
           =6 
           =6 #ifndef VGEN_ENABLE_VSTDLIB
           =6 /* TpMC requires VSTDLIB */
           =6 #define VGEN_ENABLE_VSTDLIB
           =6 #endif
           =6 
           =6 
           =6 
           =6 /* begin Fileversion check */
           =6 #ifndef SKIP_MAGIC_NUMBER
           =6 #ifdef MAGIC_NUMBER
           =6   #if MAGIC_NUMBER != 204819919
           =6       #error "The magic number of the generated file <Y:\CANGEN\v_cfg.h> is different. Please check time a
             -nd date of generated files!"
           =6   #endif
           =6 #else
           =6   #define MAGIC_NUMBER 204819919
           =6 #endif  /* MAGIC_NUMBER */
           =6 #endif  /* SKIP_MAGIC_NUMBER */
           =6 
           =6 /* end Fileversion check */
           =6 
           =6 #endif /* __V_CFG_H__ */
  51      =5  #include "drv_par.h"
   1      =6  /* -----------------------------------------------------------------------------
   2      =6    Filename:    drv_par.h
   3      =6    Description: Toolversion: 05.00.51.01.30.02.86.01.00.00
   4      =6                 
   5      =6                 Serial Number: CBD1300286
   6      =6                 Customer Info: Hyundai Mobis Co., Ltd.
   7      =6                                Package: CBD Hmc SLP5 - CBD License f. HKMC
   8      =6                                Micro: C8051F582
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 254 

   9      =6                                Compiler: Keil PK51
  10      =6                 
  11      =6                 
  12      =6                 Generator Fwk   : GENy 
  13      =6                 Generator Module: GenTool_GenyDriverBase
  14      =6                 
  15      =6                 Configuration   : Y:\20150903_DiagCam_DE.gny
  16      =6                 
  17      =6                 ECU: 
  18      =6                         TargetSystem: Hw_Slc8051Cpu
  19      =6                         Compiler:     KEIL
  20      =6                         Derivates:    C8051F58x_59x
  21      =6                 
  22      =6                 Channel "Channel0":
  23      =6                         Databasefile: Y:\20150206_JF_DiagCamera_CAN_DB_R6(LangInfo).dbc
  24      =6                         Bussystem:    CAN
  25      =6                         Manufacturer: HMC
  26      =6                         Node:         PGS
  27      =6  
  28      =6    Generated by , 2015-10-19  18:50:07
  29      =6   ----------------------------------------------------------------------------- */
  30      =6  /* -----------------------------------------------------------------------------
  31      =6    C O P Y R I G H T
  32      =6   -------------------------------------------------------------------------------
  33      =6    Copyright (c) 2001-2011 by Vector Informatik GmbH. All rights reserved.
  34      =6   
  35      =6    This software is copyright protected and proprietary to Vector Informatik 
  36      =6    GmbH.
  37      =6    
  38      =6    Vector Informatik GmbH grants to you only those rights as set out in the 
  39      =6    license conditions.
  40      =6    
  41      =6    All other rights remain with Vector Informatik GmbH.
  42      =6   -------------------------------------------------------------------------------
  43      =6   ----------------------------------------------------------------------------- */
  44      =6  
  45      =6  #if !defined(__DRV_PAR_H__)
  46      =6  #define __DRV_PAR_H__
  47      =6  
  48      =6  /* -----------------------------------------------------------------------------
  49      =6      &&&~ Signal Structures
  50      =6   ----------------------------------------------------------------------------- */
  51      =6  
  52      =6  typedef struct _c_MDPS11_msgTypeTag
  53      =6  {
  54      =6    vbittype unused0 : 8;
  55      =6    vbittype unused1 : 8;
  56      =6    vbittype unused2 : 8;
  57      =6    vbittype unused3 : 8;
  58      =6    vbittype unused4 : 8;
  59      =6    vbittype unused5 : 8;
  60      =6    vbittype unused6 : 8;
  61      =6    vbittype unused7 : 5;
  62      =6    vbittype CF_Mdps_Type : 2;
  63      =6    vbittype unused8 : 1;
  64      =6  } _c_MDPS11_msgType;
  65      =6  typedef struct _c_HU_MON_PE_01_msgTypeTag
  66      =6  {
  67      =6    vbittype HU_TYPE : 8;
  68      =6  } _c_HU_MON_PE_01_msgType;
  69      =6  typedef struct _c_CGW4_msgTypeTag
  70      =6  {
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 255 

  71      =6    vbittype unused0 : 8;
  72      =6    vbittype unused1 : 8;
  73      =6    vbittype unused2 : 8;
  74      =6    vbittype unused3 : 8;
  75      =6    vbittype unused4 : 8;
  76      =6    vbittype unused5 : 8;
  77      =6    vbittype unused6 : 7;
  78      =6    vbittype CF_Gway_Navi_On_Off : 1;
  79      =6  } _c_CGW4_msgType;
  80      =6  typedef struct _c_CGW2_msgTypeTag
  81      =6  {
  82      =6    vbittype unused0 : 8;
  83      =6    vbittype unused1 : 8;
  84      =6    vbittype unused2 : 8;
  85      =6    vbittype unused3 : 2;
  86      =6    vbittype CF_Gway_CountryCfg : 3;
  87      =6    vbittype unused4 : 3;
  88      =6  } _c_CGW2_msgType;
  89      =6  typedef struct _c_CLU15_msgTypeTag
  90      =6  {
  91      =6    vbittype unused0 : 8;
  92      =6    vbittype unused1 : 8;
  93      =6    vbittype unused2 : 8;
  94      =6    vbittype unused3 : 8;
  95      =6    vbittype unused4 : 1;
  96      =6    vbittype CF_Clu_LanguageInfo : 5;
  97      =6    vbittype unused5 : 2;
  98      =6  } _c_CLU15_msgType;
  99      =6  typedef struct _c_PGS_GST_msgTypeTag
 100      =6  {
 101      =6    vbittype PGS_GST_Byte0_TPCI : 8;
 102      =6    vbittype PGS_GST_Byte1_Data : 8;
 103      =6    vbittype PGS_GST_Byte2_Data : 8;
 104      =6    vbittype PGS_GST_Byte3_Data : 8;
 105      =6    vbittype PGS_GST_Byte4_Data : 8;
 106      =6    vbittype PGS_GST_Byte5_Data : 8;
 107      =6    vbittype PGS_GST_Byte6_Data : 8;
 108      =6    vbittype PGS_GST_Byte7_Data : 8;
 109      =6  } _c_PGS_GST_msgType;
 110      =6  typedef struct _c_SAS1_msgTypeTag
 111      =6  {
 112      =6    vbittype SAS_Angle_0 : 8;
 113      =6    vbittype SAS_Angle_1 : 8;
 114      =6  } _c_SAS1_msgType;
 115      =6  
 116      =6  
 117      =6  /* -----------------------------------------------------------------------------
 118      =6      &&&~ Signal value names
 119      =6   ----------------------------------------------------------------------------- */
 120      =6  
 121      =6  
 122      =6  
 123      =6  /* -----------------------------------------------------------------------------
 124      =6      &&&~ Message Unions
 125      =6   ----------------------------------------------------------------------------- */
 126      =6  
 127      =6  typedef union _c_MDPS11_bufTag
 128      =6  {
 129      =6    vuint8 _c[8];
 130      =6    _c_MDPS11_msgType MDPS11;
 131      =6  } _c_MDPS11_buf;
 132      =6  typedef union _c_HU_MON_PE_01_bufTag
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 256 

 133      =6  {
 134      =6    vuint8 _c[1];
 135      =6    _c_HU_MON_PE_01_msgType HU_MON_PE_01;
 136      =6  } _c_HU_MON_PE_01_buf;
 137      =6  typedef union _c_CGW4_bufTag
 138      =6  {
 139      =6    vuint8 _c[7];
 140      =6    _c_CGW4_msgType CGW4;
 141      =6  } _c_CGW4_buf;
 142      =6  typedef union _c_CGW2_bufTag
 143      =6  {
 144      =6    vuint8 _c[4];
 145      =6    _c_CGW2_msgType CGW2;
 146      =6  } _c_CGW2_buf;
 147      =6  typedef union _c_CLU15_bufTag
 148      =6  {
 149      =6    vuint8 _c[5];
 150      =6    _c_CLU15_msgType CLU15;
 151      =6  } _c_CLU15_buf;
 152      =6  typedef union _c_PGS_GST_bufTag
 153      =6  {
 154      =6    vuint8 _c[8];
 155      =6    _c_PGS_GST_msgType PGS_GST;
 156      =6  } _c_PGS_GST_buf;
 157      =6  typedef union _c_SAS1_bufTag
 158      =6  {
 159      =6    vuint8 _c[2];
 160      =6    _c_SAS1_msgType SAS1;
 161      =6  } _c_SAS1_buf;
 162      =6  
 163      =6  
 164      =6  /* -----------------------------------------------------------------------------
 165      =6      &&&~ Message Buffers
 166      =6   ----------------------------------------------------------------------------- */
 167      =6  
 168      =6  /* RAM CATEGORY 2 START */
 169      =6  V_MEMRAM0 extern  V_MEMRAM1 _c_MDPS11_buf V_MEMRAM2 MDPS11;
 170      =6  /* RAM CATEGORY 2 END */
 171      =6  
 172      =6  /* RAM CATEGORY 2 START */
 173      =6  V_MEMRAM0 extern  V_MEMRAM1 _c_HU_MON_PE_01_buf V_MEMRAM2 HU_MON_PE_01;
 174      =6  /* RAM CATEGORY 2 END */
 175      =6  
 176      =6  /* RAM CATEGORY 2 START */
 177      =6  V_MEMRAM0 extern  V_MEMRAM1 _c_CGW4_buf V_MEMRAM2 CGW4;
 178      =6  /* RAM CATEGORY 2 END */
 179      =6  
 180      =6  /* RAM CATEGORY 2 START */
 181      =6  V_MEMRAM0 extern  V_MEMRAM1 _c_CGW2_buf V_MEMRAM2 CGW2;
 182      =6  /* RAM CATEGORY 2 END */
 183      =6  
 184      =6  /* RAM CATEGORY 2 START */
 185      =6  V_MEMRAM0 extern  V_MEMRAM1 _c_CLU15_buf V_MEMRAM2 CLU15;
 186      =6  /* RAM CATEGORY 2 END */
 187      =6  
 188      =6  /* RAM CATEGORY 2 START */
 189      =6  /* RAM CATEGORY 2 END */
 190      =6  
 191      =6  /* RAM CATEGORY 2 START */
 192      =6  V_MEMRAM0 extern  V_MEMRAM1 _c_PGS_GST_buf V_MEMRAM2 PGS_GST;
 193      =6  /* RAM CATEGORY 2 END */
 194      =6  
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 257 

 195      =6  /* RAM CATEGORY 2 START */
 196      =6  /* RAM CATEGORY 2 END */
 197      =6  
 198      =6  /* RAM CATEGORY 2 START */
 199      =6  V_MEMRAM0 extern  V_MEMRAM1 _c_SAS1_buf V_MEMRAM2 SAS1;
 200      =6  /* RAM CATEGORY 2 END */
 201      =6  
 202      =6  
 203      =6  
 204      =6  
 205      =6  
 206      =6  
 207      =6  /* begin Fileversion check */
 208      =6  #ifndef SKIP_MAGIC_NUMBER
 209      =6  #ifdef MAGIC_NUMBER
 210      =6    #if MAGIC_NUMBER != 204819919
           =6       #error "The magic number of the generated file <Y:\CANGEN\drv_par.h> is different. Please check time
             - and date of generated files!"
           =6   #endif
 213      =6  #else
           =6   #define MAGIC_NUMBER 204819919
           =6 #endif  /* MAGIC_NUMBER */
 216      =6  #endif  /* SKIP_MAGIC_NUMBER */
 217      =6  
 218      =6  /* end Fileversion check */
 219      =6  
 220      =6  #endif /* __DRV_PAR_H__ */
  52      =5  
  53      =5  #include "nmb_cfg.h"
   1      =6  /* -----------------------------------------------------------------------------
   2      =6    Filename:    nmb_cfg.h
   3      =6    Description: Toolversion: 05.00.51.01.30.02.86.01.00.00
   4      =6                 
   5      =6                 Serial Number: CBD1300286
   6      =6                 Customer Info: Hyundai Mobis Co., Ltd.
   7      =6                                Package: CBD Hmc SLP5 - CBD License f. HKMC
   8      =6                                Micro: C8051F582
   9      =6                                Compiler: Keil PK51
  10      =6                 
  11      =6                 
  12      =6                 Generator Fwk   : GENy 
  13      =6                 Generator Module: Nm_PwrTrainBasic
  14      =6                 
  15      =6                 Configuration   : Y:\20150903_DiagCam_DE.gny
  16      =6                 
  17      =6                 ECU: 
  18      =6                         TargetSystem: Hw_Slc8051Cpu
  19      =6                         Compiler:     KEIL
  20      =6                         Derivates:    C8051F58x_59x
  21      =6                 
  22      =6                 Channel "Channel0":
  23      =6                         Databasefile: Y:\20150206_JF_DiagCamera_CAN_DB_R6(LangInfo).dbc
  24      =6                         Bussystem:    CAN
  25      =6                         Manufacturer: HMC
  26      =6                         Node:         PGS
  27      =6  
  28      =6    Generated by , 2015-10-19  18:50:07
  29      =6   ----------------------------------------------------------------------------- */
  30      =6  /* -----------------------------------------------------------------------------
  31      =6    C O P Y R I G H T
  32      =6   -------------------------------------------------------------------------------
  33      =6    Copyright (c) 2001-2011 by Vector Informatik GmbH. All rights reserved.
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 258 

  34      =6   
  35      =6    This software is copyright protected and proprietary to Vector Informatik 
  36      =6    GmbH.
  37      =6    
  38      =6    Vector Informatik GmbH grants to you only those rights as set out in the 
  39      =6    license conditions.
  40      =6    
  41      =6    All other rights remain with Vector Informatik GmbH.
  42      =6   -------------------------------------------------------------------------------
  43      =6   ----------------------------------------------------------------------------- */
  44      =6  
  45      =6  #if !defined(__NMB_CFG_H__)
  46      =6  #define __NMB_CFG_H__
  47      =6  
  48      =6  /* Compatibility with other generation tools */
  49      =6  #define __NMBASIC_CFG_H__
  50      =6  /* Version */
  51      =6  #define NM_BASICDLL_VERSION                  0x0104
  52      =6  #define NM_BASICDLL_RELEASE_VERSION          0x00
  53      =6  #define cNmBasicNrOfChannels                 1
  54      =6  /* Nm instance properties */
  55      =6  #define NM_TYPE_BASIC
  56      =6  /* Options */
  57      =6  #define NMBASIC_ENABLE_SOFTWARE_CHECK
  58      =6  #define NMBASIC_BUSOFF_RECOV_EXTENDED
  59      =6  #define NMBASIC_DISABLE_BUSOFFREP_TIMER
  60      =6  #define NMBASIC_ENABLE_BUSOFFREP_MSG
  61      =6  /* Support for indexed NM */
  62      =6  #define NMBASIC_DISABLE_INDEXED_NM
  63      =6  #define NMBASIC_DISABLE_TX_OBSERVATION
  64      =6  #define NMBASIC_DISABLE_EXTERNAL_CANONLINE_HANDLING
  65      =6  #define NMBASIC_DISABLE_EARLY_BUSOFF_REINIT
  66      =6  #define NMBASIC_DISABLE_SET_CONTEXT
  67      =6  #define NMBASIC_DISABLE_GET_CONTEXT
  68      =6  /* Nm channel properties */
  69      =6  #define cNmBasicInitObject                   0
  70      =6  #define cNmBasicTaskPeriod                   10
  71      =6  #define cNmBasicBusOffRecTime                50
  72      =6  #define cNmBasicBusOffRecTimeSlow            100
  73      =6  #define cNmBasicBusOffChangeFastToSlow       500
  74      =6  #define cNmBasicBusOffRepairedTime           2000
  75      =6  
  76      =6  /* begin Fileversion check */
  77      =6  #ifndef SKIP_MAGIC_NUMBER
  78      =6  #ifdef MAGIC_NUMBER
  79      =6    #if MAGIC_NUMBER != 204819919
           =6       #error "The magic number of the generated file <Y:\CANGEN\nmb_cfg.h> is different. Please check time
             - and date of generated files!"
           =6   #endif
  82      =6  #else
           =6   #define MAGIC_NUMBER 204819919
           =6 #endif  /* MAGIC_NUMBER */
  85      =6  #endif  /* SKIP_MAGIC_NUMBER */
  86      =6  
  87      =6  /* end Fileversion check */
  88      =6  
  89      =6  #endif /* __NMB_CFG_H__ */
  54      =5  #include "tpmc.h"
           =2 
           =2 
           =2 
           =2 /******************************************************************************
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 259 

           =2 * compatibility to older generation tool versions
           =2 ******************************************************************************/
           =2 #if defined (TP_ENABLE_FC_SUPRESS)
           =2 # define TP_ENABLE_FC_SUPPRESS
           =2 #endif
           =2 #if defined (V_ENABLE_VSTDLIB)
           =2 # if !defined (VGEN_ENABLE_VSTDLIB)
           =2 #  define VGEN_ENABLE_VSTDLIB
           =2 # endif
           =2 #endif
           =2 
           =2 #if defined (TP_USE_NORMAL_ADDRESSING)
           =2 # if (TP_USE_NORMAL_ADDRESSING == kTpOn)
           =2 #  ifndef TP_ENABLE_NORMAL_ADDRESSING
           =2  #define TP_ENABLE_NORMAL_ADDRESSING
           =2 #  endif
           =2 # else /* (TP_USE_NORMAL_ADDRESSING == kTpOff) */
           =2 #  ifndef TP_DISABLE_NORMAL_ADDRESSING
           =2  #define TP_DISABLE_NORMAL_ADDRESSING
           =2 #  endif
           =2 # endif
           =2 #else 
           =2 # if (!defined(TP_ENABLE_NORMAL_ADDRESSING) && !defined(TP_DISABLE_NORMAL_ADDRESSING))
           =2  #define TP_DISABLE_NORMAL_ADDRESSING
           =2 # endif
           =2 #endif
           =2 #if defined (TP_USE_NORMAL_FIXED_ADDRESSING)
           =2 # if (TP_USE_NORMAL_FIXED_ADDRESSING == kTpOn)
           =2  #define TP_ENABLE_NORMAL_FIXED_ADDRESSING
           =2 # else /* (TP_USE_NORMAL_FIXED_ADDRESSING == kTpOff) */
           =2 #  ifndef TP_DISABLE_NORMAL_FIXED_ADDRESSING
           =2  #define TP_DISABLE_NORMAL_FIXED_ADDRESSING
           =2 #  endif
           =2 # endif
           =2 #else 
           =2 # if (!defined(TP_DISABLE_NORMAL_FIXED_ADDRESSING))
           =2  #define TP_DISABLE_NORMAL_FIXED_ADDRESSING
           =2 # endif
           =2 #endif
           =2 #if defined (TP_USE_EXTENDED_ADDRESSING)
           =2 # if (TP_USE_EXTENDED_ADDRESSING == kTpOn)
           =2  #define TP_ENABLE_EXTENDED_ADDRESSING
           =2 # else /* (TP_USE_EXTENDED_ADDRESSING == kTpOff) */
           =2 #  ifndef TP_DISABLE_EXTENDED_ADDRESSING
           =2  #define TP_DISABLE_EXTENDED_ADDRESSING
           =2 #  endif
           =2 # endif
           =2 #else 
           =2 # if (!defined(TP_DISABLE_EXTENDED_ADDRESSING))
           =2  #define TP_DISABLE_EXTENDED_ADDRESSING
           =2 # endif
           =2 #endif
           =2 #if defined (TP_USE_MIXED_29_ADDRESSING)
           =2 # if (TP_USE_MIXED_29_ADDRESSING == kTpOn)
           =2  #define TP_ENABLE_MIXED_29_ADDRESSING
           =2 # else /* (TP_USE_MIXED_29_ADDRESSING == kTpOff) */
           =2 #  ifndef TP_DISABLE_MIXED_29_ADDRESSING
           =2  #define TP_DISABLE_MIXED_29_ADDRESSING
           =2 #  endif
           =2 # endif
           =2 #else 
           =2 # if (!defined(TP_DISABLE_MIXED_29_ADDRESSING))
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 260 

           =2  #define TP_DISABLE_MIXED_29_ADDRESSING
           =2 # endif
           =2 #endif
           =2 #if defined (TP_USE_MIXED_11_ADDRESSING)
           =2 # if (TP_USE_MIXED_11_ADDRESSING == kTpOn)
           =2  #define TP_ENABLE_MIXED_11_ADDRESSING
           =2 # else /* (TP_USE_MIXED_11_ADDRESSING == kTpOff) */
           =2 #  ifndef TP_DISABLE_MIXED_11_ADDRESSING
           =2  #define TP_DISABLE_MIXED_11_ADDRESSING
           =2 #  endif
           =2 # endif
           =2 #else 
           =2 # if (!defined(TP_DISABLE_MIXED_11_ADDRESSING))
           =2  #define TP_DISABLE_MIXED_11_ADDRESSING
           =2 # endif
           =2 #endif
           =2 #if defined (TP_USE_DYN_ID)
           =2 # if (TP_USE_DYN_ID == kTpOn)
           =2 #   define TP_ENABLE_DYNAMIC_CHANNELS
           =2 # else /* (TP_USE_DYN_ID == kTpOff) */
           =2 #  ifndef TP_DISABLE_DYNAMIC_CHANNELS
           =2 #   define TP_DISABLE_DYNAMIC_CHANNELS
           =2 #  endif
           =2 # endif
           =2 #else 
           =2 # if (!defined(TP_DISABLE_DYNAMIC_CHANNELS))
           =2 # error Static/Dynamic channel not specified
           =2 # endif
           =2 #endif
           =2 
           =2 #if defined (TP_USE_VARIABLE_DLC)
           =2 # if (TP_USE_VARIABLE_DLC == kTpOn)
           =2 #  ifndef TP_ENABLE_VARIABLE_DLC
           =2 #   define TP_ENABLE_VARIABLE_DLC
           =2 #  endif
           =2 # else /* (TP_USE_VARIABLE_DLC == kTpOff) */
           =2 #  ifndef TP_DISABLE_VARIABLE_DLC
           =2 #   define TP_DISABLE_VARIABLE_DLC
           =2 #  endif
           =2 # endif
           =2 #endif
           =2 
           =2 #if !defined( TP_USE_WAIT_FOR_CORRECT_SN )
           =2 # define TP_USE_WAIT_FOR_CORRECT_SN kTpOff
           =2 #else
           =2 # if (TP_USE_WAIT_FOR_CORRECT_SN == kTpOn)
           =2 #  if !defined (TP_ENABLE_WAIT_FOR_CORRECT_SN)
           =2 #   define TP_ENABLE_WAIT_FOR_CORRECT_SN
           =2 #  endif
           =2 # endif
           =2 #endif
           =2 
           =2 #if !defined (TP_ENABLE_SINGLE_MSG_OBJ)
           =2 #else
           =2 # if (!defined (TP_ENABLE_CHECKTA_COMPATIBILITY) && !defined (TP_DISABLE_CHECKTA_COMPATIBILITY))
           =2   /* check for GENy compatible version */
           =2 #  if ((TP_ISO15765DLL_VERSION == 0x0202) && (TP_ISO15765DLL_RELEASE_VERSION > 0x01)) || (TP_ISO15765DLL_V
             -ERSION > 0x0202)
           =2    /* use new prototype version of ApplTpCheckTA */
           =2 #   define TP_DISABLE_CHECKTA_COMPATIBILITY
           =2 #  else
           =2    /* no compatible GENy version detected - use compatibility mode */
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 261 

           =2 #   define TP_ENABLE_CHECKTA_COMPATIBILITY
           =2 #  endif
           =2 # endif
           =2 #endif
           =2 
           =2 /*******************************************************************************
           =2 * set switches to default
           =2 *******************************************************************************/
           =2 #ifndef kTpNumberOfCanChannels
           =2 # define kTpNumberOfCanChannels kCanNumberOfChannels
           =2 #endif
           =2 #if ( (defined (C_MULTIPLE_RECEIVE_CHANNEL)) )
           =2 #else
           =2 # if ( kTpNumberOfCanChannels > 1 ) /* more than one CanChannel ? */
           =2 #  define TP_CAN_CODEDOUBLED    
           =2 # endif
           =2 #endif
           =2 #if ((!defined (TP_DISABLE_DYNAMIC_CHANNELS)))
           =2 # define TP_DISABLE_DYNAMIC_CHANNELS
           =2 #endif
           =2 
           =2 #if defined (TP_ENABLE_SINGLE_CHANNEL_TP)
           =2 #else
           =2 # ifndef TP_ENABLE_MULTI_CHANNEL_TP
           =2 #  define TP_ENABLE_MULTI_CHANNEL_TP
           =2 # endif
           =2 #endif
           =2 # ifndef TP_DISABLE_MULTIPLE_ADDRESSING
           =2 #  define TP_DISABLE_MULTIPLE_ADDRESSING
           =2 # endif
           =2 
           =2 #if defined (TP_ENABLE_ISO_15765_2_2)
           =2 #else
           =2 # ifndef TP_DISABLE_ISO_15765_2_2
           =2 #  define TP_DISABLE_ISO_15765_2_2
           =2 # endif
           =2 #endif
           =2 
           =2 #ifndef TP_USE_PRE_DISPATCHED_MODE
           =2 # define TP_USE_PRE_DISPATCHED_MODE           kTpOff
           =2 #endif
           =2 #if (TP_USE_PRE_DISPATCHED_MODE == kTpOn)
           =2 # define TP_ENABLE_PRE_DISPATCHED_MODE
           =2 #else
           =2 # define TP_DISABLE_PRE_DISPATCHED_MODE
           =2 #endif
           =2 
           =2 #ifndef TP_USE_CONNECTIONS 
           =2  #define TP_USE_CONNECTIONS                   kTpOn
           =2 #endif
           =2 #ifndef TP_USE_FAST_PRECOPY
           =2  #define TP_USE_FAST_PRECOPY                  kTpOff
           =2 #endif
           =2 #ifndef TP_USE_DIAGPRECOPY
           =2  #define TP_USE_DIAGPRECOPY                   kTpOff
           =2 #endif
           =2 #ifndef TP_USE_CHANNEL_0_FOR_SPECIAL_PURPOSE
           =2  #define TP_USE_CHANNEL_0_FOR_SPECIAL_PURPOSE kTpOff
           =2 #endif
           =2 #ifndef TP_USE_WAIT_FRAMES
           =2  #define TP_USE_WAIT_FRAMES                   kTpOff
           =2 #endif
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 262 

           =2 
           =2 #if ( (!defined(TP_ENABLE_MCAN)) && (!defined(TP_DISABLE_MCAN)) )
           =2 # define TP_DISABLE_MCAN
           =2 #endif
           =2 #if ( (!defined(VGEN_ENABLE_TP_MCAN)) && (!defined(VGEN_DISABLE_TP_MCAN)) )
           =2 # define VGEN_DISABLE_TP_MCAN
           =2 #endif
           =2 #if ( (!defined(TP_ENABLE_MF_RECEPTION)) && (!defined(TP_DISABLE_MF_RECEPTION)) )
           =2 # define TP_ENABLE_MF_RECEPTION
           =2 #endif
           =2 #ifndef TP_USE_APPL_PRECOPY
           =2  #define TP_USE_APPL_PRECOPY                  kTpOff
           =2 #endif
           =2 #ifndef TP_USE_GATEWAY_API
           =2  #define TP_USE_GATEWAY_API                   kTpOff
           =2 #endif
           =2 #ifndef TP_USE_EXTENDED_API_STMIN
           =2  #define TP_USE_EXTENDED_API_STMIN            kTpOff
           =2 #endif
           =2 #ifndef TP_USE_RX_CHANNEL_WITHOUT_FC
           =2 # define TP_USE_RX_CHANNEL_WITHOUT_FC         kTpOff
           =2 #endif
           =2 #ifndef TP_USE_TX_CHANNEL_WITHOUT_FC
           =2 # define TP_USE_TX_CHANNEL_WITHOUT_FC         kTpOff
           =2 #endif
           =2 #ifndef TP_USE_MULTIPLE_ECU_NR
           =2 # define TP_USE_MULTIPLE_ECU_NR               kTpOff
           =2 #endif
           =2 #ifndef TP_USE_MULTIPLE_ECU
           =2 # define TP_USE_MULTIPLE_ECU                  kTpOff
           =2 #endif
           =2 #ifndef TP_USE_MULTIPLE_BASEADDRESS
           =2 # define TP_USE_MULTIPLE_BASEADDRESS          kTpOff
           =2 #endif
           =2 #ifndef TP_USE_TX_ERROR_IND_COMPATIBILITY
           =2 # define TP_USE_TX_ERROR_IND_COMPATIBILITY    kTpOff
           =2 #endif
           =2 #ifndef TP_USE_TX_HANDLE_CHANGEABLE
           =2 # define TP_USE_TX_HANDLE_CHANGEABLE          kTpOff
           =2 #endif
           =2 #ifndef TP_USE_EXT_IDS_FOR_NORMAL
           =2 # define TP_USE_EXT_IDS_FOR_NORMAL            kTpOff
           =2 #endif
           =2 #ifndef TP_USE_MIXED_IDS_FOR_NORMAL
           =2 # define TP_USE_MIXED_IDS_FOR_NORMAL          kTpOff
           =2 #endif
           =2 
           =2 #ifndef TP_USE_STRICT_MSG_FLOW_CHECKING
           =2 /* 7.4.4.2  FlowStatus error handling
           =2 If a FlowControl N_PDU message is received with an invalid FlowStatus parameter value then
           =2 proper error handling shall take place in the network layer. The message transmission shall
           =2 be aborted, and the network layer shall make a N_USData.indication service call with
           =2 the parameter <N_Result> = N_INVALID_FS to the adjacent upper layer. */
           =2 # define TP_USE_STRICT_MSG_FLOW_CHECKING     kTpOn
           =2 #endif
           =2 
           =2 #if (!defined (TP_ENABLE_FC_MSG_FLOW_DYN_CHECK) && !defined(TP_DISABLE_FC_MSG_FLOW_DYN_CHECK))
           =2 # define TP_DISABLE_FC_MSG_FLOW_DYN_CHECK
           =2 #endif
           =2 
           =2 #if (!defined(TP_ENABLE_VARIABLE_DLC) && !defined(TP_DISABLE_VARIABLE_DLC))
           =2 # define TP_DISABLE_VARIABLE_DLC
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 263 

           =2 #endif
           =2 
           =2 #if (!defined(TP_DISABLE_IGNORE_CONTENT_FC))
           =2 # define TP_DISABLE_IGNORE_CONTENT_FC
           =2 #endif
           =2 
           =2 #if !defined (TP_ENABLE_WAIT_FOR_CORRECT_SN) && !defined (TP_DISABLE_WAIT_FOR_CORRECT_SN)
           =2 # define TP_DISABLE_WAIT_FOR_CORRECT_SN
           =2 #endif
           =2 
           =2 #if (!defined (TP_DISABLE_DYN_AWAIT_CORRECT_SN) && !defined(TP_ENABLE_DYN_AWAIT_CORRECT_SN))
           =2 # define TP_DISABLE_DYN_AWAIT_CORRECT_SN
           =2 #endif
           =2 
           =2 #if !defined (TP_ENABLE_DYN_TX_STMIN_TIMING) &&  !defined(TP_DISABLE_DYN_TX_STMIN_TIMING)
           =2 #define TP_DISABLE_DYN_TX_STMIN_TIMING
           =2 #endif
           =2 
           =2 #if !defined (TP_ENABLE_DYN_CHANNEL_TIMING) &&  !defined(TP_DISABLE_DYN_CHANNEL_TIMING)
           =2 #define TP_DISABLE_DYN_CHANNEL_TIMING
           =2 #endif
           =2 
           =2 #if (!defined (TP_ENABLE_SINGLE_CHAN_MULTICONN) && !defined(TP_DISABLE_SINGLE_CHAN_MULTICONN))
           =2 # define TP_DISABLE_SINGLE_CHAN_MULTICONN
           =2 #endif
           =2 
           =2 #if (!defined (TP_ENABLE_EXT_COPYFROMCAN_API) && !defined(TP_DISABLE_EXT_COPYFROMCAN_API))
           =2 # define TP_DISABLE_EXT_COPYFROMCAN_API
           =2 #endif
           =2 
           =2 #ifndef TP_USE_OLD_STMIN_CALCULATION
           =2 # define TP_USE_OLD_STMIN_CALCULATION         kTpOff
           =2 #endif
           =2 #ifndef TP_USE_PRE_COPY_CHECK 
           =2 # define TP_USE_PRE_COPY_CHECK                kTpOff
           =2 #endif
           =2 #ifndef TP_USE_FAST_TX_TRANSMISSION
           =2 # define TP_USE_FAST_TX_TRANSMISSION          kTpOff
           =2 #endif
           =2 #ifndef TP_USE_ISO_COMPLIANCE
           =2 # define TP_USE_ISO_COMPLIANCE                kTpOff
           =2 #endif
           =2 #ifndef TP_USE_OVERRUN_INDICATION
           =2 # define TP_USE_OVERRUN_INDICATION            kTpOff
           =2 #endif
           =2 #ifndef TP_USE_TX_OF_FC_IN_ISR
           =2 # define TP_USE_TX_OF_FC_IN_ISR              kTpOn 
           =2 #endif
           =2 #ifndef TP_USE_QUEUE_IN_ISR
           =2 # define TP_USE_QUEUE_IN_ISR                  kTpOn 
           =2 #endif
           =2 #ifndef TP_USE_NO_STMIN_AFTER_FC
           =2 # define TP_USE_NO_STMIN_AFTER_FC             kTpOff
           =2 #endif
           =2 #ifndef TP_USE_VARIABLE_RX_DLC_CHECK 
           =2 # define TP_USE_VARIABLE_RX_DLC_CHECK         kTpOn
           =2 #endif
           =2 #ifndef TP_USE_FIX_RX_DLC_CHECK
           =2 # define TP_USE_FIX_RX_DLC_CHECK              kTpOff
           =2 #endif
           =2 #ifndef TP_USE_EXTENDED_API_BS
           =2 # define TP_USE_EXTENDED_API_BS               kTpOff
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 264 

           =2 #endif
           =2 #ifndef TP_USE_ONLY_FIRST_FC
           =2 # define TP_USE_ONLY_FIRST_FC                 kTpOff
           =2 #endif
           =2 
           =2 #ifndef TP_USE_WITHOUT_FC_TPCI_ADDON
           =2 # define TP_USE_WITHOUT_FC_TPCI_ADDON         kTpOff
           =2 #endif
           =2 #ifndef TP_USE_TP_TX_FC
           =2 # define TP_USE_TP_TX_FC                      kTpOff
           =2 #endif
           =2 
           =2 #ifndef TP_HIGH_RX_LOW_TX_PRIORITY
           =2 # define TP_HIGH_RX_LOW_TX_PRIORITY           kTpOn
           =2 #endif
           =2 
           =2 
           =2 #if !defined (TP_USE_STMIN_OF_FC)
           =2 # define TP_USE_STMIN_OF_FC                   kTpOn
           =2 #endif
           =2 
           =2 #if !defined (TP_USE_TP_INDICATION)
           =2 # define TP_USE_TP_INDICATION                 kTpOff
           =2 #endif
           =2 
           =2 #if !defined (TP_USE_TP_RX_SF)
           =2 # define TP_USE_TP_RX_SF                      kTpOff
           =2 #endif
           =2 
           =2 #if !defined (TP_USE_TP_RX_FF)
           =2 # define TP_USE_TP_RX_FF                      kTpOff
           =2 #endif
           =2 
           =2 #if !defined (TP_USE_TP_RX_CF)
           =2 # define TP_USE_TP_RX_CF                      kTpOff
           =2 #endif
           =2 
           =2 #if !defined (TP_USE_TP_RX_GET_BUFFER)
           =2 # define TP_USE_TP_RX_GET_BUFFER              kTpOff
           =2 #endif
           =2 
           =2 #if !defined (TP_USE_TX_ERROR_INDICATION)
           =2 # define TP_USE_TX_ERROR_INDICATION           kTpOff
           =2 #endif
           =2 
           =2 #if !defined (TP_USE_CUSTOM_TX_MEMCPY)
           =2 # define TP_USE_CUSTOM_TX_MEMCPY              kTpOff
           =2 #endif
           =2 
           =2 #if !defined (TP_USE_CUSTOM_RX_MEMCPY)
           =2 # define TP_USE_CUSTOM_RX_MEMCPY              kTpOff
           =2 #endif
           =2 
           =2 #if ( TP_USE_CUSTOM_RX_MEMCPY == kTpOn )
           =2 # if defined( TP_ENABLE_EXT_COPYFROMCAN_API )
           =2 #  if !defined (TP_ENABLE_SINGLE_MSG_OBJ )
           =2 #  endif
           =2 # endif
           =2 #endif
           =2 
           =2 #if !defined (TP_USE_TP_CONFIRMATION)
           =2 # define TP_USE_TP_CONFIRMATION               kTpOff
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 265 

           =2 #endif
           =2 
           =2 #if !defined (TP_USE_TP_NOTIFY_TX)
           =2 # define TP_USE_TP_NOTIFY_TX                  kTpOff
           =2 #endif
           =2 
           =2 #if !defined (TP_USE_TP_CAN_MESSAGE_TRANSMITTED)
           =2 # define TP_USE_TP_CAN_MESSAGE_TRANSMITTED    kTpOff
           =2 #endif
           =2 
           =2 #if !defined (TP_USE_TP_CAN_MESSAGE_RECEIVED)
           =2 # define TP_USE_TP_CAN_MESSAGE_RECEIVED       kTpOff
           =2 #endif
           =2 
           =2 #if ! ( defined(TP_ENABLE_FC_WAIT) || defined(TP_DISABLE_FC_WAIT) )
           =2 # define TP_DISABLE_FC_WAIT
           =2 #endif
           =2 
           =2 #if ! ( defined(TP_ENABLE_FC_SUPPRESS) || defined(TP_DISABLE_FC_SUPPRESS) )
           =2 # define TP_ENABLE_FC_SUPPRESS
           =2 #endif
           =2 
           =2 #if !defined (TP_USE_UNEXPECTED_FC_CANCELATION)
           =2 # define TP_USE_UNEXPECTED_FC_CANCELATION     kTpOff
           =2 #endif
           =2 
           =2 #if !defined (TP_USE_MICROSEC_STMIN)
           =2 # define TP_USE_MICROSEC_STMIN                kTpOn
           =2 #endif
           =2 
           =2 
           =2 #if ! ( defined(TP_ENABLE_TX_ERR_ON_RX_FC_WAIT) || defined(TP_DISABLE_TX_ERR_ON_RX_FC_WAIT) )
           =2 # define TP_DISABLE_TX_ERR_ON_RX_FC_WAIT
           =2 #endif
           =2 
           =2 #if ! ( defined(TP_ENABLE_DYN_EXT_ID) || defined(TP_DISABLE_DYN_EXT_ID) )
           =2 # define TP_DISABLE_DYN_EXT_ID
           =2 #endif
           =2 #if defined( TP_ENABLE_DYN_EXT_ID )
           =2 # define TP_RX_ENABLE_DYN_EXT_ID
           =2 # define TP_RX_ENABLE_DYN_EXT_ID
           =2 #endif
           =2 #if ! ( defined(TP_RX_ENABLE_DYN_EXT_ID) || defined(TP_RX_DISABLE_DYN_EXT_ID) )
           =2 # define TP_RX_DISABLE_DYN_EXT_ID
           =2 #endif
           =2 #if ! ( defined(TP_TX_ENABLE_DYN_EXT_ID) || defined(TP_TX_DISABLE_DYN_EXT_ID) )
           =2 # define TP_TX_DISABLE_DYN_EXT_ID
           =2 #endif
           =2 
           =2 #if ! ( defined(TP_ENABLE_FC_OVERFLOW) || defined(TP_DISABLE_FC_OVERFLOW) )
           =2 #if defined (TP_ENABLE_ISO_15765_2_2)
           =2 #  define TP_ENABLE_FC_OVERFLOW
           =2 # else
           =2 #  define TP_DISABLE_FC_OVERFLOW
           =2 # endif
           =2 #endif
           =2 
           =2 #if ! ( defined (TP_ENABLE_REQUEST_QUEUE) || defined(TP_DISABLE_REQUEST_QUEUE) )
           =2 # if defined (TP_ENABLE_MIN_TIMER)
           =2 #  define TP_ENABLE_REQUEST_QUEUE
           =2 # else
           =2 #  define TP_DISABLE_REQUEST_QUEUE
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 266 

           =2 # endif
           =2 #endif
           =2 
           =2 #if ! (defined (TP_ENABLE_OBD_PRECOPY) || defined(TP_DISABLE_OBD_PRECOPY) )
           =2 # define TP_DISABLE_OBD_PRECOPY
           =2 #endif
           =2 
           =2 #if ! (defined (TP_ENABLE_IGNORE_FC_RES_STMIN) || defined(TP_DISABLE_IGNORE_FC_RES_STMIN) )
           =2 # define TP_DISABLE_IGNORE_FC_RES_STMIN
           =2 #endif
           =2 
           =2 #if ! (defined (TP_ENABLE_CANCEL_FC_RES_STMIN) || defined(TP_DISABLE_CANCEL_FC_RES_STMIN) )
           =2 # define TP_DISABLE_CANCEL_FC_RES_STMIN
           =2 #endif
           =2 
           =2 #if ! (defined (TP_ENABLE_IGNORE_FC_OVFL) || defined(TP_DISABLE_IGNORE_FC_OVFL) )
           =2 # define TP_DISABLE_IGNORE_FC_OVFL
           =2 #endif
           =2 
           =2 #if (TP_USE_PRE_COPY_CHECK == kTpOn)
           =2 # ifndef __ApplTpPreCopyCheckFunction
           =2 # define __ApplTpPreCopyCheckFunction(x)      1
           =2 # endif
           =2 #endif
           =2 
           =2 #ifndef __ApplTpTxDelayFinished
           =2 # if defined (TP_ENABLE_SINGLE_MSG_OBJ)
           =2 #define __ApplTpTxDelayFinished(tpChannel, state)
           =2 # endif
           =2 #endif
           =2 
           =2 #ifndef __ApplTpRxCanMessageTransmitted
           =2 #define __ApplTpRxCanMessageTransmitted(tpChannel)
           =2 #endif
           =2 
           =2 #if defined (TP_DISABLE_DYNAMIC_CHANNELS)         && \
           =2     (defined (TP_ENABLE_NORMAL_ADDRESSING)        )
           =2 #else
           =2 # ifndef __ApplTpTxFC
           =2 # define __ApplTpTxFC(tpChannel)
           =2 # endif
           =2 #endif
           =2 
           =2 #if !defined (TP_USE_PADDING)
           =2 #  if defined (TP_ENABLE_USER_CHECK)
           =2 #   define TP_USE_PADDING                       kTpOn
           =2 #  else
           =2 #   define TP_USE_PADDING                       kTpOff
           =2 #  endif
           =2 #endif
           =2 
           =2 #ifndef TP_PADDING_PATTERN 
           =2 # define TP_PADDING_PATTERN                    0xff
           =2 #endif
           =2 
           =2 #ifndef TP_SECURITY_LEVEL
           =2 # define TP_SECURITY_LEVEL 2 /* highest Security class */
           =2 #endif
           =2 
           =2 #ifndef TP_MEMORY_MODEL_DATA
           =2 # if defined(V_ENABLE_USED_GLOBAL_VAR)
           =2 # endif
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 267 

           =2 #endif
           =2 
           =2 #ifndef TP_MEMORY_MODEL_DATA
           =2 # define TP_MEMORY_MODEL_DATA                  /* V_MEMRAM1_NEAR or V_MEMRAM1_FAR: has to be done via user
             -_cfg */
           =2 #endif
           =2 
           =2 #ifndef TP_API_CALL_TYPE
           =2 # define TP_API_CALL_TYPE 
           =2 #endif
           =2 #ifndef TP_API_CALLBACK_TYPE
           =2 # define TP_API_CALLBACK_TYPE 
           =2 #endif
           =2 #ifndef TP_INTERNAL_CALL_TYPE
           =2 # define TP_INTERNAL_CALL_TYPE 
           =2 #endif
           =2 
           =2 #ifndef TP_EXTERNAL_INLINE
           =2 # define TP_EXTERNAL_INLINE
           =2 #endif
           =2 #ifndef TP_INTERNAL_INLINE
           =2 # define TP_INTERNAL_INLINE
           =2 #endif
           =2 
           =2 #if defined (TP_TEST_ROUTINE_CONF_TIMEOUT)
           =2 /* Make test code harmless */
           =2 # if !defined (TpTestTxCheckForcingConfTimeout)
           =2 #  define TpTestTxCheckForcingConfTimeout()  (1)
           =2 # endif
           =2 # if !defined (TpTestRxCheckForcingConfTimeout)
           =2 #  define TpTestRxCheckForcingConfTimeout()  (1)
           =2 # endif
           =2 #endif
           =2 
           =2 /* Mixed AUTOSAR configuration */
           =2 
           =2 #if defined (TP_ENABLE_SINGLE_MSG_OBJ)
           =2 /* Define PGN */
           =2 /* Define Prio */
           =2 #endif /* TP_ENABLE_SINGLE_MSG_OBJ */
           =2 
           =2 #if (TP_USE_FAST_PRECOPY == kTpOn) && (TP_USE_APPL_PRECOPY == kTpOn) 
           =2 # error Check TA function is not supported in case of optimized range check
           =2 #endif
           =2 
           =2 /* Some micros support configurations where the software is configured in near model             */
           =2 /* but the CAN registers are in far memory. To support this the following switch must be enabled */
           =2 #if (!defined (TP_ENABLE_INTERMEDIATE_CANCHIP_BUFFER) && !defined (TP_DISABLE_INTERMEDIATE_CANCHIP_BUFFER)
             -)
           =2 # define TP_DISABLE_INTERMEDIATE_CANCHIP_BUFFER
           =2 #endif
           =2 
           =2 #if !defined (kTpTimeoutFactorCF)
           =2 # define kTpTimeoutFactorCF     (1)
           =2 #endif
           =2 
           =2 #if !defined (kTpTimeoutFactorFC)
           =2 # define kTpTimeoutFactorFC     (1)
           =2 #endif
           =2 
           =2 
           =2 /* internal switch to cover special use case (physical normal addressing & functional extended addressing)
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 268 

             - */
           =2 #if defined (TP_ENABLE_NORMAL_ADDRESSING) && \
           =2     defined (TP_FUNC_ENABLE_EXTENDED_ADDRESSING)
           =2 # define TP_ENABLE_PHYS_NORMAL_EXT_FUNC_ADDRESSING
           =2 #endif
           =2 
           =2 
           =2 /*******************************************************************************
           =2 * Consistency of switches
           =2 *******************************************************************************/
           =2 #if (TP_USE_MIXED_IDS_FOR_NORMAL == kTpOn)
           =2 #  if (TP_USE_EXT_IDS_FOR_NORMAL == kTpOff)
           =2 #   error "Parallel usage of mixed identifiers (11/29 bit) for normal addressing support requires TP_USE_E
             -XT_IDS_FOR_NORMAL set to kTpOn"
           =2 # endif
           =2 #endif
           =2 
           =2 #if defined (TP_TX_ERROR_IND_COMPATIBILITY)
           =2 # error TP_TX_ERROR_IND_COMPATIBILITY is not supported any more
           =2 #endif 
           =2 
           =2 #define kTpMaxCanChannels 15
           =2 /* CanChannel has 4 bits width */
           =2 #if( kCanNumberOfChannels > kTpMaxCanChannels )
           =2 # error "The number of CAN channels supported is limited to a maximum of 15"
           =2 #endif
           =2 
           =2 #if !defined (C_ENABLE_EXTENDED_ID)
           =2 #endif
           =2 /* Addressing */
           =2 
           =2 # if defined (TP_ENABLE_NORMAL_ADDRESSING)
           =2 #  if defined (TP_ENABLE_NORMAL_MIXED11_ADDRESSING)
           =2 #  else
           =2 #  endif
           =2 # endif
           =2 
           =2 
           =2 
           =2 
           =2 
           =2 #if  (TP_USE_MULTIPLE_BASEADDRESS == kTpOn)
           =2 #  error multiple baseaddresses works only with extended addressing
           =2 #endif
           =2 
           =2 /* TX: Dynamic Id */
           =2 
           =2 #if (TP_USE_APPL_PRECOPY == kTpOn)                || \
           =2     (TP_USE_MULTIPLE_ECU_NR == kTpOn)
           =2 # error GATEWAY_PRECOPY or MULTIPLE_ECU_NR only with EXTENDED_ADDRESSING, NORMAL_FIXED_ADDRESSING and MIXE
             -D_ADDRESSING
           =2 #endif 
           =2 
           =2 
           =2 #if defined (TP_ENABLE_SINGLE_CHANNEL_TP)
           =2 # if (TP_USE_TX_CHANNEL_WITHOUT_FC == kTpOn)
           =2 # error Channel without FlowControl are not supported by SingleConnectionTP
           =2 # endif
           =2 #endif
           =2 
           =2 #if defined (TP_ENABLE_SINGLE_CHANNEL_TP)
           =2 # if (TP_USE_RX_CHANNEL_WITHOUT_FC == kTpOn)
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 269 

           =2 # error Channel without FlowControl are not supported by SingleConnectionTP
           =2 # endif
           =2 #endif
           =2 
           =2 #if defined (TP_ENABLE_VARIABLE_DLC)
           =2 # if (TP_USE_PADDING == kTpOn )
           =2 # error Padding cannot be combined with variable DLC. Deactivate one option.
           =2 # endif
           =2 #endif
           =2 
           =2 #if defined(TP_USE_TX_ID_APPL_CHECK)
           =2 # if (TP_USE_TX_ID_APPL_CHECK == kTpOn)
           =2 # error Feature no longer supported.
           =2 # endif
           =2 #endif
           =2 
           =2 #if defined (TP_ENABLE_REQUEST_QUEUE) &&  defined(TP_DISABLE_MIN_TIMER)
           =2 # error Re-transmission feature only available if observation of minimum sending distance is activated
           =2 #endif
           =2 
           =2 
           =2 #if defined (TP_ENABLE_DYN_AWAIT_CORRECT_SN) &&  !defined(TP_ENABLE_MULTI_CHANNEL_TP)
           =2 # error Dynamic SN check only available for multi channel configurations
           =2 #endif
           =2 
           =2 #if defined (TP_ENABLE_DYN_TX_STMIN_TIMING) 
           =2 # error Dynamic timings only available for dynamic multi channel configurations
           =2 #endif
           =2 
           =2 #if defined (TP_ENABLE_DYN_CHANNEL_TIMING) 
           =2 # error Dynamic timings only available for dynamic multi channel configurations
           =2 #endif
           =2 
           =2 #if defined ( TP_ENABLE_SINGLE_CHAN_MULTICONN )
           =2 # if defined ( TP_ENABLE_SINGLE_CHANNEL_TP ) && \
           =2     (defined( TP_ENABLE_NORMAL_ADDRESSING ) ) 
           =2 # else
           =2 #   error Single TP channel with multiple CAN channels not supported
           =2 # endif
           =2 #endif
           =2 
           =2 #if !defined( kTpWFTmax )
           =2 /* WFTmax not defined: derive WFTmax value from ENABLE_FC_WAIT switch */
           =2 # if defined( TP_ENABLE_FC_WAIT )
           =2 #  define kTpWFTmax     0xFF
           =2 # else
           =2 #  define kTpWFTmax     0x01
           =2 # endif
           =2 typedef vuint8 tWFTmaxType;
           =2 
           =2 #else
           =2 /* WFTmax defined: derive ENABLE_FC_WAIT switch setting from WFTmax value */
           =2 # if ( kTpWFTmax > 0 )
           =2 #  if !defined( TP_ENABLE_FC_WAIT )
           =2 #   define TP_ENABLE_FC_WAIT
           =2 #  endif
           =2 #  if ( kTpWFTmax > 255 )
           =2 typedef vuint16 tWFTmaxType;
           =2 #  else
           =2 typedef vuint8 tWFTmaxType;
           =2 #  endif
           =2 # else
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 270 

           =2 #  if defined( TP_ENABLE_FC_WAIT )
           =2 #   undef  TP_ENABLE_FC_WAIT
           =2 #  endif
           =2 # endif
           =2 #endif
           =2 
           =2 #if !defined( kTpTxWFTmax )
           =2 # if ( (defined( TP_ENABLE_MCAN )) || (defined(VGEN_ENABLE_TP_MCAN)) )
           =2 #  define kTpTxWFTmax     0x00
           =2 # else
           =2 #  define kTpTxWFTmax     0xFF
           =2 # endif
           =2 #endif
           =2 
           =2 #if (!defined (TP_DISABLE_ACKNOWLEDGED_CONNECTION))
           =2 # define TP_DISABLE_ACKNOWLEDGED_CONNECTION
           =2 #endif
           =2 
           =2 # define TP_DISABLE_SF_ACKNOWLEDGE
           =2 
           =2 #if (!defined (TP_ENABLE_STRICT_DL_CHECK) && !defined (TP_DISABLE_STRICT_DL_CHECK))
           =2 # define TP_DISABLE_STRICT_DL_CHECK
           =2 #endif
           =2 
           =2 
           =2 /*******************************************************************************
           =2 * Transport protocol global result codes
           =2 *******************************************************************************/
           =2 #define kTpSuccess            0  /*Everythings fine*/
           =2 #define kTpFailed             1  /*Error*/
           =2 #define kTpBusy               3  /*tpTransmit while tp is running*/
           =2 #define kTpTxBufferUnderrun   4  /*Not enough data to send*/
           =2 
           =2 /* ApplTpTxErrorIndication */
           =2 #define kTpHoldChannel        0
           =2 #define kTpFreeChannel        1
           =2 
           =2 #define kTpNoChannel          0xFF
           =2 #if defined (TP_ENABLE_SINGLE_MSG_OBJ)
           =2 #define kTpTxChannel          0x00
           =2 #define kTpRxChannel          0x80
           =2 #endif
           =2 
           =2 #define kTpChannelInHold      0x03
           =2 #define kTpChannelInUse       0x01
           =2 #define kTpChannelNotInUse    0x00
           =2 
           =2 
           =2 #if( TP_USE_MIXED_IDS_FOR_NORMAL == kTpOn )
           =2 # define kTpCanIdTypeStd           0x00
           =2 # define kTpCanIdTypeExt           0x01
           =2 #endif
           =2 
           =2 #if (defined(TP_ENABLE_FC_WAIT) || defined(TP_ENABLE_FC_SUPPRESS) || defined(TP_ENABLE_FC_OVERFLOW))
           =2 # define kTpFCClearToSend           0x00
           =2 #endif
           =2 #if defined (TP_ENABLE_FC_WAIT)
           =2 # define kTpFCStatusWait            0x01
           =2 #endif
           =2 #if defined (TP_ENABLE_FC_SUPPRESS)
           =2 # define kTpFCSuppressFrame         0x02
           =2 #endif
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 271 

           =2 #if defined (TP_ENABLE_FC_OVERFLOW)
           =2 # define kTpFCStatusOverflow        0x03
           =2 #endif
           =2 /***************************************************************************/
           =2 /* error codes                                                             */
           =2 /***************************************************************************/
           =2 /* error numbers for ErrorCallback functions                               */
           =2 
           =2 /* RX: */
           =2 #define kTpRxErrWrongSNreceived                       0x01
           =2 #define kTpRxErrTransmissionOfFCFailed                0x02
           =2 #define kTpRxErrCFTimeout                             0x03
           =2 #define kTpRxErrConfIntTimeout                        0x04
           =2 #define kTpRxErrFcCanIdIsMissing                      0x05
           =2 #define kTpRxErrFF_SFreceivedAgain                    0x06
           =2 #define kTpRxErrRxResetChannelIsCalled                0x07
           =2 #define kTpRxErrTpInitIsCalled                        0x08
           =2 #define kTpRxErrWFTmaxOverrun                         0x09
           =2                                                       
           =2 /* TX: */                                             
           =2 #define kTpTxErrBufferUnderrun                        0x21
           =2 #define kTpTxErrConfIntTimeout                        0x22
           =2 #define kTpTxErrFCTimeout                             0x23
           =2 #define kTpTxErrTransmissionFailed                    0x24
           =2 #define kTpTxErrFCNotExpected                         0x25
           =2 #define kTpTxErrFCWrongFlowStatus                     0x26
           =2 #define kTpTxErrTxResetChannelIsCalled                0x27
           =2 #define kTpTxErrTpInitIsCalled                        0x28
           =2 #define kTpTxErrFCOverrun                             0x32
           =2 #define kTpTxErrSFExeedsFrameLength                   0x33
           =2 #define kTpTxErrWFTmaxOverrun                         0x34
           =2 #define kTpTxErrUnsupportedFCWait                     0x35
           =2 #define kTpTxErrReservedSTmin                         0x36
           =2 
           =2 /* error numbers for User Assertions 0x00-0xff */
           =2 #define kTpErrNoDynObjAtTpInit                        0x00
           =2 #define kTpErrChannelNrTooHigh                        0x01
           =2 #define kTpErrConnectionNrTooHigh                     0x02
           =2 #define kTpErrChannelNotInUse                         0x03
           =2 #define kTpErrWrongAddressingFormat                   0x04
           =2 #define kTpErrNoCanChannelFound                       0x05
           =2 #define kTpErrCommunicationIsRunning                  0x06
           =2 #define kTpErrChannelNotInPreTransmitState            0x07
           =2 #define kTpErrCanChannelNotSupported                  0x08
           =2 #define kTpErrMemCpyInvalidParameter                  0x09
           =2 #define kTpErrPrecopyCheckInvalidReturn               0x0A
           =2 #define kTpErrInvalidParameterValue                   0x0C
           =2 
           =2 /* ASSERT - TX: */
           =2 #define kTpTxErrChannelAlreadyInQueue                 0x11 
           =2 #define kTpTxErrNoFrameAtPretransmitSpecified         0x12
           =2 #define kTpTxErrWrongFrameAtPretransmitSpecified      0x13
           =2 #define kTpTxErrNoConfStateAtConfirmationSpecified    0x14
           =2 #define kTpTxErrWrongConfStateAtConfirmationSpecified 0x15
           =2 #define kTpTxErrFrameAlreadyInQueue                   0x16
           =2 #define kTpTxErrDatalengthTooHigh                     0x17
           =2 #define kTpTxErrChannelIsNotInUse                     0x18
           =2 #define kTpTxErrTransmissionInProgress                0x19
           =2 #define kTpTxErrSetResponseWithoutFc                  0x1A
           =2 #define kTpTxErrNoStateSpecified                      0x1B
           =2 #define kTpTxErrNotInWaitFCState                      0x1C
           =2 #define kTpTxErrTxFlagsInconsitent                    0x1D
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 272 

           =2 #define kTpTxErrMinTimerIsInconsistent                0x1E
           =2 
           =2 /* ASSERT - RX: */
           =2 #define kTpRxErrNoConfStateAtConfirmationSpecified    0x21
           =2 #define kTpRxErrWrongConfStateAtConfirmationSpecified 0x22
           =2 #define kTpRxErrChannelAlreadyInQueue                 0x23
           =2 #define kTpRxErrFrameAlreadyInQueue                   0x24
           =2 #define kTpRxErrNoChannelFree                         0x25
           =2 #define kTpRxErrCFnotAssignableToAChannel             0x26
           =2 #define kTpRxErrFCnotAssignableToAChannel             0x27
           =2 #define kTpRxErrSetResponseWithoutFc                  0x28
           =2 #define kTpRxErrNoStateSpecified                      0x29
           =2 #define kTpRxErrNotInWaitCFState                      0x2A
           =2 #define kTpRxErrChannelNotInState                     0x2B
           =2 #define kTpRxErrInconsistentSemaphore                 0x2C
           =2 #define kTpRxErrFCWaitCombinedWithNoFC                0x2D
           =2 #define kTpRxErrInconsistentFlowStatus                0x2E
           =2 
           =2 /***************************************************************************/
           =2 /* constants                                                               */
           =2 /***************************************************************************/
           =2 
           =2 V_MEMROM0 extern V_MEMROM1 canuint8 V_MEMROM2 kTpMainVersion;
           =2 V_MEMROM0 extern V_MEMROM1 canuint8 V_MEMROM2 kTpSubVersion;
           =2 V_MEMROM0 extern V_MEMROM1 canuint8 V_MEMROM2 kTpBugFixVersion;
           =2 
           =2 
           =2 /*******************************************************************************
           =2 * Typedef declarations
           =2 *******************************************************************************/
           =2 typedef enum 
           =2 {
           =2   kTpFalse = 0,
           =2   kTpTrue  = 1
           =2 } tpBool;
           =2 
           =2 typedef vuint8 tTpConnectionHandle;
           =2 
           =2 /*******************************************************************************
           =2 * Optimization for different CPU types
           =2 *******************************************************************************/
           =2 #if defined (C_CPUTYPE_8BIT)
           =2 typedef canuint8        canuintCPUtype;
           =2 typedef cansint8        cansintCPUtype;
           =2 #else
           =2 typedef unsigned int    canuintCPUtype;
           =2 typedef signed int      cansintCPUtype;
           =2 #endif
           =2 
           =2 #if defined (C_CPUTYPE_8BIT)
           =2 # if defined( TP_CHANNEL_SPECIFIC_TIMING )
           =2 typedef canuint16 tTpEngineTimer;
           =2 # else
           =2 #  if(TpTxTimeoutFC  < 255) &&\
           =2      (TpRxTimeoutCF  < 255) &&\
           =2      (TpTxTransmitCF < 255) &&\
           =2      (kTpTxConfirmationTimeout < 255) &&\
           =2      (kTpRxConfirmationTimeout < 255) 
           =2 typedef canuint8 tTpEngineTimer;
           =2 #  else
           =2 typedef canuint16 tTpEngineTimer;
           =2 #  endif
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 273 

           =2 # endif
           =2 #else
           =2 typedef canuint16 tTpEngineTimer;
           =2 #endif
           =2 /******************************************************************************/
           =2 
           =2 #if defined (C_MULTIPLE_RECEIVE_CHANNEL) 
           =2 #else
           =2 # if ( kCanNumberOfChannels > 1 ) /* more than one CanChannel ? */
           =2 
           =2   typedef canuint8 CanChannelHandle;
           =2 
           =2   typedef struct 
           =2   {
           =2 #if (TP_USE_GATEWAY_API == kTpOn)
           =2     CanChipMsgPtr     pChipMsgObj; 
           =2 #endif   
           =2     CanChipDataPtr    pChipData;
           =2 #if defined (C_ENABLE_EXTENDED_ID)
           =2     canuint32         CanRxActualId;
           =2 #else
           =2     canuint16         CanRxActualId;
           =2 #endif
           =2     canuint8          CanRxActualDLC;
           =2     CanChannelHandle  Channel;
           =2   } tCanRxInfoStruct;
           =2 
           =2   typedef tCanRxInfoStruct          *CanRxInfoStructPtr;
           =2 
           =2 # endif
           =2 #endif
           =2 
           =2 typedef struct
           =2 {
           =2   CanChipDataPtr DataCanBufferPtr;
           =2   TP_MEMORY_MODEL_DATA canuint8 * DataApplBufferPtr; 
           =2 } tTpBufferPtr;
           =2 
           =2 typedef struct 
           =2 {
           =2   tTpBufferPtr DataBufferPtr;
           =2 /* Description : List of pointer to receive buffers from the application      */
           =2 /******************************************************************************/
           =2   canuint16 DataIndex;
           =2 /* Description : Index to transmit data - used instead of DataSegments        */
           =2 /* Val. range / Coding: 0..4095                                               */
           =2 /******************************************************************************/
           =2   canuint16 DataLength;
           =2 /* Description : Length of data to be transmitted. The size of this variable  */
           =2 /*               limits the maximum size of messages.                         */
           =2 /* Val. range / Coding: 0..4095                                               */
           =2 /******************************************************************************/
           =2 #if (TP_USE_MULTIPLE_ECU_NR == kTpOn)
           =2   canuint8 EcuNumber;
           =2 /* Description :                                                              */
           =2 /* Val. range / Coding: 0..0xff                                               */
           =2 /******************************************************************************/
           =2 #endif
           =2 #if defined(TP_ENABLE_MF_RECEPTION)
           =2 # if (TP_USE_EXTENDED_API_BS == kTpOn)
           =2   canuint8 BlockSize;
           =2 /* Description :                                                              */
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 274 

           =2 /* Val. range / Coding: 0..0xff                                               */
           =2 /******************************************************************************/
           =2 # endif
           =2 # if (TP_USE_EXTENDED_API_STMIN == kTpOn)
           =2   canuint8 STMin;
           =2 /* Description :                                                              */
           =2 /* Val. range / Coding: 0..0xff                                               */
           =2 /******************************************************************************/
           =2 # endif
           =2 #endif
           =2 #if defined (TP_ENABLE_SINGLE_CHANNEL_TP)
           =2 #else
           =2   canuint8  Connection;
           =2 /* Description :   Indirection Table to store the ConnectionNr                */
           =2 /* Val. range / Coding: 0..255                                                */
           =2 /******************************************************************************/
           =2 #endif
           =2 #if defined(TP_ENABLE_MF_RECEPTION)
           =2 # if defined (TP_ENABLE_FC_WAIT)
           =2 #  if defined (TP_ENABLE_NORMAL_ADDRESSING)       
           =2   canuint8 FFDataBuffer[6];
           =2 #  else
           =2   canuint8 FFDataBuffer[5];
           =2 #  endif
           =2 /* Description : Non ISO feature: acknowledged connections                    */
           =2 /* with FC after last CF                                                      */
           =2 /* Val. range / Coding: 0..1                                                  */
           =2 /******************************************************************************/
           =2 # endif
           =2 #endif
           =2   canbittype sequencenumber:4; /*lint !e46*/
           =2 /* Description : SequenceNumber SN                                            */
           =2 /* Val. range / Coding: 0..0xf                                                */
           =2 /******************************************************************************/
           =2 
           =2 # if (kTpNumberOfCanChannels > 1)
           =2   canbittype CanChannel:4;    /*lint !e46*/
           =2 /* Description : For a MultiCAN System, the physical CanChannel               */
           =2 /*               have to be stored in RAM for being changed by the            */
           =2 /*               application. To support this, the additional functions       */
           =2 /*               TpTxSetCanChannel and TpRxGetCanChannel are provided.        */
           =2 /* Val. range / Coding: 0..7                                                  */
           =2 /******************************************************************************/
           =2 # else
           =2   canbittype stuffbits1:4;
           =2 # endif
           =2 
           =2 #if (defined(TP_ENABLE_FC_WAIT) || defined(TP_ENABLE_FC_SUPPRESS) || defined(TP_ENABLE_FC_OVERFLOW))
           =2   canbittype ApplGetBufferStatus:2;        /*lint !e46*/
           =2 /* Description : Status flag to proceed SF/FF reception  */
           =2 /*                                                       */
           =2 /* Val. range / Coding: 0..3                                                  */
           =2 /******************************************************************************/
           =2 #endif
           =2 #if defined(TP_ENABLE_MF_RECEPTION)
           =2 # if (TP_USE_RX_CHANNEL_WITHOUT_FC == kTpOn)
           =2   canbittype withoutFC:1;       /*lint !e46*/
           =2 /* Description : Channel without using FlowControls                           */
           =2 /*               (Static:GenTool provides no send message for this tpChannel) */
           =2 /* Val. range / Coding: 0..1                                                  */
           =2 /******************************************************************************/
           =2 # endif
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 275 

           =2 #endif
           =2 #if defined (TP_ENABLE_DYN_AWAIT_CORRECT_SN)
           =2   canbittype SNwait:1;       /*lint !e46*/
           =2 /* Description : Wait for correct SN instead of reinitialization              */
           =2 /* Val. range / Coding: 0 = strict SN check, 1 = wait for correct SN          */
           =2 /******************************************************************************/
           =2 #endif
           =2 #if (TP_USE_APPL_PRECOPY == kTpOn) && (TP_USE_FAST_PRECOPY == kTpOff) && defined (TP_DISABLE_CHECKTA_COMPA
             -TIBILITY)
           =2   canbittype ta_type:1;
           =2 #endif
           =2 
           =2 } tTpRxInfoStruct;
           =2 
           =2 typedef struct 
           =2 {
           =2   TP_MEMORY_MODEL_DATA canuint8 *DataBufferPtr;
           =2 /* Description : List of pointer to transmit buffers from the application     */
           =2 /******************************************************************************/
           =2   canuint16 DataIndex;
           =2 /* Description : Index to transmit data - used instead of DataSegments        */
           =2 /* Val. range / Coding: 0..4095                                               */
           =2 /******************************************************************************/
           =2   canuint16 DataLength;
           =2 /* Description : Length of data to be transmitted. The size of this variable  */
           =2 /*               limits the maximum size of messages.                         */
           =2 /* Val. range / Coding: 0..4095                                               */
           =2 /******************************************************************************/
           =2 #if (TP_USE_MULTIPLE_ECU_NR == kTpOn)
           =2   canuint8 EcuNumber;
           =2 /* Description :                                                              */
           =2 /* Val. range / Coding: 0..                                                   */
           =2 /******************************************************************************/
           =2 #endif
           =2 #if (TP_USE_ONLY_FIRST_FC == kTpOn)
           =2   canuint8 BlockSize;
           =2 /* Description :                                                              */
           =2 /* Val. range / Coding: 0..                                                   */
           =2 /******************************************************************************/
           =2 #endif
           =2 #if (TP_USE_STMIN_OF_FC == kTpOn)
           =2   canuint8 STMin;
           =2 /* Description : Global value to store the requested min. separation time     */ 
           =2 /*               received in the flow control frames. The received STmin      */
           =2 /*               value will be adjusted to multiples of TpTxCallCycle.        */
           =2 /* Val. range / Coding: 0..255 / in ms                                        */
           =2 /******************************************************************************/
           =2 # if (TP_USE_FAST_TX_TRANSMISSION == kTpOn)
           =2   canuint8 STminInFrame;
           =2 # endif
           =2 #endif
           =2 #if defined (TP_ENABLE_SINGLE_CHANNEL_TP)
           =2 #else
           =2   canuint8  Connection;
           =2 /* Description :   Indirection Table to store the ConnectionNr                */
           =2 /* Val. range / Coding: 0..255                                                */
           =2 /******************************************************************************/
           =2 #endif
           =2   canbittype sequencenumber:4;    /*lint !e46*/
           =2 /* Description : SequenceNumber SN                                            */
           =2 /* Val. range / Coding: 0..0xf                                                */
           =2 /******************************************************************************/
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 276 

           =2 #if defined (TP_ENABLE_VARIABLE_DLC)
           =2   canbittype CurrentTpCanDLC:4;
           =2 /* Description : Stores the DLC while sending with variable DLC               */
           =2 /* Val. range / Coding: 1..4                                                  */
           =2 /******************************************************************************/
           =2 #else
           =2   canbittype stuffbits1:4;
           =2 #endif
           =2 
           =2 #if (kTpNumberOfCanChannels > 1)
           =2 #endif
           =2 #if (TP_USE_TX_CHANNEL_WITHOUT_FC == kTpOn)
           =2   canbittype withoutFC:1;       /*lint !e46*/
           =2 /* Description : Channel without waiting for FlowControls                     */
           =2 /* Val. range / Coding: 0..1                                                  */
           =2 /******************************************************************************/
           =2 #endif
           =2 #if defined (TP_ENABLE_FC_MSG_FLOW_DYN_CHECK)
           =2   canbittype FCwfs:1;       /*lint !e46*/
           =2 /* Description : Strict Flow Control checking for wrong flow status           */
           =2 /* Val. range / Coding: 0 = non strict check, 1 = strict check                */
           =2 /******************************************************************************/
           =2 #endif
           =2 #if defined (TP_ENABLE_RUNTIME_CHECK)
           =2 # if (TP_USE_MULTIPLE_ECU_NR == kTpOn)
           =2   canbittype EcuNumberIsValid:1;        /*lint !e46*/
           =2 /* Description : Stores validity for member 'EcuNumber'                       */
           =2 /* Val. range / Coding: 0..1                                                  */
           =2 /******************************************************************************/
           =2 # endif
           =2 #endif
           =2 } tTpTxInfoStruct;
           =2 
           =2 /***************************************************************************/
           =2 /* Callback Functions                                                      */
           =2 /***************************************************************************/
           =2 #if defined (TP_ENABLE_USER_CHECK)                || \
           =2     defined (TP_ENABLE_INTERNAL_CHECK)            || \
           =2     defined (TP_ENABLE_GEN_CHECK)
           =2 extern void     TP_API_CALLBACK_TYPE ApplTpFatalError(canuint8 errorNumber);
           =2 #endif
           =2 
           =2 #if (TP_USE_PRE_COPY_CHECK == kTpOn)
           =2 # if defined (C_MULTIPLE_RECEIVE_CHANNEL)         || \
           =2      defined (C_SINGLE_RECEIVE_CHANNEL)           
           =2 extern canuint8 TP_API_CALLBACK_TYPE TpPreCopyCheckFunction(CanRxInfoStructPtr rxStruct);
           =2 #else
           =2 #  if defined (C_MULTIPLE_RECEIVE_BUFFER)
           =2 extern canuint8 TP_API_CALLBACK_TYPE TpPreCopyCheckFunction(CanChipDataPtr rxDataPtr);
           =2 #  endif
           =2 #  if defined (C_SINGLE_RECEIVE_BUFFER)
           =2 extern canuint8 TP_API_CALLBACK_TYPE TpPreCopyCheckFunction(CanReceiveHandle rxObject);
           =2 #  endif
           =2 # endif
           =2 #endif
           =2 
           =2 
           =2 /*******************************************************************************
           =2 * Functions declarations 
           =2 *******************************************************************************/
           =2 #if defined (C_ENABLE_MEMCOPY_SUPPORT)
           =2 #else
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 277 

           =2 # if defined (TP_ENABLE_INTERMEDIATE_CANCHIP_BUFFER)
           =2 # else
           =2 #  if defined (VGEN_ENABLE_VSTDLIB)
           =2 #  else
           =2 extern void     TP_API_CALL_TYPE TpIntMemCpy(TP_MEMORY_MODEL_DATA void *pDest, TP_MEMORY_MODEL_DATA void* 
             -pSrc, canuint16 nCnt);
           =2 #  endif
           =2 # endif
           =2 #endif
           =2 
           =2 extern void     TP_API_CALL_TYPE TpInitPowerOn(void);
           =2 extern void     TP_API_CALL_TYPE TpInit(void);
           =2 
           =2 #if defined (TP_ENABLE_SINGLE_CHANNEL_TP)
           =2 #else
           =2 # if ( kTpNumberOfCanChannels > 1 ) /* more than one canChannel ? */
           =2 # endif
           =2 #endif
           =2 
           =2 extern void     TP_API_CALL_TYPE TpTask(void);
           =2 extern void     TP_API_CALL_TYPE TpTxTask(void);
           =2 extern void     TP_API_CALL_TYPE TpRxTask(void);
           =2 
           =2 
           =2 /* Single Channel API */
           =2 #if defined (TP_ENABLE_SINGLE_CHANNEL_TP)
           =2   extern canuint8 TP_API_CALL_TYPE TpTransmit(TP_MEMORY_MODEL_DATA canuint8* ptrData, canuint16 count);
           =2   extern void     TP_API_CALL_TYPE TpTxResetChannel(void);
           =2 
           =2 
           =2 # if defined (TP_TX_ENABLE_DYN_EXT_ID)
           =2   extern void     TP_API_CALL_TYPE TpTxSetPriorityBits(canuint8 prio, canuint8 res, canuint8 dataPage);
           =2   extern void     TP_API_CALL_TYPE TpTxSetPGN(canuint8 pgn);
           =2 # endif
           =2 # if defined (TP_RX_ENABLE_DYN_EXT_ID)
           =2   extern void     TP_API_CALL_TYPE TpRxSetPriorityBits(canuint8 prio, canuint8 res, canuint8 dataPage);
           =2   extern void     TP_API_CALL_TYPE TpRxSetPGN(canuint8 pgn);
           =2 # endif
           =2 
           =2 # if (kTpNumberOfCanChannels > 1)
           =2 # endif
           =2 # if (TP_USE_MULTIPLE_ECU_NR == kTpOn)
           =2   extern void     TP_API_CALL_TYPE TpTxSetEcuNumber(canuint8 ecuNr);
           =2 # endif
           =2 # if defined (TP_DISABLE_NORMAL_ADDRESSING)
           =2   extern void     TP_API_CALL_TYPE TpTxSetResponse(void);
           =2 # else
           =2 #  define TpTxSetResponse() 
           =2 # endif
           =2 
           =2   extern void     TP_API_CALL_TYPE TpRxResetChannel(void);  
           =2   extern canuint8 TP_API_CALL_TYPE TpRxGetStatus(void);
           =2 # if (TP_USE_EXTENDED_API_BS == kTpOn)
           =2   extern void     TP_API_CALL_TYPE TpRxSetBS(canuint8 newBS);
           =2   extern canuint8 TP_API_CALL_TYPE TpRxGetBS(void);
           =2 # endif
           =2 #if (TP_USE_APPL_PRECOPY == kTpOn) && (TP_USE_FAST_PRECOPY == kTpOff) && defined (TP_DISABLE_CHECKTA_COMPA
             -TIBILITY)
           =2   extern t_ta_type TP_API_CALL_TYPE TpRxGetTaType(void);
           =2 # endif
           =2 # if (TP_USE_EXTENDED_API_STMIN == kTpOn)
           =2   extern void     TP_API_CALL_TYPE TpRxSetSTMIN(canuint8 newSTmin);
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 278 

           =2   extern canuint8 TP_API_CALL_TYPE TpRxGetSTMIN(void);
           =2 # endif
           =2 # if (TP_USE_MULTIPLE_ECU_NR == kTpOn)
           =2   extern canuint8 TP_API_CALL_TYPE TpRxGetEcuNumber(void);
           =2 # endif
           =2 # if (TP_USE_FAST_TX_TRANSMISSION == kTpOn)
           =2   extern TP_EXTERNAL_INLINE canuint8 TP_API_CALL_TYPE TpTxPrepareSendImmediate(void);
           =2   extern TP_EXTERNAL_INLINE void TP_API_CALL_TYPE TpTxSendImmediate(void);
           =2   extern canuint8 TP_API_CALL_TYPE TpTxGetSTminInFrame(void);
           =2 # endif
           =2 
           =2 #  if (kTpNumberOfCanChannels > 1)
           =2   extern canuint8 TP_API_CALL_TYPE TpRxGetCanChannel(void);
           =2 #  else
           =2 #  define TpRxGetCanChannel() (TP_CAN_CHANNEL_INDEX)
           =2 #  endif
           =2   extern CanChipDataPtr TP_API_CALL_TYPE TpRxGetCanBuffer(void);
           =2 
           =2 # if (TP_USE_OVERRUN_INDICATION == kTpOn)
           =2   extern void TP_API_CALL_TYPE TpRxSetBufferOverrun(void);
           =2 # endif
           =2 # if defined (TP_TEST_ROUTINE_CONF_TIMEOUT)
           =2   extern void TP_API_CALL_TYPE TpTxTestForceConfirmationTimeout(void);
           =2   extern void TP_API_CALL_TYPE TpRxTestForceConfirmationTimeout(void);
           =2 # endif
           =2 #if defined (TP_ENABLE_FC_WAIT)
           =2   extern void     TP_API_CALL_TYPE TpRxSetClearToSend(TP_MEMORY_MODEL_DATA canuint8 * pBuffer);
           =2 #endif
           =2 #if (defined (TP_ENABLE_FC_WAIT) || defined(TP_ENABLE_FC_SUPPRESS) || defined(TP_ENABLE_FC_OVERFLOW))
           =2   extern void     TP_API_CALL_TYPE TpRxSetFCStatus(canuint8 FCStatus);
           =2   extern canuint8 TP_API_CALL_TYPE TpRxGetFCStatus(void);
           =2 #endif
           =2 
           =2 
           =2 
           =2 #else /* Multi Channel API */
           =2 
           =2   extern canuint8 TP_API_CALL_TYPE TpTransmit                   (canuint8 tpChannel, TP_MEMORY_MODEL_DATA 
             -canuint8 *ptrData, canuint16 count);
           =2 
           =2   extern void     TP_API_CALL_TYPE TpTxResetChannel             (canuint8 tpChannel);
           =2 #  define TpTxGetConnectionStatus(connection)                   (connection)
           =2 
           =2 
           =2 
           =2 # if defined (TP_TX_ENABLE_DYN_EXT_ID)
           =2   extern void     TP_API_CALL_TYPE TpTxSetPriorityBits          (canuint8 tpChannel, canuint8 prio, canuin
             -t8 res, canuint8 dataPage);
           =2   extern void     TP_API_CALL_TYPE TpTxSetPGN                   (canuint8 tpChannel, canuint8 pgn);
           =2 # endif
           =2 # if defined (TP_RX_ENABLE_DYN_EXT_ID)
           =2   extern void     TP_API_CALL_TYPE TpRxSetPriorityBits          (canuint8 tpChannel, canuint8 prio, canuin
             -t8 res, canuint8 dataPage);
           =2   extern void     TP_API_CALL_TYPE TpRxSetPGN                   (canuint8 tpChannel, canuint8 pgn);
           =2 # endif
           =2 
           =2 # if (kTpNumberOfCanChannels > 1)
           =2 # endif
           =2 # if (TP_USE_MULTIPLE_ECU_NR == kTpOn)
           =2   extern void     TP_API_CALL_TYPE TpTxSetEcuNumber             (canuint8 tpChannel, canuint8 ecuNr);
           =2 # endif
           =2 
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 279 

           =2   extern void     TP_API_CALL_TYPE TpRxResetChannel             (canuint8 tpChannel);
           =2   extern canuint8 TP_API_CALL_TYPE TpRxGetStatus                (canuint8 tpChannel);
           =2                                                               
           =2 # if (TP_USE_EXTENDED_API_BS == kTpOn)                        
           =2   extern void     TP_API_CALL_TYPE TpRxSetBS                    (canuint8 tpChannel, canuint8 newBS);
           =2   extern canuint8 TP_API_CALL_TYPE TpRxGetBS                    (canuint8 tpChannel);
           =2 # endif                                                       
           =2 # if (TP_USE_EXTENDED_API_STMIN == kTpOn)                     
           =2   extern void     TP_API_CALL_TYPE TpRxSetSTMIN                 (canuint8 tpChannel, canuint8 newSTmin);
           =2   extern canuint8 TP_API_CALL_TYPE TpRxGetSTMIN                 (canuint8 tpChannel);
           =2 # endif                                                       
           =2 #if (TP_USE_APPL_PRECOPY == kTpOn) && (TP_USE_FAST_PRECOPY == kTpOff) && defined (TP_DISABLE_CHECKTA_COMPA
             -TIBILITY)
           =2   extern t_ta_type TP_API_CALL_TYPE TpRxGetTaType               (canuint8 tpChannel);
           =2 # endif
           =2 # if (kTpNumberOfCanChannels > 1)
           =2   extern canuint8 TP_API_CALL_TYPE TpRxGetCanChannel            (canuint8 tpChannel);
           =2 # else
           =2 #  define TpRxGetCanChannel(tpChannel)                          (TP_CAN_CHANNEL_INDEX)
           =2 # endif
           =2 # if (TP_USE_MULTIPLE_ECU_NR == kTpOn)
           =2   extern canuint8 TP_API_CALL_TYPE TpRxGetEcuNumber             (canuint8 tpChannel);
           =2 # endif
           =2 
           =2 #if defined( TP_ENABLE_MF_RECEPTION )
           =2 #endif
           =2 
           =2 # if defined (TP_DISABLE_NORMAL_ADDRESSING)
           =2   extern void     TP_API_CALL_TYPE TpTxSetResponse              (canuint8 rxChannel, canuint8 txChannel);
           =2 # else
           =2 #  define TpTxSetResponse(rxChannel, txChannel)
           =2 # endif
           =2 # if (TP_USE_FAST_TX_TRANSMISSION == kTpOn)
           =2   extern TP_EXTERNAL_INLINE canuint8 TP_API_CALL_TYPE TpTxPrepareSendImmediate(canuint8 tpChannel);
           =2   extern TP_EXTERNAL_INLINE void TP_API_CALL_TYPE TpTxSendImmediate(canuint8 tpChannel);
           =2   extern canuint8 TP_API_CALL_TYPE TpTxGetSTminInFrame(canuint8 tpChannel);
           =2 # endif
           =2 
           =2   extern CanChipDataPtr TP_API_CALL_TYPE TpRxGetCanBuffer(canuint8 tpChannel);
           =2 
           =2 # if (TP_USE_OVERRUN_INDICATION == kTpOn)
           =2   extern void TP_API_CALL_TYPE TpRxSetBufferOverrun(canuint8 tpChannel);
           =2 # endif
           =2 # if defined (TP_TEST_ROUTINE_CONF_TIMEOUT)
           =2   extern void TP_API_CALL_TYPE TpTxTestForceConfirmationTimeout(canuint8 tpChannel);
           =2   extern void TP_API_CALL_TYPE TpRxTestForceConfirmationTimeout(canuint8 tpChannel);
           =2 # endif
           =2 
           =2 #if defined (TP_ENABLE_FC_WAIT)
           =2   extern void     TP_API_CALL_TYPE TpRxSetClearToSend(canuint8 tpChannel, TP_MEMORY_MODEL_DATA canuint8 * 
             -pBuffer);
           =2 #endif
           =2 #if (defined (TP_ENABLE_FC_WAIT) || defined(TP_ENABLE_FC_SUPPRESS) || defined(TP_ENABLE_FC_OVERFLOW))
           =2   extern void     TP_API_CALL_TYPE TpRxSetFCStatus(canuint8 tpChannel, canuint8 FCStatus);
           =2   extern canuint8 TP_API_CALL_TYPE TpRxGetFCStatus(canuint8 tpChannel);
           =2 #endif
           =2 
           =2 #if defined (TP_ENABLE_DYN_AWAIT_CORRECT_SN)
           =2 extern void TP_API_CALL_TYPE TpRxSetWaitCorrectSN(canuint8 tpChannel, tpBool wait);
           =2 #endif
           =2 
           =2 #if defined (TP_ENABLE_FC_MSG_FLOW_DYN_CHECK)
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 280 

           =2 extern void TP_API_CALL_TYPE TpTxSetStrictFlowControlCheck(canuint8 tpChannel, tpBool strict);
           =2 #endif
           =2 
           =2 #if defined (TP_ENABLE_DYN_TX_STMIN_TIMING)
           =2 extern void TP_API_CALL_TYPE TpTxSetCFDelay(canuint8 tpChannel, tTpEngineTimer time);
           =2 #endif
           =2 
           =2 #if defined (TP_ENABLE_DYN_CHANNEL_TIMING)
           =2 extern void TP_API_CALL_TYPE TpRxSetTimeoutCF(canuint8 tpChannel, tTpEngineTimer time);
           =2 extern void TP_API_CALL_TYPE TpRxSetTimeoutConfirmation(canuint8 tpChannel, tTpEngineTimer time);
           =2 extern void TP_API_CALL_TYPE TpTxSetTimeoutFC(canuint8 tpChannel, tTpEngineTimer time);
           =2 extern void TP_API_CALL_TYPE TpTxSetTimeoutConfirmation(canuint8 tpChannel, tTpEngineTimer time);
           =2 #endif
           =2 
           =2 #endif /* End of Multi Channel API */
           =2 
           =2 
           =2 
           =2 #if defined (TP_ENABLE_SINGLE_CHANNEL_TP)
           =2 extern void TP_API_CALL_TYPE TpTxStateTask(void);
           =2 # define TpTxAllStateTask()     (TpTxStateTask())
           =2 #else
           =2 extern void TP_API_CALL_TYPE TpTxStateTask(canuint8 tpChannel);
           =2 extern void TP_API_CALL_TYPE TpTxAllStateTask(void);
           =2 #endif
           =2 #if defined (TP_ENABLE_SINGLE_CHANNEL_TP)
           =2 extern void TP_API_CALL_TYPE TpRxStateTask(void);
           =2 # define TpRxAllStateTask()     (TpRxStateTask())
           =2 #else
           =2 extern void TP_API_CALL_TYPE TpRxStateTask(canuint8 tpChannel);
           =2 extern void TP_API_CALL_TYPE TpRxAllStateTask(void);
           =2 #endif
           =2 
           =2 #if defined (TP_ENABLE_VARIABLE_DLC)
           =2 #  if defined (TP_ENABLE_SINGLE_MSG_OBJ) /* Geny */
           =2 #   if defined(C_MULTIPLE_RECEIVE_CHANNEL) || defined(C_SINGLE_RECEIVE_CHANNEL)
           =2 #    if defined (TP_ENABLE_SINGLE_CHANNEL_TP)
           =2 extern canuint8 TP_INTERNAL_CALL_TYPE TpTxPreTransmit(CanTxInfoStruct txStruct);
           =2 #    else
           =2 extern canuint8 TP_INTERNAL_CALL_TYPE TpDrvTxPreTransmit(vuintx tpChannel, CanTxInfoStruct txStruct);
           =2 #    endif
           =2 #   else
           =2 #    if defined (TP_ENABLE_SINGLE_CHANNEL_TP)
           =2 extern canuint8 TP_INTERNAL_CALL_TYPE TpTxPreTransmit(CanChipDataPtr txDataPtr);
           =2 #    else
           =2 extern canuint8 TP_INTERNAL_CALL_TYPE TpDrvTxPreTransmit(vuintx tpChannel, CanChipDataPtr txDataPtr);
           =2 #    endif
           =2 #   endif
           =2 #  endif
           =2 #endif
           =2 
           =2 
           =2 /*******************************************************************************
           =2 * Variable declarations
           =2 *******************************************************************************/
           =2 #if defined (TP_ENABLE_SINGLE_CHANNEL_TP)
           =2 #else
           =2 #  if defined (TP_ENABLE_NORMAL_ADDRESSING)        
           =2 /* Added for multichannel transport layer extension */
           =2 V_MEMROM0 extern V_MEMROM1 canuint8 V_MEMROM2 TpRxHandleToChannel[];
           =2 V_MEMROM0 extern V_MEMROM1 canuint8 V_MEMROM2 TpTxHandleToChannel[];
           =2 #  endif
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 281 

           =2 #endif
           =2 
           =2 extern MEMORY_NEAR_TP_SAVE tTpRxInfoStruct tpRxInfoStruct[kTpRxChannelCount];
           =2 extern MEMORY_NEAR_TP_SAVE tTpTxInfoStruct tpTxInfoStruct[kTpTxChannelCount];
           =2 
           =2 #if (TP_USE_TX_HANDLE_CHANGEABLE == kTpOn)
           =2 # if defined (TP_ENABLE_SINGLE_CHANNEL_TP)
           =2 extern MEMORY_NEAR_TP_SAVE CanTransmitHandle tpTxHandle;
           =2 #  if defined (TP_ENABLE_SINGLE_MSG_OBJ)
           =2 #  endif
           =2 # else
           =2 extern MEMORY_NEAR_TP_SAVE CanTransmitHandle tpTxHandle_Field[kTpTxChannelCount];
           =2 #  if defined (TP_ENABLE_SINGLE_MSG_OBJ)
           =2 #  endif
           =2 # endif
           =2 #endif
           =2 
           =2 #if defined (TP_ENABLE_MIN_TIMER) 
           =2 # if !defined (kTpTxMinTimer)
           =2 V_MEMROM0 extern V_MEMROM1 canuint8 V_MEMROM2 TpTxMinTimer[kTpTxChannelCount];
           =2 # endif
           =2 #endif
           =2 
           =2 
           =2 
           =2 
           =2 
           =2 /*******************************************************************************
           =2 * Variable declarations
           =2 *******************************************************************************/
           =2 # if defined (TP_ENABLE_SINGLE_CHANNEL_TP)
           =2 # else
           =2 /*******************************************************************************
           =2 * NAME:              TpRxGetConnectionNumber
           =2 *
           =2 * CALLED BY:         Application
           =2 * PRECONDITIONS:     
           =2 *
           =2 * PARAMETER:         
           =2 * RETURN VALUE:      
           =2 *******************************************************************************/
           =2 #  define TpRxGetConnectionNumber(tpChannel) (tpRxInfoStruct[tpChannel].Connection)
           =2 # endif
           =2 
           =2 # if defined (TP_ENABLE_SINGLE_CHANNEL_TP)
           =2 # else
           =2 /*******************************************************************************
           =2 * NAME:              TpRxSetConnectionNumber
           =2 *
           =2 * CALLED BY:         Application
           =2 * PRECONDITIONS:     
           =2 *
           =2 * PARAMETER:         
           =2 * RETURN VALUE:      
           =2 *******************************************************************************/
           =2 #  define TpRxSetConnectionNumber(tpChannel, connection) (tpRxInfoStruct[(tpChannel)].Connection = (connec
             -tion))
           =2 # endif
           =2 
           =2 /*******************************************************************************
           =2 * NAME:              TpTxGetDataBuffer/TpRxGetDataBuffer
           =2 *
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 282 

           =2 * CALLED BY:         Application
           =2 * PRECONDITIONS:     
           =2 *
           =2 * PARAMETER:         
           =2 * RETURN VALUE:      
           =2 *******************************************************************************/
           =2 #if defined (TP_ENABLE_SINGLE_CHANNEL_TP)
           =2 # define TpTxGetDataBuffer()         (tpTxInfoStruct[0].DataBufferPtr)
           =2 # define TpRxGetDataBuffer()         (tpRxInfoStruct[0].DataBufferPtr.DataApplBufferPtr)
           =2 #else
           =2 # define TpTxGetDataBuffer(tpChannel)  (tpTxInfoStruct[tpChannel].DataBufferPtr)
           =2 # define TpRxGetDataBuffer(tpChannel)  (tpRxInfoStruct[tpChannel].DataBufferPtr.DataApplBufferPtr)
           =2 #endif
           =2 /*******************************************************************************
           =2 * NAME:              TpTxGetDataIndex/TpRxGetDataIndex
           =2 *
           =2 * CALLED BY:         Application
           =2 * PRECONDITIONS:     
           =2 *
           =2 * PARAMETER:         
           =2 * RETURN VALUE:      
           =2 *******************************************************************************/
           =2 #if defined (TP_ENABLE_SINGLE_CHANNEL_TP)
           =2 # define TpTxGetDataIndex()          (tpTxInfoStruct[0].DataIndex)
           =2 # define TpRxGetDataIndex()          (tpRxInfoStruct[0].DataIndex)
           =2 #else
           =2 # define TpTxGetDataIndex(tpChannel)   (tpTxInfoStruct[tpChannel].DataIndex)
           =2 # define TpRxGetDataIndex(tpChannel)   (tpRxInfoStruct[tpChannel].DataIndex)
           =2 #endif
           =2 
           =2 #if defined (TP_ENABLE_SINGLE_CHANNEL_TP)
           =2 #else
           =2 /*******************************************************************************
           =2 * NAME:              TpTxGetConnectionNumber
           =2 *
           =2 * CALLED BY:         Application
           =2 * PRECONDITIONS:     
           =2 *
           =2 * PARAMETER:         
           =2 * RETURN VALUE:      
           =2 *******************************************************************************/
           =2 #  define TpTxGetConnectionNumber(tpChannel) (tpTxInfoStruct[tpChannel].Connection)
           =2 #endif
           =2 
           =2 
           =2 /*******************************************************************************
           =2 * NAME:              TpTxData
           =2 *
           =2 * CALLED BY:         Application
           =2 * PRECONDITIONS:     
           =2 *
           =2 * PARAMETER:         
           =2 * RETURN VALUE:      
           =2 *******************************************************************************/
           =2 #if defined (TP_ENABLE_SINGLE_CHANNEL_TP)
           =2 #  define TpTxData()          (CanGetTxDataPtr(kTpTxHandle_Field[0]))
           =2 #else
           =2 #  define TpTxData(tpChannel)    (CanGetTxDataPtr(kTpTxHandle_Field[tpChannel]))
           =2 #endif
           =2 
           =2 
           =2 #if (TP_USE_TX_HANDLE_CHANGEABLE == kTpOn)
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 283 

           =2 # if defined (TP_ENABLE_SINGLE_CHANNEL_TP)
           =2 /*******************************************************************************
           =2 * NAME:              TpSetTxHandle
           =2 *
           =2 * CALLED BY:         Application
           =2 * PRECONDITIONS:     
           =2 *
           =2 * PARAMETER:         
           =2 * RETURN VALUE:      
           =2 *******************************************************************************/
           =2 #  define TpSetTxHandle(x) (tpTxHandle = x)
           =2 #  if defined (TP_ENABLE_SINGLE_MSG_OBJ)
           =2 #  endif
           =2 # else
           =2 #   error "Not supported configuration!"
           =2 #  if defined (TP_ENABLE_SINGLE_MSG_OBJ)
           =2 #  endif
           =2 # endif
           =2 #endif
           =2 
           =2 #if defined (TP_ENABLE_SINGLE_CHANNEL_TP)
           =2 #else
           =2 /*******************************************************************************
           =2 * 'Static Normal Addressing' declarations
           =2 *******************************************************************************/
           =2 #  if defined (TP_ENABLE_NORMAL_ADDRESSING)       
           =2 
           =2   #define TpResetRxChannel(tpChannel) TpRxResetChannel(tpChannel)
           =2   #define SetRxChannelInUse(tpChannel)  /* */
           =2 
           =2   /*******************************************************************************
           =2   * Transport layer callback functions: MemCpy-functions for function tabels
           =2   *******************************************************************************/
           =2 
           =2 #if defined (C_ENABLE_MEMCOPY_SUPPORT)
           =2 # define __ApplTpTxCopyToCAN_mem(infoStruct)               CanCopyToCan((infoStruct->pDestination), (infoS
             -truct->pSource), infoStruct->Length);
           =2 # define __ApplTpRxCopyFromCAN_mem(tpChannel, src, datLen) CanCopyFromCan((&(tpRxInfoStruct[tpChannel].Dat
             -aBufferPtr.DataApplBufferPtr[tpRxInfoStruct[tpChannel].DataIndex])), (src), (datLen));
           =2 #else
           =2 # if defined (TP_ENABLE_INTERMEDIATE_CANCHIP_BUFFER)
           =2 #  error This configuration is not supported: C_ENABLE_MEMCOPY_SUPPORT is missing
           =2 # else
           =2 
           =2 #  if defined (VGEN_ENABLE_VSTDLIB)
           =2 #   if defined(V_ENABLE_USED_GLOBAL_VAR)
           =2      /* VStdLib additional memcpy functions: VStdMemCpyFarRamToRam, VStdMemCpyFarRamToFarRam, VStdMemCpyCF
             -arRomToFarRam */
           =2 #    define __ApplTpTxCopyToCAN_mem(infoStruct)               (void)VStdMemCpyFarRamToFarRam((TP_MEMORY_MO
             -DEL_DATA void *)(infoStruct->pDestination), (TP_MEMORY_MODEL_DATA void *)(infoStruct->pSource), infoStruct->Length);
           =2 #    define __ApplTpRxCopyFromCAN_mem(tpChannel, src, datLen) (void)VStdMemCpyFarRamToFarRam((TP_MEMORY_MO
             -DEL_DATA void *)(&(tpRxInfoStruct[tpChannel].DataBufferPtr.DataApplBufferPtr[tpRxInfoStruct[tpChannel].DataIndex])), (TP
             -_MEMORY_MODEL_DATA void *)(src), (datLen))
           =2 #   else
           =2 #    define __ApplTpTxCopyToCAN_mem(infoStruct)               (void)VStdMemCpyRamToRam( (void *)(infoStruc
             -t->pDestination), (void *)(infoStruct->pSource), infoStruct->Length);
           =2 #    define __ApplTpRxCopyFromCAN_mem(tpChannel, src, datLen) (void)VStdMemCpyRamToRam( (void *)(&(tpRxInf
             -oStruct[tpChannel].DataBufferPtr.DataApplBufferPtr[tpRxInfoStruct[tpChannel].DataIndex])), (void *)(src), (datLen))
           =2 #   endif
           =2 #  else
           =2 #   define __ApplTpTxCopyToCAN_mem(infoStruct)               (void)TpIntMemCpy((TP_MEMORY_MODEL_DATA void 
             -*)(infoStruct->pDestination), (TP_MEMORY_MODEL_DATA void *)(infoStruct->pSource), infoStruct->Length);
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 284 

           =2 #   define __ApplTpRxCopyFromCAN_mem(tpChannel, src, datLen) (void)TpIntMemCpy((TP_MEMORY_MODEL_DATA void 
             -*)(&(tpRxInfoStruct[tpChannel].DataBufferPtr.DataApplBufferPtr[tpRxInfoStruct[tpChannel].DataIndex])), (TP_MEMORY_MODEL_
             -DATA void *)(src), (datLen))
           =2 #  endif
           =2 # endif
           =2 #endif
           =2   /*******************************************************************************
           =2   * Transport layer callback functions: name definition
           =2   *******************************************************************************/
           =2 #   if defined (TP_ENABLE_SINGLE_MSG_OBJ)
           =2 #   endif
           =2   /*******************************************************************************
           =2   * Transport layer callback functions: Pointer type definition
           =2   *******************************************************************************/
           =2 #    if (TP_USE_GATEWAY_API == kTpOn)    
           =2   typedef TP_MEMORY_MODEL_DATA canuint8 *  TP_API_CALLBACK_TYPE (*ApplTpGetRxBufferFct)(canuint8, canuint1
             -6, CanRxInfoStructPtr);
           =2 #    else
           =2   typedef TP_MEMORY_MODEL_DATA canuint8 *  TP_API_CALLBACK_TYPE (*ApplTpGetRxBufferFct)(canuint8, canuint1
             -6);
           =2 #    endif
           =2   typedef void        TP_API_CALLBACK_TYPE (*ApplTpIndicationFct)(canuint8, canuint16);
           =2   typedef void        TP_API_CALLBACK_TYPE (*ApplTpConfirmationFct)(canuint8, canuint8);
           =2   typedef void        TP_API_CALLBACK_TYPE (*ApplTpRxErrorIndicationFct)(canuint8, canuint8);
           =2   typedef canuint8    TP_API_CALLBACK_TYPE (*ApplTpTxErrorIndicationFct)(canuint8, canuint8);
           =2   typedef canuint8    TP_API_CALLBACK_TYPE (*ApplTpCopyToCanFct)(TpCopyToCanInfoStructPtr);
           =2   typedef void        TP_API_CALLBACK_TYPE (*ApplTpCopyFromCanFct)(canuint8, canuint8 *, canuint16);
           =2   typedef void        TP_API_CALLBACK_TYPE (*ApplTpNotificationFct)(canuint8, canuint8);
           =2   typedef void        TP_API_CALLBACK_TYPE (*ApplTpCanMessageTransmittedFct)(canuint8);
           =2   typedef void        TP_API_CALLBACK_TYPE (*ApplTpCanMessageReceivedFct)(canuint8);
           =2   typedef void        TP_API_CALLBACK_TYPE (*ApplTpTxFCFct)(canuint8);
           =2   typedef void        TP_API_CALLBACK_TYPE (*ApplTpSFFct)(canuint8);
           =2   typedef void        TP_API_CALLBACK_TYPE (*ApplTpFFFct)(canuint8);
           =2   typedef void        TP_API_CALLBACK_TYPE (*ApplTpCFFct)(canuint8);
           =2   /*******************************************************************************
           =2   * Transport layer callback functions: External pointer declaration
           =2   *******************************************************************************/
           =2   V_MEMROM0 extern V_MEMROM1 ApplTpIndicationFct            V_MEMROM2 TpRxIndication[];
           =2   V_MEMROM0 extern V_MEMROM1 ApplTpConfirmationFct          V_MEMROM2 TpTxConfirmation[];
           =2   V_MEMROM0 extern V_MEMROM1 ApplTpRxErrorIndicationFct     V_MEMROM2 TpRxErrorIndication[];
           =2   V_MEMROM0 extern V_MEMROM1 ApplTpTxErrorIndicationFct     V_MEMROM2 TpTxErrorIndication[];
           =2   V_MEMROM0 extern V_MEMROM1 ApplTpCopyToCanFct             V_MEMROM2 TpTxCopyToCan[];
           =2 #   if (TP_USE_CUSTOM_RX_MEMCPY == kTpOn)                    
           =2   V_MEMROM0 extern V_MEMROM1 ApplTpCopyFromCanFct           V_MEMROM2 TpRxCopyFromCan[];
           =2 #   endif                                                    
           =2   V_MEMROM0 extern V_MEMROM1 ApplTpNotificationFct          V_MEMROM2 TpTxNotification[];
           =2   V_MEMROM0 extern V_MEMROM1 ApplTpCanMessageTransmittedFct V_MEMROM2 TpTxCanMessageTransmitted[];
           =2   V_MEMROM0 extern V_MEMROM1 ApplTpCanMessageTransmittedFct V_MEMROM2 TpRxCanMessageTransmitted[];
           =2   V_MEMROM0 extern V_MEMROM1 ApplTpTxFCFct                  V_MEMROM2 TpTxFC[];
           =2   V_MEMROM0 extern V_MEMROM1 ApplTpSFFct                    V_MEMROM2 TpRxSF[];
           =2   V_MEMROM0 extern V_MEMROM1 ApplTpFFFct                    V_MEMROM2 TpRxFF[];
           =2   V_MEMROM0 extern V_MEMROM1 ApplTpCFFct                    V_MEMROM2 TpRxCF[];
           =2   V_MEMROM0 extern V_MEMROM1 ApplTpGetRxBufferFct           V_MEMROM2 TpGetRxBuffer[];
           =2 
           =2   V_MEMROM0 extern V_MEMROM1 canuint8 V_MEMROM2 TpTxFlowControl[kTpTxChannelCount];
           =2   V_MEMROM0 extern V_MEMROM1 canuint8 V_MEMROM2 TpRxFlowControl[kTpRxChannelCount];
           =2 
           =2 #   if defined (TP_ENABLE_NORMAL_MIXED11_ADDRESSING)
           =2   V_MEMROM0 extern V_MEMROM1 canuint8 V_MEMROM2 TpAddressingFormatOffset[kTpTxChannelCount];
           =2 #   endif
           =2 #  endif
           =2 #endif
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 285 

           =2 
           =2 /*******************************************************************************
           =2 * CODEDOUBLED CAN-DRIVERS
           =2 *******************************************************************************/
           =2 #if defined (C_MULTIPLE_RECEIVE_CHANNEL)
           =2 #else
           =2 # if ( kCanNumberOfChannels > 1 ) /* more than one CanChannel ? */
           =2   typedef canuint8 (*TpCanTransmitFct)(CanTransmitHandle txObject);
           =2 
           =2   typedef void (*TpCanCancelTransmitFct)(CanTransmitHandle txObject);
           =2  
           =2 # endif
           =2 #endif
           =2 
           =2 /*******************************************************************************
           =2 * Functional Reception Tree 
           =2 *******************************************************************************/
           =2 #if defined TP_FUNC_ENABLE_RECEPTION
           =2   
           =2   void TP_API_CALL_TYPE TpFuncResetChannel(void);
           =2   
           =2 #  if defined (TP_ENABLE_SINGLE_CHANNEL_TP)
           =2 #   define TpFuncSetResponse()
           =2 #  else
           =2 #   define TpFuncSetResponse(tpChannel)
           =2 #  endif
           =2   
           =2 # if defined (TP_FUNC_ENABLE_EXTENDED_ADDRESSING)      || \
           =2      defined (TP_FUNC_ENABLE_NORMAL_FIXED_ADDRESSING)  || \
           =2      defined (TP_FUNC_ENABLE_MIXED_29_ADDRESSING)
           =2   canuint8 TP_API_CALL_TYPE TpFuncGetSourceAddress(void);
           =2 # endif
           =2   
           =2 # if defined (TP_FUNC_ENABLE_EXTENDED_ADDRESSING)      || \
           =2      defined (TP_FUNC_ENABLE_NORMAL_FIXED_ADDRESSING)  || \
           =2      defined (TP_FUNC_ENABLE_MIXED_29_ADDRESSING)
           =2   canuint8 TP_API_CALL_TYPE TpFuncGetTargetAddress(void);
           =2 # endif
           =2   
           =2 #  if (kTpNumberOfCanChannels > 1)
           =2   extern canuint8 TP_API_CALL_TYPE TpFuncGetCanChannel(void);
           =2 #  else
           =2 #   define TpFuncGetCanChannel()                          (TP_CAN_CHANNEL_INDEX)
           =2 #  endif
           =2   CanChipDataPtr TP_API_CALL_TYPE TpFuncGetCanBuffer(void);
           =2 
           =2 # if defined (TP_FUNC_ENABLE_MIXED_29_ADDRESSING)      || \
           =2      defined (TP_FUNC_ENABLE_MIXED_11_ADDRESSING)
           =2   canuint8 TP_API_CALL_TYPE TpFuncGetAddressExtension(void);
           =2 # endif
           =2   
           =2 
           =2 #endif
           =2 /* endif TP_FUNC_ENABLE_RECEPTION */
           =2 
           =2 #if defined (__cplusplus)
           =2 }
           =2 #endif
           =2 
           =2 #endif /* OSEKTPMC_H */
2104      =2  /* STOPSINGLE_OF_MULTIPLE */
  54      =3  /* -----------------------------------------------------------------------------
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 286 

  54      =3    Filename:    v_inc.h
  54      =3    Description: Toolversion: 05.00.51.01.30.02.86.01.00.00
  54      =3                 
  54      =3                 Serial Number: CBD1300286
  54      =3                 Customer Info: Hyundai Mobis Co., Ltd.
  54      =3                                Package: CBD Hmc SLP5 - CBD License f. HKMC
  54      =3                                Micro: C8051F582
  54      =3                                Compiler: Keil PK51
  54      =3                 
  54      =3                 
  54      =3                 Generator Fwk   : GENy 
  54      =3                 Generator Module: GenTool_GenyVcfgNameDecorator
  54      =3                 
  54      =3                 Configuration   : Y:\20150903_DiagCam_DE.gny
  54      =3                 
  54      =3                 ECU: 
  54      =3                         TargetSystem: Hw_Slc8051Cpu
  54      =3                         Compiler:     KEIL
  54      =3                         Derivates:    C8051F58x_59x
  54      =3                 
  54      =3                 Channel "Channel0":
  54      =3                         Databasefile: Y:\20150206_JF_DiagCamera_CAN_DB_R6(LangInfo).dbc
  54      =3                         Bussystem:    CAN
  54      =3                         Manufacturer: HMC
  54      =3                         Node:         PGS
  54      =3  
  54      =3    Generated by , 2015-10-19  18:50:07
  54      =3   ----------------------------------------------------------------------------- */
  54      =3  /* -----------------------------------------------------------------------------
  54      =3    C O P Y R I G H T
  54      =3   -------------------------------------------------------------------------------
  54      =3    Copyright (c) 2001-2011 by Vector Informatik GmbH. All rights reserved.
  54      =3   
  54      =3    This software is copyright protected and proprietary to Vector Informatik 
  54      =3    GmbH.
  54      =3    
  54      =3    Vector Informatik GmbH grants to you only those rights as set out in the 
  54      =3    license conditions.
  54      =3    
  54      =3    All other rights remain with Vector Informatik GmbH.
  54      =3   -------------------------------------------------------------------------------
  54      =3   ----------------------------------------------------------------------------- */
  54      =3  
  54      =3  #if !defined(__V_INC_H__)
  54      =3  #define __V_INC_H__
  54      =3  
  54      =3  #include "can_inc.h"
  54      =3  
  54      =3  #include "v_cfg.h"
  54      =3  #include "drv_par.h"
  54      =3  
  54      =3  #include "nmb_cfg.h"
  54      =3  #include "tpmc.h"
  55      =3  
  56      =3  #include "v_par.h"
   1      =4  /* -----------------------------------------------------------------------------
   2      =4    Filename:    v_par.h
   3      =4    Description: Toolversion: 05.00.51.01.30.02.86.01.00.00
   4      =4                 
   5      =4                 Serial Number: CBD1300286
   6      =4                 Customer Info: Hyundai Mobis Co., Ltd.
   7      =4                                Package: CBD Hmc SLP5 - CBD License f. HKMC
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 287 

   8      =4                                Micro: C8051F582
   9      =4                                Compiler: Keil PK51
  10      =4                 
  11      =4                 
  12      =4                 Generator Fwk   : GENy 
  13      =4                 Generator Module: GenTool_GenyVcfgNameDecorator
  14      =4                 
  15      =4                 Configuration   : Y:\20150903_DiagCam_DE.gny
  16      =4                 
  17      =4                 ECU: 
  18      =4                         TargetSystem: Hw_Slc8051Cpu
  19      =4                         Compiler:     KEIL
  20      =4                         Derivates:    C8051F58x_59x
  21      =4                 
  22      =4                 Channel "Channel0":
  23      =4                         Databasefile: Y:\20150206_JF_DiagCamera_CAN_DB_R6(LangInfo).dbc
  24      =4                         Bussystem:    CAN
  25      =4                         Manufacturer: HMC
  26      =4                         Node:         PGS
  27      =4  
  28      =4    Generated by , 2015-10-19  18:50:07
  29      =4   ----------------------------------------------------------------------------- */
  30      =4  /* -----------------------------------------------------------------------------
  31      =4    C O P Y R I G H T
  32      =4   -------------------------------------------------------------------------------
  33      =4    Copyright (c) 2001-2011 by Vector Informatik GmbH. All rights reserved.
  34      =4   
  35      =4    This software is copyright protected and proprietary to Vector Informatik 
  36      =4    GmbH.
  37      =4    
  38      =4    Vector Informatik GmbH grants to you only those rights as set out in the 
  39      =4    license conditions.
  40      =4    
  41      =4    All other rights remain with Vector Informatik GmbH.
  42      =4   -------------------------------------------------------------------------------
  43      =4   ----------------------------------------------------------------------------- */
  44      =4  
  45      =4  #if !defined(__V_PAR_H__)
           =4 #define __V_PAR_H__
           =4 
           =4 /* -----------------------------------------------------------------------------
           =4     &&&~ BaseEnv_PHF_Includes
           =4  ----------------------------------------------------------------------------- */
           =4 
           =4 #include "v_cfg.h"
           =4 #include "v_def.h"
           =4 
           =4 
           =4 /* -----------------------------------------------------------------------------
           =4     &&&~ GENy Version Information
           =4  ----------------------------------------------------------------------------- */
           =4 
           =4 #define VGEN_DELIVERY_VERSION_BYTE_0         0x05
           =4 #define VGEN_DELIVERY_VERSION_BYTE_1         0x00
           =4 #define VGEN_DELIVERY_VERSION_BYTE_2         0x51
           =4 #define VGEN_DELIVERY_VERSION_BYTE_3         0x01
           =4 #define VGEN_DELIVERY_VERSION_BYTE_4         0x30
           =4 #define VGEN_DELIVERY_VERSION_BYTE_5         0x02
           =4 #define VGEN_DELIVERY_VERSION_BYTE_6         0x86
           =4 #define VGEN_DELIVERY_VERSION_BYTE_7         0x01
           =4 #define VGEN_DELIVERY_VERSION_BYTE_8         0x00
           =4 #define VGEN_DELIVERY_VERSION_BYTE_9         0x00
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 288 

           =4 #define kGENyVersionNumberOfBytes            10
           =4 /* ROM CATEGORY 4 START */
           =4 V_MEMROM0 extern  V_MEMROM1 vuint8 V_MEMROM2 kGENyVersion[kGENyVersionNumberOfBytes];
           =4 /* ROM CATEGORY 4 END */
           =4 
           =4 
           =4 
           =4 typedef struct tDBCVersionTag
           =4 {
           =4   vuint8 kYear;
           =4   vuint8 kMonth;
           =4   vuint8 kWeek;
           =4   vuint8 kDay;
           =4   vuint32 kNumber;
           =4 } tDBCVersion;
           =4 V_MEMROM0 extern  V_MEMROM1 tDBCVersion V_MEMROM2 kDBCVersion[1];
           =4 
           =4 /* begin Fileversion check */
           =4 #ifndef SKIP_MAGIC_NUMBER
           =4 #ifdef MAGIC_NUMBER
           =4   #if MAGIC_NUMBER != 204819919
           =4       #error "The magic number of the generated file <Y:\CANGEN\v_par.h> is different. Please check time a
             -nd date of generated files!"
           =4   #endif
           =4 #else
           =4   #define MAGIC_NUMBER 204819919
           =4 #endif  /* MAGIC_NUMBER */
           =4 #endif  /* SKIP_MAGIC_NUMBER */
           =4 
           =4 /* end Fileversion check */
           =4 
           =4 #endif /* __V_PAR_H__ */
  57      =3  #include "can_par.h"
   1      =4  /* -----------------------------------------------------------------------------
   2      =4    Filename:    can_par.h
   3      =4    Description: Toolversion: 05.00.51.01.30.02.86.01.00.00
   4      =4                 
   5      =4                 Serial Number: CBD1300286
   6      =4                 Customer Info: Hyundai Mobis Co., Ltd.
   7      =4                                Package: CBD Hmc SLP5 - CBD License f. HKMC
   8      =4                                Micro: C8051F582
   9      =4                                Compiler: Keil PK51
  10      =4                 
  11      =4                 
  12      =4                 Generator Fwk   : GENy 
  13      =4                 Generator Module: DrvCan__base
  14      =4                 
  15      =4                 Configuration   : Y:\20150903_DiagCam_DE.gny
  16      =4                 
  17      =4                 ECU: 
  18      =4                         TargetSystem: Hw_Slc8051Cpu
  19      =4                         Compiler:     KEIL
  20      =4                         Derivates:    C8051F58x_59x
  21      =4                 
  22      =4                 Channel "Channel0":
  23      =4                         Databasefile: Y:\20150206_JF_DiagCamera_CAN_DB_R6(LangInfo).dbc
  24      =4                         Bussystem:    CAN
  25      =4                         Manufacturer: HMC
  26      =4                         Node:         PGS
  27      =4  
  28      =4    Generated by , 2015-10-19  18:50:07
  29      =4   ----------------------------------------------------------------------------- */
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 289 

  30      =4  /* -----------------------------------------------------------------------------
  31      =4    C O P Y R I G H T
  32      =4   -------------------------------------------------------------------------------
  33      =4    Copyright (c) 2001-2011 by Vector Informatik GmbH. All rights reserved.
  34      =4   
  35      =4    This software is copyright protected and proprietary to Vector Informatik 
  36      =4    GmbH.
  37      =4    
  38      =4    Vector Informatik GmbH grants to you only those rights as set out in the 
  39      =4    license conditions.
  40      =4    
  41      =4    All other rights remain with Vector Informatik GmbH.
  42      =4   -------------------------------------------------------------------------------
  43      =4   ----------------------------------------------------------------------------- */
  44      =4  
  45      =4  #if !defined(__CAN_PAR_H__)
           =4 #define __CAN_PAR_H__
           =4 
           =4 #include "can_cfg.h"
           =4 #include "v_inc.h"
           =4 #include "drv_par.h"
           =4 
           =4 /* -----------------------------------------------------------------------------
           =4     &&&~ Extern declarations of callback functions
           =4  ----------------------------------------------------------------------------- */
           =4 
           =4 #if defined(C_MULTIPLE_RECEIVE_CHANNEL) || defined(C_SINGLE_RECEIVE_CHANNEL)
           =4 #endif
           =4 
           =4 /* CODE CATEGORY 1 START */
           =4 extern vuint8 IlMsgHU_MON_PE_01PreCopy(CanRxInfoStructPtr rxStruct);
           =4 /* CODE CATEGORY 1 END */
           =4 
           =4 /* CODE CATEGORY 1 START */
           =4 extern vuint8 IlMsgCGW4PreCopy(CanRxInfoStructPtr rxStruct);
           =4 /* CODE CATEGORY 1 END */
           =4 
           =4 /* CODE CATEGORY 1 START */
           =4 extern vuint8 IlMsgCGW2PreCopy(CanRxInfoStructPtr rxStruct);
           =4 /* CODE CATEGORY 1 END */
           =4 
           =4 /* CODE CATEGORY 1 START */
           =4 extern vuint8 IlMsgCLU15PreCopy(CanRxInfoStructPtr rxStruct);
           =4 /* CODE CATEGORY 1 END */
           =4 
           =4 /* CODE CATEGORY 1 START */
           =4 extern vuint8 IlMsgMDPS11PreCopy(CanRxInfoStructPtr rxStruct);
           =4 /* CODE CATEGORY 1 END */
           =4 
           =4 /* CODE CATEGORY 1 START */
           =4 extern vuint8 IlMsgSAS1PreCopy(CanRxInfoStructPtr rxStruct);
           =4 /* CODE CATEGORY 1 END */
           =4 
           =4 /* CODE CATEGORY 1 START */
           =4 extern vuint8 TpFuncPrecopy(CanRxInfoStructPtr rxStruct);
           =4 /* CODE CATEGORY 1 END */
           =4 
           =4 /* CODE CATEGORY 1 START */
           =4 extern vuint8 TpPrecopy(CanRxInfoStructPtr rxStruct);
           =4 /* CODE CATEGORY 1 END */
           =4 
           =4 
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 290 

           =4 /* -----------------------------------------------------------------------------
           =4     &&&~ Extern declarations of confirmation functions
           =4  ----------------------------------------------------------------------------- */
           =4 
           =4 /* CODE CATEGORY 1 START */
           =4 extern void TpDrvConfirmation(CanTransmitHandle txObject);
           =4 /* CODE CATEGORY 1 END */
           =4 
           =4 
           =4 
           =4 /* -----------------------------------------------------------------------------
           =4     &&&~ Extern declarations of indication functions
           =4  ----------------------------------------------------------------------------- */
           =4 
           =4 /* CODE CATEGORY 1 START */
           =4 extern void ISR_HuType(CanReceiveHandle rcvObject);
           =4 /* CODE CATEGORY 1 END */
           =4 
           =4 /* CODE CATEGORY 1 START */
           =4 extern void CanRxHU_MON_PE_01IndicationFct(CanReceiveHandle rcvObject);
           =4 /* CODE CATEGORY 1 END */
           =4 /* CODE CATEGORY 1 START */
           =4 extern void IlMsgHU_MON_PE_01Indication(CanReceiveHandle rcvObject);
           =4 /* CODE CATEGORY 1 END */
           =4 
           =4 /* CODE CATEGORY 1 START */
           =4 extern void ISR_NaviOnOff(CanReceiveHandle rcvObject);
           =4 /* CODE CATEGORY 1 END */
           =4 
           =4 extern void CanRxCGW4IndicationFct(CanReceiveHandle rcvObject);
           =4 /* CODE CATEGORY 1 START */
           =4 extern void IlMsgCGW4Indication(CanReceiveHandle rcvObject);
           =4 /* CODE CATEGORY 1 END */
           =4 
           =4 /* CODE CATEGORY 1 START */
           =4 extern void ISR_CountryCfg(CanReceiveHandle rcvObject);
           =4 /* CODE CATEGORY 1 END */
           =4 
           =4 extern void CanRxCGW2IndicationFct(CanReceiveHandle rcvObject);
           =4 /* CODE CATEGORY 1 START */
           =4 extern void IlMsgCGW2Indication(CanReceiveHandle rcvObject);
           =4 /* CODE CATEGORY 1 END */
           =4 
           =4 /* CODE CATEGORY 1 START */
           =4 extern void ISR_LanguageInfo(CanReceiveHandle rcvObject);
           =4 /* CODE CATEGORY 1 END */
           =4 
           =4 extern void CanRxCLU15IndicationFct(CanReceiveHandle rcvObject);
           =4 /* CODE CATEGORY 1 START */
           =4 extern void IlMsgCLU15Indication(CanReceiveHandle rcvObject);
           =4 /* CODE CATEGORY 1 END */
           =4 
           =4 /* CODE CATEGORY 1 START */
           =4 extern void ISR_MdpsType(CanReceiveHandle rcvObject);
           =4 /* CODE CATEGORY 1 END */
           =4 
           =4 extern void CanRxMDPS11IndicationFct(CanReceiveHandle rcvObject);
           =4 /* CODE CATEGORY 1 START */
           =4 extern void IlMsgMDPS11Indication(CanReceiveHandle rcvObject);
           =4 /* CODE CATEGORY 1 END */
           =4 
           =4 /* CODE CATEGORY 1 START */
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 291 

           =4 extern void ISR_SAS(CanReceiveHandle rcvObject);
           =4 /* CODE CATEGORY 1 END */
           =4 
           =4 extern void CanRxSAS1IndicationFct(CanReceiveHandle rcvObject);
           =4 /* CODE CATEGORY 1 START */
           =4 extern void IlMsgSAS1Indication(CanReceiveHandle rcvObject);
           =4 /* CODE CATEGORY 1 END */
           =4 
           =4 
           =4 
           =4 
           =4 
           =4 /* -----------------------------------------------------------------------------
           =4     &&&~ Handles of send objects
           =4  ----------------------------------------------------------------------------- */
           =4 
           =4 #define CanTxPGS_GST                         0
           =4 
           =4 
           =4 /* -----------------------------------------------------------------------------
           =4     &&&~ Handles of receive objects
           =4  ----------------------------------------------------------------------------- */
           =4 
           =4 #define CanRxHU_MON_PE_01                    0
           =4 #define CanRxCGW4                            1
           =4 #define CanRxCGW2                            2
           =4 #define CanRxCLU15                           3
           =4 #define CanRxMDPS11                          4
           =4 #define CanRxSAS1                            5
           =4 #define CanRxGST1                            6
           =4 #define CanRxGST_PGS                         7
           =4 
           =4 
           =4 /* -----------------------------------------------------------------------------
           =4     &&&~ Access to data bytes of Rx messages
           =4  ----------------------------------------------------------------------------- */
           =4 
           =4 /* ID: 0x0000057f, Handle: 0, HU_MON_PE_01 [FC] */
           =4 #define c1_HU_MON_PE_01_c                    (HU_MON_PE_01._c[0])
           =4 
           =4 /* ID: 0x00000559, Handle: 1, CGW4 [FC] */
           =4 #define c1_CGW4_c                            (CGW4._c[0])
           =4 #define c2_CGW4_c                            (CGW4._c[1])
           =4 #define c3_CGW4_c                            (CGW4._c[2])
           =4 #define c4_CGW4_c                            (CGW4._c[3])
           =4 #define c5_CGW4_c                            (CGW4._c[4])
           =4 #define c6_CGW4_c                            (CGW4._c[5])
           =4 #define c7_CGW4_c                            (CGW4._c[6])
           =4 
           =4 /* ID: 0x00000553, Handle: 2, CGW2 [FC] */
           =4 #define c1_CGW2_c                            (CGW2._c[0])
           =4 #define c2_CGW2_c                            (CGW2._c[1])
           =4 #define c3_CGW2_c                            (CGW2._c[2])
           =4 #define c4_CGW2_c                            (CGW2._c[3])
           =4 
           =4 /* ID: 0x0000052a, Handle: 3, CLU15 [FC] */
           =4 #define c1_CLU15_c                           (CLU15._c[0])
           =4 #define c2_CLU15_c                           (CLU15._c[1])
           =4 #define c3_CLU15_c                           (CLU15._c[2])
           =4 #define c4_CLU15_c                           (CLU15._c[3])
           =4 #define c5_CLU15_c                           (CLU15._c[4])
           =4 
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 292 

           =4 /* ID: 0x00000381, Handle: 4, MDPS11 [FC] */
           =4 #define c1_MDPS11_c                          (MDPS11._c[0])
           =4 #define c2_MDPS11_c                          (MDPS11._c[1])
           =4 #define c3_MDPS11_c                          (MDPS11._c[2])
           =4 #define c4_MDPS11_c                          (MDPS11._c[3])
           =4 #define c5_MDPS11_c                          (MDPS11._c[4])
           =4 #define c6_MDPS11_c                          (MDPS11._c[5])
           =4 #define c7_MDPS11_c                          (MDPS11._c[6])
           =4 #define c8_MDPS11_c                          (MDPS11._c[7])
           =4 
           =4 /* ID: 0x000002b0, Handle: 5, SAS1 [FC] */
           =4 #define c1_SAS1_c                            (SAS1._c[0])
           =4 #define c2_SAS1_c                            (SAS1._c[1])
           =4 
           =4 
           =4 
           =4 /* -----------------------------------------------------------------------------
           =4     &&&~ Access to data bytes of Tx messages
           =4  ----------------------------------------------------------------------------- */
           =4 
           =4 /* ID: 0x0000079e, Handle: 0, PGS_GST [FC] */
           =4 #define c1_PGS_GST_c                         (PGS_GST._c[0])
           =4 #define c2_PGS_GST_c                         (PGS_GST._c[1])
           =4 #define c3_PGS_GST_c                         (PGS_GST._c[2])
           =4 #define c4_PGS_GST_c                         (PGS_GST._c[3])
           =4 #define c5_PGS_GST_c                         (PGS_GST._c[4])
           =4 #define c6_PGS_GST_c                         (PGS_GST._c[5])
           =4 #define c7_PGS_GST_c                         (PGS_GST._c[6])
           =4 #define c8_PGS_GST_c                         (PGS_GST._c[7])
           =4 
           =4 
           =4 
           =4 /* -----------------------------------------------------------------------------
           =4     &&&~ RDS Access
           =4  ----------------------------------------------------------------------------- */
           =4 
           =4 typedef struct _c_PGS_GST_RDS_msgTypeTag
           =4 {
           =4   vbittype PGS_GST_Byte0_TPCI : 8;
           =4   vbittype PGS_GST_Byte1_Data : 8;
           =4   vbittype PGS_GST_Byte2_Data : 8;
           =4   vbittype PGS_GST_Byte3_Data : 8;
           =4   vbittype PGS_GST_Byte4_Data : 8;
           =4   vbittype PGS_GST_Byte5_Data : 8;
           =4   vbittype PGS_GST_Byte6_Data : 8;
           =4   vbittype PGS_GST_Byte7_Data : 8;
           =4 } _c_PGS_GST_RDS_msgType;
           =4 
           =4 typedef struct _c_GST1_RDS_msgTypeTag
           =4 {
           =4   vbittype FRM_FORMAT : 8;
           =4   vbittype SID : 8;
           =4   vbittype REQ_RESPONSE : 8;
           =4   vbittype Reserved_GST1_1 : 8;
           =4   vbittype Reserved_GST1_2 : 8;
           =4   vbittype Reserved_GST1_3 : 8;
           =4   vbittype Reserved_GST1_4 : 8;
           =4   vbittype Reserved_GST1_5 : 8;
           =4 } _c_GST1_RDS_msgType;
           =4 
           =4 typedef struct _c_GST_PGS_RDS_msgTypeTag
           =4 {
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 293 

           =4   vbittype GST_PGS_Byte0_TPCI : 8;
           =4   vbittype GST_PGS_Byte1_Data : 8;
           =4   vbittype GST_PGS_Byte2_Data : 8;
           =4   vbittype GST_PGS_Byte3_Data : 8;
           =4   vbittype GST_PGS_Byte4_Data : 8;
           =4   vbittype GST_PGS_Byte5_Data : 8;
           =4   vbittype GST_PGS_Byte6_Data : 8;
           =4   vbittype GST_PGS_Byte7_Data : 8;
           =4 } _c_GST_PGS_RDS_msgType;
           =4 
           =4 typedef struct _c_HU_MON_PE_01_RDS_msgTypeTag
           =4 {
           =4   vbittype HU_TYPE : 8;
           =4 } _c_HU_MON_PE_01_RDS_msgType;
           =4 
           =4 typedef struct _c_CGW4_RDS_msgTypeTag
           =4 {
           =4   vbittype unused0 : 8;
           =4   vbittype unused1 : 8;
           =4   vbittype unused2 : 8;
           =4   vbittype unused3 : 8;
           =4   vbittype unused4 : 8;
           =4   vbittype unused5 : 8;
           =4   vbittype unused6 : 7;
           =4   vbittype CF_Gway_Navi_On_Off : 1;
           =4 } _c_CGW4_RDS_msgType;
           =4 
           =4 typedef struct _c_CGW2_RDS_msgTypeTag
           =4 {
           =4   vbittype unused0 : 8;
           =4   vbittype unused1 : 8;
           =4   vbittype unused2 : 8;
           =4   vbittype unused3 : 2;
           =4   vbittype CF_Gway_CountryCfg : 3;
           =4   vbittype unused4 : 3;
           =4 } _c_CGW2_RDS_msgType;
           =4 
           =4 typedef struct _c_CLU15_RDS_msgTypeTag
           =4 {
           =4   vbittype unused0 : 8;
           =4   vbittype unused1 : 8;
           =4   vbittype unused2 : 8;
           =4   vbittype unused3 : 8;
           =4   vbittype unused4 : 1;
           =4   vbittype CF_Clu_LanguageInfo : 5;
           =4   vbittype unused5 : 2;
           =4 } _c_CLU15_RDS_msgType;
           =4 
           =4 typedef struct _c_MDPS11_RDS_msgTypeTag
           =4 {
           =4   vbittype unused0 : 8;
           =4   vbittype unused1 : 8;
           =4   vbittype unused2 : 8;
           =4   vbittype unused3 : 8;
           =4   vbittype unused4 : 8;
           =4   vbittype unused5 : 8;
           =4   vbittype unused6 : 8;
           =4   vbittype unused7 : 5;
           =4   vbittype CF_Mdps_Type : 2;
           =4   vbittype unused8 : 1;
           =4 } _c_MDPS11_RDS_msgType;
           =4 
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 294 

           =4 typedef struct _c_SAS1_RDS_msgTypeTag
           =4 {
           =4   vbittype SAS_Angle_0 : 8;
           =4   vbittype SAS_Angle_1 : 8;
           =4 } _c_SAS1_RDS_msgType;
           =4 
           =4 typedef union _c_RDS1_bufTag
           =4 {
           =4   vuint8 _c[8];
           =4   _c_PGS_GST_RDS_msgType PGS_GST;
           =4 } _c_RDS1_buf;
           =4 typedef union _c_RDS23_bufTag
           =4 {
           =4   vuint8 _c[8];
           =4   _c_GST1_RDS_msgType GST1;
           =4 } _c_RDS23_buf;
           =4 typedef union _c_RDS24_bufTag
           =4 {
           =4   vuint8 _c[8];
           =4   _c_GST_PGS_RDS_msgType GST_PGS;
           =4 } _c_RDS24_buf;
           =4 typedef union _c_RDS25_bufTag
           =4 {
           =4   vuint8 _c[1];
           =4   _c_HU_MON_PE_01_RDS_msgType HU_MON_PE_01;
           =4 } _c_RDS25_buf;
           =4 typedef union _c_RDS26_bufTag
           =4 {
           =4   vuint8 _c[7];
           =4   _c_CGW4_RDS_msgType CGW4;
           =4 } _c_RDS26_buf;
           =4 typedef union _c_RDS27_bufTag
           =4 {
           =4   vuint8 _c[4];
           =4   _c_CGW2_RDS_msgType CGW2;
           =4 } _c_RDS27_buf;
           =4 typedef union _c_RDS28_bufTag
           =4 {
           =4   vuint8 _c[5];
           =4   _c_CLU15_RDS_msgType CLU15;
           =4 } _c_RDS28_buf;
           =4 typedef union _c_RDS29_bufTag
           =4 {
           =4   vuint8 _c[8];
           =4   _c_MDPS11_RDS_msgType MDPS11;
           =4 } _c_RDS29_buf;
           =4 typedef union _c_RDS30_bufTag
           =4 {
           =4   vuint8 _c[2];
           =4   _c_SAS1_RDS_msgType SAS1;
           =4 } _c_RDS30_buf;
           =4 
           =4 
           =4 #define RDS1                                 ((* ((_c_RDS1_buf MEMORY_NORMAL *)(canRDSTxPtr[0]))))
           =4 #define RDS23                                ((* ((_c_RDS23_buf MEMORY_NORMAL *)(canRDSRxPtr[0]))))
           =4 #define RDS24                                ((* ((_c_RDS24_buf MEMORY_NORMAL *)(canRDSRxPtr[0]))))
           =4 #define RDS25                                ((* ((_c_RDS25_buf MEMORY_NORMAL *)(canRDSRxPtr[0]))))
           =4 #define RDS26                                ((* ((_c_RDS26_buf MEMORY_NORMAL *)(canRDSRxPtr[0]))))
           =4 #define RDS27                                ((* ((_c_RDS27_buf MEMORY_NORMAL *)(canRDSRxPtr[0]))))
           =4 #define RDS28                                ((* ((_c_RDS28_buf MEMORY_NORMAL *)(canRDSRxPtr[0]))))
           =4 #define RDS29                                ((* ((_c_RDS29_buf MEMORY_NORMAL *)(canRDSRxPtr[0]))))
           =4 #define RDS30                                ((* ((_c_RDS30_buf MEMORY_NORMAL *)(canRDSRxPtr[0]))))
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 295 

           =4 
           =4 
           =4 
           =4 /* -----------------------------------------------------------------------------
           =4     &&&~ Message Hardware Objects
           =4  ----------------------------------------------------------------------------- */
           =4 
           =4 #define CanTxPGS_GST_HW_OBJ                  1
           =4 #define CanTxPGS_GST_HW_CHANNEL              0
           =4 #define C_TX_NORMAL_HW_OBJ                   2
           =4 #define C_TX_NORMAL_HW_CHANNEL               0
           =4 #define CanRxGST1_HW_OBJ                     23
           =4 #define CanRxGST1_HW_CHANNEL                 0
           =4 #define CanRxGST_PGS_HW_OBJ                  24
           =4 #define CanRxGST_PGS_HW_CHANNEL              0
           =4 #define CanRxHU_MON_PE_01_HW_OBJ             25
           =4 #define CanRxHU_MON_PE_01_HW_CHANNEL         0
           =4 #define CanRxCGW4_HW_OBJ                     26
           =4 #define CanRxCGW4_HW_CHANNEL                 0
           =4 #define CanRxCGW2_HW_OBJ                     27
           =4 #define CanRxCGW2_HW_CHANNEL                 0
           =4 #define CanRxCLU15_HW_OBJ                    28
           =4 #define CanRxCLU15_HW_CHANNEL                0
           =4 #define CanRxMDPS11_HW_OBJ                   29
           =4 #define CanRxMDPS11_HW_CHANNEL               0
           =4 #define CanRxSAS1_HW_OBJ                     30
           =4 #define CanRxSAS1_HW_CHANNEL                 0
           =4 #define C_BASIC0_HW_OBJ                      31
           =4 #define C_BASIC0_HW_CHANNEL                  0
           =4 
           =4 
           =4 
           =4 /* -----------------------------------------------------------------------------
           =4     &&&~ Message Hardware Objects
           =4  ----------------------------------------------------------------------------- */
           =4 
           =4 #define CanTxPGS_GST_HW_OBJ                  1
           =4 #define CanTxPGS_GST_HW_CHANNEL              0
           =4 #define C_TX_NORMAL_HW_OBJ                   2
           =4 #define C_TX_NORMAL_HW_CHANNEL               0
           =4 #define CanRxGST1_HW_OBJ                     23
           =4 #define CanRxGST1_HW_CHANNEL                 0
           =4 #define CanRxGST_PGS_HW_OBJ                  24
           =4 #define CanRxGST_PGS_HW_CHANNEL              0
           =4 #define CanRxHU_MON_PE_01_HW_OBJ             25
           =4 #define CanRxHU_MON_PE_01_HW_CHANNEL         0
           =4 #define CanRxCGW4_HW_OBJ                     26
           =4 #define CanRxCGW4_HW_CHANNEL                 0
           =4 #define CanRxCGW2_HW_OBJ                     27
           =4 #define CanRxCGW2_HW_CHANNEL                 0
           =4 #define CanRxCLU15_HW_OBJ                    28
           =4 #define CanRxCLU15_HW_CHANNEL                0
           =4 #define CanRxMDPS11_HW_OBJ                   29
           =4 #define CanRxMDPS11_HW_CHANNEL               0
           =4 #define CanRxSAS1_HW_OBJ                     30
           =4 #define CanRxSAS1_HW_CHANNEL                 0
           =4 #define C_BASIC0_HW_OBJ                      31
           =4 #define C_BASIC0_HW_CHANNEL                  0
           =4 
           =4 
           =4 
           =4 
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 296 

           =4 
           =4 /* begin Fileversion check */
           =4 #ifndef SKIP_MAGIC_NUMBER
           =4 #ifdef MAGIC_NUMBER
           =4   #if MAGIC_NUMBER != 204819919
           =4       #error "The magic number of the generated file <Y:\CANGEN\can_par.h> is different. Please check time
             - and date of generated files!"
           =4   #endif
           =4 #else
           =4   #define MAGIC_NUMBER 204819919
           =4 #endif  /* MAGIC_NUMBER */
           =4 #endif  /* SKIP_MAGIC_NUMBER */
           =4 
           =4 /* end Fileversion check */
           =4 
           =4 #endif /* __CAN_PAR_H__ */
  58      =3  
  59      =3  /* begin Fileversion check */
  60      =3  #ifndef SKIP_MAGIC_NUMBER
  61      =3  #ifdef MAGIC_NUMBER
  62      =3    #if MAGIC_NUMBER != 204819919
           =3       #error "The magic number of the generated file <Y:\CANGEN\v_inc.h> is different. Please check time a
             -nd date of generated files!"
           =3   #endif
  65      =3  #else
           =3   #define MAGIC_NUMBER 204819919
           =3 #endif  /* MAGIC_NUMBER */
  68      =3  #endif  /* SKIP_MAGIC_NUMBER */
  69      =3  
  70      =3  /* end Fileversion check */
  71      =3  
  72      =3  #endif /* __V_INC_H__ */
  49      =4  /* -----------------------------------------------------------------------------
  49      =4    Filename:    can_par.h
  49      =4    Description: Toolversion: 05.00.51.01.30.02.86.01.00.00
  49      =4                 
  49      =4                 Serial Number: CBD1300286
  49      =4                 Customer Info: Hyundai Mobis Co., Ltd.
  49      =4                                Package: CBD Hmc SLP5 - CBD License f. HKMC
  49      =4                                Micro: C8051F582
  49      =4                                Compiler: Keil PK51
  49      =4                 
  49      =4                 
  49      =4                 Generator Fwk   : GENy 
  49      =4                 Generator Module: DrvCan__base
  49      =4                 
  49      =4                 Configuration   : Y:\20150903_DiagCam_DE.gny
  49      =4                 
  49      =4                 ECU: 
  49      =4                         TargetSystem: Hw_Slc8051Cpu
  49      =4                         Compiler:     KEIL
  49      =4                         Derivates:    C8051F58x_59x
  49      =4                 
  49      =4                 Channel "Channel0":
  49      =4                         Databasefile: Y:\20150206_JF_DiagCamera_CAN_DB_R6(LangInfo).dbc
  49      =4                         Bussystem:    CAN
  49      =4                         Manufacturer: HMC
  49      =4                         Node:         PGS
  49      =4  
  49      =4    Generated by , 2015-10-19  18:50:07
  49      =4   ----------------------------------------------------------------------------- */
  49      =4  /* -----------------------------------------------------------------------------
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 297 

  49      =4    C O P Y R I G H T
  49      =4   -------------------------------------------------------------------------------
  49      =4    Copyright (c) 2001-2011 by Vector Informatik GmbH. All rights reserved.
  49      =4   
  49      =4    This software is copyright protected and proprietary to Vector Informatik 
  49      =4    GmbH.
  49      =4    
  49      =4    Vector Informatik GmbH grants to you only those rights as set out in the 
  49      =4    license conditions.
  49      =4    
  49      =4    All other rights remain with Vector Informatik GmbH.
  49      =4   -------------------------------------------------------------------------------
  49      =4   ----------------------------------------------------------------------------- */
  49      =4  
  49      =4  #if !defined(__CAN_PAR_H__)
  49      =4  #define __CAN_PAR_H__
  49      =4  
  49      =4  #include "can_cfg.h"
  49      =4  #include "v_inc.h"
  50      =4  #include "drv_par.h"
   1      =5  /* -----------------------------------------------------------------------------
   2      =5    Filename:    drv_par.h
   3      =5    Description: Toolversion: 05.00.51.01.30.02.86.01.00.00
   4      =5                 
   5      =5                 Serial Number: CBD1300286
   6      =5                 Customer Info: Hyundai Mobis Co., Ltd.
   7      =5                                Package: CBD Hmc SLP5 - CBD License f. HKMC
   8      =5                                Micro: C8051F582
   9      =5                                Compiler: Keil PK51
  10      =5                 
  11      =5                 
  12      =5                 Generator Fwk   : GENy 
  13      =5                 Generator Module: GenTool_GenyDriverBase
  14      =5                 
  15      =5                 Configuration   : Y:\20150903_DiagCam_DE.gny
  16      =5                 
  17      =5                 ECU: 
  18      =5                         TargetSystem: Hw_Slc8051Cpu
  19      =5                         Compiler:     KEIL
  20      =5                         Derivates:    C8051F58x_59x
  21      =5                 
  22      =5                 Channel "Channel0":
  23      =5                         Databasefile: Y:\20150206_JF_DiagCamera_CAN_DB_R6(LangInfo).dbc
  24      =5                         Bussystem:    CAN
  25      =5                         Manufacturer: HMC
  26      =5                         Node:         PGS
  27      =5  
  28      =5    Generated by , 2015-10-19  18:50:07
  29      =5   ----------------------------------------------------------------------------- */
  30      =5  /* -----------------------------------------------------------------------------
  31      =5    C O P Y R I G H T
  32      =5   -------------------------------------------------------------------------------
  33      =5    Copyright (c) 2001-2011 by Vector Informatik GmbH. All rights reserved.
  34      =5   
  35      =5    This software is copyright protected and proprietary to Vector Informatik 
  36      =5    GmbH.
  37      =5    
  38      =5    Vector Informatik GmbH grants to you only those rights as set out in the 
  39      =5    license conditions.
  40      =5    
  41      =5    All other rights remain with Vector Informatik GmbH.
  42      =5   -------------------------------------------------------------------------------
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 298 

  43      =5   ----------------------------------------------------------------------------- */
  44      =5  
  45      =5  #if !defined(__DRV_PAR_H__)
           =5 #define __DRV_PAR_H__
           =5 
           =5 /* -----------------------------------------------------------------------------
           =5     &&&~ Signal Structures
           =5  ----------------------------------------------------------------------------- */
           =5 
           =5 typedef struct _c_MDPS11_msgTypeTag
           =5 {
           =5   vbittype unused0 : 8;
           =5   vbittype unused1 : 8;
           =5   vbittype unused2 : 8;
           =5   vbittype unused3 : 8;
           =5   vbittype unused4 : 8;
           =5   vbittype unused5 : 8;
           =5   vbittype unused6 : 8;
           =5   vbittype unused7 : 5;
           =5   vbittype CF_Mdps_Type : 2;
           =5   vbittype unused8 : 1;
           =5 } _c_MDPS11_msgType;
           =5 typedef struct _c_HU_MON_PE_01_msgTypeTag
           =5 {
           =5   vbittype HU_TYPE : 8;
           =5 } _c_HU_MON_PE_01_msgType;
           =5 typedef struct _c_CGW4_msgTypeTag
           =5 {
           =5   vbittype unused0 : 8;
           =5   vbittype unused1 : 8;
           =5   vbittype unused2 : 8;
           =5   vbittype unused3 : 8;
           =5   vbittype unused4 : 8;
           =5   vbittype unused5 : 8;
           =5   vbittype unused6 : 7;
           =5   vbittype CF_Gway_Navi_On_Off : 1;
           =5 } _c_CGW4_msgType;
           =5 typedef struct _c_CGW2_msgTypeTag
           =5 {
           =5   vbittype unused0 : 8;
           =5   vbittype unused1 : 8;
           =5   vbittype unused2 : 8;
           =5   vbittype unused3 : 2;
           =5   vbittype CF_Gway_CountryCfg : 3;
           =5   vbittype unused4 : 3;
           =5 } _c_CGW2_msgType;
           =5 typedef struct _c_CLU15_msgTypeTag
           =5 {
           =5   vbittype unused0 : 8;
           =5   vbittype unused1 : 8;
           =5   vbittype unused2 : 8;
           =5   vbittype unused3 : 8;
           =5   vbittype unused4 : 1;
           =5   vbittype CF_Clu_LanguageInfo : 5;
           =5   vbittype unused5 : 2;
           =5 } _c_CLU15_msgType;
           =5 typedef struct _c_PGS_GST_msgTypeTag
           =5 {
           =5   vbittype PGS_GST_Byte0_TPCI : 8;
           =5   vbittype PGS_GST_Byte1_Data : 8;
           =5   vbittype PGS_GST_Byte2_Data : 8;
           =5   vbittype PGS_GST_Byte3_Data : 8;
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 299 

           =5   vbittype PGS_GST_Byte4_Data : 8;
           =5   vbittype PGS_GST_Byte5_Data : 8;
           =5   vbittype PGS_GST_Byte6_Data : 8;
           =5   vbittype PGS_GST_Byte7_Data : 8;
           =5 } _c_PGS_GST_msgType;
           =5 typedef struct _c_SAS1_msgTypeTag
           =5 {
           =5   vbittype SAS_Angle_0 : 8;
           =5   vbittype SAS_Angle_1 : 8;
           =5 } _c_SAS1_msgType;
           =5 
           =5 
           =5 /* -----------------------------------------------------------------------------
           =5     &&&~ Signal value names
           =5  ----------------------------------------------------------------------------- */
           =5 
           =5 
           =5 
           =5 /* -----------------------------------------------------------------------------
           =5     &&&~ Message Unions
           =5  ----------------------------------------------------------------------------- */
           =5 
           =5 typedef union _c_MDPS11_bufTag
           =5 {
           =5   vuint8 _c[8];
           =5   _c_MDPS11_msgType MDPS11;
           =5 } _c_MDPS11_buf;
           =5 typedef union _c_HU_MON_PE_01_bufTag
           =5 {
           =5   vuint8 _c[1];
           =5   _c_HU_MON_PE_01_msgType HU_MON_PE_01;
           =5 } _c_HU_MON_PE_01_buf;
           =5 typedef union _c_CGW4_bufTag
           =5 {
           =5   vuint8 _c[7];
           =5   _c_CGW4_msgType CGW4;
           =5 } _c_CGW4_buf;
           =5 typedef union _c_CGW2_bufTag
           =5 {
           =5   vuint8 _c[4];
           =5   _c_CGW2_msgType CGW2;
           =5 } _c_CGW2_buf;
           =5 typedef union _c_CLU15_bufTag
           =5 {
           =5   vuint8 _c[5];
           =5   _c_CLU15_msgType CLU15;
           =5 } _c_CLU15_buf;
           =5 typedef union _c_PGS_GST_bufTag
           =5 {
           =5   vuint8 _c[8];
           =5   _c_PGS_GST_msgType PGS_GST;
           =5 } _c_PGS_GST_buf;
           =5 typedef union _c_SAS1_bufTag
           =5 {
           =5   vuint8 _c[2];
           =5   _c_SAS1_msgType SAS1;
           =5 } _c_SAS1_buf;
           =5 
           =5 
           =5 /* -----------------------------------------------------------------------------
           =5     &&&~ Message Buffers
           =5  ----------------------------------------------------------------------------- */
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 300 

           =5 
           =5 /* RAM CATEGORY 2 START */
           =5 V_MEMRAM0 extern  V_MEMRAM1 _c_MDPS11_buf V_MEMRAM2 MDPS11;
           =5 /* RAM CATEGORY 2 END */
           =5 
           =5 /* RAM CATEGORY 2 START */
           =5 V_MEMRAM0 extern  V_MEMRAM1 _c_HU_MON_PE_01_buf V_MEMRAM2 HU_MON_PE_01;
           =5 /* RAM CATEGORY 2 END */
           =5 
           =5 /* RAM CATEGORY 2 START */
           =5 V_MEMRAM0 extern  V_MEMRAM1 _c_CGW4_buf V_MEMRAM2 CGW4;
           =5 /* RAM CATEGORY 2 END */
           =5 
           =5 /* RAM CATEGORY 2 START */
           =5 V_MEMRAM0 extern  V_MEMRAM1 _c_CGW2_buf V_MEMRAM2 CGW2;
           =5 /* RAM CATEGORY 2 END */
           =5 
           =5 /* RAM CATEGORY 2 START */
           =5 V_MEMRAM0 extern  V_MEMRAM1 _c_CLU15_buf V_MEMRAM2 CLU15;
           =5 /* RAM CATEGORY 2 END */
           =5 
           =5 /* RAM CATEGORY 2 START */
           =5 /* RAM CATEGORY 2 END */
           =5 
           =5 /* RAM CATEGORY 2 START */
           =5 V_MEMRAM0 extern  V_MEMRAM1 _c_PGS_GST_buf V_MEMRAM2 PGS_GST;
           =5 /* RAM CATEGORY 2 END */
           =5 
           =5 /* RAM CATEGORY 2 START */
           =5 /* RAM CATEGORY 2 END */
           =5 
           =5 /* RAM CATEGORY 2 START */
           =5 V_MEMRAM0 extern  V_MEMRAM1 _c_SAS1_buf V_MEMRAM2 SAS1;
           =5 /* RAM CATEGORY 2 END */
           =5 
           =5 
           =5 
           =5 
           =5 
           =5 
           =5 /* begin Fileversion check */
           =5 #ifndef SKIP_MAGIC_NUMBER
           =5 #ifdef MAGIC_NUMBER
           =5   #if MAGIC_NUMBER != 204819919
           =5       #error "The magic number of the generated file <Y:\CANGEN\drv_par.h> is different. Please check time
             - and date of generated files!"
           =5   #endif
           =5 #else
           =5   #define MAGIC_NUMBER 204819919
           =5 #endif  /* MAGIC_NUMBER */
           =5 #endif  /* SKIP_MAGIC_NUMBER */
           =5 
           =5 /* end Fileversion check */
           =5 
           =5 #endif /* __DRV_PAR_H__ */
  51      =4  
  52      =4  /* -----------------------------------------------------------------------------
  53      =4      &&&~ Extern declarations of callback functions
  54      =4   ----------------------------------------------------------------------------- */
  55      =4  
  56      =4  #if defined(C_MULTIPLE_RECEIVE_CHANNEL) || defined(C_SINGLE_RECEIVE_CHANNEL)
  57      =4  #endif
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 301 

  58      =4  
  59      =4  /* CODE CATEGORY 1 START */
  60      =4  extern vuint8 IlMsgHU_MON_PE_01PreCopy(CanRxInfoStructPtr rxStruct);
  61      =4  /* CODE CATEGORY 1 END */
  62      =4  
  63      =4  /* CODE CATEGORY 1 START */
  64      =4  extern vuint8 IlMsgCGW4PreCopy(CanRxInfoStructPtr rxStruct);
  65      =4  /* CODE CATEGORY 1 END */
  66      =4  
  67      =4  /* CODE CATEGORY 1 START */
  68      =4  extern vuint8 IlMsgCGW2PreCopy(CanRxInfoStructPtr rxStruct);
  69      =4  /* CODE CATEGORY 1 END */
  70      =4  
  71      =4  /* CODE CATEGORY 1 START */
  72      =4  extern vuint8 IlMsgCLU15PreCopy(CanRxInfoStructPtr rxStruct);
  73      =4  /* CODE CATEGORY 1 END */
  74      =4  
  75      =4  /* CODE CATEGORY 1 START */
  76      =4  extern vuint8 IlMsgMDPS11PreCopy(CanRxInfoStructPtr rxStruct);
  77      =4  /* CODE CATEGORY 1 END */
  78      =4  
  79      =4  /* CODE CATEGORY 1 START */
  80      =4  extern vuint8 IlMsgSAS1PreCopy(CanRxInfoStructPtr rxStruct);
  81      =4  /* CODE CATEGORY 1 END */
  82      =4  
  83      =4  /* CODE CATEGORY 1 START */
  84      =4  extern vuint8 TpFuncPrecopy(CanRxInfoStructPtr rxStruct);
  85      =4  /* CODE CATEGORY 1 END */
  86      =4  
  87      =4  /* CODE CATEGORY 1 START */
  88      =4  extern vuint8 TpPrecopy(CanRxInfoStructPtr rxStruct);
  89      =4  /* CODE CATEGORY 1 END */
  90      =4  
  91      =4  
  92      =4  /* -----------------------------------------------------------------------------
  93      =4      &&&~ Extern declarations of confirmation functions
  94      =4   ----------------------------------------------------------------------------- */
  95      =4  
  96      =4  /* CODE CATEGORY 1 START */
  97      =4  extern void TpDrvConfirmation(CanTransmitHandle txObject);
  98      =4  /* CODE CATEGORY 1 END */
  99      =4  
 100      =4  
 101      =4  
 102      =4  /* -----------------------------------------------------------------------------
 103      =4      &&&~ Extern declarations of indication functions
 104      =4   ----------------------------------------------------------------------------- */
 105      =4  
 106      =4  /* CODE CATEGORY 1 START */
 107      =4  extern void ISR_HuType(CanReceiveHandle rcvObject);
 108      =4  /* CODE CATEGORY 1 END */
 109      =4  
 110      =4  /* CODE CATEGORY 1 START */
 111      =4  extern void CanRxHU_MON_PE_01IndicationFct(CanReceiveHandle rcvObject);
 112      =4  /* CODE CATEGORY 1 END */
 113      =4  /* CODE CATEGORY 1 START */
 114      =4  extern void IlMsgHU_MON_PE_01Indication(CanReceiveHandle rcvObject);
 115      =4  /* CODE CATEGORY 1 END */
 116      =4  
 117      =4  /* CODE CATEGORY 1 START */
 118      =4  extern void ISR_NaviOnOff(CanReceiveHandle rcvObject);
 119      =4  /* CODE CATEGORY 1 END */
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 302 

 120      =4  
 121      =4  extern void CanRxCGW4IndicationFct(CanReceiveHandle rcvObject);
 122      =4  /* CODE CATEGORY 1 START */
 123      =4  extern void IlMsgCGW4Indication(CanReceiveHandle rcvObject);
 124      =4  /* CODE CATEGORY 1 END */
 125      =4  
 126      =4  /* CODE CATEGORY 1 START */
 127      =4  extern void ISR_CountryCfg(CanReceiveHandle rcvObject);
 128      =4  /* CODE CATEGORY 1 END */
 129      =4  
 130      =4  extern void CanRxCGW2IndicationFct(CanReceiveHandle rcvObject);
 131      =4  /* CODE CATEGORY 1 START */
 132      =4  extern void IlMsgCGW2Indication(CanReceiveHandle rcvObject);
 133      =4  /* CODE CATEGORY 1 END */
 134      =4  
 135      =4  /* CODE CATEGORY 1 START */
 136      =4  extern void ISR_LanguageInfo(CanReceiveHandle rcvObject);
 137      =4  /* CODE CATEGORY 1 END */
 138      =4  
 139      =4  extern void CanRxCLU15IndicationFct(CanReceiveHandle rcvObject);
 140      =4  /* CODE CATEGORY 1 START */
 141      =4  extern void IlMsgCLU15Indication(CanReceiveHandle rcvObject);
 142      =4  /* CODE CATEGORY 1 END */
 143      =4  
 144      =4  /* CODE CATEGORY 1 START */
 145      =4  extern void ISR_MdpsType(CanReceiveHandle rcvObject);
 146      =4  /* CODE CATEGORY 1 END */
 147      =4  
 148      =4  extern void CanRxMDPS11IndicationFct(CanReceiveHandle rcvObject);
 149      =4  /* CODE CATEGORY 1 START */
 150      =4  extern void IlMsgMDPS11Indication(CanReceiveHandle rcvObject);
 151      =4  /* CODE CATEGORY 1 END */
 152      =4  
 153      =4  /* CODE CATEGORY 1 START */
 154      =4  extern void ISR_SAS(CanReceiveHandle rcvObject);
 155      =4  /* CODE CATEGORY 1 END */
 156      =4  
 157      =4  extern void CanRxSAS1IndicationFct(CanReceiveHandle rcvObject);
 158      =4  /* CODE CATEGORY 1 START */
 159      =4  extern void IlMsgSAS1Indication(CanReceiveHandle rcvObject);
 160      =4  /* CODE CATEGORY 1 END */
 161      =4  
 162      =4  
 163      =4  
 164      =4  
 165      =4  
 166      =4  /* -----------------------------------------------------------------------------
 167      =4      &&&~ Handles of send objects
 168      =4   ----------------------------------------------------------------------------- */
 169      =4  
 170      =4  #define CanTxPGS_GST                         0
 171      =4  
 172      =4  
 173      =4  /* -----------------------------------------------------------------------------
 174      =4      &&&~ Handles of receive objects
 175      =4   ----------------------------------------------------------------------------- */
 176      =4  
 177      =4  #define CanRxHU_MON_PE_01                    0
 178      =4  #define CanRxCGW4                            1
 179      =4  #define CanRxCGW2                            2
 180      =4  #define CanRxCLU15                           3
 181      =4  #define CanRxMDPS11                          4
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 303 

 182      =4  #define CanRxSAS1                            5
 183      =4  #define CanRxGST1                            6
 184      =4  #define CanRxGST_PGS                         7
 185      =4  
 186      =4  
 187      =4  /* -----------------------------------------------------------------------------
 188      =4      &&&~ Access to data bytes of Rx messages
 189      =4   ----------------------------------------------------------------------------- */
 190      =4  
 191      =4  /* ID: 0x0000057f, Handle: 0, HU_MON_PE_01 [FC] */
 192      =4  #define c1_HU_MON_PE_01_c                    (HU_MON_PE_01._c[0])
 193      =4  
 194      =4  /* ID: 0x00000559, Handle: 1, CGW4 [FC] */
 195      =4  #define c1_CGW4_c                            (CGW4._c[0])
 196      =4  #define c2_CGW4_c                            (CGW4._c[1])
 197      =4  #define c3_CGW4_c                            (CGW4._c[2])
 198      =4  #define c4_CGW4_c                            (CGW4._c[3])
 199      =4  #define c5_CGW4_c                            (CGW4._c[4])
 200      =4  #define c6_CGW4_c                            (CGW4._c[5])
 201      =4  #define c7_CGW4_c                            (CGW4._c[6])
 202      =4  
 203      =4  /* ID: 0x00000553, Handle: 2, CGW2 [FC] */
 204      =4  #define c1_CGW2_c                            (CGW2._c[0])
 205      =4  #define c2_CGW2_c                            (CGW2._c[1])
 206      =4  #define c3_CGW2_c                            (CGW2._c[2])
 207      =4  #define c4_CGW2_c                            (CGW2._c[3])
 208      =4  
 209      =4  /* ID: 0x0000052a, Handle: 3, CLU15 [FC] */
 210      =4  #define c1_CLU15_c                           (CLU15._c[0])
 211      =4  #define c2_CLU15_c                           (CLU15._c[1])
 212      =4  #define c3_CLU15_c                           (CLU15._c[2])
 213      =4  #define c4_CLU15_c                           (CLU15._c[3])
 214      =4  #define c5_CLU15_c                           (CLU15._c[4])
 215      =4  
 216      =4  /* ID: 0x00000381, Handle: 4, MDPS11 [FC] */
 217      =4  #define c1_MDPS11_c                          (MDPS11._c[0])
 218      =4  #define c2_MDPS11_c                          (MDPS11._c[1])
 219      =4  #define c3_MDPS11_c                          (MDPS11._c[2])
 220      =4  #define c4_MDPS11_c                          (MDPS11._c[3])
 221      =4  #define c5_MDPS11_c                          (MDPS11._c[4])
 222      =4  #define c6_MDPS11_c                          (MDPS11._c[5])
 223      =4  #define c7_MDPS11_c                          (MDPS11._c[6])
 224      =4  #define c8_MDPS11_c                          (MDPS11._c[7])
 225      =4  
 226      =4  /* ID: 0x000002b0, Handle: 5, SAS1 [FC] */
 227      =4  #define c1_SAS1_c                            (SAS1._c[0])
 228      =4  #define c2_SAS1_c                            (SAS1._c[1])
 229      =4  
 230      =4  
 231      =4  
 232      =4  /* -----------------------------------------------------------------------------
 233      =4      &&&~ Access to data bytes of Tx messages
 234      =4   ----------------------------------------------------------------------------- */
 235      =4  
 236      =4  /* ID: 0x0000079e, Handle: 0, PGS_GST [FC] */
 237      =4  #define c1_PGS_GST_c                         (PGS_GST._c[0])
 238      =4  #define c2_PGS_GST_c                         (PGS_GST._c[1])
 239      =4  #define c3_PGS_GST_c                         (PGS_GST._c[2])
 240      =4  #define c4_PGS_GST_c                         (PGS_GST._c[3])
 241      =4  #define c5_PGS_GST_c                         (PGS_GST._c[4])
 242      =4  #define c6_PGS_GST_c                         (PGS_GST._c[5])
 243      =4  #define c7_PGS_GST_c                         (PGS_GST._c[6])
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 304 

 244      =4  #define c8_PGS_GST_c                         (PGS_GST._c[7])
 245      =4  
 246      =4  
 247      =4  
 248      =4  /* -----------------------------------------------------------------------------
 249      =4      &&&~ RDS Access
 250      =4   ----------------------------------------------------------------------------- */
 251      =4  
 252      =4  typedef struct _c_PGS_GST_RDS_msgTypeTag
 253      =4  {
 254      =4    vbittype PGS_GST_Byte0_TPCI : 8;
 255      =4    vbittype PGS_GST_Byte1_Data : 8;
 256      =4    vbittype PGS_GST_Byte2_Data : 8;
 257      =4    vbittype PGS_GST_Byte3_Data : 8;
 258      =4    vbittype PGS_GST_Byte4_Data : 8;
 259      =4    vbittype PGS_GST_Byte5_Data : 8;
 260      =4    vbittype PGS_GST_Byte6_Data : 8;
 261      =4    vbittype PGS_GST_Byte7_Data : 8;
 262      =4  } _c_PGS_GST_RDS_msgType;
 263      =4  
 264      =4  typedef struct _c_GST1_RDS_msgTypeTag
 265      =4  {
 266      =4    vbittype FRM_FORMAT : 8;
 267      =4    vbittype SID : 8;
 268      =4    vbittype REQ_RESPONSE : 8;
 269      =4    vbittype Reserved_GST1_1 : 8;
 270      =4    vbittype Reserved_GST1_2 : 8;
 271      =4    vbittype Reserved_GST1_3 : 8;
 272      =4    vbittype Reserved_GST1_4 : 8;
 273      =4    vbittype Reserved_GST1_5 : 8;
 274      =4  } _c_GST1_RDS_msgType;
 275      =4  
 276      =4  typedef struct _c_GST_PGS_RDS_msgTypeTag
 277      =4  {
 278      =4    vbittype GST_PGS_Byte0_TPCI : 8;
 279      =4    vbittype GST_PGS_Byte1_Data : 8;
 280      =4    vbittype GST_PGS_Byte2_Data : 8;
 281      =4    vbittype GST_PGS_Byte3_Data : 8;
 282      =4    vbittype GST_PGS_Byte4_Data : 8;
 283      =4    vbittype GST_PGS_Byte5_Data : 8;
 284      =4    vbittype GST_PGS_Byte6_Data : 8;
 285      =4    vbittype GST_PGS_Byte7_Data : 8;
 286      =4  } _c_GST_PGS_RDS_msgType;
 287      =4  
 288      =4  typedef struct _c_HU_MON_PE_01_RDS_msgTypeTag
 289      =4  {
 290      =4    vbittype HU_TYPE : 8;
 291      =4  } _c_HU_MON_PE_01_RDS_msgType;
 292      =4  
 293      =4  typedef struct _c_CGW4_RDS_msgTypeTag
 294      =4  {
 295      =4    vbittype unused0 : 8;
 296      =4    vbittype unused1 : 8;
 297      =4    vbittype unused2 : 8;
 298      =4    vbittype unused3 : 8;
 299      =4    vbittype unused4 : 8;
 300      =4    vbittype unused5 : 8;
 301      =4    vbittype unused6 : 7;
 302      =4    vbittype CF_Gway_Navi_On_Off : 1;
 303      =4  } _c_CGW4_RDS_msgType;
 304      =4  
 305      =4  typedef struct _c_CGW2_RDS_msgTypeTag
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 305 

 306      =4  {
 307      =4    vbittype unused0 : 8;
 308      =4    vbittype unused1 : 8;
 309      =4    vbittype unused2 : 8;
 310      =4    vbittype unused3 : 2;
 311      =4    vbittype CF_Gway_CountryCfg : 3;
 312      =4    vbittype unused4 : 3;
 313      =4  } _c_CGW2_RDS_msgType;
 314      =4  
 315      =4  typedef struct _c_CLU15_RDS_msgTypeTag
 316      =4  {
 317      =4    vbittype unused0 : 8;
 318      =4    vbittype unused1 : 8;
 319      =4    vbittype unused2 : 8;
 320      =4    vbittype unused3 : 8;
 321      =4    vbittype unused4 : 1;
 322      =4    vbittype CF_Clu_LanguageInfo : 5;
 323      =4    vbittype unused5 : 2;
 324      =4  } _c_CLU15_RDS_msgType;
 325      =4  
 326      =4  typedef struct _c_MDPS11_RDS_msgTypeTag
 327      =4  {
 328      =4    vbittype unused0 : 8;
 329      =4    vbittype unused1 : 8;
 330      =4    vbittype unused2 : 8;
 331      =4    vbittype unused3 : 8;
 332      =4    vbittype unused4 : 8;
 333      =4    vbittype unused5 : 8;
 334      =4    vbittype unused6 : 8;
 335      =4    vbittype unused7 : 5;
 336      =4    vbittype CF_Mdps_Type : 2;
 337      =4    vbittype unused8 : 1;
 338      =4  } _c_MDPS11_RDS_msgType;
 339      =4  
 340      =4  typedef struct _c_SAS1_RDS_msgTypeTag
 341      =4  {
 342      =4    vbittype SAS_Angle_0 : 8;
 343      =4    vbittype SAS_Angle_1 : 8;
 344      =4  } _c_SAS1_RDS_msgType;
 345      =4  
 346      =4  typedef union _c_RDS1_bufTag
 347      =4  {
 348      =4    vuint8 _c[8];
 349      =4    _c_PGS_GST_RDS_msgType PGS_GST;
 350      =4  } _c_RDS1_buf;
 351      =4  typedef union _c_RDS23_bufTag
 352      =4  {
 353      =4    vuint8 _c[8];
 354      =4    _c_GST1_RDS_msgType GST1;
 355      =4  } _c_RDS23_buf;
 356      =4  typedef union _c_RDS24_bufTag
 357      =4  {
 358      =4    vuint8 _c[8];
 359      =4    _c_GST_PGS_RDS_msgType GST_PGS;
 360      =4  } _c_RDS24_buf;
 361      =4  typedef union _c_RDS25_bufTag
 362      =4  {
 363      =4    vuint8 _c[1];
 364      =4    _c_HU_MON_PE_01_RDS_msgType HU_MON_PE_01;
 365      =4  } _c_RDS25_buf;
 366      =4  typedef union _c_RDS26_bufTag
 367      =4  {
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 306 

 368      =4    vuint8 _c[7];
 369      =4    _c_CGW4_RDS_msgType CGW4;
 370      =4  } _c_RDS26_buf;
 371      =4  typedef union _c_RDS27_bufTag
 372      =4  {
 373      =4    vuint8 _c[4];
 374      =4    _c_CGW2_RDS_msgType CGW2;
 375      =4  } _c_RDS27_buf;
 376      =4  typedef union _c_RDS28_bufTag
 377      =4  {
 378      =4    vuint8 _c[5];
 379      =4    _c_CLU15_RDS_msgType CLU15;
 380      =4  } _c_RDS28_buf;
 381      =4  typedef union _c_RDS29_bufTag
 382      =4  {
 383      =4    vuint8 _c[8];
 384      =4    _c_MDPS11_RDS_msgType MDPS11;
 385      =4  } _c_RDS29_buf;
 386      =4  typedef union _c_RDS30_bufTag
 387      =4  {
 388      =4    vuint8 _c[2];
 389      =4    _c_SAS1_RDS_msgType SAS1;
 390      =4  } _c_RDS30_buf;
 391      =4  
 392      =4  
 393      =4  #define RDS1                                 ((* ((_c_RDS1_buf MEMORY_NORMAL *)(canRDSTxPtr[0]))))
 394      =4  #define RDS23                                ((* ((_c_RDS23_buf MEMORY_NORMAL *)(canRDSRxPtr[0]))))
 395      =4  #define RDS24                                ((* ((_c_RDS24_buf MEMORY_NORMAL *)(canRDSRxPtr[0]))))
 396      =4  #define RDS25                                ((* ((_c_RDS25_buf MEMORY_NORMAL *)(canRDSRxPtr[0]))))
 397      =4  #define RDS26                                ((* ((_c_RDS26_buf MEMORY_NORMAL *)(canRDSRxPtr[0]))))
 398      =4  #define RDS27                                ((* ((_c_RDS27_buf MEMORY_NORMAL *)(canRDSRxPtr[0]))))
 399      =4  #define RDS28                                ((* ((_c_RDS28_buf MEMORY_NORMAL *)(canRDSRxPtr[0]))))
 400      =4  #define RDS29                                ((* ((_c_RDS29_buf MEMORY_NORMAL *)(canRDSRxPtr[0]))))
 401      =4  #define RDS30                                ((* ((_c_RDS30_buf MEMORY_NORMAL *)(canRDSRxPtr[0]))))
 402      =4  
 403      =4  
 404      =4  
 405      =4  /* -----------------------------------------------------------------------------
 406      =4      &&&~ Message Hardware Objects
 407      =4   ----------------------------------------------------------------------------- */
 408      =4  
 409      =4  #define CanTxPGS_GST_HW_OBJ                  1
 410      =4  #define CanTxPGS_GST_HW_CHANNEL              0
 411      =4  #define C_TX_NORMAL_HW_OBJ                   2
 412      =4  #define C_TX_NORMAL_HW_CHANNEL               0
 413      =4  #define CanRxGST1_HW_OBJ                     23
 414      =4  #define CanRxGST1_HW_CHANNEL                 0
 415      =4  #define CanRxGST_PGS_HW_OBJ                  24
 416      =4  #define CanRxGST_PGS_HW_CHANNEL              0
 417      =4  #define CanRxHU_MON_PE_01_HW_OBJ             25
 418      =4  #define CanRxHU_MON_PE_01_HW_CHANNEL         0
 419      =4  #define CanRxCGW4_HW_OBJ                     26
 420      =4  #define CanRxCGW4_HW_CHANNEL                 0
 421      =4  #define CanRxCGW2_HW_OBJ                     27
 422      =4  #define CanRxCGW2_HW_CHANNEL                 0
 423      =4  #define CanRxCLU15_HW_OBJ                    28
 424      =4  #define CanRxCLU15_HW_CHANNEL                0
 425      =4  #define CanRxMDPS11_HW_OBJ                   29
 426      =4  #define CanRxMDPS11_HW_CHANNEL               0
 427      =4  #define CanRxSAS1_HW_OBJ                     30
 428      =4  #define CanRxSAS1_HW_CHANNEL                 0
 429      =4  #define C_BASIC0_HW_OBJ                      31
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 307 

 430      =4  #define C_BASIC0_HW_CHANNEL                  0
 431      =4  
 432      =4  
 433      =4  
 434      =4  /* -----------------------------------------------------------------------------
 435      =4      &&&~ Message Hardware Objects
 436      =4   ----------------------------------------------------------------------------- */
 437      =4  
 438      =4  #define CanTxPGS_GST_HW_OBJ                  1
 439      =4  #define CanTxPGS_GST_HW_CHANNEL              0
 440      =4  #define C_TX_NORMAL_HW_OBJ                   2
 441      =4  #define C_TX_NORMAL_HW_CHANNEL               0
 442      =4  #define CanRxGST1_HW_OBJ                     23
 443      =4  #define CanRxGST1_HW_CHANNEL                 0
 444      =4  #define CanRxGST_PGS_HW_OBJ                  24
 445      =4  #define CanRxGST_PGS_HW_CHANNEL              0
 446      =4  #define CanRxHU_MON_PE_01_HW_OBJ             25
 447      =4  #define CanRxHU_MON_PE_01_HW_CHANNEL         0
 448      =4  #define CanRxCGW4_HW_OBJ                     26
 449      =4  #define CanRxCGW4_HW_CHANNEL                 0
 450      =4  #define CanRxCGW2_HW_OBJ                     27
 451      =4  #define CanRxCGW2_HW_CHANNEL                 0
 452      =4  #define CanRxCLU15_HW_OBJ                    28
 453      =4  #define CanRxCLU15_HW_CHANNEL                0
 454      =4  #define CanRxMDPS11_HW_OBJ                   29
 455      =4  #define CanRxMDPS11_HW_CHANNEL               0
 456      =4  #define CanRxSAS1_HW_OBJ                     30
 457      =4  #define CanRxSAS1_HW_CHANNEL                 0
 458      =4  #define C_BASIC0_HW_OBJ                      31
 459      =4  #define C_BASIC0_HW_CHANNEL                  0
 460      =4  
 461      =4  
 462      =4  
 463      =4  
 464      =4  
 465      =4  /* begin Fileversion check */
 466      =4  #ifndef SKIP_MAGIC_NUMBER
 467      =4  #ifdef MAGIC_NUMBER
 468      =4    #if MAGIC_NUMBER != 204819919
           =4       #error "The magic number of the generated file <Y:\CANGEN\can_par.h> is different. Please check time
             - and date of generated files!"
           =4   #endif
 471      =4  #else
           =4   #define MAGIC_NUMBER 204819919
           =4 #endif  /* MAGIC_NUMBER */
 474      =4  #endif  /* SKIP_MAGIC_NUMBER */
 475      =4  
 476      =4  /* end Fileversion check */
 477      =4  
 478      =4  #endif /* __CAN_PAR_H__ */
  48      =5  /* -----------------------------------------------------------------------------
  48      =5    Filename:    tp_cfg.h
  48      =5    Description: Toolversion: 05.00.51.01.30.02.86.01.00.00
  48      =5                 
  48      =5                 Serial Number: CBD1300286
  48      =5                 Customer Info: Hyundai Mobis Co., Ltd.
  48      =5                                Package: CBD Hmc SLP5 - CBD License f. HKMC
  48      =5                                Micro: C8051F582
  48      =5                                Compiler: Keil PK51
  48      =5                 
  48      =5                 
  48      =5                 Generator Fwk   : GENy 
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 308 

  48      =5                 Generator Module: Tp_Iso15765
  48      =5                 
  48      =5                 Configuration   : Y:\20150903_DiagCam_DE.gny
  48      =5                 
  48      =5                 ECU: 
  48      =5                         TargetSystem: Hw_Slc8051Cpu
  48      =5                         Compiler:     KEIL
  48      =5                         Derivates:    C8051F58x_59x
  48      =5                 
  48      =5                 Channel "Channel0":
  48      =5                         Databasefile: Y:\20150206_JF_DiagCamera_CAN_DB_R6(LangInfo).dbc
  48      =5                         Bussystem:    CAN
  48      =5                         Manufacturer: HMC
  48      =5                         Node:         PGS
  48      =5  
  48      =5    Generated by , 2015-10-19  18:50:07
  48      =5   ----------------------------------------------------------------------------- */
  48      =5  /* -----------------------------------------------------------------------------
  48      =5    C O P Y R I G H T
  48      =5   -------------------------------------------------------------------------------
  48      =5    Copyright (c) 2001-2011 by Vector Informatik GmbH. All rights reserved.
  48      =5   
  48      =5    This software is copyright protected and proprietary to Vector Informatik 
  48      =5    GmbH.
  48      =5    
  48      =5    Vector Informatik GmbH grants to you only those rights as set out in the 
  48      =5    license conditions.
  48      =5    
  48      =5    All other rights remain with Vector Informatik GmbH.
  48      =5   -------------------------------------------------------------------------------
  48      =5   ----------------------------------------------------------------------------- */
  48      =5  
  48      =5  #if !defined(__TP_CFG_H__)
  48      =5  #define __TP_CFG_H__
  48      =5  
  48      =5  #include "can_par.h"
  49      =5  #define TP_MEMORY_MODEL_DATA
  50      =5  
  51      =5  #define TP_ENABLE_SINGLE_MSG_OBJ
  52      =5  #define TP_ISO15765DLL_VERSION               0x0234
  53      =5  #define TP_ISO15765DLL_RELEASE_VERSION       0x00
  54      =5  
  55      =5  #define kTpNumberOfCanChannels               1
  56      =5  #ifndef kTpOn
  57      =5  #define kTpOn                                1
  58      =5  #endif
  59      =5  
  60      =5  #ifndef kTpOff
  61      =5  #define kTpOff                               0
  62      =5  #endif
  63      =5  
  64      =5  #define TP_TYPE_SINGLE_NORMAL_ADDRESSING_MULTI_BASED
  65      =5  struct tTpCopyToCanInfoStruct_s
  66      =5  {
  67      =5    canuint8                       Channel;     /* TP Channel                           */
  68      =5    TxDataPtr                      pDestination;/* Pointer to destination buffer        */
  69      =5    TP_MEMORY_MODEL_DATA canuint8* pSource;     /* Pointer to source buffer (if linear) */
  70      =5    canuint16                      Length;      /* The maximum length to copy           */
  71      =5  };
  72      =5  typedef struct tTpCopyToCanInfoStruct_s tTpCopyToCanInfoStruct;
  73      =5  typedef struct tTpCopyToCanInfoStruct_s *TpCopyToCanInfoStructPtr;
  74      =5  
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 309 

  75      =5  #define TP_USE_ISO_COMPLIANCE                kTpOn
  76      =5  #define TP_USE_FAST_PRECOPY                  kTpOff
  77      =5  #define TP_USE_DIAGPRECOPY                   kTpOff
  78      =5  #define TP_CAN_CHANNEL_INDEX                 0
  79      =5  #define TP_ENABLE_ISO_15765_2_2
  80      =5  #define TP_DISABLE_ASR_SINGLE_TP
  81      =5  #define TP_DISABLE_OBD_PRECOPY
  82      =5  
  83      =5  /* -----------------------------------------------------------------------------
  84      =5      &&&~ 
  85      =5   ----------------------------------------------------------------------------- */
  86      =5  
  87      =5  #define TP_USE_EXTENDED_API_BS               kTpOff
  88      =5  #define TP_USE_EXTENDED_API_STMIN            kTpOff
  89      =5  #define TP_USE_TX_OF_FC_IN_ISR               kTpOn
  90      =5  #define TP_USE_OVERRUN_INDICATION            kTpOff
  91      =5  #define TP_USE_ONLY_FIRST_FC                 kTpOn
  92      =5  #define TP_USE_FAST_TX_TRANSMISSION          kTpOff
  93      =5  #define TP_USE_QUEUE_IN_ISR                  kTpOn
  94      =5  #define TP_USE_NO_STMIN_AFTER_FC             kTpOff
  95      =5  #define MEMORY_NEAR_TP_SAVE                  MEMORY_NEAR
  96      =5  #define TP_USE_TX_HANDLE_CHANGEABLE          kTpOff
  97      =5  #define TP_USE_GATEWAY_API                   kTpOff
  98      =5  #define TP_USE_RX_CHANNEL_WITHOUT_FC         kTpOff
  99      =5  #define TP_USE_TX_CHANNEL_WITHOUT_FC         kTpOff
 100      =5  #define TP_USE_OLD_STMIN_CALCULATION         kTpOff
 101      =5  #define TP_USE_VARIABLE_RX_DLC_CHECK         kTpOff
 102      =5  #define TP_USE_FIX_RX_DLC_CHECK              kTpOff
 103      =5  #define TP_USE_PADDING                       kTpOn
 104      =5  #define TP_PADDING_PATTERN                   0xAA
 105      =5  #define TP_USE_VARIABLE_DLC                  kTpOff
 106      =5  #define TP_DISABLE_IGNORE_FC_RES_STMIN
 107      =5  #define TP_DISABLE_CANCEL_FC_RES_STMIN
 108      =5  #define TP_DISABLE_IGNORE_FC_OVFL
 109      =5  #define TP_DISABLE_WAIT_FOR_CORRECT_SN
 110      =5  #define TP_DISABLE_SINGLE_CHAN_MULTICONN
 111      =5  #define TP_DISABLE_FC_WAIT
 112      =5  #define TP_USE_UNEXPECTED_FC_CANCELATION     kTpOff
 113      =5  #define TP_DISABLE_EXT_COPYFROMCAN_API
 114      =5  
 115      =5  
 116      =5  /* -----------------------------------------------------------------------------
 117      =5      &&&~ 
 118      =5   ----------------------------------------------------------------------------- */
 119      =5  
 120      =5  #define TP_USE_NORMAL_ADDRESSING             kTpOn
 121      =5  #define TP_USE_NORMAL_FIXED_ADDRESSING       kTpOff
 122      =5  #define TP_USE_EXTENDED_ADDRESSING           kTpOff
 123      =5  #define TP_USE_MIXED_11_ADDRESSING           kTpOff
 124      =5  #define TP_USE_MIXED_29_ADDRESSING           kTpOff
 125      =5  #define TP_ENABLE_SINGLE_CHANNEL_TP
 126      =5  #define TP_DISABLE_MULTIPLE_ADDRESSING
 127      =5  #define TP_DISABLE_MULTIPLE_NODES
 128      =5  #define TP_ENABLE_USER_CHECK
 129      =5  #define TP_ENABLE_INTERNAL_CHECK
 130      =5  #define TP_ENABLE_GEN_CHECK
 131      =5  #define TP_ENABLE_RUNTIME_CHECK
 132      =5  
 133      =5  
 134      =5  /* -----------------------------------------------------------------------------
 135      =5      &&&~ 
 136      =5   ----------------------------------------------------------------------------- */
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 310 

 137      =5  
 138      =5  #define TP_USE_PRE_COPY_CHECK                kTpOff
 139      =5  #define TP_USE_APPL_PRECOPY                  kTpOff
 140      =5  #define TP_USE_FREE_CHANNEL_SEARCH           kTpOff
 141      =5  #define TP_USE_CUSTOM_RX_MEMCPY              kTpOff
 142      =5  #define TP_DISABLE_FUNCTIONAL_FC_WAIT
 143      =5  
 144      =5  
 145      =5  /* -----------------------------------------------------------------------------
 146      =5      &&&~ 
 147      =5   ----------------------------------------------------------------------------- */
 148      =5  
 149      =5  #define TP_USE_STMIN_OF_FC                   kTpOn
 150      =5  #define TP_USE_TP_TRANSMIT_QUEUE             kTpOff
 151      =5  #define TP_USE_DYN_ID                        kTpOff
 152      =5  #define TP_USE_CUSTOM_TX_MEMCPY              kTpOn
 153      =5  
 154      =5  
 155      =5  /* -----------------------------------------------------------------------------
 156      =5      &&&~ 
 157      =5   ----------------------------------------------------------------------------- */
 158      =5  
 159      =5  #define TP_USE_WAIT_FRAMES                   kTpOff
 160      =5  #define TP_USE_MULTIPLE_BASEADDRESS          kTpOff
 161      =5  #define TP_USE_PRE_DISPATCHED_MODE           kTpOff
 162      =5  
 163      =5  
 164      =5  /* -----------------------------------------------------------------------------
 165      =5      &&&~ 
 166      =5   ----------------------------------------------------------------------------- */
 167      =5  
 168      =5  #define TP_USE_EXT_IDS_FOR_NORMAL            kTpOff
 169      =5  #define TP_USE_MIXED_IDS_FOR_NORMAL          kTpOff
 170      =5  
 171      =5  
 172      =5  /* -----------------------------------------------------------------------------
 173      =5      &&&~ 
 174      =5   ----------------------------------------------------------------------------- */
 175      =5  
 176      =5  #define TP_DISABLE_MIN_TIMER
 177      =5  #define kTpTxChannelCount                    1
 178      =5  #define kTpRxChannelCount                    1
 179      =5  
 180      =5  #define TpMemCpy                             memcpy
 181      =5  #define TpTxCallCycle                        10
 182      =5  #define TpRxCallCycle                        10
 183      =5  
 184      =5  #define kBSRequested                         8
 185      =5  #define kTpTxConfirmationTimeout             101
 186      =5  #define kTpRxConfirmationTimeout             101
 187      =5  #define TpSTMin                              1
 188      =5  #define TpTxTimeoutFC                        101
 189      =5  #define TpRxTimeoutCF                        101
 190      =5  #define TpTxTransmitCF                       1
 191      =5  #define __ApplTpPreCopyCheckFunction(x)
 192      =5  #define __ApplTpPrecopyCheckFCFunctional(tpCurrentTargetAddress)
 193      =5  #define TP_DISABLE_CHECKTA_COMPATIBILITY
 194      =5  
 195      =5  
 196      =5  /* -----------------------------------------------------------------------------
 197      =5      &&&~ 
 198      =5   ----------------------------------------------------------------------------- */
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 311 

 199      =5  
 200      =5  #define TP_FUNC_ENABLE_RECEPTION
 201      =5  #define TP_FUNC_ENABLE_NORMAL_ADDRESSING
 202      =5  #define TP_FUNC_DISABLE_NORMAL_FIXED_ADDRESSING
 203      =5  #define TP_FUNC_DISABLE_EXTENDED_ADDRESSING
 204      =5  #define TP_FUNC_DISABLE_MIXED_11_ADDRESSING
 205      =5  #define TP_FUNC_DISABLE_MIXED_29_ADDRESSING
 206      =5  #define TP_FUNC_DISABLE_APPL_PRECOPY
 207      =5  #define __ApplTpFuncGetBuffer                DescGetFuncBuffer
 208      =5  canuint8* DescGetFuncBuffer(vuint16 dataLength);
 209      =5  #define __ApplTpFuncIndication               DescFuncReqInd
 210      =5  void DescFuncReqInd(vuint16 dataLength);
 211      =5  
 212      =5  
 213      =5  #define TP_USE_TP_INDICATION kTpOn
 214      =5  #define TP_USE_RX_ERROR_INDICATION kTpOn
 215      =5  #define TP_USE_TP_CONFIRMATION kTpOn
 216      =5  #define TP_USE_TP_RX_SF kTpOff
 217      =5  #define TP_USE_TP_RX_FF kTpOff
 218      =5  #define TP_USE_TP_RX_CF kTpOff
 219      =5  #define TP_USE_TP_NOTIFY_TX kTpOff
 220      =5  #define TP_USE_TP_CAN_MESSAGE_TRANSMITTED kTpOff
 221      =5  #define TP_USE_TP_TX_FC kTpOff
 222      =5  #define TP_USE_TP_RX_GET_BUFFER kTpOn
 223      =5  #define TP_USE_TX_ERROR_INDICATION kTpOn
 224      =5  #define TP_USE_TP_COPY_TO_CAN kTpOn
 225      =5  #define TP_USE_TP_COPY_FROM_CAN kTpOff
 226      =5  #define TP_USE_TP_RX_CAN_MESSAGE_TRANSMITTED kTpOff
 227      =5  #define TP_USE_TP_TX_DELAY_FINISHED kTpOff
 228      =5  
 229      =5  #define kTpTxHandle CanTxPGS_GST
 230      =5  
 231      =5  #define kTpTxData PGS_GST._c
 232      =5  
 233      =5  
 234      =5  /* function prototypes */
 235      =5  void DescPhysReqInd(canuint16 datLen);
 236      =5  void DescRxErrorIndication(canuint8 errNo);
 237      =5  void DescConfirmation(canuint8 state);
 238      =5  canuint8* DescGetBuffer(canuint16 datLen);
 239      =5  canuint8 DescTxErrorIndication(canuint8 errNo);
 240      =5  vuint8 DescCopyToCAN(TpCopyToCanInfoStructPtr infoStruct);
 241      =5  
 242      =5  #define __ApplTpRxIndication(tpChannel, datLen) (DescPhysReqInd(datLen))
 243      =5  #define __ApplTpRxErrorIndication(tpChannel, errNo) (DescRxErrorIndication(errNo))
 244      =5  #define __ApplTpTxConfirmation(tpChannel, state) (DescConfirmation(state))
 245      =5  #define __ApplTpRxSF(tpChannel) 
 246      =5  #define __ApplTpRxFF(tpChannel) 
 247      =5  #define __ApplTpRxCF(tpChannel) 
 248      =5  #define __ApplTpTxNotification(tpChannel, datLen) 
 249      =5  #define __ApplTpTxCanMessageTransmitted(tpChannel) 
 250      =5  #define __ApplTpTxFC(tpChannel) 
 251      =5  #define __ApplTpRxGetBuffer(tpChannel, datLen) (DescGetBuffer(datLen))
 252      =5  #define __ApplTpTxErrorIndication(tpChannel, errNo) (DescTxErrorIndication(errNo))
 253      =5  #define __ApplTpTxCopyToCAN(infoStruct) (DescCopyToCAN(infoStruct))
 254      =5  #define __ApplTpRxCopyFromCAN(tpChannel, src, datLen) 
 255      =5  #define __ApplTpRxCanMessageTransmitted(tpChannel) 
 256      =5  #define __ApplTpTxDelayFinished(tpChannel, state)
 257      =5  
 258      =5  /* begin Fileversion check */
 259      =5  #ifndef SKIP_MAGIC_NUMBER
 260      =5  #ifdef MAGIC_NUMBER
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 312 

 261      =5    #if MAGIC_NUMBER != 204819919
           =5       #error "The magic number of the generated file <Y:\CANGEN\tp_cfg.h> is different. Please check time 
             -and date of generated files!"
           =5   #endif
 264      =5  #else
           =5   #define MAGIC_NUMBER 204819919
           =5 #endif  /* MAGIC_NUMBER */
 267      =5  #endif  /* SKIP_MAGIC_NUMBER */
 268      =5  
 269      =5  /* end Fileversion check */
 270      =5  
 271      =5  #endif /* __TP_CFG_H__ */
 133      =1  
 134      =1  
 135      =1  
 136      =1  /* -----------------------------------------------------------------------------
 137      =1      &&&~ Configuration switches
 138      =1   ----------------------------------------------------------------------------- */
 139      =1  
 140      =1  #if defined (V_ENABLE_USE_DUMMY_STATEMENT)
 141      =1  /* Everything ok */
 142      =1  #else
           =1 # if defined (V_DISABLE_USE_DUMMY_STATEMENT)
           =1   /* Everything ok */
           =1 # else
           =1   /* Define compatibile switch in case of older tools */
           =1 #  define V_ENABLE_USE_DUMMY_STATEMENT
           =1 # endif
           =1 #endif
 150      =1  
 151      =1  /* Gentool GENy will be supported. */
 152      =1  #define DESC_ENABLE_GENTOOL_GENY
 153      =1  /* Flashable ECU will not be supported. */
 154      =1  #define DESC_DISABLE_FLASHABLE_ECU
 155      =1  /* Vectors FBL will not be supported. */
 156      =1  #define DESC_DISABLE_VECTOR_FBL_USAGE
 157      =1  /* Far addressing of diagnostic buffer will not be supported. */
 158      =1  #define DESC_DISABLE_FAR_BUFFER
 159      =1  /* KWP2000 diagnostic protocol will not be supported. */
 160      =1  #define DESC_DISABLE_PROTOCOL_KWP
 161      =1  /* UDS diagnostic protocol will be supported. */
 162      =1  #define DESC_ENABLE_PROTOCOL_UDS
 163      =1  /* UDS diagnostic protocol will not be supported. */
 164      =1  #define DESC_DISABLE_PROTOCOL_UDS2012
 165      =1  /* Application debug monitoring will be supported. */
 166      =1  #define DESC_ENABLE_DEBUG_USER
 167      =1  /* Internal processes' debug monitoring will be supported. */
 168      =1  #define DESC_ENABLE_DEBUG_INTERNAL
 169      =1  
 170      =1  
 171      =1  #if (TP_USE_EXTENDED_ADDRESSING == kTpOn) || \
 172      =1      defined (TP_ENABLE_NORMAL_FIXED_ADDRESSING) || \
 173      =1      defined (TP_ENABLE_MIXED_29_ADDRESSING)
           =1 # define DESC_ENABLE_ACCESS_TESTER_ADDRESS_API
           =1 #endif
 176      =1  
 177      =1  /* Transport layer type */
 178      =1  #if defined (TP_ENABLE_SINGLE_CHANNEL_TP)
 179      =1  # define DESC_USDTNET_DISABLE_MULTI_TP
 180      =1  # define DESC_USDTNET_ENABLE_SINGLE_TP_OPTIMIZED
 181      =1  #else
           =1 # define DESC_USDTNET_ENABLE_MULTI_TP
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 313 

           =1 # define DESC_USDTNET_DISABLE_SINGLE_TP_OPTIMIZED
           =1 #endif
 185      =1  
 186      =1  /* LongServiceExecution will not be supported. */
 187      =1  #define DESC_USDTNET_DISABLE_LONGSERVICE_SUPPORT
 188      =1  /* Ring buffer will not be supported. */
 189      =1  #define DESC_USDTNET_DISABLE_RING_BUFFER
 190      =1  /* Far RAM buffer will not be supported. */
 191      =1  #define DESC_USDTNET_DISABLE_FAR_BUFFER
 192      =1  /* Shared buffer multi client usage will not be supported. */
 193      =1  #define DESC_USDTNET_DISABLE_MULTI_OWNER_SHARED_BUFFER
 194      =1  /* Dynamic buffer usage will not be supported. */
 195      =1  #define DESC_USDTNET_DISABLE_DYNAMIC_BUFFER_LENGTH
 196      =1  /* Static buffer allocation */
 197      =1  #define DESC_USDTNET_ENABLE_VECTOR_ISO_TP
 198      =1  
 199      =1  /* UUDT Network will not be supported. */
 200      =1  #define DESC_DISABLE_UUDT_NET
 201      =1  /* Check before message reception will not be supported. */
 202      =1  #define DESC_DISABLE_CHECK_MSG_RX_ACCEPTANCE
 203      =1  /* Spontaneous response will not be supported. */
 204      =1  #define DESC_DISABLE_SPONTANEOUS_RES
 205      =1  /* Secured data transmission API will not be supported. */
 206      =1  #define DESC_DISABLE_SECURED_DATA_TRANSMISSION
 207      =1  /* Multi channel system will not be supported. */
 208      =1  #define DESC_DISABLE_MULTI_CHANNEL_SUPPORT
 209      =1  /* Code-doubled CANdriver will not be supported. */
 210      =1  #define DESC_DISABLE_CODE_DOUBLED_DRIVER_API
 211      =1  /* Parallel reception and rejection diagnostic service will not be supported. */
 212      =1  #define DESC_DISABLE_BUSY_REPEAT_RESPONDER
 213      =1  /* Additional OBD reception path will not be supported. */
 214      =1  #define DESC_DISABLE_OBD_FUNC_REQUEST
 215      =1  /* Parallel handling of OBD service will not be supported. */
 216      =1  #define DESC_DISABLE_PARALLEL_OBD
 217      =1  /* CCL usage */
 218      =1  #if defined (VGEN_ENABLE_CCL)
           =1 # define DESC_ENABLE_CCL_SUPPORT
           =1 #else
 221      =1  # define DESC_DISABLE_CCL_SUPPORT
 222      =1  #endif
 223      =1  /* Transport layer type */
 224      =1  #if defined (TP_ENABLE_SINGLE_CHANNEL_TP)
 225      =1  # define DESC_DISABLE_MULTI_TP
 226      =1  # define DESC_ENABLE_SINGLE_TP_OPTIMIZED
 227      =1  #else
           =1 # define DESC_ENABLE_MULTI_TP
           =1 # define DESC_DISABLE_SINGLE_TP_OPTIMIZED
           =1 #endif
 231      =1  
 232      =1  /* Addressing information validation */
 233      =1  #define DESC_DISABLE_PHYSREQ_TA_CHECK
 234      =1  #define DESC_DISABLE_PHYSREQ_SA_CHECK
 235      =1  
 236      =1  #define DESC_DISABLE_FUNCREQ_TA_CHECK
 237      =1  #define DESC_DISABLE_FUNCREQ_SA_CHECK
 238      =1  
 239      =1  /* Enable response on requests whic SID are in range 
 240      =1   * [0x40, 0x7F]U[0xC0, 0xFF]
 241      =1   */
 242      =1  #define DESC_ENABLE_NEG_RES_ON_SID_WITH_SET_BIT6
 243      =1   /* No node power management */
 244      =1  #define DESC_DISABLE_NODE_POWER_CONTROL
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 314 

 245      =1  /* In general use default session monitoring */
 246      =1  #define DESC_DISABLE_DEFAULT_SESSION_SLEEP_PREVENTION
 247      =1  
 248      =1  /* TesterPresent monitoring will be supported. */
 249      =1  #define DESC_ENABLE_S1_TIME_MONITORING
 250      =1  /* No RCR-RP limitation will be used. */
 251      =1  #define DESC_DISABLE_RES_PENDING_TIME_LIMIT
 252      =1  #define DESC_DISABLE_RES_PENDING_COUNT_LIMIT
 253      =1  /* Application forced RCR-RP response transmission will not be supported. */
 254      =1  #define DESC_DISABLE_FORCE_RCR_RP
 255      =1  /* Session specific P2 (P2*) timings will not be supported. */
 256      =1  #define DESC_DISABLE_DYNAMICAL_P2_TIMINGS
 257      =1  /* Disable special handling on RCR-RP limit expiration (e.g. send negative response $71) */
 258      =1  #define DESC_DISABLE_OEM_HANDLING_ON_RCRRP_LIMIT_EXPIRATION
 259      =1  
 260      =1  /* Automaticaly managed states will be supported. */
 261      =1  #define DESC_ENABLE_AUTO_STATES
 262      =1  /* Don't check on SID level the addressing method */
 263      =1  #define DESC_DISABLE_ADDR_METHOD_CHECK_ON_SID
 264      =1  /* Do not ignore the SPRMIB (mask out but response will be sent) */
 265      =1  #define DESC_DISABLE_POS_RES_ON_SET_SPRMIB
 266      =1  
 267      =1  /* Do distinguish between sub-function and identifier */
 268      =1  #define DESC_DISABLE_SAME_NRC_ON_SUB_FUNC_AND_PARAM_ID
 269      =1  
 270      =1  /* Each main-handler will be called only once. The application shall take care about calling DescProcessin
             -gDone from somwhere at the end of the request process. */
 271      =1  #define DESC_DISABLE_MAINHANDLER_MULTICALL
 272      =1  #define DESC_DISABLE_INDIVIDUAL_MAINHANDLER_MULTICALL
 273      =1  #define DESC_DISABLE_PERMANENT_MAINHANDLER_MULTICALL
 274      =1  /* Request minimum length check will be supported. */
 275      =1  #define DESC_ENABLE_MIN_REQ_LEN_CHECK
 276      =1  /* Any pre-Handler from the SvcInst table will not be supported. */
 277      =1  #define DESC_DISABLE_PREHANDLER_USAGE
 278      =1  /* Any post-Handler from the SvcInst table will be supported. */
 279      =1  #define DESC_ENABLE_POSTHANDLER_USAGE
 280      =1  /* User (unknown) service-handler will not be supported. */
 281      =1  #define DESC_DISABLE_GENERIC_USER_SERVICE_SUPPORT
 282      =1  /* User (unknown) service post-handler will not be supported. */
 283      =1  #define DESC_DISABLE_GENERIC_USER_POST_HANDLER_SUPPORT
 284      =1  /* Do check addressing of request will be supported. */
 285      =1  #define DESC_ENABLE_ADDR_METHOD_CHECK
 286      =1  /* Do check all state groups on SID level. will not be supported. */
 287      =1  #define DESC_DISABLE_ALL_STATEGROUPS_SID_CHECK
 288      =1  /* Session check before format check will not be supported. */
 289      =1  #define DESC_DISABLE_SESSION_FORMAT_STATE_CHECK
 290      =1  /* Send all Nrcs after a pending was sent will not be supported. */
 291      =1  #define DESC_DISABLE_ALL_RES_AFTER_RCRRP
 292      =1  /* Handle DIDs not supported in current session as not supported will not be supported. */
 293      =1  #define DESC_DISABLE_SKIP_PID_ON_WRONG_SESSION
 294      =1  /* Do send NRC for wrong session only if none of the requested PIDs are supported in the session. will not
             - be supported. */
 295      =1  #define DESC_DISABLE_PID_NRC_ALL_ON_WRONG_SESSION
 296      =1  /* Handle DIDs not supported in current security state as not supported will not be supported. */
 297      =1  #define DESC_DISABLE_SKIP_PID_ON_WRONG_SECURITY_STATE
 298      =1  /* If OBD services are present enable conformance */
 299      =1  #if defined (DESC_ENABLE_OBD_FUNC_REQUEST)
           =1 # define DESC_ENABLE_OBDII_NR_CONFORMANCE
           =1 #endif
 302      =1  
 303      =1  /* Is skip PID supported? */
 304      =1  #if defined (DESC_ENABLE_SKIP_PID_ON_WRONG_SESSION) || \
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 315 

 305      =1      defined (DESC_ENABLE_SKIP_PID_ON_WRONG_SECURITY_STATE)
           =1 # define DESC_ENABLE_SKIP_PID
           =1 #else
 308      =1  # define DESC_DISABLE_SKIP_PID
 309      =1  #endif
 310      =1  
 311      =1  /* Pre-handlers will not be supported. */
 312      =1  #define DESC_DISABLE_ANY_PREHANDLER_USAGE
 313      =1  /* Post-handlers will be supported. */
 314      =1  #define DESC_ENABLE_ANY_POSTHANDLER_USAGE
 315      =1  /* Use linear search for optimal runtime. */
 316      =1  #define DESC_DISABLE_BINARY_SVCINST_SEARCH
 317      =1  #define DESC_ENABLE_LINEAR_SVCINST_SEARCH
 318      =1  /* Sub-service protocol information will be supported. */
 319      =1  #define DESC_ENABLE_SUB_SVC_USAGE
 320      =1  /* Supplier callbacks are called will not be supported. */
 321      =1  #define DESC_DISABLE_SUPPLIER_CALLBACKS
 322      =1  /* Manufacturer callbacks are called will not be supported. */
 323      =1  #define DESC_DISABLE_MANUFACTURER_CALLBACKS
 324      =1  /* Self-transition workaround will not be supported. */
 325      =1  #define DESC_DISABLE_SESSION_SELFTRANSITION_SIM
 326      =1  /* Common post-Handler function for start diagnostic session will be supported. */
 327      =1  #define DESC_ENABLE_COMMON_OEM_POST_HANDLER
 328      =1  /* Communication control service will be supported. */
 329      =1  #define DESC_ENABLE_COMM_CTRL
 330      =1  /* Communication control on RX path will be supported. */
 331      =1  #define DESC_ENABLE_RX_COMM_CONTROL
 332      =1  /* Communication Control Service 29 will be supported. */
 333      =1  #define DESC_ENABLE_COMM_SVC_29
 334      =1  /* Communciation control based on subnetworks will not be supported. */
 335      =1  #define DESC_DISABLE_COMM_CTRL_SUBNET_SUPPORT
 336      =1  /* Programming session OEM handling will be supported. */
 337      =1  #define DESC_ENABLE_PROGRAMMING_SESSION
 338      =1  /* Stop session service will be supported. */
 339      =1  #define DESC_ENABLE_SERVICE_STOP_SESSION
 340      =1  /* Additonal Kwp Sessions will be supported. */
 341      =1  #define DESC_ENABLE_ADD_KWP_SESSIONS
 342      =1  /* P2 and P2Ex times report in the positive response of DiagSessionControl will be supported. */
 343      =1  #define DESC_ENABLE_P2_TIME_REPORT
 344      =1  /* Security access service will be supported. */
 345      =1  #define DESC_ENABLE_SECURITY_ACCESS
 346      =1  /* Same Nrc is used for key as for seed when delay timer is active. will not be supported. */
 347      =1  #define DESC_DISABLE_DELAY_NRC_KEY
 348      =1  /* PowerOn timer activation will not be supported. */
 349      =1  #define DESC_DISABLE_START_SA_TIMER_ON_POWERON
 350      =1  /* Start extern timer activation will not be supported. */
 351      =1  #define DESC_DISABLE_START_SA_TIMER_EXTERN
 352      =1  /* Attempt counter reset on time expired will not be supported. */
 353      =1  #define DESC_DISABLE_ATT_CNTR_RESET_ON_TIME_EXPIRE
 354      =1  /* On change attempt counter value notification will not be supported. */
 355      =1  #define DESC_DISABLE_REPORT_ATT_CNTR_STATE
 356      =1  /* Another key request without seed on seed mismatch will not be supported. */
 357      =1  #define DESC_DISABLE_ALLOW_KEY_REQ_ON_SEED_MISMATCH
 358      =1  /* Reset awaitKeyState on invalid request will be supported. */
 359      =1  #define DESC_ENABLE_RESET_AWAIT_KEY_ON_INVALID_REQ
 360      =1  /* Attempt counter reset on valid key will not be supported. */
 361      =1  #define DESC_DISABLE_ATT_CNTR_RESET_ON_KEY_OK
 362      =1  /* Seed protection by seed repetition will not be supported. */
 363      =1  #define DESC_DISABLE_USE_OLD_SEED_PROTECTION
 364      =1  /* Seed protection by attempt counter increment will not be supported. */
 365      =1  #define DESC_DISABLE_USE_ERR_CNTR_PROTECTION
 366      =1  /* Multiple seed length will not be supported. */
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 316 

 367      =1  #define DESC_DISABLE_MULTIPLE_SEED_LENGTH
 368      =1  /* Total attempt counter is used will not be supported. */
 369      =1  #define DESC_DISABLE_TOTAL_ATTEMPT_COUNTER
 370      =1  /* Unified PID management will not be supported. */
 371      =1  #define DESC_DISABLE_UNIFIED_PID_MGR
 372      =1  /* PidList mode simulation will not be supported. */
 373      =1  #define DESC_DISABLE_SIM_PID_LIST_MODE
 374      =1  /* PIDs pre-Handlers will not be supported. */
 375      =1  #define DESC_DISABLE_PID_PREHANDLER_USAGE
 376      =1  /* PIDs post-Handlers will not be supported. */
 377      =1  #define DESC_DISABLE_PID_POSTHANDLER_USAGE
 378      =1  /* Combinable PID with dynamic data length will not be supported. */
 379      =1  #define DESC_DISABLE_DYN_DID_RES_LENGTH
 380      =1  #define DESC_DISABLE_PID_SECURITY_FILTER
 381      =1  /* Routine control management will be supported. */
 382      =1  #define DESC_ENABLE_ROUTINE_CONTROL_MODE
 383      =1  /* RIDs pre-Handlers will not be supported. */
 384      =1  #define DESC_DISABLE_RID_PREHANDLER_USAGE
 385      =1  /* RIDs post-Handlers will not be supported. */
 386      =1  #define DESC_DISABLE_RID_POSTHANDLER_USAGE
 387      =1  /* RIDs control operation check will not be supported. */
 388      =1  #define DESC_DISABLE_RID_CTRL_OPER_CHECK
 389      =1  /* Scheduled PID will not be supported. */
 390      =1  #define DESC_DISABLE_PERIODIC_MODE
 391      =1  /* No periodical transmission. */
 392      =1  #define DESC_DISABLE_SCHEDULER_UUDT_TRANSMITTER
 393      =1  #define DESC_DISABLE_SCHEDULER_USDT_TRANSMITTER
 394      =1  /* Multiple PID in single request will be supported. */
 395      =1  #define DESC_ENABLE_PID_LIST_MODE
 396      =1  /* Dynamically defined DIDs will not be supported. */
 397      =1  #define DESC_DISABLE_DYN_DEFINED_DID_MODE
 398      =1  /* Dynamically defined by Id DIDs will not be supported. */
 399      =1  #define DESC_DISABLE_DEF_DYN_ID_BY_PID
 400      =1  /* Dynamically defined by memory DIDs will not be supported. */
 401      =1  #define DESC_DISABLE_DEF_DYN_ID_BY_MEM
 402      =1  /* Dynamically defined DPIDs will not be supported. */
 403      =1  #define DESC_DISABLE_DYN_DEFINED_DPID_MODE
 404      =1  /* ResponseOnEvent service will not be supported. */
 405      =1  #define DESC_DISABLE_ROE_SUPPORT
 406      =1  /* Ring-buffer handling will not be supported. */
 407      =1  #define DESC_DISABLE_RES_RINGBUFFER
 408      =1  /* Multi variants/ VSGs are supported will not be supported. */
 409      =1  #define DESC_DISABLE_MULTI_VARIANT
 410      =1  
 411      =1  
 412      =1  /* -----------------------------------------------------------------------------
 413      =1      &&&~ Preprocessor constants (defines)
 414      =1   ----------------------------------------------------------------------------- */
 415      =1  
 416      =1  /* ##V_CFG_MANAGEMENT ##CQProject : Diag_CanDesc__core CQComponent : Implementation */
 417      =1  #define DIAG_CANDESC__CORE_VERSION                                   0x0614
 418      =1  #define DIAG_CANDESC__CORE_RELEASE_VERSION                           0x01
 419      =1  #define DESC_VERSION                                                 0x0614
 420      =1  #define DESC_RELEASE_VERSION                                         0x01
 421      =1  /* Desc generic return codes */
 422      =1  #define kDescOk                                                      ((vuint8)0x00)
 423      =1  #define kDescFailed                                                  ((vuint8)0x01)
 424      =1  /*  data type according to the CPU type */
 425      =1  #if defined( C_CPUTYPE_8BIT )
 426      =1  /* 8-Bit qualifier */
 427      =1  # ifndef vuint8_least
 428      =1  #  define vuint8_least                                               vuintx
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 317 

 429      =1  # endif
 430      =1  # ifndef vsint8_least
 431      =1  #  define vsint8_least                                               vsintx
 432      =1  # endif
 433      =1  #else
           =1 # if defined( C_CPUTYPE_16BIT )
           =1 /* 16-Bit qualifier */
           =1 #  ifndef vuint8_least
           =1 #   define vuint8_least                                              vuintx
           =1 #  endif
           =1 #  ifndef vsint8_least
           =1 #   define vsint8_least                                              vsintx
           =1 #  endif
           =1 #  ifndef vuint16_least
           =1 #   define vuint16_least                                             vuintx
           =1 #  endif
           =1 #  ifndef vsint16_least
           =1 #   define vsint16_least                                             vsintx
           =1 #  endif
           =1 
           =1 # else
           =1 #  if defined( C_CPUTYPE_32BIT )
           =1 /* 32-Bit qualifier */
           =1 #   ifndef vuint8_least
           =1 #    define vuint8_least                                             vuintx
           =1 #   endif
           =1 #   ifndef vsint8_least
           =1 #    define vsint8_least                                             vsintx
           =1 #   endif
           =1 #   ifndef vuint16_least
           =1 #    define vuint16_least                                            vuintx
           =1 #   endif
           =1 #   ifndef vsint16_least
           =1 #    define vsint16_least                                            vsintx
           =1 #   endif
           =1 #   ifndef vuint32_least
           =1 #    define vuint32_least                                            vuintx
           =1 #   endif
           =1 #   ifndef vsint32_least
           =1 #    define vsint32_least                                            vsintx
           =1 #   endif
           =1 #  endif
           =1 # endif
           =1 #endif
 473      =1  
 474      =1  /* Default optimized types */
 475      =1  #ifndef vuint8_least
           =1 # define vuint8_least                                                vuint8
           =1 #endif
 478      =1  #ifndef vuint16_least
 479      =1  # define vuint16_least                                               vuint16
 480      =1  #endif
 481      =1  #ifndef vuint32_least
 482      =1  # define vuint32_least                                               vuint32
 483      =1  #endif
 484      =1  
 485      =1  #ifndef vsint8_least
           =1 # define vsint8_least                                                vsint8
           =1 #endif
 488      =1  #ifndef vsint16_least
 489      =1  # define vsint16_least                                               vsint16
 490      =1  #endif
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 318 

 491      =1  #ifndef vsint32_least
 492      =1  # define vsint32_least                                               vsint32
 493      =1  #endif
 494      =1  
 495      =1  /* Optimized boolean type */
 496      =1  #ifndef vboolean
 497      =1  # define vboolean                                                    vuint8_least
 498      =1  #endif
 499      =1  
 500      =1  #ifndef V_BOOL_TRUE
 501      =1  # define V_BOOL_TRUE                                                 (vboolean)1
 502      =1  #endif
 503      =1  
 504      =1  #ifndef V_BOOL_FALSE
 505      =1  # define V_BOOL_FALSE                                                (vboolean)0
 506      =1  #endif
 507      =1  /* CANdesc API types use the CANdesc namings convention! */
 508      =1  #define kDescFalse                                                   V_BOOL_FALSE
 509      =1  #define kDescTrue                                                    V_BOOL_TRUE
 510      =1  #define DESC_IGNORE_UNREF_PARAM(paramName)                           ((void)paramName)
 511      =1  
 512      =1  #if !defined (VUINT8_CAST)
           =1 # if defined ( C_COMP_COSMIC_HC08 ) || defined ( C_COMP_COSMIC_HC12 ) /* any cosmic cpu */
           =1 #  define VUINT8_CAST                                                (vuint8)
           =1 #  define VSINT8_CAST                                                (vsint8)
           =1 #  define VUINT16_CAST                                               (vuint16)
           =1 #  define VSINT16_CAST                                               (vsint16)
           =1 #  define CANBITTYPE_CAST                                            (vbittype)
           =1 #  define CANSINTCPUTYPE_CAST                                        (int)
           =1 #  define CANUINTCPUTYPE_CAST                                        (unsigned int)
           =1 # else
           =1 #  define VUINT8_CAST
           =1 #  define VSINT8_CAST
           =1 #  define VUINT16_CAST
           =1 #  define VSINT16_CAST
           =1 #  define CANBITTYPE_CAST
           =1 #  define CANSINTCPUTYPE_CAST
           =1 #  define CANUINTCPUTYPE_CAST
           =1 # endif /* ( C_COMP_COSMIC_HC08 ) || defined ( C_COMP_COSMIC_HC12 ) */
           =1 #endif
 531      =1  
 532      =1  #if defined (V_MEMROM0)
 533      =1  /* new driver ok */
 534      =1  #else
           =1 # define V_MEMROM0
           =1 #endif
 537      =1  
 538      =1  
 539      =1  #if defined (V_MEMROM1)
 540      =1  /* new driver ok */
 541      =1  #else
           =1 # define V_MEMROM1
           =1 #endif
 544      =1  
 545      =1  #if defined (V_MEMROM2)
 546      =1  /* new driver ok */
 547      =1  #else
           =1 # define V_MEMROM2                                                   MEMORY_ROM
           =1 #endif
 550      =1  
 551      =1  #if defined (V_MEMROM3)
 552      =1  /* new driver ok */
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 319 

 553      =1  #else
           =1 # define V_MEMROM3
           =1 #endif
 556      =1  #if defined (V_MEMRAM0)
 557      =1  /* new driver ok */
 558      =1  #else
           =1 # define V_MEMRAM0
           =1 #endif
 561      =1  
 562      =1  #if defined (V_MEMRAM1)
 563      =1  /* new driver ok */
 564      =1  #else
           =1 # define V_MEMRAM1
           =1 #endif
 567      =1  
 568      =1  #if defined (V_MEMRAM1_FAR)
 569      =1  /* new driver ok */
 570      =1  #else
           =1 # define V_MEMRAM1_FAR
           =1 #endif
 573      =1  
 574      =1  #if defined (V_MEMRAM2)
 575      =1  /* new driver ok */
 576      =1  #else
           =1 # define V_MEMRAM2
           =1 #endif
 579      =1  
 580      =1  #if defined (V_MEMRAM2_FAR)
 581      =1  /* new driver ok */
 582      =1  #else
           =1 # define V_MEMRAM2_FAR
           =1 #endif
 585      =1  
 586      =1  #if defined (V_MEMRAM3)
 587      =1  /* new driver ok */
 588      =1  #else
           =1 # define V_MEMRAM3
           =1 #endif
 591      =1  /* Define of a DESC_CONST_MEM_ABSTRACT*/
 592      =1  #define DESC_CONST_MEM_ABSTRACT                                      const
 593      =1  
 594      =1  /* Compile memory model abstraction */
 595      =1  #if defined(DESC_ENABLE_FAR_BUFFER)
           =1 /* Ram Pointer to Far Ram */
           =1 # define DESC_P2FARRAM(baseType)                                     V_MEMRAM1_FAR baseType V_MEMRAM2_FAR 
             -V_MEMRAM3_FAR *
           =1 /* DESC_CONSTP2FARRAM is only used as function parameter.
           =1 Therefore, DESC_CONST_MEM_ABSTRACT is defined to const and not
           =1 explicit mapped to the ROM*/
           =1 # define DESC_CONSTP2FARRAM(baseType)                                V_MEMRAM1_FAR baseType V_MEMRAM2_FAR 
             -V_MEMRAM3_FAR * DESC_CONST_MEM_ABSTRACT
           =1 # define DESC_PUBL_DEF_VAR_FAR(baseType)                             V_MEMRAM0 V_MEMRAM1_FAR baseType V_ME
             -MRAM2_FAR V_MEMRAM3_FAR
           =1 # define DESC_PRVT_DEF_VAR_FAR(baseType)                             V_MEMRAM0 static V_MEMRAM1_FAR baseTy
             -pe V_MEMRAM2_FAR
           =1 # define DESC_PUBL_DECL_VAR_FAR(baseType)                            V_MEMRAM0 extern V_MEMRAM1_FAR baseTy
             -pe V_MEMRAM2_FAR
           =1 #else /*DESC_ENABLE_FAR_BUFFER*/
 606      =1  # define DESC_P2FARRAM(baseType)                                     V_MEMRAM1 baseType V_MEMRAM2 V_MEMRAM
             -3 *
 607      =1  /* DESC_CONSTP2FARRAM is only used as function parameter.
 608      =1  Therefore, DESC_CONST_MEM_ABSTRACT is defined to const and not
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 320 

 609      =1  explicit mapped to the ROM*/
 610      =1  # define DESC_CONSTP2FARRAM(baseType)                                V_MEMRAM1 baseType V_MEMRAM2 V_MEMRAM
             -3 * DESC_CONST_MEM_ABSTRACT
 611      =1  # define DESC_PUBL_DEF_VAR_FAR(baseType)                             V_MEMRAM0 V_MEMRAM1 baseType V_MEMRAM
             -2 V_MEMRAM3
 612      =1  # define DESC_PRVT_DEF_VAR_FAR(baseType)                             V_MEMRAM0 static V_MEMRAM1 baseType V
             -_MEMRAM2
 613      =1  # define DESC_PUBL_DECL_VAR_FAR(baseType)                            V_MEMRAM0 extern V_MEMRAM1 baseType V
             -_MEMRAM2
 614      =1  #endif
 615      =1  
 616      =1  #if defined(DESC_API_CALL_TYPE)
           =1 #else
 618      =1    /* No paging used. */
 619      =1    #define DESC_API_CALL_TYPE
 620      =1  #endif
 621      =1  
 622      =1  #if defined(DESC_API_CALLBACK_TYPE)
           =1 #else
 624      =1    /* No paging used. */
 625      =1    #define DESC_API_CALLBACK_TYPE
 626      =1  #endif
 627      =1  
 628      =1  #if defined(TP_API_CALLBACK_TYPE)
 629      =1  #else
           =1   /* No paging used. */
           =1   #define TP_API_CALLBACK_TYPE
           =1 #endif
 633      =1  
 634      =1  #if defined(DRV_API_CALLBACK_TYPE)
 635      =1  #else
           =1   /* No paging used. */
           =1   #define DRV_API_CALLBACK_TYPE
           =1 #endif
 639      =1  
 640      =1  #if defined(DRV_API_CALL_TYPE)
 641      =1  #else
           =1   /* No paging used. */
           =1   #define DRV_API_CALL_TYPE
           =1 #endif
 645      =1  
 646      =1  /* This magic number provides inter CANdesc generation process consistency check.All CANdesc files must ha
             -ve the same one. */
 647      =1  #define DESC_PUBLIC_INTERFACE_MAGIC_NUMBER                           30284
 648      =1  /* ---  Debug assertion codes  --- */
 649      =1  #define kDescAssertWrongTpTxChannel                                  0x00
 650      =1  #define kDescAssertCanBufferIsNullPointer                            0x01
 651      =1  #define kDescAssertIndexTableInvalidReference                        0x02
 652      =1  #define kDescAssertSvcTableUnreachableItem                           0x03
 653      =1  #define kDescAssertSvcTableInvalidReference                          0x04
 654      =1  #define kDescAssertSvcTableInconsistentNumber                        0x05
 655      =1  #define kDescAssertMissingMainHandler                                0x06
 656      =1  /* Obsolete: 
 657      =1  #define kDescAssertSFMsgTooLong                                      0x07
 658      =1  */
 659      =1  #define kDescAssertInvalidContextId                                  0x08
 660      =1  #define kDescAssertSvcTableIndexOutOfRange                           0x09
 661      =1  #define kDescAssertSvcInstTableIndexOutOfRange                       0x0A
 662      =1  #define kDescAssertContextIdWasModified                              0x0B
 663      =1  /* Obsolete: 
 664      =1  #define kDescAssertContextPointerWasModified                         0x0C
 665      =1  #define kDescAssertWrongTpRxChannel                                  0x0D
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 321 

 666      =1  */
 667      =1  #define kDescAssertProcessingDoneCallAfterResFlushing                0x0E
 668      =1  #define kDescAssertTooLongSingleFrameResponse                        0x0F
 669      =1  /* Obsolete: 
 670      =1  #define kDescAssertIllegalTxModeState                                0x10
 671      =1  */
 672      =1  #define kDescAssertApplLackOfConfirmation                            0x11
 673      =1  /* Obsolete: 
 674      =1  #define kDescAssertUnconfirmedSecureServiceUsed                      0x12
 675      =1  */
 676      =1  #define kDescAssertZeroStateValue                                    0x13
 677      =1  /* Obsolete: 
 678      =1  #define kDescAssertSecureServiceFunctionallyRequested                0x14
 679      =1  #define kDescAssertInvalidCanChannel                                 0x15
 680      =1  */
 681      =1  #define kDescAssertInvalidContextMode                                0x16
 682      =1  #define kDescAssertUnexpectedWriteIntoRingBuffer                     0x17
 683      =1  #define kDescAssertRingBufferWriteExceedsTheResLen                   0x18
 684      =1  /* Obsolete: 
 685      =1  #define kDescAssertIllegalUsageOfRingBufferWithPidListMode           0x19 
 686      =1  #define kDescAssertIllegalUsageOfNegativeResponse                    0x1A
 687      =1  */
 688      =1  #define kDescAssertDiagnosticBufferOverflow                          0x1B
 689      =1  #define kDescAssertFuncReqWoResMayNotUseRingBuffer                   0x1C
 690      =1  /* Obsolete: 
 691      =1  #define kDescAssertContextChannelRelationLost                        0x1D
 692      =1  */
 693      =1  #define kDescAssertSchedulerTimerEventWithoutAnyPID                  0x1E
 694      =1  #define kDescAssertSchedulerRingBufferIsActivated                    0x1F
 695      =1  /* Obsolete: 
 696      =1  #define kDescAssertSchedulerWrongContextMode                         0x20
 697      =1  */
 698      =1  #define kDescAssertUnknownTpTransmissionType                         0x21
 699      =1  #define kDescAssertIllegalAddRequestCount                            0x22
 700      =1  #define kDescAssertNoSidCanBeReportedInIdleMode                      0x23
 701      =1  #define kDescAssertInvalidUsageOfForceRcrRpApi                       0x24
 702      =1  /* Obsolete: 
 703      =1  #define kDescAssertRoeResponderWrongContextMode                      0x25
 704      =1  */
 705      =1  #define kDescAssertPidResLenToCddDefNotMatched                       0x26
 706      =1  #define kDescAssertPidResLenToCurrLinearFreeSpace                    0x27
 707      =1  #define kDescAssertMissingDataForTransmission                        0x28
 708      =1  #define kDescAssertSchedulerFreeCellNotFound                         0x29
 709      =1  #define kDescAssertInvalidStateParameterValue                        0x2A
 710      =1  #define kDescAssertNoFreeICNChannel                                  0x2B
 711      =1  #define kDescAssertInvalidDescICNClient                              0x2C
 712      =1  #define kDescAssertNoFreeMsgContext                                  0x2D
 713      =1  #define kDescAssertUnExpectedContextWithResponse                     0x2E
 714      =1  #define kDescAssertIllegalCallOfRingBufferCancel                     0x2F
 715      =1  #define kDescAssertIllegalUsageOfRingBufferOnSupprPosRes             0x30
 716      =1  #define kDescAssertWrongFblPosResParameterValue                      0x31 /* former 0xA1 */
 717      =1  
 718      =1  #define kDescAssertRoeUnexpectedEventNRC                             0x32
 719      =1  #define kDescAssertRoeUnexpectedEventSid                             0x33
 720      =1  /* Obsolete
 721      =1  #define kDescAssertRoeGeneralTransmissionError                       0x34
 722      =1  #define kDescAssertRoeNumEventsIsEmpty                               0x35
 723      =1  */
 724      =1  #define kDescAssertRoeUnexpectedEventType                            0x36
 725      =1  
 726      =1  #define kDescAssertMemByAddrUnexpectedType                           0x37
 727      =1  #define kDescAssertRoeUnexpectedResultLength                         0x38
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 322 

 728      =1  
 729      =1  /* DescNet assertions numbers */
 730      =1  #define kDescNetAssertWrongIsoTpRxChannel                            0x40
 731      =1  #define kDescNetAssertWrongIsoTpTxChannel                            0x41
 732      =1  #define kDescNetAssertWrongBusType                                   0x42
 733      =1  
 734      =1  #define kDescNetAssertIllegalPduId                                   0x43
 735      =1  #define kDescNetAssertIllegalResponseType                            0x44
 736      =1  
 737      =1  #define kDescNetAssertUnexpectedLength                               0x45
 738      =1  
 739      =1  /* DescICNNet assertions numbers */
 740      =1  #define kDescAssertDescIcnIllegalTargetPointer                       0x50
 741      =1  
 742      =1  
 743      =1  /* Page buffer assertion*/
 744      =1  #define kDescAssertPageBufferTooSmallForResponse                     0x60
 745      =1  
 746      =1  /* -----------------------------------------------------------------------------
 747      =1      &&&~ Negative response codes
 748      =1   ----------------------------------------------------------------------------- */
 749      =1  
 750      =1  #define kDescNrcGeneralReject                                        0x10
 751      =1  #define kDescNrcServiceNotSupported                                  0x11
 752      =1  #define kDescNrcSubfunctionNotSupported                              0x12
 753      =1  #define kDescNrcInvalidFormat                                        0x13
 754      =1  #define kDescNrcResponseTooLong                                      0x14
 755      =1  #define kDescNrcBusyRepeatRequest                                    0x21
 756      =1  #define kDescNrcConditionsNotCorrect                                 0x22
 757      =1  #define kDescNrcRequestSequenceError                                 0x24
 758      =1  #define kDescNrcRequestOutOfRange                                    0x31
 759      =1  #define kDescNrcAccessDenied                                         0x33
 760      =1  #define kDescNrcInvalidKey                                           0x35
 761      =1  #define kDescNrcExceedNumOfAttempts                                  0x36
 762      =1  #define kDescNrcTimeDelayNotExpired                                  0x37
 763      =1  #define kDescNrcUploadDownloadNotAccepted                            0x70
 764      =1  #define kDescNrcTransferDataSuspended                                0x71
 765      =1  #define kDescNrcGeneralProgrammingFailure                            0x72
 766      =1  #define kDescNrcWrongBlockSequenceCounter                            0x73
 767      =1  #define kDescNrcResponsePending                                      0x78
 768      =1  #define kDescNrcSubfunctionNotSupportedInActiveSession               0x7E
 769      =1  #define kDescNrcServiceNotSupportedInActiveSession                   0x7F
 770      =1  #define kDescNrcService_not_supported_in_active_diagnostic_mode      0x80
 771      =1  #define kDescNrcRpmTooHigh                                           0x81
 772      =1  #define kDescNrcRpmTooLow                                            0x82
 773      =1  #define kDescNrcEngineIsRunning                                      0x83
 774      =1  #define kDescNrcEngineIsNotRunning                                   0x84
 775      =1  #define kDescNrcEngineRunTimeTooLow                                  0x85
 776      =1  #define kDescNrcTemperatureTooHigh                                   0x86
 777      =1  #define kDescNrcTemperatureTooLow                                    0x87
 778      =1  #define kDescNrcVehicleSpeedTooHigh                                  0x88
 779      =1  #define kDescNrcVehicleSpeedTooLow                                   0x89
 780      =1  #define kDescNrcThrottleSpeedTooHigh                                 0x8A
 781      =1  #define kDescNrcThrottleSpeedTooLow                                  0x8B
 782      =1  #define kDescNrcTransmissionRangeInNeutral                           0x8C
 783      =1  #define kDescNrcTransmissionRangeInGears                             0x8D
 784      =1  #define kDescNrcBrakeSwitchNotClosed                                 0x8F
 785      =1  #define kDescNrcShifterLeverNotInPark                                0x90
 786      =1  #define kDescNrcTorqueConverterClutchLocked                          0x91
 787      =1  #define kDescNrcVoltageTooHigh                                       0x92
 788      =1  #define kDescNrcVoltageTooLow                                        0x93
 789      =1  
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 323 

 790      =1  
 791      =1  #define TP_CHANNEL_PARAM_TYPE                                        vuint8
 792      =1  #define TP_CHANNEL_RX_PARAM_NAME                                     tpRxChannel
 793      =1  #define TP_CHANNEL_TX_PARAM_NAME                                     tpTxChannel
 794      =1  
 795      =1  #if defined (DESC_USDTNET_ENABLE_MULTI_TP)
           =1 /* rx */
           =1 # define TP_CHANNEL_RX_FORMAL_PARAM_DEF_ONLY                         TP_CHANNEL_PARAM_TYPE TP_CHANNEL_RX_P
             -ARAM_NAME
           =1 # define TP_CHANNEL_RX_PARAM_DEF_LOCAL                               TP_CHANNEL_RX_FORMAL_PARAM_DEF_ONLY;
           =1 # define TP_CHANNEL_RX_FORMAL_PARAM_DEF_FIRST                        TP_CHANNEL_RX_FORMAL_PARAM_DEF_ONLY,
           =1 # define TP_CHANNEL_RX_PARAM_IGNORE_UNREF                            DESC_IGNORE_UNREF_PARAM(TP_CHANNEL_RX
             -_PARAM_NAME)
           =1 /* tx */
           =1 # define TP_CHANNEL_TX_FORMAL_PARAM_DEF_ONLY                         TP_CHANNEL_PARAM_TYPE TP_CHANNEL_TX_P
             -ARAM_NAME
           =1 # define TP_CHANNEL_TX_PARAM_DEF_LOCAL                               TP_CHANNEL_TX_FORMAL_PARAM_DEF_ONLY;
           =1 # define TP_CHANNEL_TX_FORMAL_PARAM_DEF_FIRST                        TP_CHANNEL_TX_FORMAL_PARAM_DEF_ONLY,
           =1 # define TP_CHANNEL_TX_PARAM_IGNORE_UNREF                            DESC_IGNORE_UNREF_PARAM(TP_CHANNEL_TX
             -_PARAM_NAME)
           =1 #else
 807      =1  /* rx */
 808      =1  # define TP_CHANNEL_RX_FORMAL_PARAM_DEF_ONLY                         void
 809      =1  # define TP_CHANNEL_RX_PARAM_DEF_LOCAL
 810      =1  # define TP_CHANNEL_RX_FORMAL_PARAM_DEF_FIRST
 811      =1  # define TP_CHANNEL_RX_PARAM_IGNORE_UNREF
 812      =1  /* tx */
 813      =1  # define TP_CHANNEL_TX_FORMAL_PARAM_DEF_ONLY                         void
 814      =1  # define TP_CHANNEL_TX_PARAM_DEF_LOCAL
 815      =1  # define TP_CHANNEL_TX_FORMAL_PARAM_DEF_FIRST
 816      =1  # define TP_CHANNEL_TX_PARAM_IGNORE_UNREF
 817      =1  #endif
 818      =1  
 819      =1  #define DESC_USDTNET_CONST_MEM_ABSTRACT                              const
 820      =1  /* Compile memory model abstraction */
 821      =1  #if defined(DESC_USDTNET_ENABLE_FAR_BUFFER)
           =1 /* Ram Pointer to Far Ram */
           =1 # define DESC_USDTNET_P2FARRAM(baseType)                             V_MEMRAM1_FAR baseType V_MEMRAM2_FAR 
             -V_MEMRAM3_FAR *
           =1 /* DESC_CONSTP2FARRAM is not used until now.
           =1 DESC_USDTNET_CONST_MEM_ABSTRACT is defined to const and not
           =1 explicit mapped to the ROM*/
           =1 # define DESC_USDTNET_CONSTP2FARRAM(baseType)                        V_MEMRAM1_FAR baseType V_MEMRAM2_FAR 
             -V_MEMRAM3_FAR * DESC_USDTNET_CONST_MEM_ABSTRACT
           =1 # define DESC_USDTNET_PUBL_DEF_VAR_FAR(baseType)                     V_MEMRAM0 V_MEMRAM1_FAR baseType V_ME
             -MRAM2_FAR V_MEMRAM3_FAR
           =1 # define DESC_USDTNET_PRVT_DEF_VAR_FAR(baseType)                     V_MEMRAM0 static V_MEMRAM1_FAR baseTy
             -pe V_MEMRAM2_FAR
           =1 # define DESC_USDTNET_PUBL_DECL_VAR_FAR(baseType)                    V_MEMRAM0 extern V_MEMRAM1_FAR baseTy
             -pe V_MEMRAM2_FAR
           =1 #else /*DESC_USDTNET_ENABLE_FAR_BUFFER*/
 832      =1  # define DESC_USDTNET_P2FARRAM(baseType)                             V_MEMRAM1 baseType V_MEMRAM2 V_MEMRAM
             -3 *
 833      =1  /* DESC_CONSTP2FARRAM is not used until now.
 834      =1  DESC_USDTNET_CONST_MEM_ABSTRACT is defined to const and not
 835      =1  explicit mapped to the ROM*/
 836      =1  # define DESC_USDTNET_CONSTP2FARRAM(baseType)                        V_MEMRAM1 baseType V_MEMRAM2 V_MEMRAM
             -3 * DESC_USDTNET_CONST_MEM_ABSTRACT
 837      =1  # define DESC_USDTNET_PUBL_DEF_VAR_FAR(baseType)                     V_MEMRAM0 V_MEMRAM1 baseType V_MEMRAM
             -2 V_MEMRAM3
 838      =1  # define DESC_USDTNET_PRVT_DEF_VAR_FAR(baseType)                     V_MEMRAM0 static V_MEMRAM1 baseType V
             -_MEMRAM2
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 324 

 839      =1  # define DESC_USDTNET_PUBL_DECL_VAR_FAR(baseType)                    V_MEMRAM0 extern V_MEMRAM1 baseType V
             -_MEMRAM2
 840      =1  #endif
 841      =1  
 842      =1  #define kDescNumCommChannels                                         1
 843      =1  #define kDescNumContexts                                             1
 844      =1  #define kDescPrimBufferLen                                           256
 845      =1  #if defined (DESC_ENABLE_MULTI_CHANNEL_SUPPORT)
           =1 # define DESC_COMM_CHANNEL_FORMAL_PARAM_DEF_ONLY                     vuint8_least commChannel
           =1 # define DESC_COMM_CHANNEL_FORMAL_PARAM_DEF_FIRST                    DESC_COMM_CHANNEL_FORMAL_PARAM_DEF_ON
             -LY,
           =1 # define DESC_COMM_CHANNEL_PARAM_VALUE                               commChannel
           =1 # define DESC_COMM_CHANNEL_PARAM_ONLY                                commChannel
           =1 # define DESC_COMM_CHANNEL_PARAM_FIRST                               DESC_COMM_CHANNEL_PARAM_ONLY,
           =1 # define DESC_COMM_CHANNEL_LOCAL_PARAM_DEF                           DESC_COMM_CHANNEL_FORMAL_PARAM_DEF_ON
             -LY;
           =1 # define DESC_COMM_CHANNEL_PARAM_VALUE_INIT                          DESC_COMM_CHANNEL_PARAM_VALUE = kDesc
             -NumCommChannels
           =1 # define DESC_COMM_CHANNEL_PARAM_VALUE_DEC                           DESC_COMM_CHANNEL_PARAM_VALUE--
           =1 # define DESC_COMM_CHANNEL_LOOP                                      while(commChannel != 0)
           =1 # define DESC_COMM_CHANNEL_PARAM_WRAP_ONLY(channel)                  (channel)
           =1 # define DESC_COMM_CHANNEL_PARAM_WRAP_INDEX(channel)                 (channel)
           =1 #else
 858      =1  # define DESC_COMM_CHANNEL_FORMAL_PARAM_DEF_ONLY                     void
 859      =1  # define DESC_COMM_CHANNEL_FORMAL_PARAM_DEF_FIRST
 860      =1  # define DESC_COMM_CHANNEL_PARAM_ONLY
 861      =1  # define DESC_COMM_CHANNEL_PARAM_FIRST
 862      =1  # define DESC_COMM_CHANNEL_PARAM_VALUE                               0
 863      =1  # define DESC_COMM_CHANNEL_LOCAL_PARAM_DEF
 864      =1  # define DESC_COMM_CHANNEL_PARAM_VALUE_INIT
 865      =1  # define DESC_COMM_CHANNEL_PARAM_VALUE_DEC
 866      =1  # define DESC_COMM_CHANNEL_LOOP
 867      =1  # define DESC_COMM_CHANNEL_PARAM_WRAP_ONLY(channel)
 868      =1  # define DESC_COMM_CHANNEL_PARAM_WRAP_INDEX(channel)                 0
 869      =1  #endif
 870      =1  
 871      =1  /* If more than one parallel request may be processed - use real context */
 872      =1  #if (kDescNumContexts > 1)
           =1 # define DESC_CONTEXT_PARAM_TYPE_ONLY                                vuint8                               
             -                 /* Used in CANdesc for function prototypes */
           =1 # define DESC_CONTEXT_PARAM_TYPE_FIRST                               vuint8,                              
             -                 /* Used in CANdesc for function prototypes */
           =1 # define DESC_CONTEXT_PARAM_VALUE                                    iContext                             
             -                 /* Used in CANdesc context accesses as "g_descMsgContext[DESC_CONTEXT_PARAM_VALUE].reqDataLen" in case 
             -the parameter is defined using the other optimization macros */
           =1 # define DESC_CONTEXT_PARAM_ONLY                                     iContext                             
             -                 /* Used in application/CANdesc functions as DescProcessingDone(DESC_CONTEXT_PARAM_ONLY), in case the pa
             -rameter is defined using the other optimization macros */
           =1 # define DESC_CONTEXT_PARAM_FIRST                                    iContext,                            
             -                 /* Used in application/CANdesc functions as DescSetNegResponse(DESC_CONTEXT_PARAM_FIRST, kDescNrcCode),
             - in case the parameter is defined using the other optimization macros */
           =1 # define DESC_CONTEXT_FORMAL_PARAM_DEF_ONLY                          DESC_CONTEXT_PARAM_TYPE_ONLY DESC_CON
             -TEXT_PARAM_ONLY  /* Used in application/CANdesc functions as DescProcessingDone(DESC_CONTEXT_FORMAL_PARAM_DEF_ONLY);*/
           =1 # define DESC_CONTEXT_PARAM_DEF_LOCAL                                DESC_CONTEXT_FORMAL_PARAM_DEF_ONLY;  
             -                 /* Used in functions as a local variable definition so it can be used with all other optimization macro
             -s */
           =1 # define DESC_CONTEXT_FORMAL_PARAM_DEF_FIRST                         DESC_CONTEXT_PARAM_TYPE_ONLY DESC_CON
             -TEXT_PARAM_ONLY, /* Used in application/CANdesc functions as ApplDescPostHandler(DESC_CONTEXT_FORMAL_PARAM_DEF_FIRST vui
             -nt8 status) */
           =1 # define DESC_CONTEXT_PARAM_WRAPPER_ONLY(contextConst)               contextConst                         
             -                 /* Used in call backs as DescProcessingDone(DESC_CONTEXT_PARAM_WRAPPER_ONLY(pMsgContext->iContext)) as 
             -universal ignore parameter macro */
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 325 

           =1 # define DESC_CONTEXT_PARAM_WRAPPER_FIRST(contextConst)              contextConst,                        
             -                 /* Used in call backs as DescSetNegResponse(DESC_CONTEXT_PARAM_WRAPPER_FIRST(pMsgContext->iContext) kDe
             -scNrcConditionsNotCorrect) as universal ignore parameter macro */
           =1 # define DESC_CONTEXT_PARAM_WRAPPER_INDEX(contextConst)              contextConst                         
             -                 /* Used for accessing context specific tables */
           =1 # define DESC_CONTEXT_PARAM_DUMMY_USE                                DESC_IGNORE_UNREF_PARAM(DESC_CONTEXT_
             -PARAM_ONLY)      /* Used to avoid compiler warnings for unreferenced variables */
           =1 #else
 886      =1  # define DESC_CONTEXT_PARAM_TYPE_ONLY                                void
 887      =1  # define DESC_CONTEXT_PARAM_TYPE_FIRST
 888      =1  # define DESC_CONTEXT_PARAM_VALUE                                    ((vuint8)0)
 889      =1  # define DESC_CONTEXT_PARAM_ONLY
 890      =1  # define DESC_CONTEXT_PARAM_FIRST
 891      =1  # define DESC_CONTEXT_FORMAL_PARAM_DEF_ONLY                          void
 892      =1  # define DESC_CONTEXT_FORMAL_PARAM_DEF_FIRST
 893      =1  # define DESC_CONTEXT_PARAM_DEF_LOCAL
 894      =1  # define DESC_CONTEXT_PARAM_WRAPPER_ONLY(contextConst)
 895      =1  # define DESC_CONTEXT_PARAM_WRAPPER_FIRST(contextConst)
 896      =1  # define DESC_CONTEXT_PARAM_WRAPPER_INDEX(contextConst)              0
 897      =1  # define DESC_CONTEXT_PARAM_DUMMY_USE
 898      =1  #endif
 899      =1  
 900      =1  /* Diag connection number (in case of TPMC with DYN_ID usage) */
 901      =1  #if ! defined(kDescDiagConnection)
 902      =1  # define kDescDiagConnection                                         ((vuint8)0xF0)
 903      =1  #endif
 904      =1  
 905      =1  #if ! defined(kDescDiagObdConnection)
 906      =1  # define kDescDiagObdConnection                                      ((vuint8)0xF1)
 907      =1  #endif
 908      =1  
 909      =1  #if ! defined(kDescDiagAddConnection)
 910      =1  # define kDescDiagAddConnection                                      ((vuint8)0xF2)
 911      =1  #endif
 912      =1  
 913      =1  /* -- Context specific activity states -- */
 914      =1  #define kDescContextIdle                                             ((DescContextActivity)0x00)
 915      =1  #define kDescContextActiveRxBegin                                    ((DescContextActivity)0x01)
 916      =1  #define kDescContextActiveRxEnd                                      ((DescContextActivity)0x02)
 917      =1  #define kDescContextActiveProcess                                    ((DescContextActivity)0x04)
 918      =1  #define kDescContextActiveProcessEnd                                 ((DescContextActivity)0x08)
 919      =1  #define kDescContextActiveTxReady                                    ((DescContextActivity)0x10)
 920      =1  #define kDescContextActiveTx                                         ((DescContextActivity)0x20)
 921      =1  #define kDescContextActivePostProcess                                ((DescContextActivity)0x40)
 922      =1  
 923      =1  /* Any transmission is currently active */
 924      =1  #define kDescContextActiveRx                                         (DescContextActivity)(kDescContextAct
             -iveRxBegin | kDescContextActiveRxEnd)
 925      =1  
 926      =1  
 927      =1  /* ---  Addressing methods  --- */
 928      =1  #define kDescPhysReq                                                 ((vuint8)0x01)
 929      =1  #define kDescFuncReq                                                 ((vuint8)0x02)
 930      =1  
 931      =1  #define kDescPrimContext                                             (vuint8) 0
 932      =1  #define kDescSecContext                                              (vuint8) 0
 933      =1  #define kDescCallCycleUs                                             10000
 934      =1  #define kDescS1TimerTicks                                            500
 935      =1  /* P2 timeout in DescTask cycles. */
 936      =1  #define kDescP2Ticks                                                 4
 937      =1  /* P2Ex timeout in DescTask cycles. */
 938      =1  #define kDescP2StarTicks                                             499
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 326 

 939      =1  /* P2 timeout time in 1ms resolution. */
 940      =1  #define kDescTimeValueP2                                             50
 941      =1  /* P2Ex timeout time in 10 ms resolution. */
 942      =1  #define kDescTimeValueP2Star                                         500
 943      =1  #define kDescStateValueInvalid                                       (DescStateGroup)0xFFFF
 944      =1  
 945      =1  /* CANdesc supports at maximum as many states pro StateGroup as given below: */
 946      =1  #define kDescMaxAllowedNumStates                                     16
 947      =1  #define kDescNumStateSession                                         5
 948      =1  #define kDescStateSessionDefault                                     ((DescStateGroup)0x01)
 949      =1  #define kDescStateSessionProgramming                                 ((DescStateGroup)0x02)
 950      =1  #define kDescStateSessionExtended                                    ((DescStateGroup)0x04)
 951      =1  #define kDescStateSessionExtendedDiagnosticMode                      ((DescStateGroup)0x08)
 952      =1  #define kDescStateSessionECUProgrammingMode                          ((DescStateGroup)0x10)
 953      =1  #define kDescNumStateSecurityAccess                                  2
 954      =1  #define kDescStateSecurityAccessLocked                               ((DescStateGroup)0x01)
 955      =1  #define kDescStateSecurityAccessUnlockedL1                           ((DescStateGroup)0x02)
 956      =1  /* Error free diagnsotic request process */
 957      =1  #define kDescNrcNone                                                 ((DescNegResCode)0x00)
 958      =1  #define kDescExtNrcNone                                              ((vuint16)0x0000)
 959      =1  
 960      =1  /* ---  Post handler status masks --- */
 961      =1  #define kDescPostHandlerStateOk                                      ((vuint8)0x01)
 962      =1  #define kDescPostHandlerStateNegResSent                              ((vuint8)0x02)
 963      =1  #define kDescPostHandlerStateTxFailed                                ((vuint8)0x04)
 964      =1  
 965      =1  /* Default BOOT state */
 966      =1  #define kDescPowerOnInitParam                                        (DescInitParam)0
 967      =1  
 968      =1  /**************************/
 969      =1  /* Communication control  */
 970      =1  /**************************/
 971      =1  /* Communication control */
 972      =1  #define kDescCommControlStateEnable                                  0x01
 973      =1  #define kDescCommControlStateDisable                                 0x00
 974      =1  
 975      =1  /* CAN channel values */
 976      =1  #define kDescCommControlSubNetNumAll                                 0x00
 977      =1  
 978      =1  /* No CAN channel shall be manipulated */
 979      =1  #define kDescCommControlCanChNone                                    0x0F
 980      =1  
 981      =1  /* The corresponding CAN channel shall be disabled/enabled */
 982      =1  
 983      =1  #define kDescCommControlCanCh01                                      0x00
 984      =1  #define kDescCommControlCanCh02                                      0x01
 985      =1  #define kDescCommControlCanCh03                                      0x02
 986      =1  #define kDescCommControlCanCh04                                      0x03
 987      =1  #define kDescCommControlCanCh05                                      0x04
 988      =1  #define kDescCommControlCanCh06                                      0x05
 989      =1  #define kDescCommControlCanCh07                                      0x06
 990      =1  #define kDescCommControlCanCh08                                      0x07
 991      =1  #define kDescCommControlCanCh09                                      0x08
 992      =1  #define kDescCommControlCanCh10                                      0x09
 993      =1  #define kDescCommControlCanCh11                                      0x0A
 994      =1  #define kDescCommControlCanCh12                                      0x0B
 995      =1  #define kDescCommControlCanCh13                                      0x0C
 996      =1  #define kDescCommControlCanCh14                                      0x0D
 997      =1  
 998      =1  /* Message groups */
 999      =1  #define kDescCommControlMsgAppl                                      0x01
1000      =1  #define kDescCommControlMsgNm                                        0x02
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 327 

1001      =1  #define kDescCommControlMsgTypeAll                                   ((vuint8) (kDescCommControlMsgAppl | 
             -kDescCommControlMsgNm))
1002      =1  #define kDescSecureTimer                                             10000
1003      =1  #define kDescMaxNumberOfAttempts                                     3
1004      =1  #if defined (DESC_ENABLE_REPORT_ATT_CNTR_STATE)
           =1 # define kDescSecAccAttCtrChgOnTimeExpire                            (DescSecAccAttCtrChgEvType)0
           =1 # define kDescSecAccAttCtrChgOnTooManyInvalidKeys                    (DescSecAccAttCtrChgEvType)1
           =1 # define kDescSecAccAttCtrChgOnInvalidKey                            (DescSecAccAttCtrChgEvType)2
           =1 # define kDescSecAccAttCtrChgOnValidKey                              (DescSecAccAttCtrChgEvType)3
           =1 # define kDescSecAccAttCtrChgOnTooManySeedsWithoutKey                (DescSecAccAttCtrChgEvType)4
           =1 # define kDescSecAccAttCtrChgOnSeedWithoutKey                        (DescSecAccAttCtrChgEvType)5
           =1 # define kDescSecAccAttCtrChgOnApplRequest                           (DescSecAccAttCtrChgEvType)6
           =1 # define kDescSecAccAttCtrChgInvalid                                 (DescSecAccAttCtrChgEvType)255
           =1 #endif
1014      =1  
1015      =1  #define kDescNumMaxPidList                                           10
1016      =1  
1017      =1  
1018      =1  /* -----------------------------------------------------------------------------
1019      =1      &&&~ Datatype definitions
1020      =1   ----------------------------------------------------------------------------- */
1021      =1  
1022      =1  /* CANdesc internal boolean type (used for better code readability and code optimum) */
1023      =1  typedef vboolean DescBool;
1024      =1  #if defined (DESC_USE_ANSI_C_BIT_TYPE)
           =1 typedef unsigned int DescBitType;
           =1 #else
1027      =1  typedef vbittype     DescBitType;
1028      =1  #endif
1029      =1  
1030      =1  
1031      =1  typedef struct t_AddrInfoIsoTpTag
1032      =1  {
1033      =1    vuint8  Dummy;
1034      =1  
1035      =1  #if defined (TP_ENABLE_NORMAL_ADDRESSING)       || \
1036      =1      defined (TP_ENABLE_MIXED_11_ADDRESSING)
1037      =1  # if defined (TP_ENABLE_DYNAMIC_CHANNELS)
           =1   vuint16 TransmitID;
           =1   vuint16 ReceiveID;
           =1 # else
1041      =1  # endif
1042      =1  #endif
1043      =1  #if (TP_USE_EXTENDED_ADDRESSING == kTpOn) || \
1044      =1      defined (TP_ENABLE_NORMAL_FIXED_ADDRESSING) || \
1045      =1      defined(TP_FUNC_ENABLE_EXTENDED_ADDRESSING) || \
1046      =1      defined (TP_ENABLE_MIXED_29_ADDRESSING)
           =1   vuint8 SourceAddress;
           =1   vuint8 TargetAddress;
           =1 #endif
1050      =1  #if ( kCanNumberOfChannels > 1 ) /* more than one canChannel ? */
           =1   vuint8 CanChannel;
           =1 #endif
1053      =1  #if (TP_USE_EXTENDED_ADDRESSING == kTpOn)
           =1 # if (TP_USE_MULTIPLE_BASEADDRESS == kTpOn)
           =1   vuint16 BaseAddress;
           =1 # endif
           =1 #endif
1058      =1  } t_AddrInfoIsoTp;
1059      =1  
1060      =1  /* USDT Net result return type */
1061      =1  typedef enum
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 328 

1062      =1  {
1063      =1    kDescUsdtNetworkOk = 0,
1064      =1    kDescUsdtNetworkFailed = 1,
1065      =1    kDescUsdtNetBufferUnderrun = 2,
1066      =1    kDescUsdtNetworkAbort = 3
1067      =1  } t_descUsdtNetResult;
1068      =1  
1069      =1  /* CANdesc internal handle type */
1070      =1  typedef vuint8 t_descHandle;
1071      =1  
1072      =1  /* USDT Net bus handle type */
1073      =1  typedef vuint8 t_descUsdtNetBusHandle;
1074      =1  
1075      =1  typedef enum
1076      =1  {
1077      =1    kDescUsdtNetReqTypePhysical,
1078      =1    kDescUsdtNetReqTypeFunctional,
1079      =1    kDescUsdtNetReqTypeInternal
1080      =1  } t_descUsdtNetReqType;
1081      =1  
1082      =1  typedef enum
1083      =1  {
1084      =1    kDescUsdtResponseNone,
1085      =1    kDescUsdtResponsePositive,
1086      =1    kDescUsdtResponseRingBuffer,
1087      =1    kDescUsdtResponseNegative,
1088      =1    kDescUsdtResponseNegativeRCR_RP,
1089      =1    kDescUsdtResponseNegativeApplRCR_RP,
1090      =1    kDescUsdtResponseRoe,
1091      =1    kDescUsdtResponsePeriodic,
1092      =1    kDescUsdtResponseSpontaneous,
1093      =1    kDescUsdtResponseSpontaneousAppl
1094      =1  } t_descUsdtNetResType;
1095      =1  
1096      =1  
1097      =1  typedef DESC_USDTNET_P2FARRAM(vuint8) DescUsdtNetMsg;
1098      =1  
1099      =1  typedef enum
1100      =1  {
1101      =1    kDescUsdtNetBusTypeNone, 
1102      =1    kDescUsdtNetBusTypeIsoTp
1103      =1  } t_descUsdtNetBusType;
1104      =1  typedef union t_descUsdtNetAddrInfoTag
1105      =1  {
1106      =1    t_AddrInfoIsoTp isoTp;
1107      =1  } t_descUsdtNetAddrInfo;
1108      =1  typedef struct
1109      =1  {
1110      =1    vuint8                comChannel; /* relevant only on multi-channel systems (e.g. multi CAN channels) */
1111      =1    vuint8                testerId;   /* in some cases the tester address (ID) is from importance - store he
             -re if you have it */
1112      =1    t_descUsdtNetBusType  busType;        /* from DescUsdtNetDispatcher.h */
1113      =1    t_descUsdtNetAddrInfo addressingInfo; /* from DescUsdtNetDispatcher.h */
1114      =1  #if defined (DESC_USDTNET_ENABLE_DYNAMIC_BUFFER_LENGTH)
           =1   vuint16               availBufferLength;
           =1 #endif
1117      =1  } t_descUsdtNetBus;
1118      =1  
1119      =1  typedef vuint8                                        DescContextActivity;
1120      =1  typedef vuint8                                        DescMsgItem;
1121      =1  
1122      =1  typedef DESC_P2FARRAM(DescMsgItem)                    DescMsg;
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 329 

1123      =1  typedef DESC_CONSTP2FARRAM(DescMsgItem)               DescConstPtr;
1124      =1  typedef vuint16                                       DescMsgLen;
1125      =1  
1126      =1  /* Some groups can have more than 8 states */
1127      =1  typedef unsigned int DescStateGroup;
1128      =1  
1129      =1  /* Negative response codes is normally single Byte */
1130      =1  typedef vuint8 DescNegResCode;
1131      =1  /* Additional information about a request */
1132      =1  typedef struct
1133      =1  {
1134      =1    DescBitType reqType   :2; /* 0x01: Phys 0x02: Func */
1135      =1    DescBitType resOnReq  :2; /* 0x01: Phys 0x02: Func */
1136      =1    DescBitType suppPosRes:1; /* 0x00: No   0x02: Yes  */
1137      =1  } DescMsgAddInfo;
1138      =1  
1139      =1  /* Context information of a request */
1140      =1  typedef struct
1141      =1  {
1142      =1    DescMsg             reqData;
1143      =1    DescMsgLen          reqDataLen;
1144      =1    DescMsg             resData;
1145      =1    DescMsgLen          resDataLen;
1146      =1    DescMsgAddInfo      msgAddInfo;
1147      =1    DESC_CONTEXT_PARAM_DEF_LOCAL /* No iContext in non-parallel system */
1148      =1    t_descUsdtNetBus    busInfo;
1149      =1  } DescMsgContext;
1150      =1  
1151      =1  /* Main handler function pointer type */
1152      =1  typedef void DESC_API_CALL_TYPE (*DescMainHandler)     (DescMsgContext*);
1153      =1  
1154      =1  /* not used */
1155      =1  typedef vuint8 DescInitParam;
1156      =1  
1157      =1  /**************************/
1158      =1  /* Communication control  */
1159      =1  /**************************/
1160      =1  typedef struct
1161      =1  {
1162      =1  #if defined (DESC_ENABLE_RX_COMM_CONTROL)
1163      =1    DescBitType  dummy_gap           :2; /* Alignment gap */
1164      =1    DescBitType  rxPathState         :2; /* Enable/Disable */
1165      =1  #endif
1166      =1    DescBitType  txPathState         :2; /* Enable/Disable */
1167      =1    DescBitType  msgTypes            :2; /* Appl OR/AND NM */
1168      =1    DescBitType  subNetNumber        :4; /* Subnetwork channel number */
1169      =1    DescBitType  reqCommChannel      :4; /* up to 15 CAN channels */
1170      =1    DescBitType  commCtrlChannel     :4; /* up to 15 CAN channels (former commChannelCtrlTx)*/
1171      =1  }DescOemCommControlInfo;
1172      =1  
1173      =1  
1174      =1  #if defined (DESC_ENABLE_REPORT_ATT_CNTR_STATE)
           =1 typedef vuint8 DescSecAccAttCtrChgEvType;
           =1 #endif
1177      =1  
1178      =1  typedef enum
1179      =1  {
1180      =1    kDescSaStatusOk = 0,
1181      =1    kDescSaStatusNok = 1
1182      =1  }DescSecurityAccessStatus;
1183      =1  
1184      =1  typedef struct
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 330 

1185      =1  {
1186      =1    DescStateGroup            securityLevel;
1187      =1    DescSecurityAccessStatus  status;
1188      =1    vuint8                    dataLen;
1189      =1    DescMsg                   dataPtr;
1190      =1    DESC_CONTEXT_PARAM_DEF_LOCAL /* No iContext in non-parallel system */
1191      =1  } DescSecurityAccessContext;
1192      =1  
1193      =1  
1194      =1  
1195      =1  /* -----------------------------------------------------------------------------
1196      =1      &&&~ Function prototypes
1197      =1   ----------------------------------------------------------------------------- */
1198      =1  
1199      =1  #if defined (TP_ENABLE_DYNAMIC_CHANNELS)
           =1 /* Rx path phys */
           =1 TP_MEMORY_MODEL_DATA vuint8* TP_API_CALLBACK_TYPE DescGetBuffer(TP_CHANNEL_RX_FORMAL_PARAM_DEF_FIRST vuint
             -16 dataLength);
           =1 void    TP_API_CALLBACK_TYPE DescRxErrorIndication(TP_CHANNEL_RX_FORMAL_PARAM_DEF_FIRST vuint8 status);
           =1 void    TP_API_CALLBACK_TYPE DescPhysReqInd(TP_CHANNEL_RX_FORMAL_PARAM_DEF_FIRST vuint16 dataLen);
           =1 
           =1 /* Rx path func */
           =1 # if defined(TP_FUNC_ENABLE_RECEPTION) && \
           =1      !defined (TP_ENABLE_EXTENDED_ADDRESSING)
           =1 TP_MEMORY_MODEL_DATA vuint8* TP_API_CALLBACK_TYPE DescGetFuncBuffer(vuint16 dataLength);
           =1 void TP_API_CALLBACK_TYPE DescFuncReqInd(vuint16 dataLen);
           =1 # endif
           =1 
           =1 /* Tx path */
           =1 vuint8 TP_API_CALLBACK_TYPE DescCopyToCAN(TpCopyToCanInfoStructPtr infoStruct);
           =1 vuint8 TP_API_CALLBACK_TYPE DescTxErrorIndication(TP_CHANNEL_TX_FORMAL_PARAM_DEF_FIRST vuint8 status);
           =1 void   TP_API_CALLBACK_TYPE DescConfirmation(TP_CHANNEL_TX_FORMAL_PARAM_DEF_FIRST vuint8 status);
           =1 #endif
1217      =1  
1218      =1  #if defined (DESC_ENABLE_SPONTANEOUS_RES)
           =1 /* ---- Extended functionality ---- */
           =1 DescBool DescSendSpontaneousResponse(DescMsg resData, DescMsgLen resLen, t_descUsdtNetBus* pBusInfo, t_des
             -cUsdtNetResType repType);
           =1 #endif
1222      =1  
1223      =1  /* Reports the current diagnostic activity state (e.g. Idle, ActiveRx, ActiveProcess, ActiveTx.*/
1224      =1  DescContextActivity DESC_API_CALL_TYPE DescGetActivityState(DESC_CONTEXT_FORMAL_PARAM_DEF_ONLY);
1225      =1  
1226      =1  #if defined (DESC_ENABLE_ACCESS_TESTER_ADDRESS_API)
           =1 vuint8 DESC_API_CALL_TYPE DescGetTesterAddress(DESC_CONTEXT_FORMAL_PARAM_DEF_ONLY);
           =1 #endif
1229      =1  
1230      =1  /*Get access to the current communication parameters */
1231      =1  t_descUsdtNetBus* DESC_API_CALL_TYPE DescGetCurrentBusInfo (DESC_CONTEXT_FORMAL_PARAM_DEF_ONLY);
1232      =1  
1233      =1  #if defined (DESC_ENABLE_FORCE_RCR_RP)
           =1 /* Force CANdesc to send RCR-RP response */
           =1 void DESC_API_CALL_TYPE DescForceRcrRpResponse(DESC_CONTEXT_FORMAL_PARAM_DEF_ONLY);
           =1 #endif
1237      =1  
1238      =1  #if defined (DESC_ENABLE_AUTO_STATES)
1239      =1  /* If needed - reset the whole state machine (only the states defined in the CDD!!!) */
1240      =1  void DESC_API_CALL_TYPE DescStateInit(void);
1241      =1  #endif
1242      =1  
1243      =1  DescStateGroup DESC_API_CALL_TYPE DescGetStateSession(void);
1244      =1  void DESC_API_CALL_TYPE DescSetStateSession(DescStateGroup descState);
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 331 

1245      =1  DescStateGroup DESC_API_CALL_TYPE DescGetStateSecurityAccess(void);
1246      =1  void DESC_API_CALL_TYPE DescSetStateSecurityAccess(DescStateGroup descState);
1247      =1  #if defined(DESC_ENABLE_AUTO_STATES)
1248      =1  /* Converts session id (sub-function) to session state */
1249      =1  DescStateGroup DESC_API_CALL_TYPE DescGetSessionStateOfSessionId(DescMsgItem sessionId);
1250      =1  /* Converts session state to session id (sub-function) */
1251      =1  DescMsgItem DESC_API_CALL_TYPE DescGetSessionIdOfSessionState(DescStateGroup sessionState);
1252      =1  /* Get access to the session specific timings */
1253      =1  void DESC_API_CALL_TYPE DescGetSessionTimings(DescStateGroup sessionState, vuint16* p2Time_1ms, vuint16* p
             -2ExTime_10ms);
1254      =1  #endif
1255      =1  
1256      =1  #if defined (DESC_ENABLE_MAINHANDLER_MULTICALL)
           =1 /* Use this function if you want your application to be polled for a certain service */
           =1 void DESC_API_CALL_TYPE DescStartRepeatedServiceCall(DESC_CONTEXT_FORMAL_PARAM_DEF_FIRST DescMainHandler m
             -ainHandler);
           =1 #endif
1260      =1  /* Activate linear response transmission */
1261      =1  void DESC_API_CALL_TYPE DescProcessingDone(DESC_CONTEXT_FORMAL_PARAM_DEF_ONLY);
1262      =1  /* Set a diagnostic error */
1263      =1  void DESC_API_CALL_TYPE DescSetNegResponse(DESC_CONTEXT_FORMAL_PARAM_DEF_FIRST DescNegResCode errorCode);
1264      =1  #if defined(DESC_ENABLE_GENERIC_USER_SERVICE_SUPPORT)
           =1 /* Returns the current service's Sid */
           =1 DescMsgItem DESC_API_CALL_TYPE DescGetServiceId(DESC_CONTEXT_FORMAL_PARAM_DEF_ONLY);
           =1 #endif
1268      =1  
1269      =1  /* Initilize the CANdesc on PowerOnReset using this function */
1270      =1  void DESC_API_CALL_TYPE DescInitPowerOn(DescInitParam initParam);
1271      =1  /* Initilize the CANdesc if needed during the ECU  runtime using this function (status reset) */
1272      =1  void DESC_API_CALL_TYPE DescInit(DescInitParam initParam);
1273      =1  
1274      =1  /* DescTask function must be call cyclically in the specified period of time */
1275      =1  void DESC_API_CALL_TYPE DescTask(void);
1276      =1  
1277      =1  void DESC_API_CALL_TYPE DescTimerTask(void);
1278      =1  void DESC_API_CALL_TYPE DescStateTask(void);
1279      =1  
1280      =1  /* Returns true if the positive response will be supressed. */
1281      =1  DescBool DESC_API_CALL_TYPE DescIsSuppressPosResBitSet(DESC_CONTEXT_FORMAL_PARAM_DEF_ONLY);
1282      =1  
1283      =1  /* Confirmation for seed generation */
1284      =1  void DescSecurityAccessSeedReady(DESC_CONTEXT_FORMAL_PARAM_DEF_ONLY);
1285      =1  /* Confirmation for key validation */
1286      =1  void DescSecurityAccessKeyChecked(DESC_CONTEXT_FORMAL_PARAM_DEF_ONLY);
1287      =1  
1288      =1  #if (kDescSecureTimer != 0)
1289      =1  /* Attempt counter access */
1290      =1  vuint8 DescGetAttemptCounterValue(DESC_CONTEXT_FORMAL_PARAM_DEF_ONLY);
1291      =1  void DescSetAttemptCounterValue(DESC_CONTEXT_FORMAL_PARAM_DEF_FIRST vuint8 value);
1292      =1  
1293      =1  # if defined (DESC_ENABLE_START_SA_TIMER_EXTERN)
           =1 void DescStartSecureTimer(DESC_CONTEXT_FORMAL_PARAM_DEF_ONLY);
           =1 # endif
1296      =1  #endif
1297      =1  
1298      =1  
1299      =1  
1300      =1  /* -----------------------------------------------------------------------------
1301      =1      &&&~ ROM definitions
1302      =1   ----------------------------------------------------------------------------- */
1303      =1  
1304      =1  /* Version information */
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 332 

1305      =1  V_MEMROM0 extern V_MEMROM1 vuint8 V_MEMROM2 g_descMainVersion;
1306      =1  V_MEMROM0 extern V_MEMROM1 vuint8 V_MEMROM2 g_descSubVersion;
1307      =1  V_MEMROM0 extern V_MEMROM1 vuint8 V_MEMROM2 g_descBugFixVersion;
1308      =1  
1309      =1  
1310      =1  
1311      =1  /* -----------------------------------------------------------------------------
1312      =1      &&&~ Macro definitions
1313      =1   ----------------------------------------------------------------------------- */
1314      =1  
1315      =1  #if defined (DESC_ENABLE_FAR_BUFFER)
           =1 /* Copy RAM->FAR RAM */
           =1 # define DescCopyNByteRAM(t,s,l)                                     (VStdMemCpyRamToFarRam((t),(s),(l)))
           =1 /* Copy ROM->FAR RAM */
           =1 # define DescCopyNByteROM(t,s,l)                                     (VStdMemCpyRomToFarRam((t),(s),(l)))
           =1 
           =1 # define DescMsgCopyRamToRam(t,s,l)                                  (VStdMemCpyRamToRam((t),(s),(l)))
           =1 # define DescMsgCopyFarRamToRam(t,s,l)                               (VStdMemCpyFarRamToRam((t),(s),(l)))
           =1 # define DescMsgCopyRamToFarRam(t,s,l)                               (VStdMemCpyRamToFarRam((t),(s),(l)))
           =1 # define DescMsgCopyFarRamToFarRam(t,s,l)                            (VStdMemCpyFarRamToFarRam((t),(s),(l)
             -))
           =1 # define DescMsgCopyRomToRam(t,s,l)                                  (VStdMemCpyRomToRam((t),(s),(l)))
           =1 # define DescMsgCopyRomToFarRam(t,s,l)                               (VStdMemCpyRomToFarRam((t),(s),(l)))
           =1 #else
1328      =1  /* TMS320 specifics */
1329      =1  # if defined (VStdMemCpyRamToRamElement)
           =1 #  define DescWrapCpyRamToRam(t,s,l)                                 (VStdMemCpyRamToRamElement((t),(s),(l
             -)))
           =1 #  define DescWrapCpyRomToRam(t,s,l)                                 (VStdMemCpyRomToRamElement((t),(s),(l
             -)))
           =1 # else
1333      =1  #  define DescWrapCpyRamToRam(t,s,l)                                 (VStdMemCpyRamToRam((t),(s),(l)))
1334      =1  #  define DescWrapCpyRomToRam(t,s,l)                                 (VStdMemCpyRomToRam((t),(s),(l)))
1335      =1  # endif
1336      =1  /* Copy RAM->RAM */
1337      =1  # define DescCopyNByteRAM(t,s,l)                                     (DescWrapCpyRamToRam((t),(s),(l)))
1338      =1  /* Copy ROM->RAM */
1339      =1  # define DescCopyNByteROM(t,s,l)                                     (DescWrapCpyRomToRam((t),(s),(l)))
1340      =1  
1341      =1  # define DescMsgCopyRamToRam(t,s,l)                                  (DescWrapCpyRamToRam((t),(s),(l)))
1342      =1  # define DescMsgCopyFarRamToRam(t,s,l)                               (DescWrapCpyRamToRam((t),(s),(l)))
1343      =1  # define DescMsgCopyRamToFarRam(t,s,l)                               (DescWrapCpyRamToRam((t),(s),(l)))
1344      =1  # define DescMsgCopyFarRamToFarRam(t,s,l)                            (DescWrapCpyRamToRam((t),(s),(l)))
1345      =1  # define DescMsgCopyRomToRam(t,s,l)                                  (DescWrapCpyRomToRam((t),(s),(l)))
1346      =1  # define DescMsgCopyRomToFarRam(t,s,l)                               (DescWrapCpyRomToRam((t),(s),(l)))
1347      =1  #endif
1348      =1  
1349      =1  #define DescSendApplSpontaneousResponse(d,l,b)                       (DescSendSpontaneousResponse((d), (l)
             -, (b) , (kDescUsdtResponseSpontaneousAppl)))
1350      =1  
1351      =1  /* Global initialization of the state machine */
1352      =1  #if defined (DESC_ENABLE_AUTO_STATES)
1353      =1  /* Func prototype is used */
1354      =1  #else
           =1 # define DescStateInit()                                             /* Not used */
           =1 #endif
1357      =1  
1358      =1  /* Data assemble/deassemble macros */
1359      =1  /* compose from byte stream a 16 bit data */
1360      =1  #define DescMake16Bit(hiByte,loByte)                                 ((vuint16)((((vuint16)(hiByte))<<8)| 
             -\
1361      =1                                                                       ((vuint16)(loByte))))
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 333 

1362      =1  /* compose from byte stream a 32 bit data */
1363      =1  #define DescMake32Bit(hiHiByte,hiLoByte,loHiByte,loLoByte)           ((vuint32)((((vuint32)(hiHiByte))<<24
             -)| \
1364      =1                                                                       (((vuint32)(hiLoByte))<<16)| \
1365      =1                                                                       (((vuint32)(loHiByte))<<8) | \
1366      =1                                                                       ((vuint32)(loLoByte))))
1367      =1  /* decompose 16 bit data in byte stream */
1368      =1  #define DescGetHiByte(data)                                          ((vuint8)(((vuint16)(data))>>8))
1369      =1  #define DescGetLoByte(data)                                          ((vuint8)(data))
1370      =1  
1371      =1  /* decompose 32 bit data in byte stream */
1372      =1  #define DescGetHiHiByte(data)                                        ((vuint8)(((vuint32)(data))>>24))
1373      =1  #define DescGetHiLoByte(data)                                        ((vuint8)(((vuint32)(data))>>16))
1374      =1  #define DescGetLoHiByte(data)                                        ((vuint8)(((vuint32)(data))>>8))
1375      =1  #define DescGetLoLoByte(data)                                        ((vuint8)(data))
1376      =1  
1377      =1  /**************************/
1378      =1  /* Communication control  */
1379      =1  /**************************/
1380      =1  /* Acknowledge the communication control */
1381      =1  #define DescCommCtrlChecked(DESC_CONTEXT_PARAM_ONLY)                 (DescProcessingDone(DESC_CONTEXT_PARA
             -M_ONLY))
1382      =1  /* Communication control anti-panic solution :)*/
1383      =1  void DESC_API_CALL_TYPE DescEnableCommunication(void);
1384      =1  
1385      =1  /**************************/
1386      =1  /* Session control        */
1387      =1  /**************************/
1388      =1  /* Acknowledge the session transition */
1389      =1  #if defined (DESC_ENABLE_PERMANENT_MAINHANDLER_MULTICALL)
           =1 void DescSessionTransitionChecked(DESC_CONTEXT_FORMAL_PARAM_DEF_ONLY);
           =1 #else
1392      =1  /* Acknowledge the session transition */
1393      =1  # define DescSessionTransitionChecked(DESC_CONTEXT_PARAM_ONLY)       (DescProcessingDone(DESC_CONTEXT_PARA
             -M_ONLY))
1394      =1  #endif
1395      =1  
1396      =1  
1397      =1  
1398      =1  #endif /* __DESC_H__ */
  20          #include "nm_basic.h"
   1      =1  
   2      =1  /*****************************************************************************
   3      =1  | Project Name: Node-Management Basic
   4      =1  |    File Name: nm_basic.h
   5      =1  |
   6      =1  |  Description: implementation of node management for CAN Class C ECUs
   7      =1  |
   8      =1  |
   9      =1  |-----------------------------------------------------------------------------
  10      =1  |               C O P Y R I G H T
  11      =1  |-----------------------------------------------------------------------------
  12      =1  | Copyright (c) 2003 - 2013 by Vector Informatik GmbH.    All rights reserved.
  13      =1  |
  14      =1  | COPYRIGHT NOTE / Urheberrechtlicher Vermerk
  15      =1  | 
  16      =1  |
  17      =1  | This software is copyright protected and proprietary 
  18      =1  | to Vector Informatik GmbH. Vector Informatik GmbH 
  19      =1  | grants to you only those rights as set out in the 
  20      =1  | license conditions. All other rights remain with 
  21      =1  | Vector Informatik GmbH.
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 334 

  22      =1  |
  23      =1  |-----------------------------------------------------------------------------
  24      =1  |               A U T H O R   I D E N T I T Y
  25      =1  |-----------------------------------------------------------------------------
  26      =1  | Initials     Name                      Company
  27      =1  | --------     ---------------------     ------------------------------------
  28      =1  | Bs           Thomas Balster            Vector Informatik GmbH
  29      =1  | Et           Thomas Ebert              Vector Informatik GmbH
  30      =1  | Pet          Thomas Petrus             Vector Informatik GmbH
  31      =1  | Dhf          Daniel Hof                Vector Informatik GmbH
  32      =1  | vismpf       Marco Pfalzgraf           Vector Informatik GmbH
  33      =1  |-----------------------------------------------------------------------------
  34      =1  |               R E V I S I O N   H I S T O R Y
  35      =1  |-----------------------------------------------------------------------------
  36      =1  | Date         Ver   Author    Description
  37      =1  | ----------   ---   -------   -----------------------------------------------
  38      =1  | 2003-10-31   1.0   Et,Pet    creation
  39      =1  | 2004-09-06   1.01  Bs        copyright paragraph changed into english version
  40      =1  |                              ESCAN00009376: adapt the names of the constants which store the version num
             -bers
  41      =1  |                              ESCAN00009705: add callback functions for transceiver handling
  42      =1  | 2004-10-13   1.02  Bs        ESCAN00009878: Naming Conventions: change version defines to serve the Vect
             -or naming rules
  43      =1  | 2005-04-05   1.03  Bs        ESCAN00011712: add the new BusOff recovery algorithm 'extended'
  44      =1  |                              ESCAN00011728: NM start and stop handling must be configurable
  45      =1  |                              ESCAN00011785: add assertions for runtime checks
  46      =1  |                              ESCAN00011786: add a 'get Net state' function
  47      =1  |                              ESCAN00011787: add const pragma to support IAR linker
  48      =1  | 2005-04-21   1.04  Bs        ESCAN00011990: change memory qualifier of version number constants
  49      =1  |                              ESCAN00011994: change datatype of configuration fields for multi channel su
             -pport
  50      =1  |                              ESCAN00012062: standardization of NMbasic defines
  51      =1  |                              ESCAN00012063: add support of indexed and indirected NM channels for use in
             - multi channel systems
  52      =1  | 2005-07-06   1.05  Bs        ESCAN00012094: just check the indirection switch instead in combination wit
             -h indexed NM
  53      =1  |                              ESCAN00012095: add interface to AsrNm
  54      =1  |                              ESCAN00012490: include of configuration header file added
  55      =1  |                              ESCAN00012670: two compiler switches corrected
  56      =1  |                              ESCAN00012853: Add return value to application callback function 
  57      =1  |                                             'ApplNmBasicSwitchTransceiverOff()'
  58      =1  | 2005-07-14   1.06  Bs        ESCAN00012906: Delete the define 'kNmBasicErrStateNotRunInTxConf'
  59      =1  | 2005-07-25   1.07  Bs        ESCAN00013016: change automatic version number detection
  60      =1  | 2006-02-16   1.08  Bs        ESCAN00015623: Assertion-Defines 'kNmBasicErrStateNotOkInStart' and 
  61      =1  |                                             'kNmBasicErrStateNotOkInStop' not used anymore
  62      =1  | 2006-03-14   1.09  Pet       ESCAN00015663: initialization of multi NM-channel systems corrected for no 
             -channel indirection
  63      =1  | 2006-04-26   1.10  Bs        Assertion defines reworked
  64      =1  | 2006-06-08   1.11  Bs        changes just in source file
  65      =1  | 2006-08-03   1.12  Dhf       changes just in source file
  66      =1  | 2006-10-06   1.13  Dhf       ESCAN00017908: Adaption of Nm_PwrTrainBasic to 
  67      =1  |                              support the BusOff algorithm 'time supervised'
  68      =1  | 2007-01-24   1.14  Dhf       ESCAN00012093: changes just in source file
  69      =1  |                              ESCAN00012097: add assertions to check the generated tabels during initiali
             -zation
  70      =1  |                              ESCAN00018548: changes just in source file
  71      =1  |                              ESCAN00018971: Nm Basic uses incorrect preprocessor switch: VGEN_ENABLE_NM_
             -ASR_GENERIC replaced by VGEN_ENABLE_NM_ASR_CAN
  72      =1  |                              ESCAN00018298: changes just in source file
  73      =1  |                              ESCAN00019119: added BusOff additions and Tx-Observation-Handling
  74      =1  |                              ESCAN00019593: changes just in source file
  75      =1  | 2008-11-10   1.15  Dhf       ESCAN00023008: changes in source file only
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 335 

  76      =1  |                              ESCAN00025822: changes in source file only
  77      =1  |                              ESCAN00030715: changes in source file only
  78      =1  |                              ESCAN00031037: changes in source file only
  79      =1  |                              ESCAN00031155: Adapt NM Basic to support QNX context switch
  80      =1  |                              ESCAN00031157: added external CanOnline/Offline handling
  81      =1  |                              ESCAN00031403: changes in source file only
  82      =1  | 2009-02-04   1.15.01 Dhf     ESCAN00032403: changes in source file only
  83      =1  | 2009-10-19   1.15.02 Dhf     ESCAN00034728: changes in source file only
  84      =1  |                              ESCAN00038780: changes in source file only
  85      =1  | 2010-08-18   1.15.03 Dhf     ESCAN00044450: changes in source file only
  86      =1  | 2011-11-23   1.15.04 vismpf  ESCAN00051839: changes in source file only
  87      =1  | 2012-10-08   1.15.05 vismpf  ESCAN00061225: corrected encapsulation of bNmBasicStateRequest and bNmBasic
             -BusOffRepaired
  88      =1  | 2013-03-21   1.15.06 vismpf  ESCAN00066076: corrected compiler abstraction of NmBasicCanToNmIndirection 
             -and NmBasicNmToCanIndirection
  89      =1  |****************************************************************************/
  90      =1  
  91      =1  #ifndef NMBASIC_IMPL_H
  92      =1  #define NMBASIC_IMPL_H
  93      =1  
  94      =1  #include "v_cfg.h"
   1      =2  /* -----------------------------------------------------------------------------
   2      =2    Filename:    v_cfg.h
   3      =2    Description: Toolversion: 05.00.51.01.30.02.86.01.00.00
   4      =2                 
   5      =2                 Serial Number: CBD1300286
   6      =2                 Customer Info: Hyundai Mobis Co., Ltd.
   7      =2                                Package: CBD Hmc SLP5 - CBD License f. HKMC
   8      =2                                Micro: C8051F582
   9      =2                                Compiler: Keil PK51
  10      =2                 
  11      =2                 
  12      =2                 Generator Fwk   : GENy 
  13      =2                 Generator Module: GenTool_GenyVcfgNameDecorator
  14      =2                 
  15      =2                 Configuration   : Y:\20150903_DiagCam_DE.gny
  16      =2                 
  17      =2                 ECU: 
  18      =2                         TargetSystem: Hw_Slc8051Cpu
  19      =2                         Compiler:     KEIL
  20      =2                         Derivates:    C8051F58x_59x
  21      =2                 
  22      =2                 Channel "Channel0":
  23      =2                         Databasefile: Y:\20150206_JF_DiagCamera_CAN_DB_R6(LangInfo).dbc
  24      =2                         Bussystem:    CAN
  25      =2                         Manufacturer: HMC
  26      =2                         Node:         PGS
  27      =2  
  28      =2    Generated by , 2015-10-19  18:50:07
  29      =2   ----------------------------------------------------------------------------- */
  30      =2  /* -----------------------------------------------------------------------------
  31      =2    C O P Y R I G H T
  32      =2   -------------------------------------------------------------------------------
  33      =2    Copyright (c) 2001-2011 by Vector Informatik GmbH. All rights reserved.
  34      =2   
  35      =2    This software is copyright protected and proprietary to Vector Informatik 
  36      =2    GmbH.
  37      =2    
  38      =2    Vector Informatik GmbH grants to you only those rights as set out in the 
  39      =2    license conditions.
  40      =2    
  41      =2    All other rights remain with Vector Informatik GmbH.
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 336 

  42      =2   -------------------------------------------------------------------------------
  43      =2   ----------------------------------------------------------------------------- */
  44      =2  
  45      =2  #if !defined(__V_CFG_H__)
           =2 #define __V_CFG_H__
           =2 
           =2 #ifndef VGEN_GENY
           =2 #define VGEN_GENY
           =2 #endif
           =2 
           =2 #ifndef GENy
           =2 #define GENy
           =2 #endif
           =2 
           =2 #ifndef SUPPLIER_CANBEDDED
           =2 #define SUPPLIER_CANBEDDED                   30
           =2 #endif
           =2 
           =2 /* -----------------------------------------------------------------------------
           =2     &&&~ Version
           =2  ----------------------------------------------------------------------------- */
           =2 
           =2 #ifndef VERSIONNUMBER
           =2 #define VERSIONNUMBER                        0x178
           =2 #endif
           =2 
           =2 
           =2 
           =2 /* -----------------------------------------------------------------------------
           =2     &&&~ General Switches
           =2  ----------------------------------------------------------------------------- */
           =2 
           =2 #ifndef V_OSTYPE_NONE
           =2 #define V_OSTYPE_NONE
           =2 #endif
           =2 
           =2 
           =2 
           =2 /* -----------------------------------------------------------------------------
           =2     &&&~ Processor specific
           =2  ----------------------------------------------------------------------------- */
           =2 
           =2 #ifndef C_CPUTYPE_8BIT
           =2 #define C_CPUTYPE_8BIT
           =2 #endif
           =2 
           =2 
           =2 #ifndef V_CPUTYPE_BITARRAY_16BIT
           =2 #define V_CPUTYPE_BITARRAY_16BIT
           =2 #endif
           =2 
           =2 
           =2 #ifndef C_CPUTYPE_BIGENDIAN
           =2 #define C_CPUTYPE_BIGENDIAN
           =2 #endif
           =2 
           =2 
           =2 #ifndef C_CPUTYPE_BITORDER_LSB2MSB
           =2 #define C_CPUTYPE_BITORDER_LSB2MSB
           =2 #endif
           =2 
           =2 
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 337 

           =2 #ifndef V_DISABLE_USE_DUMMY_FUNCTIONS
           =2 #define V_DISABLE_USE_DUMMY_FUNCTIONS
           =2 #endif
           =2 
           =2 
           =2 #ifndef V_ENABLE_USE_DUMMY_STATEMENT
           =2 #define V_ENABLE_USE_DUMMY_STATEMENT
           =2 #endif
           =2 
           =2 
           =2 #ifndef C_COMP_KEIL_SLC8051_CCAN
           =2 #define C_COMP_KEIL_SLC8051_CCAN
           =2 #endif
           =2 
           =2 
           =2 #ifndef V_CPU_SLC8051
           =2 #define V_CPU_SLC8051
           =2 #endif
           =2 
           =2 #ifndef V_COMP_KEIL
           =2 #define V_COMP_KEIL
           =2 #endif
           =2 
           =2 #ifndef V_COMP_KEIL_SLC8051
           =2 #define V_COMP_KEIL_SLC8051
           =2 #endif
           =2 
           =2 #ifndef V_PROCESSOR_C8051F58X_59X
           =2 #define V_PROCESSOR_C8051F58X_59X
           =2 #endif
           =2 
           =2 
           =2 #ifndef C_PROCESSOR_C8051F58X_59X
           =2 #define C_PROCESSOR_C8051F58X_59X
           =2 #endif
           =2 
           =2 
           =2 
           =2 
           =2 /* -----------------------------------------------------------------------------
           =2     &&&~ Used Modules
           =2  ----------------------------------------------------------------------------- */
           =2 
           =2 #define VGEN_ENABLE_DIAG_CANDESC_UDS
           =2 #ifndef VGEN_ENABLE_VSTDLIB
           =2 #define VGEN_ENABLE_VSTDLIB
           =2 #endif
           =2 
           =2 #ifndef VSTD_ENABLE_DEFAULT_INTCTRL
           =2 #define VSTD_ENABLE_DEFAULT_INTCTRL
           =2 #endif
           =2 
           =2 #ifndef VSTD_ENABLE_GLOBAL_LOCK
           =2 #define VSTD_ENABLE_GLOBAL_LOCK
           =2 #endif
           =2 
           =2 #ifndef VSTD_DISABLE_DEBUG_SUPPORT
           =2 #define VSTD_DISABLE_DEBUG_SUPPORT
           =2 #endif
           =2 
           =2 #ifndef VSTD_ENABLE_LIBRARY_FUNCTIONS
           =2 #define VSTD_ENABLE_LIBRARY_FUNCTIONS
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 338 

           =2 #endif
           =2 
           =2 
           =2 #define VGEN_ENABLE_CAN_DRV
           =2 #define C_ENABLE_CAN_CHANNELS
           =2 #define V_BUSTYPE_CAN
           =2 #define VGEN_ENABLE_IL_VECTOR
           =2 #define VGEN_ENABLE_NM_BASIC
           =2 #define VGEN_ENABLE_TP_ISO_MC
           =2 
           =2 
           =2 #ifndef kVNumberOfIdentities
           =2 #define kVNumberOfIdentities                 1
           =2 #endif
           =2 
           =2 #ifndef tVIdentityMsk
           =2 #define tVIdentityMsk                        vuint8
           =2 #endif
           =2 
           =2 #ifndef kVIdentityIdentity_0
           =2 #define kVIdentityIdentity_0                 (vuint8) 0
           =2 #endif
           =2 
           =2 #ifndef VSetActiveIdentity
           =2 #define VSetActiveIdentity(identityLog)
           =2 #endif
           =2 
           =2 #ifndef V_ACTIVE_IDENTITY_MSK
           =2 #define V_ACTIVE_IDENTITY_MSK                1
           =2 #endif
           =2 
           =2 #ifndef V_ACTIVE_IDENTITY_LOG
           =2 #define V_ACTIVE_IDENTITY_LOG                0
           =2 #endif
           =2 
           =2 
           =2 #define DIAG_API_CALL_TYPE
           =2 #define DIAG_API_CALLBACK_TYPE
           =2 #define DIAG_INTERNAL_CALL_TYPE
           =2 #define DRV_API_CALL_TYPE
           =2 #define DRV_API_CALLBACK_TYPE
           =2 #define TP_API_CALL_TYPE
           =2 #define TP_API_CALLBACK_TYPE
           =2 #define TP_INTERNAL_CALL_TYPE
           =2 
           =2 /* -----------------------------------------------------------------------------
           =2     &&&~ Versions of Preconfig Files
           =2  ----------------------------------------------------------------------------- */
           =2 
           =2 #define VGEN_OEM_PRECONFIG_HMC_SLP5
           =2 #define VGEN_OEM_PRECONFIG_VERSION           0x0101
           =2 #define VGEN_OEM_PRECONFIG_RELEASE_VERSION   0x00
           =2 #define VGEN_USER_PRECONFIG_HMC_SLP5_HIGH_SPEED
           =2 #define VGEN_USER_PRECONFIG_VERSION          0x0000
           =2 #define VGEN_USER_PRECONFIG_RELEASE_VERSION  0x00
           =2 
           =2 
           =2 /* -----------------------------------------------------------------------------
           =2     &&&~ Optimization
           =2  ----------------------------------------------------------------------------- */
           =2 
           =2 #define V_ATOMIC_BIT_ACCESS_IN_BITFIELD      STD_OFF
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 339 

           =2 #define V_ATOMIC_VARIABLE_ACCESS             16
           =2 
           =2 
           =2 
           =2 #ifndef VGEN_ENABLE_VSTDLIB
           =2 /* Diag_CanDesc requires VSTDLIB */
           =2 #define VGEN_ENABLE_VSTDLIB
           =2 #endif
           =2 
           =2 #ifndef C_CLIENT_HMC
           =2 #define C_CLIENT_HMC
           =2 #endif
           =2 
           =2 #ifndef __PGS__
           =2 #define __PGS__
           =2 #endif
           =2 
           =2 /* -----------------------------------------------------------------------------
           =2     &&&~ Compatibility defines for ComSetCurrentECU
           =2  ----------------------------------------------------------------------------- */
           =2 
           =2 #ifndef kComNumberOfNodes
           =2 #define kComNumberOfNodes                    kVNumberOfIdentities
           =2 #endif
           =2 
           =2 #ifndef ComSetCurrentECU
           =2 #define ComSetCurrentECU                     VSetActiveIdentity
           =2 #endif
           =2 
           =2 #ifndef comMultipleECUCurrent
           =2 #define comMultipleECUCurrent                vActiveIdentityLog
           =2 #endif
           =2 
           =2 
           =2 
           =2 #define C_VERSION_REF_IMPLEMENTATION         0x150
           =2 
           =2 
           =2 #ifndef VGEN_ENABLE_VSTDLIB
           =2 /* DrvCan__baseRi15 requires VSTDLIB */
           =2 #define VGEN_ENABLE_VSTDLIB
           =2 #endif
           =2 
           =2 #ifndef VGEN_ENABLE_VSTDLIB
           =2 #define VGEN_ENABLE_VSTDLIB
           =2 #endif
           =2 
           =2 
           =2 #ifndef VGEN_ENABLE_VSTDLIB
           =2 /* TpMC requires VSTDLIB */
           =2 #define VGEN_ENABLE_VSTDLIB
           =2 #endif
           =2 
           =2 
           =2 
           =2 /* begin Fileversion check */
           =2 #ifndef SKIP_MAGIC_NUMBER
           =2 #ifdef MAGIC_NUMBER
           =2   #if MAGIC_NUMBER != 204819919
           =2       #error "The magic number of the generated file <Y:\CANGEN\v_cfg.h> is different. Please check time a
             -nd date of generated files!"
           =2   #endif
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 340 

           =2 #else
           =2   #define MAGIC_NUMBER 204819919
           =2 #endif  /* MAGIC_NUMBER */
           =2 #endif  /* SKIP_MAGIC_NUMBER */
           =2 
           =2 /* end Fileversion check */
           =2 
           =2 #endif /* __V_CFG_H__ */
  95      =1  
  96      =1  #if defined ( VGEN_GENY )
  97      =1  # include "v_inc.h"
   1      =2  /* -----------------------------------------------------------------------------
   2      =2    Filename:    v_inc.h
   3      =2    Description: Toolversion: 05.00.51.01.30.02.86.01.00.00
   4      =2                 
   5      =2                 Serial Number: CBD1300286
   6      =2                 Customer Info: Hyundai Mobis Co., Ltd.
   7      =2                                Package: CBD Hmc SLP5 - CBD License f. HKMC
   8      =2                                Micro: C8051F582
   9      =2                                Compiler: Keil PK51
  10      =2                 
  11      =2                 
  12      =2                 Generator Fwk   : GENy 
  13      =2                 Generator Module: GenTool_GenyVcfgNameDecorator
  14      =2                 
  15      =2                 Configuration   : Y:\20150903_DiagCam_DE.gny
  16      =2                 
  17      =2                 ECU: 
  18      =2                         TargetSystem: Hw_Slc8051Cpu
  19      =2                         Compiler:     KEIL
  20      =2                         Derivates:    C8051F58x_59x
  21      =2                 
  22      =2                 Channel "Channel0":
  23      =2                         Databasefile: Y:\20150206_JF_DiagCamera_CAN_DB_R6(LangInfo).dbc
  24      =2                         Bussystem:    CAN
  25      =2                         Manufacturer: HMC
  26      =2                         Node:         PGS
  27      =2  
  28      =2    Generated by , 2015-10-19  18:50:07
  29      =2   ----------------------------------------------------------------------------- */
  30      =2  /* -----------------------------------------------------------------------------
  31      =2    C O P Y R I G H T
  32      =2   -------------------------------------------------------------------------------
  33      =2    Copyright (c) 2001-2011 by Vector Informatik GmbH. All rights reserved.
  34      =2   
  35      =2    This software is copyright protected and proprietary to Vector Informatik 
  36      =2    GmbH.
  37      =2    
  38      =2    Vector Informatik GmbH grants to you only those rights as set out in the 
  39      =2    license conditions.
  40      =2    
  41      =2    All other rights remain with Vector Informatik GmbH.
  42      =2   -------------------------------------------------------------------------------
  43      =2   ----------------------------------------------------------------------------- */
  44      =2  
  45      =2  #if !defined(__V_INC_H__)
           =2 #define __V_INC_H__
           =2 
           =2 #include "can_inc.h"
           =2 
           =2 #include "v_cfg.h"
           =2 #include "drv_par.h"
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 341 

           =2 
           =2 #include "nmb_cfg.h"
           =2 #include "tpmc.h"
           =2 
           =2 #include "v_par.h"
           =2 #include "can_par.h"
           =2 
           =2 /* begin Fileversion check */
           =2 #ifndef SKIP_MAGIC_NUMBER
           =2 #ifdef MAGIC_NUMBER
           =2   #if MAGIC_NUMBER != 204819919
           =2       #error "The magic number of the generated file <Y:\CANGEN\v_inc.h> is different. Please check time a
             -nd date of generated files!"
           =2   #endif
           =2 #else
           =2   #define MAGIC_NUMBER 204819919
           =2 #endif  /* MAGIC_NUMBER */
           =2 #endif  /* SKIP_MAGIC_NUMBER */
           =2 
           =2 /* end Fileversion check */
           =2 
           =2 #endif /* __V_INC_H__ */
  98      =1  #else
           =1 # include "can_inc.h"
           =1 #endif
 101      =1  
 102      =1  #include "nmb_cfg.h"
   1      =2  /* -----------------------------------------------------------------------------
   2      =2    Filename:    nmb_cfg.h
   3      =2    Description: Toolversion: 05.00.51.01.30.02.86.01.00.00
   4      =2                 
   5      =2                 Serial Number: CBD1300286
   6      =2                 Customer Info: Hyundai Mobis Co., Ltd.
   7      =2                                Package: CBD Hmc SLP5 - CBD License f. HKMC
   8      =2                                Micro: C8051F582
   9      =2                                Compiler: Keil PK51
  10      =2                 
  11      =2                 
  12      =2                 Generator Fwk   : GENy 
  13      =2                 Generator Module: Nm_PwrTrainBasic
  14      =2                 
  15      =2                 Configuration   : Y:\20150903_DiagCam_DE.gny
  16      =2                 
  17      =2                 ECU: 
  18      =2                         TargetSystem: Hw_Slc8051Cpu
  19      =2                         Compiler:     KEIL
  20      =2                         Derivates:    C8051F58x_59x
  21      =2                 
  22      =2                 Channel "Channel0":
  23      =2                         Databasefile: Y:\20150206_JF_DiagCamera_CAN_DB_R6(LangInfo).dbc
  24      =2                         Bussystem:    CAN
  25      =2                         Manufacturer: HMC
  26      =2                         Node:         PGS
  27      =2  
  28      =2    Generated by , 2015-10-19  18:50:07
  29      =2   ----------------------------------------------------------------------------- */
  30      =2  /* -----------------------------------------------------------------------------
  31      =2    C O P Y R I G H T
  32      =2   -------------------------------------------------------------------------------
  33      =2    Copyright (c) 2001-2011 by Vector Informatik GmbH. All rights reserved.
  34      =2   
  35      =2    This software is copyright protected and proprietary to Vector Informatik 
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 342 

  36      =2    GmbH.
  37      =2    
  38      =2    Vector Informatik GmbH grants to you only those rights as set out in the 
  39      =2    license conditions.
  40      =2    
  41      =2    All other rights remain with Vector Informatik GmbH.
  42      =2   -------------------------------------------------------------------------------
  43      =2   ----------------------------------------------------------------------------- */
  44      =2  
  45      =2  #if !defined(__NMB_CFG_H__)
           =2 #define __NMB_CFG_H__
           =2 
           =2 /* Compatibility with other generation tools */
           =2 #define __NMBASIC_CFG_H__
           =2 /* Version */
           =2 #define NM_BASICDLL_VERSION                  0x0104
           =2 #define NM_BASICDLL_RELEASE_VERSION          0x00
           =2 #define cNmBasicNrOfChannels                 1
           =2 /* Nm instance properties */
           =2 #define NM_TYPE_BASIC
           =2 /* Options */
           =2 #define NMBASIC_ENABLE_SOFTWARE_CHECK
           =2 #define NMBASIC_BUSOFF_RECOV_EXTENDED
           =2 #define NMBASIC_DISABLE_BUSOFFREP_TIMER
           =2 #define NMBASIC_ENABLE_BUSOFFREP_MSG
           =2 /* Support for indexed NM */
           =2 #define NMBASIC_DISABLE_INDEXED_NM
           =2 #define NMBASIC_DISABLE_TX_OBSERVATION
           =2 #define NMBASIC_DISABLE_EXTERNAL_CANONLINE_HANDLING
           =2 #define NMBASIC_DISABLE_EARLY_BUSOFF_REINIT
           =2 #define NMBASIC_DISABLE_SET_CONTEXT
           =2 #define NMBASIC_DISABLE_GET_CONTEXT
           =2 /* Nm channel properties */
           =2 #define cNmBasicInitObject                   0
           =2 #define cNmBasicTaskPeriod                   10
           =2 #define cNmBasicBusOffRecTime                50
           =2 #define cNmBasicBusOffRecTimeSlow            100
           =2 #define cNmBasicBusOffChangeFastToSlow       500
           =2 #define cNmBasicBusOffRepairedTime           2000
           =2 
           =2 /* begin Fileversion check */
           =2 #ifndef SKIP_MAGIC_NUMBER
           =2 #ifdef MAGIC_NUMBER
           =2   #if MAGIC_NUMBER != 204819919
           =2       #error "The magic number of the generated file <Y:\CANGEN\nmb_cfg.h> is different. Please check time
             - and date of generated files!"
           =2   #endif
           =2 #else
           =2   #define MAGIC_NUMBER 204819919
           =2 #endif  /* MAGIC_NUMBER */
           =2 #endif  /* SKIP_MAGIC_NUMBER */
           =2 
           =2 /* end Fileversion check */
           =2 
           =2 #endif /* __NMB_CFG_H__ */
 103      =1  
 104      =1  /***************************************************************************
 105      =1  * defines
 106      =1  ****************************************************************************/
 107      =1  /* node management version */
 108      =1  /* ##V_CFG_MANAGEMENT ##CQProject : Nm_PwrTrainBasic CQComponent : Implementation */
 109      =1  #define NM_PWRTRAINBASIC_VERSION 0x0115
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 343 

 110      =1  #define NM_PWRTRAINBASIC_RELEASE_VERSION 0x06
 111      =1  
 112      =1  #define NM_TYPE_NMBASIC
 113      =1  
 114      =1  /* NM states */
 115      =1  #define NMBASIC_STATE_POWER_OFF      0x00
 116      =1  #define NMBASIC_STATE_TX_ERROR       0x01 /* ESCAN00019119 */
 117      =1  #define NMBASIC_STATE_STOP           0x02
 118      =1  #define NMBASIC_STATE_RUN            0x03
 119      =1  #define NMBASIC_STATE_BUSOFF         0x04
 120      =1  
 121      =1  /* different handling of channel parameter in prototypes and funcion calls */
 122      =1  /* used for NM and CAN Driver functions */
 123      =1  #if defined ( NMBASIC_ENABLE_INDEXED_NM )
           =1 # if defined ( C_MULTIPLE_RECEIVE_CHANNEL )
           =1 #  define NMBASIC_CHANNEL_NMTYPE_ONLY     CanChannelHandle channel
           =1 #  define NMBASIC_CHANNEL_NMTYPE_FIRST    CanChannelHandle channel,
           =1 #  define NMBASIC_CHANNEL_NMPARA_ONLY     channel
           =1 #  define NMBASIC_CHANNEL_NMPARA_FIRST    channel,
           =1 
           =1 #  if defined ( NMBASIC_ENABLE_CHANNEL_INDIRECTION )
           =1 #   define NMBASIC_CHANNEL_CANTYPE_ONLY  CanChannelHandle channel
           =1 #   define NMBASIC_CHANNEL_CANTYPE_FIRST CanChannelHandle channel,
           =1 #   define NMBASIC_CHANNEL_CANPARA_ONLY  NmBasicNmToCanIndirection[channel]
           =1 #   define NMBASIC_CHANNEL_CANPARA_FIRST NmBasicNmToCanIndirection[channel],
           =1 #  else
           =1 #   define NMBASIC_CHANNEL_CANTYPE_ONLY  NMBASIC_CHANNEL_NMTYPE_ONLY
           =1 #   define NMBASIC_CHANNEL_CANTYPE_FIRST NMBASIC_CHANNEL_NMTYPE_FIRST
           =1 #   define NMBASIC_CHANNEL_CANPARA_ONLY  NMBASIC_CHANNEL_NMPARA_ONLY
           =1 #   define NMBASIC_CHANNEL_CANPARA_FIRST NMBASIC_CHANNEL_NMPARA_FIRST
           =1 #  endif
           =1 
           =1 #  define NMBASIC_CHANNEL_APPLTYPE_ONLY   NMBASIC_CHANNEL_NMTYPE_ONLY
           =1 #  define NMBASIC_CHANNEL_APPLTYPE_FIRST  NMBASIC_CHANNEL_NMTYPE_FIRST
           =1 #  define NMBASIC_CHANNEL_APPLPARA_ONLY   NMBASIC_CHANNEL_CANPARA_ONLY
           =1 #  define NMBASIC_CHANNEL_APPLPARA_FIRST  NMBASIC_CHANNEL_CANPARA_FIRST
           =1 # else
           =1 #  error "Configuration error in NMBASIC: NM indexed on driver without C_MULTIPLE_RECEIVE_CHANNEL not poss
             -ible!"
           =1 # endif
           =1 #else  /* NMBASIC_ENABLE_INDEXED_NM */
 150      =1  # define NMBASIC_CHANNEL_NMTYPE_ONLY         void
 151      =1  # define NMBASIC_CHANNEL_NMTYPE_FIRST
 152      =1  # define NMBASIC_CHANNEL_NMPARA_ONLY    
 153      =1  # define NMBASIC_CHANNEL_NMPARA_FIRST
 154      =1  
 155      =1  # if defined ( C_MULTIPLE_RECEIVE_CHANNEL )
           =1 #  define NMBASIC_CHANNEL_CANTYPE_ONLY      CanChannelHandle channel
           =1 #  define NMBASIC_CHANNEL_CANTYPE_FIRST     CanChannelHandle channel,
           =1 
           =1 #  if defined ( NMBASIC_CAN_CHANNEL )
           =1 #   define NMBASIC_CHANNEL_CANPARA_ONLY    NMBASIC_CAN_CHANNEL
           =1 #   define NMBASIC_CHANNEL_CANPARA_FIRST   NMBASIC_CAN_CHANNEL,
           =1 #  else
           =1 #   if ( cNmBasicNrOfChannels > 1 )
           =1 #    error "Configuration error in NMBASIC: NM non indexed on more than one channels with C_MULTIPLE_RECEI
             -VE_CHANNEL not possible!"
           =1 #   else
           =1 #    define NMBASIC_CHANNEL_CANPARA_ONLY  0
           =1 #    define NMBASIC_CHANNEL_CANPARA_FIRST 0,
           =1 #   endif
           =1 #  endif
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 344 

           =1 # else
 171      =1  #  define NMBASIC_CHANNEL_CANTYPE_ONLY      NMBASIC_CHANNEL_NMTYPE_ONLY
 172      =1  #  define NMBASIC_CHANNEL_CANTYPE_FIRST     NMBASIC_CHANNEL_NMTYPE_FIRST
 173      =1  #  define NMBASIC_CHANNEL_CANPARA_ONLY      NMBASIC_CHANNEL_NMPARA_ONLY
 174      =1  #  define NMBASIC_CHANNEL_CANPARA_FIRST     NMBASIC_CHANNEL_NMPARA_FIRST
 175      =1  # endif
 176      =1  
 177      =1  # define NMBASIC_CHANNEL_APPLTYPE_ONLY       NMBASIC_CHANNEL_NMTYPE_ONLY
 178      =1  # define NMBASIC_CHANNEL_APPLTYPE_FIRST      NMBASIC_CHANNEL_NMTYPE_FIRST
 179      =1  # define NMBASIC_CHANNEL_APPLPARA_ONLY
 180      =1  # define NMBASIC_CHANNEL_APPLPARA_FIRST
 181      =1  #endif  /* NMBASIC_ENABLE_INDEXED_NM */
 182      =1  
 183      =1  #if defined ( NMBASIC_ENABLE_INDEXED_NM )
           =1 # define NMBASICVAR_CH_DEF(var)               var[cNmBasicNrOfChannels] /* PRQA S 3410 */ 
           =1 # define NMBASICVAR(var)                      var[channel]              /* PRQA S 3410 */ 
           =1 #else
 187      =1  # define NMBASICVAR_CH_DEF(var)               var /* PRQA S 3410 */ 
 188      =1  # define NMBASICVAR(var)                      var /* PRQA S 3410 */ 
 189      =1  #endif
 190      =1  
 191      =1  
 192      =1  /***************************************************************************/
 193      =1  /* error codes for ApplNmBasicFatalError                                   */
 194      =1  /***************************************************************************/
 195      =1  /* error codes to check generated tables */
 196      =1  /* There are gaps in the assertion numbering. These gaps belong to former assertions which were deleted me
             -anwhile. */
 197      =1  #if (defined NMBASIC_ENABLE_SOFTWARE_CHECK)
 198      =1  # define kNmBasicErrStateUndefined                 0x01 /* an undefined state is detected in the NM state 
             -machine */
 199      =1  
 200      =1  /* ESCAN00012097 */
 201      =1  # define kNmBasicErrInitObjOutOfRange              0x02 /* the initialization object is out of range */
 202      =1  
 203      =1  # if( defined(NMBASIC_BUSOFF_RECOV_DELAYED) || defined(NMBASIC_BUSOFF_RECOV_EXTENDED) )
 204      =1  #  define kNmBasicErrBusOffFastTimeOutOfRange       0x03 /* the fast BusOff recovery time is out of range 
             -*/
 205      =1  # endif
 206      =1  
 207      =1  # if defined(NMBASIC_BUSOFF_RECOV_EXTENDED)
 208      =1  #  define kNmBasicErrBusOffSlowTimeOutOfRange       0x04 /* the slow BusOff recovery time is out of range 
             -*/
 209      =1  #  define kNmBasicErrBusOffFastSlowTimeOutOfRange   0x05 /* the change-from-fast-to-slow BusOff recovery t
             -ime is out of range */
 210      =1  #  define kNmBasicErrFastLargerSlowTime             0x06
 211      =1  #  if defined(NMBASIC_ENABLE_BUSOFFREP_TIMER)
           =1 #   define kNmBasicErrBusOffRepTimeOutOfRange        0x07 /* the BusOff repaired time is out of range */
           =1 #   define kNmBasicErrBusOffRepairTimeTooSmall       0x08 /* the fast BusOff repaired time is too small */
           =1 #  endif
 215      =1  # endif
 216      =1  
 217      =1  
 218      =1  
 219      =1  # define kNmBasicErrWrongChannelHandle             0x0D /* NM Basic API is called for a CAN channel which 
             -does not belong to the current identity */
 220      =1  #endif
 221      =1  
 222      =1  
 223      =1  /*********************************************************************************************************
             -*************
 224      =1    Global typedefs
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 345 

 225      =1  **********************************************************************************************************
             -************/
 226      =1  /* ESCAN00031155 */
 227      =1  
 228      =1  
 229      =1  /***************************************************************************/
 230      =1  /* External Data                                                           */
 231      =1  /***************************************************************************/
 232      =1  /* ROM constants for version control */
 233      =1  V_MEMROM0 extern V_MEMROM1 vuint8 V_MEMROM2 kNmBasicMainVersion;
 234      =1  V_MEMROM0 extern V_MEMROM1 vuint8 V_MEMROM2 kNmBasicSubVersion;
 235      =1  V_MEMROM0 extern V_MEMROM1 vuint8 V_MEMROM2 kNmBasicReleaseVersion;
 236      =1  
 237      =1  /* ROM tables for multi NM channel systems */
 238      =1  #if defined ( NMBASIC_ENABLE_CHANNEL_INDIRECTION )  /* ESCAN00012670 */
           =1 /* channel indirection */
           =1 extern V_MEMROM0 V_MEMROM1 CanChannelHandle V_MEMROM2 NmBasicCanToNmIndirection[kCanNumberOfChannels];
           =1 extern V_MEMROM0 V_MEMROM1 CanChannelHandle V_MEMROM2 NmBasicNmToCanIndirection[cNmBasicNrOfChannels];
           =1 #endif
 243      =1  
 244      =1  #if( defined NMBASIC_ENABLE_INDEXED_NM )
           =1 /* field of init objects */
           =1 extern V_MEMROM0 V_MEMROM1 vuint8 V_MEMROM2 NmBasicCanInitObject_Field[cNmBasicNrOfChannels];
           =1 
           =1 /* field of task cyles */
           =1 extern V_MEMROM0 V_MEMROM1 vuint8 V_MEMROM2 NmBasicTaskPeriod_Field[cNmBasicNrOfChannels];
           =1 
           =1 # if( defined(NMBASIC_BUSOFF_RECOV_DELAYED) || defined(NMBASIC_BUSOFF_RECOV_EXTENDED) || defined(NMBASIC_B
             -USOFF_RECOV_TIME_SUPERVISED) )/* ESCAN00017908 */
           =1 /* time distance between HW BusOff event and SW BusOff recovery */
           =1 extern V_MEMROM0 V_MEMROM1 vuint16 V_MEMROM2 NmBasicBusOffRecTime_Field[cNmBasicNrOfChannels];
           =1 # endif
           =1 
           =1 # if defined(NMBASIC_BUSOFF_RECOV_EXTENDED)
           =1 /* time distance between HW BusOff event and SW BusOff recovery for slow recovery */
           =1 extern V_MEMROM0 V_MEMROM1 vuint16 V_MEMROM2 NmBasicBusOffRecTimeSlow_Field[cNmBasicNrOfChannels];
           =1 
           =1 /* time distance between first fast and first slow BusOff recovery */
           =1 extern V_MEMROM0 V_MEMROM1 vuint16 V_MEMROM2 NmBasicBusOffFastToSlow_Field[cNmBasicNrOfChannels];
           =1 # endif
           =1 
           =1 # if defined(NMBASIC_ENABLE_BUSOFFREP_TIMER)
           =1 /* time distance between detected BusOff event and a detection of BusOff repaired */
           =1 extern V_MEMROM0 V_MEMROM1 vuint16 V_MEMROM2 NmBasicBusOffRepairedTime_Field[cNmBasicNrOfChannels];
           =1 # endif
           =1 
           =1 #endif
 270      =1  
 271      =1  
 272      =1  /***************************************************************************
 273      =1  * service function prototypes
 274      =1  ****************************************************************************/
 275      =1  extern void NmBasicInitPowerOn(void);
 276      =1  extern void NmBasicInit(NMBASIC_CHANNEL_NMTYPE_ONLY);
 277      =1  extern void NmBasicTask(NMBASIC_CHANNEL_NMTYPE_ONLY);
 278      =1  extern void NmBasicStart(NMBASIC_CHANNEL_NMTYPE_ONLY);
 279      =1  extern void NmBasicStop(NMBASIC_CHANNEL_NMTYPE_ONLY);
 280      =1  extern void NmBasicCanBusOff(NMBASIC_CHANNEL_CANTYPE_ONLY);
 281      =1  extern vuint8 NmBasicGetNetState(NMBASIC_CHANNEL_NMTYPE_ONLY);
 282      =1  
 283      =1  
 284      =1  
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 346 

 285      =1  
 286      =1  /***************************************************************************
 287      =1  * callback function prototypes
 288      =1  ****************************************************************************/
 289      =1  extern void ApplNmBasicBusOffStart(NMBASIC_CHANNEL_APPLTYPE_ONLY);
 290      =1  extern void ApplNmBasicBusOffEnd(NMBASIC_CHANNEL_APPLTYPE_ONLY);
 291      =1  
 292      =1  #if (defined NMBASIC_BUSOFF_RECOV_EXTENDED)
 293      =1  extern void ApplNmBasicFirstBusOffSlow(NMBASIC_CHANNEL_APPLTYPE_ONLY);
 294      =1  extern void ApplNmBasicBusOffRestart(NMBASIC_CHANNEL_APPLTYPE_ONLY);
 295      =1  #endif
 296      =1  
 297      =1  
 298      =1  
 299      =1  extern void ApplNmBasicEnabledCom(NMBASIC_CHANNEL_APPLTYPE_ONLY);
 300      =1  extern void ApplNmBasicSwitchTransceiverOn(NMBASIC_CHANNEL_APPLTYPE_ONLY);
 301      =1  
 302      =1  extern void ApplNmBasicDisabledCom(NMBASIC_CHANNEL_APPLTYPE_ONLY);
 303      =1  extern vuint8 ApplNmBasicSwitchTransceiverOff(NMBASIC_CHANNEL_APPLTYPE_ONLY);
 304      =1  
 305      =1  #if (defined NMBASIC_ENABLE_SOFTWARE_CHECK)
 306      =1  # if( defined (C_MULTIPLE_RECEIVE_CHANNEL) && defined (NMBASIC_ENABLE_INDEXED_NM) )
           =1 extern void ApplNmBasicFatalError(NMBASIC_CHANNEL_APPLTYPE_FIRST vuint8 error);
           =1 # else
 309      =1  extern void ApplNmBasicFatalError(vuint8 error);
 310      =1  # endif
 311      =1  #endif
 312      =1  
 313      =1  /* ESCAN00031157 */
 314      =1  
 315      =1  #endif  /* NMBASIC_IMPL_H */
  21          #include "il_inc.h"
   1      =1  /* Kernbauer Version: 1.14 Konfiguration: Il_Vector Erzeugungsgangnummer: 138 */
   2      =1  
   3      =1  /* STARTSINGLE_OF_MULTIPLE */
   4      =1  /* KB begin Il_Vector_HeaderText */
   5      =1  /* KB end Il_Vector_HeaderText */
   6      =1  /*********************************************************************************************************
             -*************
   7      =1    COPYRIGHT
   8      =1  ----------------------------------------------------------------------------------------------------------
             --------------
   9      =1    \par      copyright
  10      =1    \verbatim
  11      =1    Copyright (c) 2000-2012 by Vector Informatik GmbH. All rights reserved.
  12      =1   
  13      =1                  This software is copyright protected and proprietary to Vector Informatik GmbH.
  14      =1                  Vector Informatik GmbH grants to you only those rights as set out in the license condition
             -s.
  15      =1                  All other rights remain with Vector Informatik GmbH.
  16      =1    \endverbatim
  17      =1  ----------------------------------------------------------------------------------------------------------
             --------------
  18      =1    FILE DESCRIPTION
  19      =1  ----------------------------------------------------------------------------------------------------------
             --------------
  20      =1    \file  File:  Il_Inc.h
  21      =1        Project:  Il_Vector
  22      =1         Module:  -
  23      =1      Generator:  -
  24      =1  
  25      =1    \brief Description:  Vector Interaction Layer include header file
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 347 

  26      =1  **********************************************************************************************************
             -************/
  27      =1  
  28      =1  /*********************************************************************************************************
             -*************
  29      =1    AUTHOR IDENTITY
  30      =1  ----------------------------------------------------------------------------------------------------------
             --------------
  31      =1    Name                          Initials      Company
  32      =1  ----------------------------------------------------------------------------------------------------------
             --------------
  33      =1    Heike Honert                  Ht            Vector Informatik GmbH
  34      =1    Georg Pfluegel                Pl            Vector Informatik GmbH
  35      =1    Armin Happel                  Hp            Vector Informatik GmbH
  36      =1    Gunnar Meiss                  Ms            Vector Informatik GmbH
  37      =1    Ralf Fritz                    Fz            Vector Informatik GmbH
  38      =1    Patrick Markl                 Ml            Vector Informatik GmbH
  39      =1    Sebastian Waldvogel           Swa           Vector Informatik GmbH
  40      =1    Heiko Huebler                 Hho           Vector Informatik GmbH
  41      =1  ----------------------------------------------------------------------------------------------------------
             --------------
  42      =1    REVISION HISTORY
  43      =1  ----------------------------------------------------------------------------------------------------------
             --------------
  44      =1    Version   Date        Author  Change Id     Description
  45      =1  ----------------------------------------------------------------------------------------------------------
             --------------
  46      =1    01.00.00  2001-04-18  Ht                    Creation
  47      =1    01.01.00  2002-05-15  Pl                    add STARTSINGLE_OF_MULTIPLE and STOPSINGLE_OF_MULTIPLE
  48      =1    01.02.00  2002-08-16  Ht                    avoid multiple include
  49      =1    01.03.00  2003-07-18  Hp                    Include NM-Header for certain OEM's only.
  50      =1    01.04.00  2004-08-18  Ms      ESCAN00009633 Naming Conventions
  51      =1    01.05.00  2005-05-09  Ms      ESCAN00008746 Geny Compatibility
  52      =1    01.06.00  2005-11-17  Ms      ESCAN00013712 added AUTOSAR Pdu Interface
  53      =1    01.07.00  2006-04-10  Ms      ESCAN00016017 Add include for Il_Ni
  54      =1    01.08.00  2007-03-30  Fz      ESCAN00020135 GM-Only: Include file added
  55      =1    05.00.00  2008-01-10  Ms      ESCAN00023206 Split Oem Extensions
  56      =1                          Ms      ESCAN00023270 No changes here
  57      =1                          Ms      ESCAN00023300 No changes here
  58      =1                          Ms      ESCAN00023284 No changes here
  59      =1                          Ms      ESCAN00023821 No changes here
  60      =1                          Ms      ESCAN00023822 GM-Only: No changes here
  61      =1    05.01.00  2008-01-25  Ms      ESCAN00023109 PSA-Only: No changes here
  62      =1    05.02.00  2008-04-21  Ms      ESCAN00026301 No changes here
  63      =1              2008-07-17  Ms      ESCAN00025002 No changes here
  64      =1                          Ms      ESCAN00028780 No changes here
  65      =1                          Ms      ESCAN00025178 No changes here
  66      =1                          Ms      ESCAN00013854 No changes here
  67      =1    05.02.01  2008-10-17  Ms      ESCAN00029307 No changes here
  68      =1                          Ms      ESCAN00030750 No changes here
  69      =1    05.02.02  2009-08-28  Ml      ESCAN00037350 No changes here
  70      =1    05.03.00  2009-11-19  Swa     ESCAN00039257 No changes here
  71      =1                          Swa     ESCAN00039071 No changes here
  72      =1                          Swa     ESCAN00039274 No changes here
  73      =1              2010-04-20  Swa     ESCAN00042420 No changes here
  74      =1    05.04.00  2010-06-14  Swa     ESCAN00043305 No changes here
  75      =1              2010-06-28  Ms      ESCAN00042424 No changes here
  76      =1    05.05.00  2010-10-27  Ms      ESCAN00046426 No changes here
  77      =1    05.06.00  2011-06-28  Ms      ESCAN00051034 No changes here
  78      =1    05.06.01  2011-07-14  Ms      ESCAN00052200 No changes here
  79      =1    05.06.02  2012-02-06  Ms      ESCAN00056637 No changes here
  80      =1    05.07.00  2012-01-30  Hho     ESCAN00059505 Support Update Bits (Signal status information)
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 348 

  81      =1              2012-03-21  Hho     ESCAN00057706 Improve Misra compliance
  82      =1    05.07.01  2012-06-26  Ms      ESCAN00059650 The version defines and constants are not 5.07.00
  83      =1    05.07.02  2012-10-08  Hho     ESCAN00060945 No changes here
  84      =1    05.08.00  2012-11-05  Hho     ESCAN00062550 No changes here
  85      =1  **********************************************************************************************************
             -************/
  86      =1  /*********************************************************************************************************
             -*************
  87      =1   * MISRA / PCLINT JUSTIFICATION
  88      =1   *********************************************************************************************************
             -************/
  89      =1   /* *INDENT-OFF* */
  90      =1  /* PRQA S 3460 EOF */ /**/
  91      =1  /* PRQA S 3410 EOF */ /**/
  92      =1  /* PRQA S 0818 EOF */ /**/
  93      =1  /* PRQA S 3412 EOF */ /**/
  94      =1  /* PRQA S 0883 EOF */ /**/
  95      =1  /* *INDENT-ON* */
  96      =1  
  97      =1  #if !defined ( V_IL_INC_COMPONENT_HEADER )
  98      =1  # define V_IL_INC_COMPONENT_HEADER
  99      =1  
 100      =1  
 101      =1  
 102      =1  
 103      =1  /*********************************************************************************************************
             -*************
 104      =1    INCLUDES
 105      =1  **********************************************************************************************************
             -************/
 106      =1  
 107      =1  #  include "v_cfg.h"            /* Generated file...... */
   1      =2  /* -----------------------------------------------------------------------------
   2      =2    Filename:    v_cfg.h
   3      =2    Description: Toolversion: 05.00.51.01.30.02.86.01.00.00
   4      =2                 
   5      =2                 Serial Number: CBD1300286
   6      =2                 Customer Info: Hyundai Mobis Co., Ltd.
   7      =2                                Package: CBD Hmc SLP5 - CBD License f. HKMC
   8      =2                                Micro: C8051F582
   9      =2                                Compiler: Keil PK51
  10      =2                 
  11      =2                 
  12      =2                 Generator Fwk   : GENy 
  13      =2                 Generator Module: GenTool_GenyVcfgNameDecorator
  14      =2                 
  15      =2                 Configuration   : Y:\20150903_DiagCam_DE.gny
  16      =2                 
  17      =2                 ECU: 
  18      =2                         TargetSystem: Hw_Slc8051Cpu
  19      =2                         Compiler:     KEIL
  20      =2                         Derivates:    C8051F58x_59x
  21      =2                 
  22      =2                 Channel "Channel0":
  23      =2                         Databasefile: Y:\20150206_JF_DiagCamera_CAN_DB_R6(LangInfo).dbc
  24      =2                         Bussystem:    CAN
  25      =2                         Manufacturer: HMC
  26      =2                         Node:         PGS
  27      =2  
  28      =2    Generated by , 2015-10-19  18:50:07
  29      =2   ----------------------------------------------------------------------------- */
  30      =2  /* -----------------------------------------------------------------------------
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 349 

  31      =2    C O P Y R I G H T
  32      =2   -------------------------------------------------------------------------------
  33      =2    Copyright (c) 2001-2011 by Vector Informatik GmbH. All rights reserved.
  34      =2   
  35      =2    This software is copyright protected and proprietary to Vector Informatik 
  36      =2    GmbH.
  37      =2    
  38      =2    Vector Informatik GmbH grants to you only those rights as set out in the 
  39      =2    license conditions.
  40      =2    
  41      =2    All other rights remain with Vector Informatik GmbH.
  42      =2   -------------------------------------------------------------------------------
  43      =2   ----------------------------------------------------------------------------- */
  44      =2  
  45      =2  #if !defined(__V_CFG_H__)
           =2 #define __V_CFG_H__
           =2 
           =2 #ifndef VGEN_GENY
           =2 #define VGEN_GENY
           =2 #endif
           =2 
           =2 #ifndef GENy
           =2 #define GENy
           =2 #endif
           =2 
           =2 #ifndef SUPPLIER_CANBEDDED
           =2 #define SUPPLIER_CANBEDDED                   30
           =2 #endif
           =2 
           =2 /* -----------------------------------------------------------------------------
           =2     &&&~ Version
           =2  ----------------------------------------------------------------------------- */
           =2 
           =2 #ifndef VERSIONNUMBER
           =2 #define VERSIONNUMBER                        0x178
           =2 #endif
           =2 
           =2 
           =2 
           =2 /* -----------------------------------------------------------------------------
           =2     &&&~ General Switches
           =2  ----------------------------------------------------------------------------- */
           =2 
           =2 #ifndef V_OSTYPE_NONE
           =2 #define V_OSTYPE_NONE
           =2 #endif
           =2 
           =2 
           =2 
           =2 /* -----------------------------------------------------------------------------
           =2     &&&~ Processor specific
           =2  ----------------------------------------------------------------------------- */
           =2 
           =2 #ifndef C_CPUTYPE_8BIT
           =2 #define C_CPUTYPE_8BIT
           =2 #endif
           =2 
           =2 
           =2 #ifndef V_CPUTYPE_BITARRAY_16BIT
           =2 #define V_CPUTYPE_BITARRAY_16BIT
           =2 #endif
           =2 
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 350 

           =2 
           =2 #ifndef C_CPUTYPE_BIGENDIAN
           =2 #define C_CPUTYPE_BIGENDIAN
           =2 #endif
           =2 
           =2 
           =2 #ifndef C_CPUTYPE_BITORDER_LSB2MSB
           =2 #define C_CPUTYPE_BITORDER_LSB2MSB
           =2 #endif
           =2 
           =2 
           =2 #ifndef V_DISABLE_USE_DUMMY_FUNCTIONS
           =2 #define V_DISABLE_USE_DUMMY_FUNCTIONS
           =2 #endif
           =2 
           =2 
           =2 #ifndef V_ENABLE_USE_DUMMY_STATEMENT
           =2 #define V_ENABLE_USE_DUMMY_STATEMENT
           =2 #endif
           =2 
           =2 
           =2 #ifndef C_COMP_KEIL_SLC8051_CCAN
           =2 #define C_COMP_KEIL_SLC8051_CCAN
           =2 #endif
           =2 
           =2 
           =2 #ifndef V_CPU_SLC8051
           =2 #define V_CPU_SLC8051
           =2 #endif
           =2 
           =2 #ifndef V_COMP_KEIL
           =2 #define V_COMP_KEIL
           =2 #endif
           =2 
           =2 #ifndef V_COMP_KEIL_SLC8051
           =2 #define V_COMP_KEIL_SLC8051
           =2 #endif
           =2 
           =2 #ifndef V_PROCESSOR_C8051F58X_59X
           =2 #define V_PROCESSOR_C8051F58X_59X
           =2 #endif
           =2 
           =2 
           =2 #ifndef C_PROCESSOR_C8051F58X_59X
           =2 #define C_PROCESSOR_C8051F58X_59X
           =2 #endif
           =2 
           =2 
           =2 
           =2 
           =2 /* -----------------------------------------------------------------------------
           =2     &&&~ Used Modules
           =2  ----------------------------------------------------------------------------- */
           =2 
           =2 #define VGEN_ENABLE_DIAG_CANDESC_UDS
           =2 #ifndef VGEN_ENABLE_VSTDLIB
           =2 #define VGEN_ENABLE_VSTDLIB
           =2 #endif
           =2 
           =2 #ifndef VSTD_ENABLE_DEFAULT_INTCTRL
           =2 #define VSTD_ENABLE_DEFAULT_INTCTRL
           =2 #endif
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 351 

           =2 
           =2 #ifndef VSTD_ENABLE_GLOBAL_LOCK
           =2 #define VSTD_ENABLE_GLOBAL_LOCK
           =2 #endif
           =2 
           =2 #ifndef VSTD_DISABLE_DEBUG_SUPPORT
           =2 #define VSTD_DISABLE_DEBUG_SUPPORT
           =2 #endif
           =2 
           =2 #ifndef VSTD_ENABLE_LIBRARY_FUNCTIONS
           =2 #define VSTD_ENABLE_LIBRARY_FUNCTIONS
           =2 #endif
           =2 
           =2 
           =2 #define VGEN_ENABLE_CAN_DRV
           =2 #define C_ENABLE_CAN_CHANNELS
           =2 #define V_BUSTYPE_CAN
           =2 #define VGEN_ENABLE_IL_VECTOR
           =2 #define VGEN_ENABLE_NM_BASIC
           =2 #define VGEN_ENABLE_TP_ISO_MC
           =2 
           =2 
           =2 #ifndef kVNumberOfIdentities
           =2 #define kVNumberOfIdentities                 1
           =2 #endif
           =2 
           =2 #ifndef tVIdentityMsk
           =2 #define tVIdentityMsk                        vuint8
           =2 #endif
           =2 
           =2 #ifndef kVIdentityIdentity_0
           =2 #define kVIdentityIdentity_0                 (vuint8) 0
           =2 #endif
           =2 
           =2 #ifndef VSetActiveIdentity
           =2 #define VSetActiveIdentity(identityLog)
           =2 #endif
           =2 
           =2 #ifndef V_ACTIVE_IDENTITY_MSK
           =2 #define V_ACTIVE_IDENTITY_MSK                1
           =2 #endif
           =2 
           =2 #ifndef V_ACTIVE_IDENTITY_LOG
           =2 #define V_ACTIVE_IDENTITY_LOG                0
           =2 #endif
           =2 
           =2 
           =2 #define DIAG_API_CALL_TYPE
           =2 #define DIAG_API_CALLBACK_TYPE
           =2 #define DIAG_INTERNAL_CALL_TYPE
           =2 #define DRV_API_CALL_TYPE
           =2 #define DRV_API_CALLBACK_TYPE
           =2 #define TP_API_CALL_TYPE
           =2 #define TP_API_CALLBACK_TYPE
           =2 #define TP_INTERNAL_CALL_TYPE
           =2 
           =2 /* -----------------------------------------------------------------------------
           =2     &&&~ Versions of Preconfig Files
           =2  ----------------------------------------------------------------------------- */
           =2 
           =2 #define VGEN_OEM_PRECONFIG_HMC_SLP5
           =2 #define VGEN_OEM_PRECONFIG_VERSION           0x0101
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 352 

           =2 #define VGEN_OEM_PRECONFIG_RELEASE_VERSION   0x00
           =2 #define VGEN_USER_PRECONFIG_HMC_SLP5_HIGH_SPEED
           =2 #define VGEN_USER_PRECONFIG_VERSION          0x0000
           =2 #define VGEN_USER_PRECONFIG_RELEASE_VERSION  0x00
           =2 
           =2 
           =2 /* -----------------------------------------------------------------------------
           =2     &&&~ Optimization
           =2  ----------------------------------------------------------------------------- */
           =2 
           =2 #define V_ATOMIC_BIT_ACCESS_IN_BITFIELD      STD_OFF
           =2 #define V_ATOMIC_VARIABLE_ACCESS             16
           =2 
           =2 
           =2 
           =2 #ifndef VGEN_ENABLE_VSTDLIB
           =2 /* Diag_CanDesc requires VSTDLIB */
           =2 #define VGEN_ENABLE_VSTDLIB
           =2 #endif
           =2 
           =2 #ifndef C_CLIENT_HMC
           =2 #define C_CLIENT_HMC
           =2 #endif
           =2 
           =2 #ifndef __PGS__
           =2 #define __PGS__
           =2 #endif
           =2 
           =2 /* -----------------------------------------------------------------------------
           =2     &&&~ Compatibility defines for ComSetCurrentECU
           =2  ----------------------------------------------------------------------------- */
           =2 
           =2 #ifndef kComNumberOfNodes
           =2 #define kComNumberOfNodes                    kVNumberOfIdentities
           =2 #endif
           =2 
           =2 #ifndef ComSetCurrentECU
           =2 #define ComSetCurrentECU                     VSetActiveIdentity
           =2 #endif
           =2 
           =2 #ifndef comMultipleECUCurrent
           =2 #define comMultipleECUCurrent                vActiveIdentityLog
           =2 #endif
           =2 
           =2 
           =2 
           =2 #define C_VERSION_REF_IMPLEMENTATION         0x150
           =2 
           =2 
           =2 #ifndef VGEN_ENABLE_VSTDLIB
           =2 /* DrvCan__baseRi15 requires VSTDLIB */
           =2 #define VGEN_ENABLE_VSTDLIB
           =2 #endif
           =2 
           =2 #ifndef VGEN_ENABLE_VSTDLIB
           =2 #define VGEN_ENABLE_VSTDLIB
           =2 #endif
           =2 
           =2 
           =2 #ifndef VGEN_ENABLE_VSTDLIB
           =2 /* TpMC requires VSTDLIB */
           =2 #define VGEN_ENABLE_VSTDLIB
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 353 

           =2 #endif
           =2 
           =2 
           =2 
           =2 /* begin Fileversion check */
           =2 #ifndef SKIP_MAGIC_NUMBER
           =2 #ifdef MAGIC_NUMBER
           =2   #if MAGIC_NUMBER != 204819919
           =2       #error "The magic number of the generated file <Y:\CANGEN\v_cfg.h> is different. Please check time a
             -nd date of generated files!"
           =2   #endif
           =2 #else
           =2   #define MAGIC_NUMBER 204819919
           =2 #endif  /* MAGIC_NUMBER */
           =2 #endif  /* SKIP_MAGIC_NUMBER */
           =2 
           =2 /* end Fileversion check */
           =2 
           =2 #endif /* __V_CFG_H__ */
 108      =1  
 109      =1  #  if defined ( VGEN_GENY )
 110      =1  #   include "v_inc.h"           /* Generated file...... */
   1      =2  /* -----------------------------------------------------------------------------
   2      =2    Filename:    v_inc.h
   3      =2    Description: Toolversion: 05.00.51.01.30.02.86.01.00.00
   4      =2                 
   5      =2                 Serial Number: CBD1300286
   6      =2                 Customer Info: Hyundai Mobis Co., Ltd.
   7      =2                                Package: CBD Hmc SLP5 - CBD License f. HKMC
   8      =2                                Micro: C8051F582
   9      =2                                Compiler: Keil PK51
  10      =2                 
  11      =2                 
  12      =2                 Generator Fwk   : GENy 
  13      =2                 Generator Module: GenTool_GenyVcfgNameDecorator
  14      =2                 
  15      =2                 Configuration   : Y:\20150903_DiagCam_DE.gny
  16      =2                 
  17      =2                 ECU: 
  18      =2                         TargetSystem: Hw_Slc8051Cpu
  19      =2                         Compiler:     KEIL
  20      =2                         Derivates:    C8051F58x_59x
  21      =2                 
  22      =2                 Channel "Channel0":
  23      =2                         Databasefile: Y:\20150206_JF_DiagCamera_CAN_DB_R6(LangInfo).dbc
  24      =2                         Bussystem:    CAN
  25      =2                         Manufacturer: HMC
  26      =2                         Node:         PGS
  27      =2  
  28      =2    Generated by , 2015-10-19  18:50:07
  29      =2   ----------------------------------------------------------------------------- */
  30      =2  /* -----------------------------------------------------------------------------
  31      =2    C O P Y R I G H T
  32      =2   -------------------------------------------------------------------------------
  33      =2    Copyright (c) 2001-2011 by Vector Informatik GmbH. All rights reserved.
  34      =2   
  35      =2    This software is copyright protected and proprietary to Vector Informatik 
  36      =2    GmbH.
  37      =2    
  38      =2    Vector Informatik GmbH grants to you only those rights as set out in the 
  39      =2    license conditions.
  40      =2    
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 354 

  41      =2    All other rights remain with Vector Informatik GmbH.
  42      =2   -------------------------------------------------------------------------------
  43      =2   ----------------------------------------------------------------------------- */
  44      =2  
  45      =2  #if !defined(__V_INC_H__)
           =2 #define __V_INC_H__
           =2 
           =2 #include "can_inc.h"
           =2 
           =2 #include "v_cfg.h"
           =2 #include "drv_par.h"
           =2 
           =2 #include "nmb_cfg.h"
           =2 #include "tpmc.h"
           =2 
           =2 #include "v_par.h"
           =2 #include "can_par.h"
           =2 
           =2 /* begin Fileversion check */
           =2 #ifndef SKIP_MAGIC_NUMBER
           =2 #ifdef MAGIC_NUMBER
           =2   #if MAGIC_NUMBER != 204819919
           =2       #error "The magic number of the generated file <Y:\CANGEN\v_inc.h> is different. Please check time a
             -nd date of generated files!"
           =2   #endif
           =2 #else
           =2   #define MAGIC_NUMBER 204819919
           =2 #endif  /* MAGIC_NUMBER */
           =2 #endif  /* SKIP_MAGIC_NUMBER */
           =2 
           =2 /* end Fileversion check */
           =2 
           =2 #endif /* __V_INC_H__ */
 111      =1  #  else
           =1 #   include "can_inc.h"         /* Can driver include file */
           =1 #  endif
 114      =1  
 115      =1  #  include "il_cfg.h"
   1      =2  /* -----------------------------------------------------------------------------
   2      =2    Filename:    il_cfg.h
   3      =2    Description: Toolversion: 05.00.51.01.30.02.86.01.00.00
   4      =2                 
   5      =2                 Serial Number: CBD1300286
   6      =2                 Customer Info: Hyundai Mobis Co., Ltd.
   7      =2                                Package: CBD Hmc SLP5 - CBD License f. HKMC
   8      =2                                Micro: C8051F582
   9      =2                                Compiler: Keil PK51
  10      =2                 
  11      =2                 
  12      =2                 Generator Fwk   : GENy 
  13      =2                 Generator Module: Il_Vector
  14      =2                 
  15      =2                 Configuration   : Y:\20150903_DiagCam_DE.gny
  16      =2                 
  17      =2                 ECU: 
  18      =2                         TargetSystem: Hw_Slc8051Cpu
  19      =2                         Compiler:     KEIL
  20      =2                         Derivates:    C8051F58x_59x
  21      =2                 
  22      =2                 Channel "Channel0":
  23      =2                         Databasefile: Y:\20150206_JF_DiagCamera_CAN_DB_R6(LangInfo).dbc
  24      =2                         Bussystem:    CAN
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 355 

  25      =2                         Manufacturer: HMC
  26      =2                         Node:         PGS
  27      =2  
  28      =2    Generated by , 2015-10-19  18:50:07
  29      =2   ----------------------------------------------------------------------------- */
  30      =2  /* -----------------------------------------------------------------------------
  31      =2    C O P Y R I G H T
  32      =2   -------------------------------------------------------------------------------
  33      =2    Copyright (c) 2001-2011 by Vector Informatik GmbH. All rights reserved.
  34      =2   
  35      =2    This software is copyright protected and proprietary to Vector Informatik 
  36      =2    GmbH.
  37      =2    
  38      =2    Vector Informatik GmbH grants to you only those rights as set out in the 
  39      =2    license conditions.
  40      =2    
  41      =2    All other rights remain with Vector Informatik GmbH.
  42      =2   -------------------------------------------------------------------------------
  43      =2   ----------------------------------------------------------------------------- */
  44      =2  
  45      =2  #if !defined(__IL_CFG_H__)
  46      =2  #define __IL_CFG_H__
  47      =2  
  48      =2  /* -----------------------------------------------------------------------------
  49      =2      &&&~ Version
  50      =2   ----------------------------------------------------------------------------- */
  51      =2  
  52      =2  #define IL_VECTORDLL_VERSION                 0x0116
  53      =2  #define IL_VECTORDLL_RELEASE_VERSION         0x03
  54      =2  #define IL_IMPLEMENTATION_VERSION            0x0202
  55      =2  
  56      =2  
  57      =2  /* -----------------------------------------------------------------------------
  58      =2      &&&~ Switches
  59      =2   ----------------------------------------------------------------------------- */
  60      =2  
  61      =2  #define IL_DISABLE_SYS_INIT_FCT
  62      =2  #define IL_DISABLE_TX
  63      =2  #define IL_DISABLE_SYS_SIGNAL_INIT_FCT
  64      =2  #if defined(IL_ENABLE_TX)
           =2 #define IL_DISABLE_TX_SIGNAL_START_FCT
           =2 #define IL_DISABLE_TX_SIGNAL_STOP_FCT
           =2 #define IL_DISABLE_TX_CONFIRMATION_FLAG
           =2 #define IL_DISABLE_TX_TIMEOUT_FLAG
           =2 #define IL_DISABLE_TX_DEFAULTVALUE
           =2 #define IL_DISABLE_TX_UPDATE_BITS
           =2 #if defined(IL_ENABLE_TX_DEFAULTVALUE)
           =2 #define IL_DISABLE_TX_START_DEFAULTVALUE
           =2 #define IL_DISABLE_TX_STOP_DEFAULTVALUE
           =2 #endif
           =2 
           =2 #define IL_DISABLE_TX_TIMEOUT
           =2 #define IL_DISABLE_TX_SEND_ON_INIT
           =2 #define IL_DISABLE_TX_FAST_ON_START
           =2 #define IL_DISABLE_TX_SECURE_EVENT
           =2 #define IL_DISABLE_TX_CYCLIC_EVENT
           =2 #define IL_DISABLE_TX_POLLING
           =2 #define IL_DISABLE_TX_INTERRUPT
           =2 #define IL_DISABLE_TX_VARYING_TIMEOUT
           =2 #define IL_DISABLE_TX_MODE_SIGNALS
           =2 #endif
  86      =2  
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 356 

  87      =2  #define IL_DISABLE_TX_STARTSTOP_CYCLIC
  88      =2  #define IL_DISABLE_SYS_ARGCHECK
  89      =2  #define IL_ENABLE_SYS_TESTDEBUG
  90      =2  #define IL_ENABLE_RX
  91      =2  #define IL_DISABLE_SYS_TX_START_FCT
  92      =2  #define IL_DISABLE_SYS_TX_STOP_FCT
  93      =2  #define IL_DISABLE_SYS_TX_REPETITIONS_ARE_ACTIVE_FCT
  94      =2  #define IL_DISABLE_SYS_TX_SIGNALS_ARE_ACTIVE_FCT
  95      =2  #define IL_DISABLE_SYS_RX_RESET_TIMEOUT_FLAGS_ON_ILRXRELEASE
  96      =2  #if defined(IL_ENABLE_RX)
  97      =2  #define IL_DISABLE_RX_SIGNAL_START_FCT
  98      =2  #define IL_DISABLE_RX_SIGNAL_STOP_FCT
  99      =2  #define IL_DISABLE_RX_INDICATION_FLAG
 100      =2  #define IL_ENABLE_RX_TIMEOUT_FLAG
 101      =2  #define IL_DISABLE_RX_FIRSTVALUE_FLAG
 102      =2  #define IL_DISABLE_RX_DATACHANGED_FLAG
 103      =2  #define IL_ENABLE_RX_DEFAULTVALUE
 104      =2  #if defined(IL_ENABLE_RX_DEFAULTVALUE)
 105      =2  #define IL_DISABLE_RX_START_DEFAULTVALUE
 106      =2  #define IL_DISABLE_RX_STOP_DEFAULTVALUE
 107      =2  #endif
 108      =2  
 109      =2  #define IL_ENABLE_RX_TIMEOUT
 110      =2  #define IL_DISABLE_RX_POLLING
 111      =2  #define IL_ENABLE_RX_INTERRUPT
 112      =2  #define IL_DISABLE_RX_TIMEOUT_DELAY
 113      =2  #define IL_DISABLE_RX_MODE_SIGNALS
 114      =2  #endif
 115      =2  
 116      =2  #define IL_DISABLE_SYS_RX_START_FCT
 117      =2  #define IL_DISABLE_SYS_RX_STOP_FCT
 118      =2  #define IL_DISABLE_TX_DYNAMIC_CYCLETIME
 119      =2  #define IL_DISABLE_SYS_MULTI_ECU_PHYS
 120      =2  #if defined(IL_ENABLE_TX)
           =2 #define IL_DISABLE_TX_VARYING_REPETITION
           =2 #endif
 123      =2  
 124      =2  #if defined(IL_ENABLE_RX) && defined(IL_ENABLE_RX_TIMEOUT)
 125      =2  #define IL_DISABLE_RX_DYNAMIC_TIMEOUT
 126      =2  #endif
 127      =2  
 128      =2  
 129      =2  
 130      =2  /* -----------------------------------------------------------------------------
 131      =2      &&&~ OEM
 132      =2   ----------------------------------------------------------------------------- */
 133      =2  
 134      =2  #define IL_TYPE_HMC
 135      =2  
 136      =2  
 137      =2  /* -----------------------------------------------------------------------------
 138      =2      &&&~ Constants
 139      =2   ----------------------------------------------------------------------------- */
 140      =2  
 141      =2  #define kIlNumberOfChannels                  1
 142      =2  #define kIlNumberOfTxObjects                 0
 143      =2  #if defined(IL_ENABLE_TX) && defined(IL_ENABLE_TX_TIMEOUT)
           =2 #define kIlNumberOfTxTimeoutCounters         0
           =2 #endif
 146      =2  
 147      =2  #if defined(IL_ENABLE_RX) && defined(IL_ENABLE_RX_TIMEOUT)
 148      =2  #define kIlNumberOfRxTimeoutCounters         6
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 357 

 149      =2  #endif
 150      =2  
 151      =2  #if defined(IL_ENABLE_RX) && defined(IL_ENABLE_RX_TIMEOUT)
 152      =2  #define kIlNoRxTimeoutSupervision            0xFF
 153      =2  #endif
 154      =2  
 155      =2  #if defined(IL_ENABLE_TX) && defined(IL_ENABLE_TX_CONFIRMATION_FLAG)
           =2 #define kIlNumberOfTxConfirmationFlags       0
           =2 #endif
 158      =2  
 159      =2  #if defined(IL_ENABLE_TX) && defined(IL_ENABLE_TX_TIMEOUT_FLAG)
           =2 #define kIlNumberOfTxTimeoutFlags            0
           =2 #endif
 162      =2  
 163      =2  #if defined(IL_ENABLE_RX) && defined(IL_ENABLE_RX_TIMEOUT)
 164      =2  #define kIlNumberOfTimerFlagBytes            1
 165      =2  #endif
 166      =2  
 167      =2  #if defined(IL_ENABLE_TX) && defined(IL_ENABLE_TX_SECURE_EVENT) && defined(IL_DISABLE_TX_VARYING_REPETITIO
             -N)
           =2 #define kIlNumberOfTxRepetitions             0
           =2 #endif
 170      =2  
 171      =2  #define kIlTxCycleTime                       10
 172      =2  #if defined(IL_ENABLE_TX) && defined(IL_ENABLE_TX_TIMEOUT) && defined(IL_DISABLE_TX_VARYING_TIMEOUT)
           =2 #define kIlTxTimeout                         5
           =2 #endif
 175      =2  
 176      =2  #define kIlNumberOfRxObjects                 6
 177      =2  #if defined(IL_ENABLE_RX) && defined(IL_ENABLE_RX_INDICATION_FLAG)
           =2 #define kIlNumberOfRxIndicationFlags         0
           =2 #endif
 180      =2  
 181      =2  #if defined(IL_ENABLE_RX) && defined(IL_ENABLE_RX_TIMEOUT_FLAG)
 182      =2  #define kIlNumberOfRxTimeoutFlags            1
 183      =2  #endif
 184      =2  
 185      =2  #if defined(IL_ENABLE_RX) && defined(IL_ENABLE_RX_FIRSTVALUE_FLAG)
           =2 #define kIlNumberOfRxFirstvalueFlags         0
           =2 #endif
 188      =2  
 189      =2  #if defined(IL_ENABLE_RX) && defined(IL_ENABLE_RX_DATACHANGED_FLAG)
           =2 #define kIlNumberOfRxDataChangedFlags        0
           =2 #endif
 192      =2  
 193      =2  #if defined(IL_ENABLE_RX) && defined(IL_ENABLE_RX_INDICATION_FLAG)
           =2 #define kIlNumberOfRxIndicationBits          0
           =2 #endif
 196      =2  
 197      =2  #define kIlRxCycleTime                       10
 198      =2  #define kIlCanNumberOfRxObjects              6
 199      =2  #define kIlCanNumberOfTxObjects              1
 200      =2  #define kIlNumberOfIdentities                1
 201      =2  
 202      =2  
 203      =2  /* -----------------------------------------------------------------------------
 204      =2      &&&~ Compatiblility
 205      =2   ----------------------------------------------------------------------------- */
 206      =2  
 207      =2  #define kIlNumberOfNodes                     1
 208      =2  
 209      =2  
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 358 

 210      =2  
 211      =2  /* begin Fileversion check */
 212      =2  #ifndef SKIP_MAGIC_NUMBER
 213      =2  #ifdef MAGIC_NUMBER
 214      =2    #if MAGIC_NUMBER != 204819919
           =2       #error "The magic number of the generated file <Y:\CANGEN\il_cfg.h> is different. Please check time 
             -and date of generated files!"
           =2   #endif
 217      =2  #else
           =2   #define MAGIC_NUMBER 204819919
           =2 #endif  /* MAGIC_NUMBER */
 220      =2  #endif  /* SKIP_MAGIC_NUMBER */
 221      =2  
 222      =2  /* end Fileversion check */
 223      =2  
 224      =2  #endif /* __IL_CFG_H__ */
 116      =1  
 117      =1  #  if !defined ( VGEN_GENY )
           =1 #   if defined( C_MULTIPLE_RECEIVE_CHANNEL ) || defined(C_SINGLE_RECEIVE_CHANNEL)
           =1 #    include "DUT.h"            /* Generated file. Name must adapted to the specific Ecu. */
           =1 #   else
           =1 #    include "DUT.h"        /* Generated file. Name must adapted to the specific Ecu. */
           =1 #   endif
           =1 #  endif
 124      =1  
 125      =1  #  if defined ( VGEN_GENY )
 126      =1  #   include "il_par.h"          /* Generated file...... */
   1      =2  /* -----------------------------------------------------------------------------
   2      =2    Filename:    il_par.h
   3      =2    Description: Toolversion: 05.00.51.01.30.02.86.01.00.00
   4      =2                 
   5      =2                 Serial Number: CBD1300286
   6      =2                 Customer Info: Hyundai Mobis Co., Ltd.
   7      =2                                Package: CBD Hmc SLP5 - CBD License f. HKMC
   8      =2                                Micro: C8051F582
   9      =2                                Compiler: Keil PK51
  10      =2                 
  11      =2                 
  12      =2                 Generator Fwk   : GENy 
  13      =2                 Generator Module: Il_Vector
  14      =2                 
  15      =2                 Configuration   : Y:\20150903_DiagCam_DE.gny
  16      =2                 
  17      =2                 ECU: 
  18      =2                         TargetSystem: Hw_Slc8051Cpu
  19      =2                         Compiler:     KEIL
  20      =2                         Derivates:    C8051F58x_59x
  21      =2                 
  22      =2                 Channel "Channel0":
  23      =2                         Databasefile: Y:\20150206_JF_DiagCamera_CAN_DB_R6(LangInfo).dbc
  24      =2                         Bussystem:    CAN
  25      =2                         Manufacturer: HMC
  26      =2                         Node:         PGS
  27      =2  
  28      =2    Generated by , 2015-10-19  18:50:07
  29      =2   ----------------------------------------------------------------------------- */
  30      =2  /* -----------------------------------------------------------------------------
  31      =2    C O P Y R I G H T
  32      =2   -------------------------------------------------------------------------------
  33      =2    Copyright (c) 2001-2011 by Vector Informatik GmbH. All rights reserved.
  34      =2   
  35      =2    This software is copyright protected and proprietary to Vector Informatik 
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 359 

  36      =2    GmbH.
  37      =2    
  38      =2    Vector Informatik GmbH grants to you only those rights as set out in the 
  39      =2    license conditions.
  40      =2    
  41      =2    All other rights remain with Vector Informatik GmbH.
  42      =2   -------------------------------------------------------------------------------
  43      =2   ----------------------------------------------------------------------------- */
  44      =2  
  45      =2  #if !defined(__IL_PAR_H__)
  46      =2  #define __IL_PAR_H__
  47      =2  
  48      =2  /* -----------------------------------------------------------------------------
  49      =2      &&&~ Typedefs
  50      =2   ----------------------------------------------------------------------------- */
  51      =2  
  52      =2  #if defined(IL_ENABLE_TX)
           =2 typedef vuint8 IltTxCounter;
           =2 #endif
  55      =2  
  56      =2  #if defined(IL_ENABLE_TX)
           =2 typedef vuint8 IltTxUpdateCounter;
           =2 #endif
  59      =2  
  60      =2  #if defined(IL_ENABLE_TX) && defined(IL_ENABLE_TX_TIMEOUT)
           =2 typedef vuint8 IltTxTimeoutCounter;
           =2 #endif
  63      =2  
  64      =2  #if defined(IL_ENABLE_RX) && defined(IL_ENABLE_RX_TIMEOUT)
  65      =2  typedef vuint8 IltRxTimeoutCounter;
  66      =2  #endif
  67      =2  
  68      =2  #if defined(IL_ENABLE_TX) && defined(IL_ENABLE_TX_SECURE_EVENT)
           =2 typedef vuint8 IltTxRepetitionCounter;
           =2 #endif
  71      =2  
  72      =2  
  73      =2  
  74      =2  /* -----------------------------------------------------------------------------
  75      =2      &&&~ Message Handles
  76      =2   ----------------------------------------------------------------------------- */
  77      =2  
  78      =2  #define IlRxMsgHndHU_MON_PE_01               0
  79      =2  #define IlRxMsgHndCGW4                       1
  80      =2  #define IlRxMsgHndCGW2                       2
  81      =2  #define IlRxMsgHndCLU15                      3
  82      =2  #define IlRxMsgHndMDPS11                     4
  83      =2  #define IlRxMsgHndSAS1                       5
  84      =2  
  85      =2  
  86      =2  /* -----------------------------------------------------------------------------
  87      =2      &&&~ Signal Handles
  88      =2   ----------------------------------------------------------------------------- */
  89      =2  
  90      =2  #define IlRxSigHndHU_TYPE                    IlRxMsgHndHU_MON_PE_01
  91      =2  #define IlRxSigHndCF_Gway_Navi_On_Off        IlRxMsgHndCGW4
  92      =2  #define IlRxSigHndCF_Gway_CountryCfg         IlRxMsgHndCGW2
  93      =2  #define IlRxSigHndCF_Clu_LanguageInfo        IlRxMsgHndCLU15
  94      =2  #define IlRxSigHndCF_Mdps_Type               IlRxMsgHndMDPS11
  95      =2  #define IlRxSigHndSAS_Angle                  IlRxMsgHndSAS1
  96      =2  
  97      =2  
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 360 

  98      =2  /* -----------------------------------------------------------------------------
  99      =2      &&&~ Critical section macros for signals
 100      =2   ----------------------------------------------------------------------------- */
 101      =2  
 102      =2  #define IlEnterCriticalHU_TYPE()             CanGlobalInterruptDisable()
 103      =2  #define IlLeaveCriticalHU_TYPE()             CanGlobalInterruptRestore()
 104      =2  #define IlEnterCriticalCF_Gway_Navi_On_Off() CanGlobalInterruptDisable()
 105      =2  #define IlLeaveCriticalCF_Gway_Navi_On_Off() CanGlobalInterruptRestore()
 106      =2  #define IlEnterCriticalCF_Gway_CountryCfg()  CanGlobalInterruptDisable()
 107      =2  #define IlLeaveCriticalCF_Gway_CountryCfg()  CanGlobalInterruptRestore()
 108      =2  #define IlEnterCriticalCF_Clu_LanguageInfo() CanGlobalInterruptDisable()
 109      =2  #define IlLeaveCriticalCF_Clu_LanguageInfo() CanGlobalInterruptRestore()
 110      =2  #define IlEnterCriticalCF_Mdps_Type()        CanGlobalInterruptDisable()
 111      =2  #define IlLeaveCriticalCF_Mdps_Type()        CanGlobalInterruptRestore()
 112      =2  #define IlEnterCriticalSAS_Angle()           CanGlobalInterruptDisable()
 113      =2  #define IlLeaveCriticalSAS_Angle()           CanGlobalInterruptRestore()
 114      =2  
 115      =2  
 116      =2  /* -----------------------------------------------------------------------------
 117      =2      &&&~ Access to RxTimeout flags
 118      =2   ----------------------------------------------------------------------------- */
 119      =2  
 120      =2  #define IlGetHU_TYPERxTimeout()              (((vuint8) (ilRxTimeoutFlags[0] & (vuint8) 0x01)) != (vuint8)
             - 0x00)
 121      =2  #define IlGetCF_Gway_Navi_On_OffRxTimeout()  (((vuint8) (ilRxTimeoutFlags[0] & (vuint8) 0x02)) != (vuint8)
             - 0x00)
 122      =2  #define IlGetCF_Gway_CountryCfgRxTimeout()   (((vuint8) (ilRxTimeoutFlags[0] & (vuint8) 0x04)) != (vuint8)
             - 0x00)
 123      =2  #define IlGetCF_Clu_LanguageInfoRxTimeout()  (((vuint8) (ilRxTimeoutFlags[0] & (vuint8) 0x08)) != (vuint8)
             - 0x00)
 124      =2  #define IlGetCF_Mdps_TypeRxTimeout()         (((vuint8) (ilRxTimeoutFlags[0] & (vuint8) 0x10)) != (vuint8)
             - 0x00)
 125      =2  #define IlGetSAS_AngleRxTimeout()            (((vuint8) (ilRxTimeoutFlags[0] & (vuint8) 0x20)) != (vuint8)
             - 0x00)
 126      =2  #define IlSetHU_TYPERxTimeout()              (ilRxTimeoutFlags[0] |= (vuint8) 0x01)
 127      =2  #define IlSetCF_Gway_Navi_On_OffRxTimeout()  (ilRxTimeoutFlags[0] |= (vuint8) 0x02)
 128      =2  #define IlSetCF_Gway_CountryCfgRxTimeout()   (ilRxTimeoutFlags[0] |= (vuint8) 0x04)
 129      =2  #define IlSetCF_Clu_LanguageInfoRxTimeout()  (ilRxTimeoutFlags[0] |= (vuint8) 0x08)
 130      =2  #define IlSetCF_Mdps_TypeRxTimeout()         (ilRxTimeoutFlags[0] |= (vuint8) 0x10)
 131      =2  #define IlSetSAS_AngleRxTimeout()            (ilRxTimeoutFlags[0] |= (vuint8) 0x20)
 132      =2  #define IlClrHU_TYPERxTimeout()              (ilRxTimeoutFlags[0] &= (vuint8) (0xFF & (vuint8) 0xFE))
 133      =2  #define IlClrCF_Gway_Navi_On_OffRxTimeout()  (ilRxTimeoutFlags[0] &= (vuint8) (0xFF & (vuint8) 0xFD))
 134      =2  #define IlClrCF_Gway_CountryCfgRxTimeout()   (ilRxTimeoutFlags[0] &= (vuint8) (0xFF & (vuint8) 0xFB))
 135      =2  #define IlClrCF_Clu_LanguageInfoRxTimeout()  (ilRxTimeoutFlags[0] &= (vuint8) (0xFF & (vuint8) 0xF7))
 136      =2  #define IlClrCF_Mdps_TypeRxTimeout()         (ilRxTimeoutFlags[0] &= (vuint8) (0xFF & (vuint8) 0xEF))
 137      =2  #define IlClrSAS_AngleRxTimeout()            (ilRxTimeoutFlags[0] &= (vuint8) (0xFF & (vuint8) 0xDF))
 138      =2  
 139      =2  
 140      =2  /* -----------------------------------------------------------------------------
 141      =2      &&&~ Declaration Confirmation Functions
 142      =2   ----------------------------------------------------------------------------- */
 143      =2  
 144      =2  /* Application signal confirmation callback functions */
 145      =2  
 146      =2  
 147      =2  /* -----------------------------------------------------------------------------
 148      =2      &&&~ Declaration Indication Functions
 149      =2   ----------------------------------------------------------------------------- */
 150      =2  
 151      =2  /* Application signal indication callback functions */
 152      =2  
 153      =2  
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 361 

 154      =2  /* -----------------------------------------------------------------------------
 155      =2      &&&~ Declaration User Timeout Functions
 156      =2   ----------------------------------------------------------------------------- */
 157      =2  
 158      =2  #if defined(IL_ENABLE_TX) && defined(IL_ENABLE_TX_TIMEOUT)
           =2 #endif
 160      =2  
 161      =2  
 162      =2  
 163      =2  /* -----------------------------------------------------------------------------
 164      =2      &&&~ Get Rx Signal Access for signals smaller or equal 8bit
 165      =2   ----------------------------------------------------------------------------- */
 166      =2  
 167      =2  /* Handle:    0,Name:                        HU_TYPE,Size:  8,UsedBytes:  1,SingleSignal */
 168      =2  #ifdef IL_ENABLE_RX
 169      =2  #define IlGetRxHU_TYPE()                     (HU_MON_PE_01.HU_MON_PE_01.HU_TYPE)
 170      =2  #endif
 171      =2  
 172      =2  /* Handle:    1,Name:            CF_Gway_Navi_On_Off,Size:  1,UsedBytes:  1,SingleSignal */
 173      =2  #ifdef IL_ENABLE_RX
 174      =2  #define IlGetRxCF_Gway_Navi_On_Off()         (CGW4.CGW4.CF_Gway_Navi_On_Off)
 175      =2  #endif
 176      =2  
 177      =2  /* Handle:    2,Name:             CF_Gway_CountryCfg,Size:  3,UsedBytes:  1,SingleSignal */
 178      =2  #ifdef IL_ENABLE_RX
 179      =2  #define IlGetRxCF_Gway_CountryCfg()          (CGW2.CGW2.CF_Gway_CountryCfg)
 180      =2  #endif
 181      =2  
 182      =2  /* Handle:    3,Name:            CF_Clu_LanguageInfo,Size:  5,UsedBytes:  1,SingleSignal */
 183      =2  #ifdef IL_ENABLE_RX
 184      =2  #define IlGetRxCF_Clu_LanguageInfo()         (CLU15.CLU15.CF_Clu_LanguageInfo)
 185      =2  #endif
 186      =2  
 187      =2  /* Handle:    4,Name:                   CF_Mdps_Type,Size:  2,UsedBytes:  1,SingleSignal */
 188      =2  #ifdef IL_ENABLE_RX
 189      =2  #define IlGetRxCF_Mdps_Type()                (MDPS11.MDPS11.CF_Mdps_Type)
 190      =2  #endif
 191      =2  
 192      =2  
 193      =2  
 194      =2  /* -----------------------------------------------------------------------------
 195      =2      &&&~ Get Rx Signal Access for signals greater 8bit and smaller or equal 32bit
 196      =2   ----------------------------------------------------------------------------- */
 197      =2  
 198      =2  /* Handle:    5,Name:                      SAS_Angle,Size: 16,UsedBytes:  2,SingleSignal */
 199      =2  #ifdef IL_ENABLE_RX
 200      =2  extern vuint16 IlGetRxSAS_Angle(void);
 201      =2  #endif
 202      =2  
 203      =2  
 204      =2  
 205      =2  
 206      =2  /* begin Fileversion check */
 207      =2  #ifndef SKIP_MAGIC_NUMBER
 208      =2  #ifdef MAGIC_NUMBER
 209      =2    #if MAGIC_NUMBER != 204819919
           =2       #error "The magic number of the generated file <Y:\CANGEN\il_par.h> is different. Please check time 
             -and date of generated files!"
           =2   #endif
 212      =2  #else
           =2   #define MAGIC_NUMBER 204819919
           =2 #endif  /* MAGIC_NUMBER */
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 362 

 215      =2  #endif  /* SKIP_MAGIC_NUMBER */
 216      =2  
 217      =2  /* end Fileversion check */
 218      =2  
 219      =2  #endif /* __IL_PAR_H__ */
 127      =1  #  else
           =1 #   include "ilpar.h"           /* Generated file...... */
           =1 #  endif
 130      =1  
 131      =1  #  include "il_def.h"           /* Il_Vector definition file. */
   1      =2  /* Kernbauer Version: 1.14 Konfiguration: Il_Vector Erzeugungsgangnummer: 138 */
   2      =2  
   3      =2  /* STARTSINGLE_OF_MULTIPLE */
   4      =2  /* KB begin Il_Vector_HeaderText */
   5      =2  /* KB end Il_Vector_HeaderText */
   6      =2  /*********************************************************************************************************
             -*************
   7      =2    COPYRIGHT
   8      =2  ----------------------------------------------------------------------------------------------------------
             --------------
   9      =2    \par      copyright
  10      =2    \verbatim
  11      =2    Copyright (c) 2000-2012 by Vector Informatik GmbH. All rights reserved.
  12      =2   
  13      =2                  This software is copyright protected and proprietary to Vector Informatik GmbH.
  14      =2                  Vector Informatik GmbH grants to you only those rights as set out in the license condition
             -s.
  15      =2                  All other rights remain with Vector Informatik GmbH.
  16      =2    \endverbatim
  17      =2  ----------------------------------------------------------------------------------------------------------
             --------------
  18      =2    FILE DESCRIPTION
  19      =2  ----------------------------------------------------------------------------------------------------------
             --------------
  20      =2    \file  File:  Il_Def.h
  21      =2        Project:  Il_Vector
  22      =2         Module:  -
  23      =2      Generator:  -
  24      =2  
  25      =2    \brief Description:  Vector Interaction Layer header file
  26      =2  **********************************************************************************************************
             -************/
  27      =2  
  28      =2  /*********************************************************************************************************
             -*************
  29      =2    AUTHOR IDENTITY
  30      =2  ----------------------------------------------------------------------------------------------------------
             --------------
  31      =2    Name                          Initials      Company
  32      =2  ----------------------------------------------------------------------------------------------------------
             --------------
  33      =2    Heike Honert                  Ht            Vector Informatik GmbH
  34      =2    Stephan Hoffmann              Hn            Vector CANtech, Inc.
  35      =2    Armin Happel                  Hp            Vector Informatik GmbH
  36      =2    Gunnar de Haan                dH            Vector Informatik GmbH
  37      =2    Bernd Stumpf                  Stu           Vector Informatik GmbH    
  38      =2    Thomas Ebert                  Et            Vector Informatik GmbH
  39      =2    Werner Ziegler                Zw            Vector Informatik GmbH
  40      =2    Thomas Petrus                 Pet           Vector Informatik GmbH
  41      =2    Ralf Fritz                    Fz            Vector Informatik GmbH
  42      =2    Gunnar Meiss                  Ms            Vector Informatik GmbH
  43      =2    Marc Rauscher                 Mra           Vector Informatik GmbH
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 363 

  44      =2    Frank Triem                   Tri           Vector Informatik GmbH
  45      =2    Todd Emaus                    Tde           Vector CANtech, Inc.
  46      =2    Hartmut Hoerner               Hh            Vector Informatik GmbH
  47      =2    Patrick Markl                 Ml            Vector Informatik GmbH
  48      =2    Sebastian Waldvogel           Swa           Vector Informatik GmbH
  49      =2    Heiko Huebler                 Hho           Vector Informatik GmbH
  50      =2  ----------------------------------------------------------------------------------------------------------
             --------------
  51      =2    REVISION HISTORY
  52      =2  ----------------------------------------------------------------------------------------------------------
             --------------
  53      =2    Version   Date        Author  Change Id     Description
  54      =2  ----------------------------------------------------------------------------------------------------------
             --------------
  55      =2    03.00.00  2000-05-08  Ht                    Creation of Vector IL derived from GMLAN Interaction Layer V
             -2.30
  56      =2    03.01.00  2000-06-16  Ht                    signal-sendtype "ifActive" added
  57      =2    03.02.00  2000-06-28  Bd                    InitIfActiveFlags call with channelindex ()
  58      =2    03.03.00  2000-09-05  Ht                    some comment changed
  59      =2    03.10.00  2000-10-30  Ht                    -adaption to CAN driver with channel index
  60      =2                                                -call of InitIfActiveFlags only if cyclic event enabled
  61      =2    03.11.00  2000-11-22  Ht                    version number increased
  62      =2    03.12.00  2001-04-12  Ht                    -INTERACTION_LAYER_BUGFIX_VERSION added
  63      =2                                                -extern declaration of module version  
  64      =2                                                -adapted extern declaration to IAR M16C
  65      =2              2001-04-20  Ht                    -adaption of functions to Keil C5x5
  66      =2    03.20.00  2001-06-01  Ht                    -new features:
  67      =2                                                -Tx: Timeout, Defaultvalues, Send on Init
  68      =2                                                -Rx: Start-Defautvalues, DataChanged
  69      =2                                                -indication if rx is waiting
  70      =2    03.21.00  2001-06-08  Ht                    -modified Tx timeout behaviour
  71      =2    03.22.00  2001-08-27  Ht      ESCAN00001168 Restart of Rx timeout monitoring in waiting mode
  72      =2                                                -Storage class of ilChannelState changed (no longer static) 
  73      =2    03.23.00  2001-09-09  Ht      ESCAN00001417 Support Multiple receive channel driver
  74      =2    03.24.00  2001-09-12  Ht      ESCAN00001448 Elimination of compiler warnings - state macros
  75      =2    03.25.00  2001-11-15  Hp      ESCAN00002245 Merge GMLAN-IL with Vector-IL.
  76      =2                                                Adding GMLAN V3.0 related features.
  77      =2    03.26.00  2001-11-20  Hp                    -Gm-Only :
  78      =2                                                -New interface function indicates learned message source add
             -ress.
  79      =2                                                -Learned source address only indicated when new.
  80      =2                                                -Bugfix for VN-array initialisation.
  81      =2                                                -Support for physical Multi-ECU configuration.
  82      =2              2002-01-30  Ms      ESCAN00002188 IlRxTask calls IlRxGenTask only if RxEnabled
  83      =2    03.27.00  2002-02-07  Ht      ESCAN00001760 insert module specific define
  84      =2                                  ESCAN00002305 Linker error for function _memcpy
  85      =2    03.28.00  2002-02-25  Hp      ESCAN00002252 New callback function for dynamic source address learning.
  86      =2                                                Revised timeout supervision for learned Extended-IDs
  87      =2              2002-03-06  Hp      ESCAN00002428 Split the tasks and call message functions individually.
  88      =2    03.30.00  2002-04-23  Ht      ESCAN00002199 Export extern declarations from IL.c to IL_def.h
  89      =2                                  ESCAN00002604 If no rx-timeout control is used, the IL cannot be compiled
  90      =2                                  ESCAN00002638 extern declaration of IlRxMsgECUMask changed  
  91      =2                                  ESCAN00002689 one call cycle missing for Start delay time
  92      =2                                  ESCAN00002713 Support the new features with multi channel systems
  93      =2                                  ESCAN00002714 Reset RxTimerFlags in IlRxRelease()
  94      =2                                  ESCAN00002715 Support systems without Tx or Rx messages
  95      =2                                  ESCAN00002716 ID priority of Tx messages could be inverted
  96      =2              2002-04-29  Hp                    Signal supervision fail indication when new msgs on a VN bec
             -ome active
  97      =2              2002-05-15  Hp                    Gm-Only : Minor corrections for GMLAN in IlTxTimerTask() and
             - IlDequeueNonActiveTxMessages
  98      =2                                                Gm-Only : start implementing indexed version
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 364 

  99      =2                                                Correct the check for max. number of nodes when learning a n
             -ew address.
 100      =2    03.32.00  2002-06-17  Ht      ESCAN00003075 Unexpected Rx-Timeout notification in MultiECU systems
 101      =2                                  ESCAN00002791 PowerOn initialization
 102      =2                                  ESCAN00002956 signal irelated start, stop and init callback functions
 103      =2                                  ESCAN00002976 additional get function for indication flags access
 104      =2              2002-07-08  Stu                   Bugfix for initialisation of index and mask in IlTxTimerTask
 105      =2    03.33.00  2002-09-09  Et      ESCAN00003694 support STmicro ST7 (beCAN) / Hiware
 106      =2              2002-09-27  Zw                    support STmicro ST7 (beCAN)/Hiware additional changes after 
             -review
 107      =2    03.34.00  2002-10-29  Fz                    No changes
 108      =2                          Hp      ESCAN00004099 Function added that provides the status of an NCA
 109      =2    03.35.00  2002-11-06  Hp      ESCAN00004124 Gm-Only : Compile error for function IlGetNodeCommActiveStat
             -e() 
 110      =2                                                for GMLAN without Extended-IDs
 111      =2              2002-12-05  Pet     ESCAN00004364 wrong define for 8Bit CPU
 112      =2    03.35.01  2002-12-18  Pet     ESCAN00004495 rx indirection check not needed when indirection index searc
             -h is used
 113      =2    03.36.00  2003-05-04  Fz      ESCAN00004484 Timeoutnotification for VN start changed
 114      =2                                  ESCAN00004424 Code optimization for transmission without Repetition
 115      =2                                  ESCAN00004621 Problem in macro IlClrChannelReceived removed  
 116      =2                                  ESCAN00004665 Gm-Only : Wrong index into structure used
 117      =2                                  ESCAN00004715 Gm-Only : Compiler failure removed
 118      =2                          Hp      ESCAN00004740 Add a function that clears the Timeout indication for receiv
             -e signals
 119      =2                          Ms      ESCAN00004956 PClint comments to avoid unauthorized Warnings
 120      =2                          Mra     ESCAN00005013 Fixed missing  inside of the IlCanGenericPrecopy function
 121      =2                          Ms      ESCAN00004413 warning from TI TMS470 Compiler
 122      =2                                  ESCAN00003525 memory qualifier for zero page mapping - HC08
 123      =2                                  ESCAN00004662 Size of "extern" object 'IlIndicationOffset' is unknown
 124      =2                          Fz      ESCAN00005215 Gm-Only : Some assertions modified
 125      =2                          Ht      ESCAN00002196 Improve Runtime for default values setting of RxSignals in M
             -ultiple ECU's
 126      =2                                  ESCAN00004205 Support  for Dual Rate Messages
 127      =2                                  ESCAN00004559 Optimisation for IlRxStateTask not working on indexed  multi
             - channel systems
 128      =2                                  ESCAN00004652 PSA specific timer handling for Periodic and Event triggered
             - messages is not supported by IL 
 129      =2                                  ESCAN00005214 avoid compiler warning in IlRxStateTask about unused paramet
             -er
 130      =2                                  ESCAN00005463 Setting of TxDefaultvalue could fail
 131      =2    03.37.00  2003-05-12  Ht      ESCAN00005627 setting of RxStart and RxStop Default Values could fail
 132      =2                          Fz      ESCAN00005560 Gm-Only : Incorrect reception handling of application messag
             -es in a Multiple-ECU environment
 133      =2    03.38.00  2003-05-15  Tri     ESCAN00005676 Implementing memory qualifier V_MEMROM0
 134      =2    03.39.00  2003-07-16  Tri     ESCAN00006095 V_MEMROM0 not used at pointer to constants
 135      =2                          Ht      ESCAN00005851 Memory access may fail with Physical Multiple ECU 
 136      =2                                  ESCAN00005852 suppressed transmission after cancelation of a message
 137      =2                          Hp      ESCAN00005993 Change bit-order for IlVnTxSendOnInit[].
 138      =2                          Ms      ESCAN00006033 Critical Indirections with more than 255 CAN messages
 139      =2    03.40.00  2003-07-16  HH      ESCAN00005827 added define for error  ILERR_ILLCHANNEL
 140      =2                          HH      ESCAN00006157 MISRA compliance improved
 141      =2                          HH      ESCAN00005996 IlUintType replaced by vuintx
 142      =2    03.41.00  2003-08-11  Hp                    No changes here
 143      =2    03.42.00  2003-08-15  Fz                    No changes here
 144      =2    03.43.00  2003-08-29  Hp                    No changes here
 145      =2    03.44.00  2003-09-08  Hp                    No changes here
 146      =2    03.45.00  2003-09-16  Fz                    No changes here
 147      =2    03.46.00  2003-09-29  Fz                    No changes here
 148      =2    03.47.00  2003-10-14  Fz                    No changes here
 149      =2    03.48.00  2004-01-16  Fz/Tde/Ms
 150      =2                                  ESCAN00006990 Add of TMS320 support
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 365 

 151      =2    03.49.00  2003-12-11  HH      ESCAN00007143 use V_MEM_* instead of MEMORY_ROM
 152      =2              2004-02-05  Ms                    added v_def.h compatibility check
 153      =2              2004-03-01  Ms                    adapted Memory Qualifier
 154      =2              2004-03-02  Ms                    adapted Version Handling
 155      =2    03.50.00  2004-04-02  HH                    improved MISRA compliance, uses vstdlib instead of own funct
             -ions
 156      =2                                  ESCAN00000815 common module functions _memcpy and _memclr
 157      =2              2004-05-14  Ms                    Added Memcopysupport check in relation to RI 1.4
 158      =2                                                Incremented and improved V_DEF_VERSION check
 159      =2                                                Added vstdlib compatibility check
 160      =2                                                Improved CANGen compatibility Check
 161      =2                                                Removed Memory Qualifier Workaround
 162      =2              2004-05-19  HH/Ms   ESCAN00007288 ilTxState and IlTxStartCycles arrays are accessed but not de
             -fined
 163      =2    03.51.00  2004-07-09  Fz      ESCAN00008856 Gm-Only : Wrong notification about failed source
 164      =2    03.52.00  2004-11-17  Fz      ESCAN00009802 No changes here
 165      =2                          Ms      ESCAN00009576 No changes here
 166      =2                                  ESCAN00009575 Remove C_COMP_FJVGC
 167      =2                                  ESCAN00009613 No changes here
 168      =2                                  ESCAN00009616 Conceptional common usage of function pointer tables 
 169      =2                                                in IlTxConfirmationFctPtr and IlCanRxIndicationFctPtr
 170      =2                                  ESCAN00009633 Naming Conventions
 171      =2                                  ESCAN00007483 No changes here
 172      =2                                  ESCAN00009836 No changes here
 173      =2                                  ESCAN00006085 No changes here
 174      =2                                  ESCAN00009889 No changes here
 175      =2                                  ESCAN00010057 VStdLib Switch
 176      =2    04.00.00  2005-06-15  Fz      ESCAN00010505 No changes here
 177      =2                          Ms      ESCAN00010691 Improve MISRA Compliance
 178      =2                          Ms      ESCAN00010404 No changes here
 179      =2                          Ms      ESCAN00010403 IlResetCanIndicationFlags Preprocessor encapsulation
 180      =2                          Ms      ESCAN00010709 Invalid Confirmation Notification and StartDelay time for Mu
             -ltiplex Messages
 181      =2                          Ms      ESCAN00010701 Not GM: Activate ApplIlInit extern declaration
 182      =2                          Ms      ESCAN00010704 Remove IL_NO_COMPATIBILITY
 183      =2                          Ms      ESCAN00010825 No changes here
 184      =2                          Ms      ESCAN00010609 IlRxFirstvalueFlagsStartIndex Spelling
 185      =2                          Ms      ESCAN00010690 Geny Compatibility
 186      =2                          Ms      ESCAN00008116 Dynamic Rx Timeouts
 187      =2                          Ms      ESCAN00008651 No changes here
 188      =2                          Ms      ESCAN00012393 Organi Check
 189      =2                          Ms      ESCAN00008455 Geny: Preprocessor Checks
 190      =2                          Ms      ESCAN00012640 No changes here
 191      =2                          Ms      ESCAN00012640 No changes here
 192      =2    04.01.00  2005-08-02  Ms      ESCAN00012851 No changes here
 193      =2                          Ms      ESCAN00012946 Geny: Standard Multiplex Interface
 194      =2                          Ms      ESCAN00013024 Geny: kIlNumberOfRxIndicationBits used, but not defined
 195      =2                          Ms      ESCAN00013049 No changes here
 196      =2                          Fz      ESCAN00012988 Interface of function IlGetRxMessageSourceAddress changed
 197      =2    04.02.00  2005-12-07  Ms      ESCAN00013387 added FastOnStart for muliplexed messages
 198      =2                          Ms      ESCAN00013712 added AUTOSAR Pdu Interface
 199      =2                          Ms      ESCAN00013963 No changes here
 200      =2                          Ms      ESCAN00014359 No changes here
 201      =2                          Ms      ESCAN00014419 Init Default Values (Tms320)
 202      =2                          Ms      ESCAN00014536 Init Dynamic Timeouts
 203      =2                          Ms      ESCAN00014539 No changes here
 204      =2    04.03.00  2005-12-20  Ms      ESCAN00014630 Add Il Rx/Tx Polling for the AUTOSAR PduRouter Interface
 205      =2    04.04.00  2006-02-23  Ms      ESCAN00014829 IlTxTimeout extern declaration
 206      =2                          Ms      ESCAN00014880 No changes here
 207      =2                          Ms      ESCAN00015290 AUTOSAR: Change Interrupt Mapping
 208      =2                          Ms      ESCAN00015456 [SR:033] Add GENy physical multiple ecu support
 209      =2                          Ms      ESCAN00015457 [SR:034] Add Dynamic Cycle Time at Init
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 366 

 210      =2    04.05.00  2006-03-20  Fz      ESCAN00015656 GM-Only: Compiler Error in IlNodeCommActiveFailed
 211      =2                          Fz      ESCAN00015622 GM-Only: Compiler Error re-definition of NULL
 212      =2                          Ms      ESCAN00015682 [SR:032] Signal Group API for GENy
 213      =2                          Ms      ESCAN00015502 VStdLib Compatibility
 214      =2    04.06.00  2006-04-10  Ms      ESCAN00015892 Support for AUTOSAR 1.0 management API
 215      =2                          Ms      ESCAN00015139 [SR:037] IlSendDirect
 216      =2                          Ms      ESCAN00016071 Dynamic Rx Timeout Value
 217      =2                          Fz      ESCAN00016041 No changes here
 218      =2    04.07.00  2006-06-14  Ms      ESCAN00015850 No changes here
 219      =2                          Ms      ESCAN00016430 [SR:039] AUTOSAR 2.0.0
 220      =2    04.08.00  2006-06-27  Ms      ESCAN00013964 No changes here
 221      =2                          Ms      ESCAN00016729 No changes here
 222      =2                          Ms      ESCAN00016933 GM-Only: Compile error in IlSet/GetRxMessageSourceAddress wh
             -en using no IL rx polling mode
 223      =2    04.09.00  2007-04-11  Ms      ESCAN00018540 Compiler warning with Hiware(Metrowerks)
 224      =2                          Ms      ESCAN00018622 Support Only Hll Based VStdLibs
 225      =2                          Ms      ESCAN00019703 GM-Only: Move extern declarations to gmlcal.h
 226      =2                          Ms      ESCAN00019849 GM-Only: No changes here
 227      =2                          Ms      ESCAN00020000 No changes here
 228      =2                          Fz      ESCAN00020134 GM-Only: No changes here
 229      =2                          Ms      ESCAN00020234 GM-Only: No changes here
 230      =2                          Ms      ESCAN00020235 AUTOSAR API: Remove unreferenced constant defines
 231      =2    04.10.00  2007-05-10  Ms      ESCAN00013075 Add IlGetModuleContext/IlSetModuleContext
 232      =2                          Ms      ESCAN00020730 No changes here
 233      =2                          Ms      ESCAN00021203 GM-Only: No changes here
 234      =2    05.00.00  2008-01-10  Ms      ESCAN00021361 GM-Only: Compile error in IlVnRx/TxMessageEnabled
 235      =2                          Ms      ESCAN00021245 IlGetModuleContext/IlSetModuleContext with IfActive
 236      =2                          Ms      ESCAN00021696 C_ENABLE_MULTI_ECU_PHYS Compatibility
 237      =2                          Ms      ESCAN00021708 No changes here
 238      =2                          Ms      ESCAN00021271 IlSendDirect declaration
 239      =2                          Ms      ESCAN00022375 No changes here
 240      =2                          Ms      ESCAN00023206 Split Oem Extensions
 241      =2                          Ms      ESCAN00023270 Near ilIfActiveFlags
 242      =2                          Ms      ESCAN00023300 Remove Signal Group Buffer Reset
 243      =2                          Ms      ESCAN00023284 Alterable Memory for Tx Default Value
 244      =2                          Ms      ESCAN00023821 No changes here
 245      =2                          Ms      ESCAN00023822 GM-Only: No changes here
 246      =2    05.01.00  2008-01-25  Ms      ESCAN00023109 PSA-Only: No changes here
 247      =2    05.02.00  2008-04-21  Ms      ESCAN00026301 SendType IfActive and Multiple Channels
 248      =2              2008-07-17  Ms      ESCAN00025002 No changes here
 249      =2                          Ms      ESCAN00028780 Detect Repetition and Signal Activity
 250      =2                          Ms      ESCAN00025178 No changes here
 251      =2                          Ms      ESCAN00013854 Support C_COMP_IAR_M16C for Compiler Version >= 3.00
 252      =2    05.02.01  2008-10-17  Ms      ESCAN00029307 Unsigned comparison with 0 is always false in a preprocessor
             - check
 253      =2                          Ms      ESCAN00030750 The description of IlRxWait() is incorrect
 254      =2    05.02.02  2009-08-28  Ml      ESCAN00037350 Resolved typo in Organi define
 255      =2    05.03.00  2009-11-19  Swa     ESCAN00039257 Added support for DrvCan search algorithm C_SEARCH_ID_MODE
 256      =2                          Swa     ESCAN00039071 No changes here
 257      =2                          Swa     ESCAN00039274 Moved type declarations before context struct
 258      =2              2010-04-20  Swa     ESCAN00042420 IlGetModuleContext/IlSetModuleContext with IfActive for C_CO
             -MP_QCC_SH4_RCAN
 259      =2    05.04.00  2010-06-14  Swa     ESCAN00043305 No changes here
 260      =2              2010-06-28  Ms      ESCAN00042424 No changes here
 261      =2    05.05.00  2010-10-27  Ms      ESCAN00046426 Support C_API_3 to indicate reentrant function calls
 262      =2    05.06.00  2011-06-28  Ms      ESCAN00051034 No changes here
 263      =2    05.06.01  2011-07-14  Ms      ESCAN00052200 No changes here
 264      =2    05.06.02  2012-02-06  Ms      ESCAN00056637 No changes here
 265      =2    05.07.00  2012-01-30  Hho     ESCAN00059505 Support Update Bits (Signal status information)
 266      =2              2012-03-21  Hho     ESCAN00057706 No changes here
 267      =2    05.07.01  2012-06-26  Ms      ESCAN00059650 The version defines and constants are not 5.07.00
 268      =2    05.07.02  2012-10-08  Hho     ESCAN00060945 Clear first value and timeout signal flags upon relevant VN 
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 367 

             -deactivation
 269      =2    05.08.00  2012-11-05  Hho     ESCAN00062550 improve IlCanCancelNotification runtime
 270      =2  **********************************************************************************************************
             -************/
 271      =2  
 272      =2  #if !defined ( V_IL_DEF_COMPONENT_HEADER )
 273      =2  # define V_IL_DEF_COMPONENT_HEADER
 274      =2  /*********************************************************************************************************
             -*************
 275      =2    INCLUDES
 276      =2  **********************************************************************************************************
             -************/
 277      =2  
 278      =2  /*********************************************************************************************************
             -*************
 279      =2    GLOBAL CONSTANT MACROS
 280      =2  **********************************************************************************************************
             -************/
 281      =2  /** \defgroup Il_VectorVersion Il_Vector version defines
 282      =2      \brief The defines are used in the constant Table IlTxType and ilTxState to configure the send behavio
             -ur state of Tx messages. */
 283      =2  /**\{*/
 284      =2  /* ##V_CFG_MANAGEMENT ##CQProject : Il_Vector CQComponent : Implementation */
 285      =2  /** This is the Il_Vector bcd coded main- and subversion bcd. */
 286      =2  # define IL_VECTOR_VERSION          0x0508
 287      =2  /** This is the Il_Vector bcd coded releaseversion. */
 288      =2  # define IL_VECTOR_RELEASE_VERSION  0x00
 289      =2  /** This is the Il_Vector decimal Kernelbuilder build version. */
 290      =2  # define IL_VECTOR_BUILD_VERSION    138
 291      =2  /**\}*/
 292      =2  
 293      =2  /** \defgroup CommonReturnValue Common Return Values
 294      =2      \brief The defines are used to evaluate the return value of various Il_Vector functions. */
 295      =2  /**\{*/
 296      =2  /** The function returned successful. */
 297      =2  # define IL_OK                  0
 298      =2  /** The function returned, but the operation was interrupted.
 299      =2      The function has been called either with and invalid argument or in an invalid call context. */
 300      =2  # define IL_ERROR              -3
 301      =2  /**\}*/
 302      =2  
 303      =2  /** \defgroup IlStartCycleReturnValue IlStartCycle Return Values
 304      =2      \brief The defines are used to evaluate the return value of IlStartCycle. */
 305      =2  /**\{*/
 306      =2  /** The message is already transmitted cyclically. */
 307      =2  # define IL_QUEUED             -2
 308      =2  /**\}*/
 309      =2  
 310      =2  /** \defgroup IlBooleanReturnValue Boolean Return Value
 311      =2      \brief The defines are used to evaluate the return value of the function with Il_Boolean return. */
 312      =2  /**\{*/
 313      =2  # define IL_FALSE            ((Il_Boolean)0)
 314      =2  # define IL_TRUE             ((Il_Boolean)1)
 315      =2  /**\}*/
 316      =2  
 317      =2  /** \defgroup IlTxTypeValuesAndMasks IlTxType Values and Masks
 318      =2      \brief The defines are used in the constant Table IlTxType and ilTxState to configure the send behavio
             -ur state of Tx messages. */
 319      =2  /**\{*/
 320      =2  /** This value is used, if nothing is configured for the message. */
 321      =2  # define kTxNoTxType           (vuint8)0x00
 322      =2  /** The message is transmitted cyclically. */
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 368 

 323      =2  # define kTxSendCyclic         (vuint8)0x01
 324      =2  /** The message is currently transmitted fast (IfActive). */
 325      =2  # define kTxSendCyclicEvent    (vuint8)0x02
 326      =2  /** The timeout supervision for the message is activated. */
 327      =2  # define kTxCheckTimeout       (vuint8)0x04
 328      =2  /** The message is transmitted with repetition. */
 329      =2  # define kTxNSendRequest       (vuint8)0x08
 330      =2  /** The message is transmitted with the fast cycle rate if the start transition is performed for tx. */
 331      =2  # define kTxFastOnStart        (vuint8)0x10
 332      =2  /** The message will be transmitted if IlSendOnInitMsg is called. */
 333      =2  # define kTxQueueInit          (vuint8)0x20
 334      =2  /** The transmission request to the Data Link layer will be performed in the next IlTxTask call, if possib
             -le. */
 335      =2  # define kTxSendRequest        (vuint8)0x80
 336      =2  
 337      =2  /** This mask is used to deactivate or decode kTxSendCyclic */
 338      =2  # define kTxNotSendCyclic      (vuint8)0xfe
 339      =2  /** This mask is used to deactivate or decode kTxSendCyclicEvent */
 340      =2  # define kTxNotSendCyclicEvent (vuint8)0xfd
 341      =2  /** This mask is used to deactivate or decode kTxCheckTimeout */
 342      =2  # define kTxNotCheckTimeout    (vuint8)0xfb
 343      =2  /** This mask is used to deactivate or decode kTxNSendRequest */
 344      =2  # define kTxNotNSendRequest    (vuint8)0xf7
 345      =2  /** This mask is used to deactivate or decode kTxFastOnStart */
 346      =2  # define kTxNotFastOnStart     (vuint8)0xef
 347      =2  /** This mask is used to deactivate or decode kTxQueueInit */
 348      =2  # define kTxNotQueueInit       (vuint8)0xdf
 349      =2  /** This mask is used to deactivate or decode kTxSendRequest */
 350      =2  # define kTxNotSendRequest     (vuint8)0x7f
 351      =2  /**\}*/
 352      =2  
 353      =2  /** \defgroup ApplIlFatalErrorCodes ApplIlFatalError Error Codes
 354      =2      \brief The defines are used as parameter for ApplIlFatalError. */
 355      =2  /**\{*/
 356      =2  /** The Tx message handle was not in a valid range. */
 357      =2  # define ILERR_ILLTXMSGHANDLE               (vuint8) 0x02
 358      =2  /** The Rx message handle was not in a valid range. */
 359      =2  # define ILERR_ILLRXMSGHANDLE               (vuint8) 0x03
 360      =2  /** The Tx timeout handle was not in a valid range. */
 361      =2  # define ILERR_ILLTXTIMEOUTINDEX            (vuint8) 0x12
 362      =2  /** The Rx timeout handle was not in a valid range. */
 363      =2  # define ILERR_ILLRXTIMEOUTINDEX            (vuint8) 0x13
 364      =2  /** The channel handle was not in a valid range. */
 365      =2  # define ILERR_ILLCHANNEL                   (vuint8) 0x17
 366      =2  /**\} */
 367      =2  
 368      =2  /** \defgroup IL_ChannelStateValuesAndMasks IL_ChannelState Values and Masks
 369      =2      \brief The defines are used to evaluate the current channel state. */
 370      =2  /**\{*/
 371      =2  /** The Rx and Tx state machine of this channel is in the suspended state. */
 372      =2  # define kIlIsSuspend     (vuint8)0x00
 373      =2  /** The Tx state machine of this channel is in the waiting state. */
 374      =2  # define kIlIsTxWait      (vuint8)0x01
 375      =2  /** The Tx state machine of this channel is in the running state. */
 376      =2  # define kIlIsTxRun       (vuint8)0x02
 377      =2  /** The Rx state machine of this channel is in the waiting state. */
 378      =2  # define kIlIsRxWait      (vuint8)0x04
 379      =2  /** The Rx state machine of this channel is in the running state. */
 380      =2  # define kIlIsRxRun       (vuint8)0x08
 381      =2  /** The Rx and Tx state machine of this channel is in the running state. */
 382      =2  # define kIlIsRxTxRun     (vuint8)0x0A
 383      =2  
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 369 

 384      =2  /** This mask is used to deactivate or decode kIlIsSuspend */
 385      =2  # define kIlIsNotSuspend     (vuint8)0xff
 386      =2  /** This mask is used to deactivate or decode kIlIsTxWait */
 387      =2  # define kIlIsNotTxWait      (vuint8)0xfe
 388      =2  /** This mask is used to deactivate or decode kIlIsTxRun */
 389      =2  # define kIlIsNotTxRun       (vuint8)0xfd
 390      =2  /** This mask is used to deactivate or decode kIlIsRxWait */
 391      =2  # define kIlIsNotRxWait      (vuint8)0xfb
 392      =2  /** This mask is used to deactivate or decode kIlIsRxRun */
 393      =2  # define kIlIsNotRxRun       (vuint8)0xf7
 394      =2  /** This mask is used to deactivate or decode kIlIsRxTxRun */
 395      =2  # define kIlIsNotRxTxRun     (vuint8)0xf5
 396      =2  /**\} */
 397      =2  
 398      =2  /** \defgroup SpecialTableValues Reserved Array Constants
 399      =2      \brief The defines are used to evaluate values in tables with reserved meanings. */
 400      =2  /**\{*/
 401      =2  
 402      =2  /** If the IL Tx message handle has no Can Driver Tx handle, this value shall be used in the IlTxIndirecti
             -on table.
 403      =2      If the value is not defined by the Can Driver, the maximum value of the datatype CanTransmitHandle mus
             -t be defined. */
 404      =2  # if !defined( kCanTxHandleNotUsed )
           =2 #  define kCanTxHandleNotUsed       ((CanTransmitHandle) 0xFFFFFFFF)
           =2 # endif
 407      =2  
 408      =2  /** This value shall be used, if ilTxUpdateCounter of an IL Tx message handle is paused.
 409      =2      The maximum value of the datatype IltTxUpdateCounter must be defined. */
 410      =2  # define kIlStopUpdateCounterValue  ((IltTxUpdateCounter)0xFFFFu)
 411      =2  
 412      =2  # if defined ( VGEN_GENY )
 413      =2  /** This value shall be used, if the IL Tx handle has no IlTxTimeoutIndirection. */
 414      =2  #  define kIlNoTxToutIndirection               0x00u
 415      =2  /** This value shall be used, if the IL Tx handle has no IlTxFastOnStartDuration. */
 416      =2  #  define kIlNoFastOnStartDuration             0x01u
 417      =2  /** This value shall be used in IlTxStartCycles, if the IL Tx handle is not transmitted cyclically. */
 418      =2  #  define kIlNoCycleTime                       0x01u
 419      =2  /** This value shall be used in IlTxUpdateCycles, if the IL Tx handle has no delay time. */
 420      =2  #  define kIlNoDelayTime                       0x01u
 421      =2  /** This value shall be used in IlTxEventCycles, if the IL Tx handle cannot be transmitted with a fast cyc
             -lic period. */
 422      =2  #  define kIlNoCycleTimeFast                   0x01u
 423      =2  # endif/* VGEN_GENY */
 424      =2  /**\} */
 425      =2  
 426      =2  /** \defgroup APIChannelAbstraction API Channel Abstraction
 427      =2      \brief The defines are used to abstact single channel and multiple channel APIs. */
 428      =2  /**\{*/
 429      =2  # if defined( C_MULTIPLE_RECEIVE_CHANNEL ) && (kIlNumberOfChannels > 1)
           =2 #  define IL_CHANNEL_ILTYPE_ONLY          CanChannelHandle channel
           =2 #  define IL_CHANNEL_ILTYPE_FIRST         CanChannelHandle channel,
           =2 #  define IL_CHANNEL_ILTYPE_LOCAL         CanChannelHandle channel;
           =2 #  define IL_CHANNEL_ILPARA_ONLY          channel
           =2 #  define IL_CHANNEL_ILPARA_FIRST         channel,
           =2 #  define IL_CHANNEL_ILPARA_MACRO         channel
           =2 #  define IL_CHANNEL_ILPRECOPY_MACRO      rxStruct->Channel
           =2 # else
 438      =2  #  define IL_CHANNEL_ILTYPE_ONLY          void
 439      =2  #  define IL_CHANNEL_ILTYPE_FIRST
 440      =2  #  define IL_CHANNEL_ILTYPE_LOCAL
 441      =2  #  define IL_CHANNEL_ILPARA_ONLY
 442      =2  #  define IL_CHANNEL_ILPARA_FIRST
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 370 

 443      =2  #  define IL_CHANNEL_ILPARA_MACRO         0
 444      =2  #  define IL_CHANNEL_ILPRECOPY_MACRO      0
 445      =2  # endif
 446      =2  /**\}*/
 447      =2  
 448      =2  
 449      =2  /** \defgroup CanChipDataPtr access abstraction for PreTransmit
 450      =2      \brief The defines are used to abstact the CanChipDataPtr access in the PreTransmit function */
 451      =2  /**\{*/
 452      =2  # if defined(C_MULTIPLE_RECEIVE_CHANNEL) || defined(C_SINGLE_RECEIVE_CHANNEL)
 453      =2  #  define IL_PRETRANSMIT_PARA            ctis
 454      =2  #  define IL_PRETRANSMIT_TYPE            CanTxInfoStruct
 455      =2  #  define IL_PRETRANSMIT_DATA_PTR(para)  para.pChipData
 456      =2  # else
           =2 #  define IL_PRETRANSMIT_PARA            txObject
           =2 #  define IL_PRETRANSMIT_TYPE            CanChipDataPtr
           =2 #  define IL_PRETRANSMIT_DATA_PTR(para)  para
           =2 # endif
 461      =2  /**\}*/
 462      =2  
 463      =2  
 464      =2  /** \defgroup CompatibilityMultipleNodes Multiple Nodes Compatibility
 465      =2      \brief The defines are used to abstact the multiple nodes of CANGen and GENy. */
 466      =2  /**\{*/
 467      =2  # if defined ( VGEN_GENY )
 468      =2  #  if defined ( IL_ENABLE_SYS_MULTI_ECU_PHYS )
           =2 #   define IL_ENABLE_RX_MULTI_ECU_PHYS
           =2 #  else/* IL_ENABLE_SYS_MULTI_ECU_PHYS */
 471      =2  #   define IL_DISABLE_RX_MULTI_ECU_PHYS
 472      =2  #  endif
 473      =2  # else
           =2 #  if defined ( IL_ENABLE_SYS_MULTIPLE_NODES )
           =2 #   define IL_ENABLE_RX_MULTIPLE_NODES
           =2 #   define IL_ENABLE_RX_MULTI_ECU_PHYS
           =2 #   define IL_ENABLE_SYS_MULTI_ECU_PHYS
           =2 
           =2 #   define tVIdentityMsk                         vuint8
           =2 #   define IlRxMsgECUMask                    IlCanRxIdentityAssignment
           =2 #   define IlTxMsgECUMask                    IlTxIdentityAssignment
           =2 #   define kIlNumberOfIdentities             kIlNumberOfNodes
           =2 #   define V_ACTIVE_IDENTITY_LOG             comMultipleECUCurrent
           =2 #   define V_ACTIVE_IDENTITY_MSK             ilECUMask
           =2 
           =2 #  else
           =2 #   define IL_DISABLE_RX_MULTI_ECU_PHYS
           =2 #  endif
           =2 # endif
 490      =2  /**\} */
 491      =2  
 492      =2  /** \defgroup CompatibilityAUTOSAR AUTOSAR Compatibility
 493      =2      \brief The defines are used to abstact the IL, Can Driver interface to the AUTOSAR COM interface. */
 494      =2  /**\{*/
 495      =2  /**\} */
 496      =2  
 497      =2  #  define IL_MEMROM1  V_MEMROM1
 498      =2  #  define IL_MEMROM2  V_MEMROM2
 499      =2  #  define IL_MEMROM3  V_MEMROM3
 500      =2  
 501      =2  /*********************************************************************************************************
             -*************
 502      =2    GLOBAL CHECK MACROS
 503      =2  **********************************************************************************************************
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 371 

             -************/
 504      =2  /* Compatibility Checks **********************************************************************************
             -************/
 505      =2  
 506      =2  # if defined ( VGEN_GENY )
 507      =2  /* Il_Vector - GenTool_Geny Compatibility Check */
 508      =2  #  if !defined( IL_VECTORDLL_VERSION )
           =2 #   error "Incompatible Il_Vector - GenTool_Geny with this Il_Vector-Implementation. IL_VECTORDLL_VERSION 
             -has to be defined!"
           =2 #  endif
 511      =2  #  if !defined( IL_VECTORDLL_RELEASE_VERSION )
           =2 #   error "Incompatible Il_Vector - GenTool_Geny with this Il_Vector-Implementation. IL_VECTORDLL_RELEASE_
             -VERSION has to be defined!"
           =2 #  endif
 514      =2  #  if defined( IL_VECTORDLL_VERSION ) && defined( IL_VECTORDLL_RELEASE_VERSION )
 515      =2  #   if ( IL_VECTORDLL_VERSION < 0x0107u )
           =2 #    error "Incompatible Il_Vector - GenTool_Geny with this Il_Vector-Implementation!"
           =2 #   else
 518      =2  #   endif
 519      =2  #  endif
 520      =2  
 521      =2  /* required to work around issue in MISRA checker tool */
 522      =2  #  define CANGENEXE_VERSION 0x0000u
 523      =2  #  define CANGENEXE_RELEASE_VERSION 0x00u
 524      =2  
 525      =2  # else
           =2 /* Il_Vector - GenTool_CanGen Compatibility Check */
           =2 #  if !defined( CANGENEXE_VERSION )
           =2 #   error "Incompatible Il_Vector - GenTool_CanGen with this Il_Vector-Implementation. CANGENEXE_VERSION h
             -as to be defined!"
           =2 #  endif
           =2 #  if !defined( CANGENEXE_RELEASE_VERSION )
           =2 #   error "Incompatible Il_Vector - GenTool_CanGen with this Il_Vector-Implementation. CANGENEXE_RELEASE_V
             -ERSION has to be defined!"
           =2 #  endif
           =2 #  if defined( CANGENEXE_VERSION ) && defined( CANGENEXE_RELEASE_VERSION )
           =2 #   if ( CANGENEXE_VERSION < 0x0424u )
           =2 #    error "Incompatible Il_Vector - GenTool_CanGen with this Il_Vector-Implementation!"
           =2 #   else
           =2 #   endif
           =2 #  endif
           =2 
           =2 /* required to work around issue in MISRA checker tool */
           =2 #  define IL_VECTORDLL_VERSION 0x0000u
           =2 #  define IL_VECTORDLL_RELEASE_VERSION 0x00u
           =2 
           =2 # endif
 545      =2  
 546      =2  /* Il_Vector GenTool Compatibility Check */
 547      =2  # if ( IL_IMPLEMENTATION_VERSION != 0x0202u )
           =2 #  error "Incompatible IL implementation version!"
           =2 # endif
 550      =2  
 551      =2  
 552      =2  /* Common_Vdef-Implementation Compatibility Check */
 553      =2  # if !defined( COMMON_VDEF_VERSION )
           =2 #  error "Incompatible Common_Vdef-Implementation with this Il_Vector-Implementation. COMMON_VDEF_VERSION 
             -has to be defined!"
           =2 # endif
 556      =2  # if !defined( COMMON_VDEF_RELEASE_VERSION )
           =2 #  error "Incompatible Common_Vdef-Implementation with this Il_Vector-Implementation. COMMON_VDEF_RELEASE_
             -VERSION has to be defined!"
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 372 

           =2 # endif
 559      =2  # if defined( COMMON_VDEF_VERSION ) && defined( COMMON_VDEF_RELEASE_VERSION )
 560      =2  #  if ( COMMON_VDEF_VERSION < 0x0289u )
           =2 #   error "Incompatible Common_Vdef-Implementation with this Il_Vector-Implementation!"
           =2 #  else
 563      =2  #  endif
 564      =2  # endif
 565      =2  
 566      =2  /* VStdLib Compatibility Check */
 567      =2  # if !defined( VGEN_ENABLE_VSTDLIB ) && !defined ( V_ENABLE_VSTDLIB )
           =2 #  error  "Error in File V_cfg.h: VGEN_ENABLE_VSTDLIB or V_ENABLE_VSTDLIB must be defined to use the Commo
             -n_VStdLib-Implementation for this Il_Vector Implementation."
           =2 # endif
 570      =2  /* VStdLib__coreHll-Implementation Compatibility Check */
 571      =2  # if defined( VSTDLIB__COREHLL_VERSION )
 572      =2  #  if ( VSTDLIB__COREHLL_VERSION < 0x0203u )
           =2 #   error "Incompatible VStdLib__coreHll-Implementation with this Il_Vector-Implementation!"
           =2 #  endif
 575      =2  # else
           =2 #  error "Incompatible VStdLib__coreHll-Implementation with this Il_Vector-Implementation. VSTDLIB__COREHL
             -L_VERSION has to be defined!"
           =2 # endif /* VSTDLIB__COREHLL_VERSION */
 578      =2  # if defined( VSTDLIB__COREHLL_RELEASE_VERSION )
 579      =2  # else
           =2 #  error "Incompatible VStdLib__coreHll-Implementation with this Il_Vector-Implementation. VSTDLIB__COREHL
             -L_RELEASE_VERSION has to be defined!"
           =2 # endif /* VSTDLIB__COREHLL_RELEASE_VERSION */
 582      =2  
 583      =2  /* Organi Check ******************************************************************************************
             -************/
 584      =2  
 585      =2  /* Oem Check *********************************************************************************************
             -************/
 586      =2  # if defined ( VGEN_GENY )
 587      =2  # endif
 588      =2  
 589      =2  
 590      =2  # if defined( IL_ENABLE_SYS_GET_CONTEXT ) || defined( IL_ENABLE_SYS_SET_CONTEXT )|| \
 591      =2      defined( VGEN_ENABLE_MDWRAP )        || defined( VGEN_ENABLE_QWRAP )
           =2 
           =2 /* Check not supported Can Drivers */
           =2 #  if defined( C_SINGLE_RECEIVE_BUFFER ) || defined( C_MULTIPLE_RECEIVE_BUFFER )
           =2 #   error "The IlGetModuleContext/IlSetModuleContext interface is not supported code replicated Can Driver
             -s!"
           =2 #  endif
           =2 #  if defined ( IL_ENABLE_TX_CYCLIC_EVENT )
           =2 #    error "The IlGetModuleContext/IlSetModuleContext Interface cannot be used with Messages and Signals, 
             -which have the sendtype IfActive!"
           =2 #  endif
           =2 /* Check not supported C_COMP switches */
           =2 # endif
 602      =2  
 603      =2  /* Compatibility Check ***********************************************************************************
             -************/
 604      =2  
 605      =2  
 606      =2  /* Vector CanDriver Interface Check Channel _Z ***********************************************************
             -********/
 607      =2  #  if !defined( XT_TX_DLC )
           =2 #   error  "Incompatible CanDriver: Missing Macro 'XT_TX_DLC'"
           =2 #  endif
 610      =2  
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 373 

 611      =2  #  if ( C_VERSION_REF_IMPLEMENTATION >= 0x120u )
 612      =2  #   if !defined( CanGetRxDataPtr )
           =2 #    error  "Incompatible CanDriver: Missing Macro 'CanGetRxDataPtr'"
           =2 #   endif
 615      =2  #   if !defined( CanGetRxDataLen )
           =2 #    error  "Incompatible CanDriver: Missing Macro 'CanGetRxDataLen'"
           =2 #   endif
 618      =2  #   if !defined( CanGetTxDlc )
           =2 #    error  "Incompatible CanDriver: Missing Macro 'CanGetTxDlc'"
           =2 #   endif
 621      =2  #   if !defined( CanGetTxDataPtr )
           =2 #    error  "Incompatible CanDriver: Missing Macro 'CanGetTxDataPtr'"
           =2 #   endif
 624      =2  #  endif
 625      =2  #  if !defined( CanGetConfirmationOffset )
           =2 #   error  "Incompatible CanDriver: Missing Macro 'CanGetConfirmationOffset'"
           =2 #  endif
 628      =2  #  if !defined( CanGetConfirmationMask )
           =2 #   error  "Incompatible CanDriver: Missing Macro 'CanGetConfirmationMask'"
           =2 #  endif
 631      =2  #  if !defined( CanGetIndicationOffset )
           =2 #   error  "Incompatible CanDriver: Missing Macro 'CanGetIndicationOffset'"
           =2 #  endif
 634      =2  #  if !defined( CanGetIndicationMask )
           =2 #   error  "Incompatible CanDriver: Missing Macro 'CanGetIndicationMask'"
           =2 #  endif
 637      =2  #  if defined ( C_ENABLE_CAN_CANCEL_NOTIFICATION ) && defined( C_MULTIPLE_RECEIVE_CHANNEL )
           =2 #   if !defined( CanGetChannelOfTxObj )
           =2 #    error  "Incompatible CanDriver: Missing Macro 'CanGetChannelOfTxObj'"
           =2 #   endif
           =2 #  endif
 642      =2  
 643      =2  #  if defined( VGEN_GENY ) && ( C_VERSION_REF_IMPLEMENTATION < 0x130u )
           =2 #   error  "Incompatible CanDriver: The Reference Implementation must be higher than Version RI 1.3!"
           =2 #  endif
 646      =2  
 647      =2  #  if defined( IL_ENABLE_TX_UPDATE_BITS )
           =2 #   if !defined( C_ENABLE_MEMCOPY_SUPPORT )
           =2 #    error  "Error: CopyToCAN and CopyFromCAN Service must be enabled for UpdateBits!"
           =2 #   endif
           =2 #  endif
 652      =2  
 653      =2  #  if !defined( VGEN_GENY )
           =2 #   if !defined( C_SEARCH_INDEX ) && !defined( C_SEARCH_ID_MODE ) && !defined( C_ENABLE_RX_MSG_INDIRECTION
             - )
           =2 #    error  "Error in File CAN_CFG.h: Rx Message Indirection has to be enabled"
           =2 #   endif
           =2 #  endif
 658      =2  
 659      =2  #  if ( C_VERSION_REF_IMPLEMENTATION >= 0x130u ) && !defined ( C_ENABLE_CAN_CANCEL_NOTIFICATION )
           =2 #   error  "Error in File Can_cfg.h: CAN Cancel Notification has to be enabled!"
           =2 #  endif
 662      =2  
 663      =2  # if defined( VGEN_GENY )
 664      =2  /* Geny Compiler Switch - Constant Integrity Check *******************************************************
             -************/
 665      =2  
 666      =2  
 667      =2  /* Compiler Switch - Constant Integrity Check */
 668      =2  
 669      =2  /* Value Existance Check */
 670      =2  #  if !defined( kIlNumberOfChannels )
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 374 

           =2 #   error  "Error in File Il_Cfg.h: kIlNumberOfChannels must be defined."
           =2 #  else
 673      =2  /* Value Range Check */
 674      =2  #   if ( kIlNumberOfChannels <= 0)
           =2 #    error  "Error in File Il_Cfg.h: kIlNumberOfChannels must be > 0."
           =2 #   endif
 677      =2  #  endif
 678      =2  
 679      =2  /* Value Existance Check */
 680      =2  #  if !defined( kIlNumberOfIdentities )
           =2 #   error  "Error in File Il_Cfg.h: kIlNumberOfIdentities must be defined."
           =2 #  else
 683      =2  /* Value Range Check */
 684      =2  #   if ( kIlNumberOfIdentities <= 0)
           =2 #    error  "Error in File Il_Cfg.h: kIlNumberOfIdentities must be > 0."
           =2 #   endif
 687      =2  #  endif
 688      =2  
 689      =2  #  if defined( IL_ENABLE_RX )
 690      =2  /* Value Existance Check */
 691      =2  #   if !defined( kIlNumberOfRxObjects )
           =2 #    error  "Error in File Il_Cfg.h: kIlNumberOfRxObjects must be defined if IL_ENABLE_RX is defined."
           =2 #   else
 694      =2  /* Value Range Check */
 695      =2  #    if ( kIlNumberOfRxObjects <= 0)
           =2 #     error  "Error in File Il_Cfg.h: kIlNumberOfRxObjects must be > 0 if IL_ENABLE_RX is defined."
           =2 #    endif
 698      =2  #   endif
 699      =2  /* Value Existance Check */
 700      =2  #   if !defined( kIlCanNumberOfRxObjects )
           =2 #    error  "Error in File Il_Cfg.h: kIlCanNumberOfRxObjects must be defined if IL_ENABLE_RX is defined."
           =2 #   else
 703      =2  /* Value Range Check */
 704      =2  #    if ( kIlCanNumberOfRxObjects <= 0)
           =2 #     error  "Error in File Il_Cfg.h: kIlCanNumberOfRxObjects must be > 0 if IL_ENABLE_RX is defined."
           =2 #    endif
 707      =2  #   endif
 708      =2  #  elif defined( IL_DISABLE_RX )
           =2 /* Value Existance Check */
           =2 #   if defined( kIlNumberOfRxObjects )
           =2 /* Value Range Check */
           =2 #    if ( kIlNumberOfRxObjects != 0 )
           =2 #     error  "Error in File Il_Cfg.h: kIlNumberOfRxObjects must be 0 if IL_DISABLE_RX is defined."
           =2 #    endif
           =2 #   endif
           =2 /* Value Existance Check */
           =2 #   if defined( kIlCanNumberOfRxObjects )
           =2 /* Value Range Check */
           =2 #    if ( kIlCanNumberOfRxObjects != 0 )
           =2 #     error  "Error in File Il_Cfg.h: kIlCanNumberOfRxObjects must be 0 if IL_DISABLE_RX is defined."
           =2 #    endif
           =2 #   endif
           =2 #  endif
 724      =2         /* IL_ENABLE_RX */
 725      =2  
 726      =2  #  if defined( IL_ENABLE_RX_INDICATION_FLAG )
           =2 /* Value Existance Check */
           =2 #   if !defined( kIlNumberOfRxIndicationFlags )
           =2 #    error  "Error in File Il_Cfg.h: kIlNumberOfRxIndicationFlags must be defined if IL_ENABLE_RX_INDICATI
             -ON_FLAG is defined."
           =2 #   else
           =2 /* Value Range Check */
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 375 

           =2 #    if ( kIlNumberOfRxIndicationFlags <= 0)
           =2 #     error  "Error in File Il_Cfg.h: kIlNumberOfRxIndicationFlags must be > 0 if IL_ENABLE_RX_INDICATION_
             -FLAG is defined."
           =2 #    endif
           =2 #   endif
           =2 /* Value Existance Check */
           =2 #   if !defined( kIlNumberOfRxIndicationBits )
           =2 #    error  "Error in File Il_Cfg.h: kIlNumberOfRxIndicationBits must be defined if IL_ENABLE_RX_INDICATIO
             -N_FLAG is defined."
           =2 #   else
           =2 /* Value Range Check */
           =2 #    if ( kIlNumberOfRxIndicationBits <= 0)
           =2 #     error  "Error in File Il_Cfg.h: kIlNumberOfRxIndicationBits must be > 0 if IL_ENABLE_RX_INDICATION_F
             -LAG is defined."
           =2 #    endif
           =2 #   endif
           =2 #  elif defined( IL_DISABLE_RX_INDICATION_FLAG )
 746      =2  /* Value Existance Check */
 747      =2  #   if defined( kIlNumberOfRxIndicationFlags )
           =2 /* Value Range Check */
           =2 #    if ( kIlNumberOfRxIndicationFlags != 0 )
           =2 #     error  "Error in File Il_Cfg.h: kIlNumberOfRxIndicationFlags must be 0 if IL_DISABLE_RX_INDICATION_F
             -LAG is defined."
           =2 #    endif
           =2 #   endif
 753      =2  /* Value Existance Check */
 754      =2  #   if defined( kIlNumberOfRxIndicationBits )
           =2 /* Value Range Check */
           =2 #    if ( kIlNumberOfRxIndicationBits != 0 )
           =2 #     error  "Error in File Il_Cfg.h: kIlNumberOfRxIndicationBits must be 0 if IL_DISABLE_RX_INDICATION_FL
             -AG is defined."
           =2 #    endif
           =2 #   endif
 760      =2  #  endif
 761      =2         /* IL_ENABLE_RX_INDICATION_FLAG */
 762      =2  
 763      =2  #  if defined( IL_ENABLE_RX_FIRSTVALUE_FLAG )
           =2 /* Value Existance Check */
           =2 #   if !defined( kIlNumberOfRxFirstvalueFlags )
           =2 #    error  "Error in File Il_Cfg.h: kIlNumberOfRxFirstvalueFlags must be defined if IL_ENABLE_RX_FIRSTVAL
             -UE_FLAG is defined."
           =2 #   else
           =2 /* Value Range Check */
           =2 #    if ( kIlNumberOfRxFirstvalueFlags <= 0)
           =2 #     error  "Error in File Il_Cfg.h: kIlNumberOfRxFirstvalueFlags must be > 0 if IL_ENABLE_RX_FIRSTVALUE_
             -FLAG is defined."
           =2 #    endif
           =2 #   endif
           =2 #  elif defined( IL_DISABLE_RX_FIRSTVALUE_FLAG )
 774      =2  /* Value Existance Check */
 775      =2  #   if defined( kIlNumberOfRxFirstvalueFlags )
           =2 /* Value Range Check */
           =2 #    if ( kIlNumberOfRxFirstvalueFlags != 0 )
           =2 #     error  "Error in File Il_Cfg.h: kIlNumberOfRxFirstvalueFlags must be 0 if IL_DISABLE_RX_FIRSTVALUE_F
             -LAG is defined."
           =2 #    endif
           =2 #   endif
 781      =2  #  endif
 782      =2         /* IL_ENABLE_RX_FIRSTVALUE_FLAG */
 783      =2  
 784      =2  #  if defined( IL_ENABLE_RX_DATACHANGED_FLAG )
           =2 /* Value Existance Check */
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 376 

           =2 #   if !defined( kIlNumberOfRxDataChangedFlags )
           =2 #    error  "Error in File Il_Cfg.h: kIlNumberOfRxDataChangedFlags must be defined if IL_ENABLE_RX_DATACHA
             -NGED_FLAG is defined."
           =2 #   else
           =2 /* Value Range Check */
           =2 #    if ( kIlNumberOfRxDataChangedFlags <= 0)
           =2 #     error  "Error in File Il_Cfg.h: kIlNumberOfRxDataChangedFlags must be > 0 if IL_ENABLE_RX_DATACHANGE
             -D_FLAG is defined."
           =2 #    endif
           =2 #   endif
           =2 #  elif defined( IL_DISABLE_RX_DATACHANGED_FLAG )
 795      =2  /* Value Existance Check */
 796      =2  #   if defined( kIlNumberOfRxDataChangedFlags )
           =2 /* Value Range Check */
           =2 #    if ( kIlNumberOfRxDataChangedFlags != 0 )
           =2 #     error  "Error in File Il_Cfg.h: kIlNumberOfRxDataChangedFlags must be 0 if IL_DISABLE_RX_DATACHANGED
             -_FLAG is defined."
           =2 #    endif
           =2 #   endif
 802      =2  #  endif
 803      =2         /* IL_ENABLE_RX_DATACHANGED_FLAG */
 804      =2  
 805      =2  #  if defined( IL_ENABLE_RX_TIMEOUT )
 806      =2  /* Value Existance Check */
 807      =2  #   if !defined( kIlNumberOfRxTimeoutCounters )
           =2 #    error  "Error in File Il_Cfg.h: kIlNumberOfRxTimeoutCounters must be defined if IL_ENABLE_RX_TIMEOUT 
             -is defined."
           =2 #   else
 810      =2  /* Value Range Check */
 811      =2  #    if ( kIlNumberOfRxTimeoutCounters <= 0)
           =2 #     error  "Error in File Il_Cfg.h: kIlNumberOfRxTimeoutCounters must be > 0 if IL_ENABLE_RX_TIMEOUT is 
             -defined."
           =2 #    endif
 814      =2  #   endif
 815      =2  /* Value Existance Check */
 816      =2  #   if !defined( kIlNumberOfTimerFlagBytes )
           =2 #    error  "Error in File Il_Cfg.h: kIlNumberOfTimerFlagBytes must be defined if IL_ENABLE_RX_TIMEOUT is 
             -defined."
           =2 #   else
 819      =2  /* Value Range Check */
 820      =2  #    if ( kIlNumberOfTimerFlagBytes <= 0)
           =2 #     error  "Error in File Il_Cfg.h: kIlNumberOfTimerFlagBytes must be > 0 if IL_ENABLE_RX_TIMEOUT is def
             -ined."
           =2 #    endif
 823      =2  #   endif
 824      =2  #  elif defined( IL_DISABLE_RX_TIMEOUT )
           =2 /* Value Existance Check */
           =2 #   if defined( kIlNumberOfRxTimeoutCounters )
           =2 /* Value Range Check */
           =2 #    if ( kIlNumberOfRxTimeoutCounters != 0 )
           =2 #     error  "Error in File Il_Cfg.h: kIlNumberOfRxTimeoutCounters must be 0 if IL_DISABLE_RX_TIMEOUT is d
             -efined."
           =2 #    endif
           =2 #   endif
           =2 /* Value Existance Check */
           =2 #   if defined( kIlNumberOfTimerFlagBytes )
           =2 /* Value Range Check */
           =2 #    if ( kIlNumberOfTimerFlagBytes != 0 )
           =2 #     error  "Error in File Il_Cfg.h: kIlNumberOfTimerFlagBytes must be 0 if IL_DISABLE_RX_TIMEOUT is defi
             -ned."
           =2 #    endif
           =2 #   endif
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 377 

           =2 #  endif
 840      =2         /* IL_ENABLE_RX_TIMEOUT */
 841      =2  
 842      =2  #  if defined( IL_ENABLE_RX_TIMEOUT_FLAG )
 843      =2  /* Value Existance Check */
 844      =2  #   if !defined( kIlNumberOfRxTimeoutFlags )
           =2 #    error  "Error in File Il_Cfg.h: kIlNumberOfRxTimeoutFlags must be defined if IL_ENABLE_RX_TIMEOUT_FLA
             -G is defined."
           =2 #   else
 847      =2  /* Value Range Check */
 848      =2  #    if ( kIlNumberOfRxTimeoutFlags <= 0)
           =2 #     error  "Error in File Il_Cfg.h: kIlNumberOfRxTimeoutFlags must be > 0 if IL_ENABLE_RX_TIMEOUT_FLAG i
             -s defined."
           =2 #    endif
 851      =2  #   endif
 852      =2  #  elif defined( IL_DISABLE_RX_TIMEOUT_FLAG )
           =2 /* Value Existance Check */
           =2 #   if defined( kIlNumberOfRxTimeoutFlags )
           =2 /* Value Range Check */
           =2 #    if ( kIlNumberOfRxTimeoutFlags != 0 )
           =2 #     error  "Error in File Il_Cfg.h: kIlNumberOfRxTimeoutFlags must be 0 if IL_DISABLE_RX_TIMEOUT_FLAG is
             - defined."
           =2 #    endif
           =2 #   endif
           =2 #  endif
 861      =2         /* IL_ENABLE_RX_TIMEOUT_FLAG */
 862      =2  
 863      =2  #  if defined( IL_ENABLE_TX )
           =2 /* Value Existance Check */
           =2 #   if !defined( kIlNumberOfTxObjects )
           =2 #    error  "Error in File Il_Cfg.h: kIlNumberOfTxObjects must be defined if IL_ENABLE_TX is defined."
           =2 #   else
           =2 /* Value Range Check */
           =2 #    if ( kIlNumberOfTxObjects <= 0)
           =2 #     error  "Error in File Il_Cfg.h: kIlNumberOfTxObjects must be > 0 if IL_ENABLE_TX is defined."
           =2 #    endif
           =2 #   endif
           =2 #  elif defined( IL_DISABLE_TX )
 874      =2  /* Value Existance Check */
 875      =2  #   if defined( kIlNumberOfTxObjects )
 876      =2  /* Value Range Check */
 877      =2  #    if ( kIlNumberOfTxObjects != 0 )
           =2 #     error  "Error in File Il_Cfg.h: kIlNumberOfTxObjects must be 0 if IL_DISABLE_TX is defined."
           =2 #    endif
 880      =2  #   endif
 881      =2  #  endif
 882      =2         /* IL_ENABLE_TX */
 883      =2  
 884      =2  #  if defined( IL_ENABLE_TX_CONFIRMATION_FLAG )
           =2 /* Value Existance Check */
           =2 #   if !defined( kIlNumberOfTxConfirmationFlags )
           =2 #    error  "Error in File Il_Cfg.h: kIlNumberOfTxConfirmationFlags must be defined if IL_ENABLE_TX_CONFIR
             -MATION_FLAG is defined."
           =2 #   else
           =2 /* Value Range Check */
           =2 #    if ( kIlNumberOfTxConfirmationFlags <= 0)
           =2 #     error  "Error in File Il_Cfg.h: kIlNumberOfTxConfirmationFlags must be > 0 if IL_ENABLE_TX_CONFIRMAT
             -ION_FLAG is defined."
           =2 #    endif
           =2 #   endif
           =2 #  elif defined( IL_DISABLE_TX_CONFIRMATION_FLAG )
           =2 /* Value Existance Check */
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 378 

           =2 #   if defined( kIlNumberOfTxConfirmationFlags )
           =2 /* Value Range Check */
           =2 #    if ( kIlNumberOfTxConfirmationFlags != 0 )
           =2 #     error  "Error in File Il_Cfg.h: kIlNumberOfTxConfirmationFlags must be 0 if IL_DISABLE_TX_CONFIRMATI
             -ON_FLAG is defined."
           =2 #    endif
           =2 #   endif
           =2 #  endif
 903      =2         /* IL_ENABLE_TX_CONFIRMATION_FLAG */
 904      =2  
 905      =2  #  if defined( IL_DISABLE_TX_VARYING_REPETITION )
           =2 #  elif defined( IL_ENSABLE_TX_VARYING_REPETITION )
           =2 #   if defined( kIlNumberOfTxConfirmationFlags )
           =2 #    if ( kIlNumberOfTxConfirmationFlags != 0 )
           =2 #     error  "Error in File Il_Cfg.h: kIlNumberOfTxConfirmationFlags must be 0 if IL_ENSABLE_TX_VARYING_RE
             -PETITION is defined."
           =2 #    endif
           =2 #   endif
           =2 #  endif
 913      =2         /* IL_ENABLE_TX_VARYING_REPETITION */
 914      =2  
 915      =2  #  if defined( IL_ENABLE_TX_TIMEOUT )
           =2 /* Value Existance Check */
           =2 #   if !defined( kIlNumberOfTxTimeoutCounters )
           =2 #    error  "Error in File Il_Cfg.h: kIlNumberOfTxTimeoutCounters must be defined if IL_ENABLE_TX_TIMEOUT 
             -is defined."
           =2 #   else
           =2 /* Value Range Check */
           =2 #    if ( kIlNumberOfTxTimeoutCounters <= 0)
           =2 #     error  "Error in File Il_Cfg.h: kIlNumberOfTxTimeoutCounters must be > 0 if IL_ENABLE_TX_TIMEOUT is 
             -defined."
           =2 #    endif
           =2 #   endif
           =2 #  elif defined( IL_DISABLE_TX_TIMEOUT )
           =2 /* Value Existance Check */
           =2 #   if defined( kIlNumberOfTxTimeoutCounters )
           =2 /* Value Range Check */
           =2 #    if ( kIlNumberOfTxTimeoutCounters != 0 )
           =2 #     error  "Error in File Il_Cfg.h: kIlNumberOfTxTimeoutCounters must be 0 if IL_DISABLE_TX_TIMEOUT is d
             -efined."
           =2 #    endif
           =2 #   endif
           =2 #  endif
 934      =2         /* IL_ENABLE_TX_TIMEOUT */
 935      =2  
 936      =2  #  if defined( IL_ENABLE_TX_TIMEOUT_FLAG )
           =2 /* Value Existance Check */
           =2 #   if !defined( kIlNumberOfTxTimeoutFlags )
           =2 #    error  "Error in File Il_Cfg.h: kIlNumberOfTxTimeoutFlags must be defined if IL_ENABLE_TX_TIMEOUT_FLA
             -G is defined."
           =2 #   else
           =2 /* Value Range Check */
           =2 #    if ( kIlNumberOfTxTimeoutFlags <= 0)
           =2 #     error  "Error in File Il_Cfg.h: kIlNumberOfTxTimeoutFlags must be > 0 if IL_ENABLE_TX_TIMEOUT_FLAG i
             -s defined."
           =2 #    endif
           =2 #   endif
           =2 #  elif defined( IL_DISABLE_TX_TIMEOUT_FLAG )
           =2 /* Value Existance Check */
           =2 #   if defined( kIlNumberOfTxTimeoutFlags )
           =2 /* Value Range Check */
           =2 #    if ( kIlNumberOfTxTimeoutFlags != 0 )
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 379 

           =2 #     error  "Error in File Il_Cfg.h: kIlNumberOfTxTimeoutFlags must be 0 if IL_DISABLE_TX_TIMEOUT_FLAG is
             - defined."
           =2 #    endif
           =2 #   endif
           =2 #  endif
 955      =2         /* IL_ENABLE_TX_TIMEOUT_FLAG */
 956      =2  
 957      =2  
 958      =2  /* Compiler Switch Integrity Check */
 959      =2  
 960      =2  #  if defined( IL_ENABLE_RX ) && defined( IL_DISABLE_RX )
           =2 #   error "Error in File Il_Cfg.h: 'IL_ENABLE_RX' and 'IL_DISABLE_RX' is defined."
           =2 #  endif
 963      =2  #  if defined( IL_ENABLE_RX_DATACHANGED_FLAG ) && defined( IL_DISABLE_RX_DATACHANGED_FLAG )
           =2 #   error "Error in File Il_Cfg.h: 'IL_ENABLE_RX_DATACHANGED_FLAG' and 'IL_DISABLE_RX_DATACHANGED_FLAG' is
             - defined."
           =2 #  endif
 966      =2  #  if defined( IL_ENABLE_RX_DEFAULTVALUE ) && defined( IL_DISABLE_RX_DEFAULTVALUE )
           =2 #   error "Error in File Il_Cfg.h: 'IL_ENABLE_RX_DEFAULTVALUE' and 'IL_DISABLE_RX_DEFAULTVALUE' is defined
             -."
           =2 #  endif
 969      =2  #  if defined( IL_ENABLE_RX_DYNAMIC_TIMEOUT ) && defined( IL_DISABLE_RX_DYNAMIC_TIMEOUT )
           =2 #   error "Error in File Il_Cfg.h: 'IL_ENABLE_RX_DYNAMIC_TIMEOUT' and 'IL_DISABLE_RX_DYNAMIC_TIMEOUT' is d
             -efined."
           =2 #  endif
 972      =2  #  if defined( IL_ENABLE_RX_FIRSTVALUE_FLAG ) && defined( IL_DISABLE_RX_FIRSTVALUE_FLAG )
           =2 #   error "Error in File Il_Cfg.h: 'IL_ENABLE_RX_FIRSTVALUE_FLAG' and 'IL_DISABLE_RX_FIRSTVALUE_FLAG' is d
             -efined."
           =2 #  endif
 975      =2  #  if defined( IL_ENABLE_RX_INDICATION_FLAG ) && defined( IL_DISABLE_RX_INDICATION_FLAG )
           =2 #   error "Error in File Il_Cfg.h: 'IL_ENABLE_RX_INDICATION_FLAG' and 'IL_DISABLE_RX_INDICATION_FLAG' is d
             -efined."
           =2 #  endif
 978      =2  #  if defined( IL_ENABLE_RX_INTERRUPT ) && defined( IL_DISABLE_RX_INTERRUPT )
           =2 #   error "Error in File Il_Cfg.h: 'IL_ENABLE_RX_INTERRUPT' and 'IL_DISABLE_RX_INTERRUPT' is defined."
           =2 #  endif
 981      =2  #  if defined( IL_ENABLE_RX_MODE_SIGNALS ) && defined( IL_DISABLE_RX_MODE_SIGNALS )
           =2 #   error "Error in File Il_Cfg.h: 'IL_ENABLE_RX_MODE_SIGNALS' and 'IL_DISABLE_RX_MODE_SIGNALS' is defined
             -."
           =2 #  endif
 984      =2  #  if defined( IL_ENABLE_RX_POLLING ) && defined( IL_DISABLE_RX_POLLING )
           =2 #   error "Error in File Il_Cfg.h: 'IL_ENABLE_RX_POLLING' and 'IL_DISABLE_RX_POLLING' is defined."
           =2 #  endif
 987      =2  #  if defined( IL_ENABLE_RX_SIGNAL_START_FCT ) && defined( IL_DISABLE_RX_SIGNAL_START_FCT )
           =2 #   error "Error in File Il_Cfg.h: 'IL_ENABLE_RX_SIGNAL_START_FCT' and 'IL_DISABLE_RX_SIGNAL_START_FCT' is
             - defined."
           =2 #  endif
 990      =2  #  if defined( IL_ENABLE_RX_SIGNAL_STOP_FCT ) && defined( IL_DISABLE_RX_SIGNAL_STOP_FCT )
           =2 #   error "Error in File Il_Cfg.h: 'IL_ENABLE_RX_SIGNAL_STOP_FCT' and 'IL_DISABLE_RX_SIGNAL_STOP_FCT' is d
             -efined."
           =2 #  endif
 993      =2  #  if defined( IL_ENABLE_RX_START_DEFAULTVALUE ) && defined( IL_DISABLE_RX_START_DEFAULTVALUE )
           =2 #   error "Error in File Il_Cfg.h: 'IL_ENABLE_RX_START_DEFAULTVALUE' and 'IL_DISABLE_RX_START_DEFAULTVALUE
             -' is defined."
           =2 #  endif
 996      =2  #  if defined( IL_ENABLE_RX_STOP_DEFAULTVALUE ) && defined( IL_DISABLE_RX_STOP_DEFAULTVALUE )
           =2 #   error "Error in File Il_Cfg.h: 'IL_ENABLE_RX_STOP_DEFAULTVALUE' and 'IL_DISABLE_RX_STOP_DEFAULTVALUE' 
             -is defined."
           =2 #  endif
 999      =2  #  if defined( IL_ENABLE_RX_TIMEOUT ) && defined( IL_DISABLE_RX_TIMEOUT )
           =2 #   error "Error in File Il_Cfg.h: 'IL_ENABLE_RX_TIMEOUT' and 'IL_DISABLE_RX_TIMEOUT' is defined."
           =2 #  endif
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 380 

1002      =2  #  if defined( IL_ENABLE_RX_TIMEOUT_DELAY ) && defined( IL_DISABLE_RX_TIMEOUT_DELAY )
           =2 #   error "Error in File Il_Cfg.h: 'IL_ENABLE_RX_TIMEOUT_DELAY' and 'IL_DISABLE_RX_TIMEOUT_DELAY' is defin
             -ed."
           =2 #  endif
1005      =2  #  if defined( IL_ENABLE_RX_TIMEOUT_FLAG ) && defined( IL_DISABLE_RX_TIMEOUT_FLAG )
           =2 #   error "Error in File Il_Cfg.h: 'IL_ENABLE_RX_TIMEOUT_FLAG' and 'IL_DISABLE_RX_TIMEOUT_FLAG' is defined
             -."
           =2 #  endif
1008      =2  #  if defined( IL_ENABLE_SYS_ARGCHECK ) && defined( IL_DISABLE_SYS_ARGCHECK )
           =2 #   error "Error in File Il_Cfg.h: 'IL_ENABLE_SYS_ARGCHECK' and 'IL_DISABLE_SYS_ARGCHECK' is defined."
           =2 #  endif
1011      =2  #  if defined( IL_ENABLE_SYS_INIT_FCT ) && defined( IL_DISABLE_SYS_INIT_FCT )
           =2 #   error "Error in File Il_Cfg.h: 'IL_ENABLE_SYS_INIT_FCT' and 'IL_DISABLE_SYS_INIT_FCT' is defined."
           =2 #  endif
1014      =2  #  if defined ( VGEN_GENY )
1015      =2  #   if defined( IL_ENABLE_SYS_MULTI_ECU_PHYS ) && defined( IL_DISABLE_SYS_MULTI_ECU_PHYS )
           =2 #    error "Error in File Il_Cfg.h: 'IL_ENABLE_SYS_MULTI_ECU_PHYS' and 'IL_DISABLE_SYS_MULTI_ECU_PHYS' is 
             -defined."
           =2 #   endif
1018      =2  #  else
           =2 #   if defined( IL_ENABLE_SYS_MULTIPLE_NODES ) && defined( IL_DISABLE_SYS_MULTIPLE_NODES )
           =2 #    error "Error in File Il_Cfg.h: 'IL_ENABLE_SYS_MULTIPLE_NODES' and 'IL_DISABLE_SYS_MULTIPLE_NODES' is 
             -defined."
           =2 #   endif
           =2 #  endif
1023      =2  #  if defined( IL_ENABLE_SYS_RX_START_FCT ) && defined( IL_DISABLE_SYS_RX_START_FCT )
           =2 #   error "Error in File Il_Cfg.h: 'IL_ENABLE_SYS_RX_START_FCT' and 'IL_DISABLE_SYS_RX_START_FCT' is defin
             -ed."
           =2 #  endif
1026      =2  #  if defined( IL_ENABLE_SYS_RX_STOP_FCT ) && defined( IL_DISABLE_SYS_RX_STOP_FCT )
           =2 #   error "Error in File Il_Cfg.h: 'IL_ENABLE_SYS_RX_STOP_FCT' and 'IL_DISABLE_SYS_RX_STOP_FCT' is defined
             -."
           =2 #  endif
1029      =2  #  if defined( IL_ENABLE_SYS_SIGNAL_INIT_FCT ) && defined( IL_DISABLE_SYS_SIGNAL_INIT_FCT )
           =2 #   error "Error in File Il_Cfg.h: 'IL_ENABLE_SYS_SIGNAL_INIT_FCT' and 'IL_DISABLE_SYS_SIGNAL_INIT_FCT' is
             - defined."
           =2 #  endif
1032      =2  #  if defined( IL_ENABLE_SYS_TESTDEBUG ) && defined( IL_DISABLE_SYS_TESTDEBUG )
           =2 #   error "Error in File Il_Cfg.h: 'IL_ENABLE_SYS_TESTDEBUG' and 'IL_DISABLE_SYS_TESTDEBUG' is defined."
           =2 #  endif
1035      =2  #  if defined( IL_ENABLE_TX ) && defined( IL_DISABLE_TX )
           =2 #   error "Error in File Il_Cfg.h: 'IL_ENABLE_TX' and 'IL_DISABLE_TX' is defined."
           =2 #  endif
1038      =2  #  if defined( IL_ENABLE_TX_CONFIRMATION_FLAG ) && defined( IL_DISABLE_TX_CONFIRMATION_FLAG )
           =2 #   error "Error in File Il_Cfg.h: 'IL_ENABLE_TX_CONFIRMATION_FLAG' and 'IL_DISABLE_TX_CONFIRMATION_FLAG' 
             -is defined."
           =2 #  endif
1041      =2  #  if defined( IL_ENABLE_TX_CYCLIC_EVENT ) && defined( IL_DISABLE_TX_CYCLIC_EVENT )
           =2 #   error "Error in File Il_Cfg.h: 'IL_ENABLE_TX_CYCLIC_EVENT' and 'IL_DISABLE_TX_CYCLIC_EVENT' is defined
             -."
           =2 #  endif
1044      =2  #  if defined( IL_ENABLE_TX_DEFAULTVALUE ) && defined( IL_DISABLE_TX_DEFAULTVALUE )
           =2 #   error "Error in File Il_Cfg.h: 'IL_ENABLE_TX_DEFAULTVALUE' and 'IL_DISABLE_TX_DEFAULTVALUE' is defined
             -."
           =2 #  endif
1047      =2  #  if defined( IL_ENABLE_TX_DYNAMIC_CYCLETIME ) && defined( IL_DISABLE_TX_DYNAMIC_CYCLETIME )
           =2 #   error "Error in File Il_Cfg.h: 'IL_ENABLE_TX_DYNAMIC_CYCLETIME' and 'IL_DISABLE_TX_DYNAMIC_CYCLETIME' 
             -is defined."
           =2 #  endif
1050      =2  #  if defined( IL_ENABLE_TX_FAST_ON_START ) && defined( IL_DISABLE_TX_FAST_ON_START )
           =2 #   error "Error in File Il_Cfg.h: 'IL_ENABLE_TX_FAST_ON_START' and 'IL_DISABLE_TX_FAST_ON_START' is defin
             -ed."
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 381 

           =2 #  endif
1053      =2  #  if defined( IL_ENABLE_TX_INTERRUPT ) && defined( IL_DISABLE_TX_INTERRUPT )
           =2 #   error "Error in File Il_Cfg.h: 'IL_ENABLE_TX_INTERRUPT' and 'IL_DISABLE_TX_INTERRUPT' is defined."
           =2 #  endif
1056      =2  #  if defined( IL_ENABLE_TX_MODE_SIGNALS ) && defined( IL_DISABLE_TX_MODE_SIGNALS )
           =2 #   error "Error in File Il_Cfg.h: 'IL_ENABLE_TX_MODE_SIGNALS' and 'IL_DISABLE_TX_MODE_SIGNALS' is defined
             -."
           =2 #  endif
1059      =2  #  if defined( IL_ENABLE_TX_POLLING ) && defined( IL_DISABLE_TX_POLLING )
           =2 #   error "Error in File Il_Cfg.h: 'IL_ENABLE_TX_POLLING' and 'IL_DISABLE_TX_POLLING' is defined."
           =2 #  endif
1062      =2  #  if defined( IL_ENABLE_TX_SECURE_EVENT ) && defined( IL_DISABLE_TX_SECURE_EVENT )
           =2 #   error "Error in File Il_Cfg.h: 'IL_ENABLE_TX_SECURE_EVENT' and 'IL_DISABLE_TX_SECURE_EVENT' is defined
             -."
           =2 #  endif
1065      =2  #  if defined( IL_ENABLE_TX_SEND_ON_INIT ) && defined( IL_DISABLE_TX_SEND_ON_INIT )
           =2 #   error "Error in File Il_Cfg.h: 'IL_ENABLE_TX_SEND_ON_INIT' and 'IL_DISABLE_TX_SEND_ON_INIT' is defined
             -."
           =2 #  endif
1068      =2  #  if defined( IL_ENABLE_TX_SIGNAL_START_FCT ) && defined( IL_DISABLE_TX_SIGNAL_START_FCT )
           =2 #   error "Error in File Il_Cfg.h: 'IL_ENABLE_TX_SIGNAL_START_FCT' and 'IL_DISABLE_TX_SIGNAL_START_FCT' is
             - defined."
           =2 #  endif
1071      =2  #  if defined( IL_ENABLE_TX_SIGNAL_STOP_FCT ) && defined( IL_DISABLE_TX_SIGNAL_STOP_FCT )
           =2 #   error "Error in File Il_Cfg.h: 'IL_ENABLE_TX_SIGNAL_STOP_FCT' and 'IL_DISABLE_TX_SIGNAL_STOP_FCT' is d
             -efined."
           =2 #  endif
1074      =2  #  if defined( IL_ENABLE_TX_START_DEFAULTVALUE ) && defined( IL_DISABLE_TX_START_DEFAULTVALUE )
           =2 #   error "Error in File Il_Cfg.h: 'IL_ENABLE_TX_START_DEFAULTVALUE' and 'IL_DISABLE_TX_START_DEFAULTVALUE
             -' is defined."
           =2 #  endif
1077      =2  #  if defined( IL_ENABLE_TX_STARTSTOP_CYCLIC ) && defined( IL_DISABLE_TX_STARTSTOP_CYCLIC )
           =2 #   error "Error in File Il_Cfg.h: 'IL_ENABLE_TX_STARTSTOP_CYCLIC' and 'IL_DISABLE_TX_STARTSTOP_CYCLIC' is
             - defined."
           =2 #  endif
1080      =2  #  if defined( IL_ENABLE_TX_STOP_DEFAULTVALUE ) && defined( IL_DISABLE_TX_STOP_DEFAULTVALUE )
           =2 #   error "Error in File Il_Cfg.h: 'IL_ENABLE_TX_STOP_DEFAULTVALUE' and 'IL_DISABLE_TX_STOP_DEFAULTVALUE' 
             -is defined."
           =2 #  endif
1083      =2  #  if defined( IL_ENABLE_TX_TIMEOUT ) && defined( IL_DISABLE_TX_TIMEOUT )
           =2 #   error "Error in File Il_Cfg.h: 'IL_ENABLE_TX_TIMEOUT' and 'IL_DISABLE_TX_TIMEOUT' is defined."
           =2 #  endif
1086      =2  #  if defined( IL_ENABLE_TX_TIMEOUT_FLAG ) && defined( IL_DISABLE_TX_TIMEOUT_FLAG )
           =2 #   error "Error in File Il_Cfg.h: 'IL_ENABLE_TX_TIMEOUT_FLAG' and 'IL_DISABLE_TX_TIMEOUT_FLAG' is defined
             -."
           =2 #  endif
1089      =2  #  if defined( IL_ENABLE_TX_VARYING_REPETITION ) && defined( IL_DISABLE_TX_VARYING_REPETITION )
           =2 #   error "Error in File Il_Cfg.h: 'IL_ENABLE_TX_VARYING_REPETITION' and 'IL_DISABLE_TX_VARYING_REPETITION
             -' is defined."
           =2 #  endif
1092      =2  #  if defined( IL_ENABLE_TX_VARYING_TIMEOUT ) && defined( IL_DISABLE_TX_VARYING_TIMEOUT )
           =2 #   error "Error in File Il_Cfg.h: 'IL_ENABLE_TX_VARYING_TIMEOUT' and 'IL_DISABLE_TX_VARYING_TIMEOUT' is d
             -efined."
           =2 #  endif
1095      =2  #  if defined( IL_ENABLE_SYS_TX_START_FCT ) && defined( IL_DISABLE_SYS_TX_START_FCT )
           =2 #   error "Error in File Il_Cfg.h: 'IL_ENABLE_SYS_TX_START_FCT' and 'IL_DISABLE_SYS_TX_START_FCT' is defin
             -ed."
           =2 #  endif
1098      =2  #  if defined( IL_ENABLE_SYS_TX_STOP_FCT ) && defined( IL_DISABLE_SYS_TX_STOP_FCT )
           =2 #   error "Error in File Il_Cfg.h: 'IL_ENABLE_SYS_TX_STOP_FCT' and 'IL_DISABLE_SYS_TX_STOP_FCT' is defined
             -."
           =2 #  endif
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 382 

1101      =2  
1102      =2  # endif/* VGEN_GENY */
1103      =2  
1104      =2  /* Feature Compatibility *********************************************************************************
             -************/
1105      =2  # if defined ( VGEN_GENY )
1106      =2  #  if defined ( IL_ENABLE_SYS_MULTIPLE_NODES )
           =2 #   error "The compiler switch IL_ENABLE_SYS_MULTIPLE_NODES is not used any more in Geny by Il_Vector!"
           =2 #  endif
1109      =2  # endif
1110      =2  
1111      =2  /* Hardware Compiler Compatibility Check *****************************************************************
             -************/
1112      =2  # if defined ( VGEN_GENY )
1113      =2  
1114      =2  /* Check supported C_COMP switches for VGEN_GENY */
1115      =2  
1116      =2  # else/* VGEN_GENY */
           =2 
           =2 /* Target Specific */
           =2 
           =2 # endif/* VGEN_GENY */
1121      =2  
1122      =2  # if !defined ( IL_MEMROM1 )
           =2 #  error "IL_MEMROM1 must be defined!"
           =2 # endif
1125      =2  # if !defined ( IL_MEMROM2 )
           =2 #  error "IL_MEMROM2 must be defined!"
           =2 # endif
1128      =2  # if !defined ( IL_MEMROM3 )
           =2 #  error "IL_MEMROM3 must be defined!"
           =2 # endif
1131      =2  
1132      =2  /*********************************************************************************************************
             -*************
1133      =2    GLOBAL FUNCTION MACROS
1134      =2  **********************************************************************************************************
             -************/
1135      =2  
1136      =2  
1137      =2  
1138      =2  /*********************************************************************************************************
             -*************
1139      =2    IlGetTxDataPtr
1140      =2  **********************************************************************************************************
             -************/
1141      =2  /** \brief    This method returns the pointer to the buffer of a tx message.
1142      =2      \param    ilTxHnd  Handle of an IL tx message.
1143      =2      \return   vuint8*  Pointer to the databuffer.
1144      =2  **********************************************************************************************************
             -************/
1145      =2  # if defined( IL_ENABLE_TX_MODE_SIGNALS ) 
           =2 #  define  IlGetTxDataPtr(ilTxHnd)                  (IlTxDataPtr[(ilTxHnd)])
           =2 # else
1148      =2  #  define  IlGetTxDataPtr(ilTxHnd)                  (CanGetTxDataPtr(IlGetIlTxIndirection((ilTxHnd))))
1149      =2  # endif
1150      =2  
1151      =2  /*********************************************************************************************************
             -*************
1152      =2    IlGetTxDlc
1153      =2  **********************************************************************************************************
             -************/
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 383 

1154      =2  /** \brief    This method returns the data length code of a tx message.
1155      =2      \param    ilTxHnd  Handle of an IL tx message.
1156      =2      \return   vuint8   Dlc of the tx message in bytes.
1157      =2  **********************************************************************************************************
             -************/
1158      =2  # if defined( IL_ENABLE_TX_MODE_SIGNALS ) 
           =2 #  define  IlGetTxDlc(ilTxHnd)                      (IlTxDLC[(ilTxHnd)])
           =2 # else
1161      =2  #  define  IlGetTxDlc(ilTxHnd)                      (XT_TX_DLC(CanGetTxDlc(IlGetIlTxIndirection((ilTxHnd))
             -)))
1162      =2  # endif
1163      =2  
1164      =2  
1165      =2  /*********************************************************************************************************
             -*************
1166      =2    IlGetIlTxIndirection
1167      =2  **********************************************************************************************************
             -************/
1168      =2  /** \brief    This method returns the Can Driver Handle of a IL tx message.
1169      =2      \param    ilTxHnd  Handle of an IL tx message.
1170      =2      \return   CanTransmitHandle  Can Driver tx message handle.
1171      =2  **********************************************************************************************************
             -************/
1172      =2  # if defined( IL_ENABLE_SYS_MULTI_ECU_PHYS )
           =2 #  define IlGetIlTxIndirection(ilTxHnd)             (IlTxIndirection[V_ACTIVE_IDENTITY_LOG][(ilTxHnd)])
           =2 # else
1175      =2  #  define IlGetIlTxIndirection(ilTxHnd)             (IlTxIndirection[(ilTxHnd)])
1176      =2  # endif
1177      =2  
1178      =2  
1179      =2  /*********************************************************************************************************
             -*************
1180      =2    IlGetRxMsgStartIndex
1181      =2  **********************************************************************************************************
             -************/
1182      =2  /** \brief    This method returns the first Il Rx message handle of the channel
1183      =2                in a kIlNumberOfRxObjects sorted table.
1184      =2      \param    channel      Handle of the CAN channel.
1185      =2      \return   IlReceiveHandle  Il Rx message handle
1186      =2  **********************************************************************************************************
             -************/
1187      =2  # if defined ( C_MULTIPLE_RECEIVE_CHANNEL ) && (kIlNumberOfChannels > 1)
           =2 #  define IlGetRxMsgStartIndex(channel)      (IlRxMsgStartIndex[channel])
           =2 # else
1190      =2  #  define IlGetRxMsgStartIndex(channel)      0
1191      =2  # endif
1192      =2  
1193      =2  /*********************************************************************************************************
             -*************
1194      =2    IlGetTxMsgStartIndex
1195      =2  **********************************************************************************************************
             -************/
1196      =2  /** \brief    This method returns the first IL Tx message handle of the channel
1197      =2                in a kIlNumberOfTxObjects sorted table.
1198      =2      \param    channel      Handle of the CAN channel.
1199      =2      \return   IlTransmitHandle  Il Tx message handle
1200      =2  **********************************************************************************************************
             -************/
1201      =2  # if defined ( C_MULTIPLE_RECEIVE_CHANNEL ) && (kIlNumberOfChannels > 1)
           =2 #  define IlGetTxMsgStartIndex(channel)      (IlTxMsgStartIndex[channel])
           =2 # else
1204      =2  #  define IlGetTxMsgStartIndex(channel)      0
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 384 

1205      =2  # endif
1206      =2  
1207      =2  /*********************************************************************************************************
             -*************
1208      =2    Il_ChannelState
1209      =2  **********************************************************************************************************
             -************/
1210      =2  /** \brief    This method serves to access the ilChannelState variable of a channel.
1211      =2      \param    channel      Handle of the CAN channel.
1212      =2      \return   vuint8       This variable contains the current state of a channel bit coded.
1213      =2                             Use the DecodeChannelState and ModifyChannelState macros to extract
1214      =2                             the current state of the channel.
1215      =2  **********************************************************************************************************
             -************/
1216      =2  # if defined( C_MULTIPLE_RECEIVE_CHANNEL ) && (kIlNumberOfChannels > 1)
           =2 #  define Il_ChannelState(channel)    (ilChannelState[(channel)])
           =2 # else
1219      =2  #  define Il_ChannelState(channel)    (ilChannelState)
1220      =2  # endif
1221      =2  
1222      =2  # if defined( IL_ENABLE_TX ) && defined( IL_ENABLE_TX_SECURE_EVENT )
           =2 /*********************************************************************************************************
             -*************
           =2   IlGetTxRepetitionCounter
           =2 **********************************************************************************************************
             -************/
           =2 /** \brief    This method returns the number of repetitions for an IL Tx handle.
           =2     \param    ilTxHnd      Handle of an IL Tx message.
           =2     \return   IltTxRepetitionCounter  Number of Repetitions.
           =2 **********************************************************************************************************
             -************/
           =2 #  if defined ( VGEN_GENY )
           =2 #   if defined( IL_ENABLE_TX_VARYING_REPETITION )
           =2 #    define IlGetTxRepetitionCounter(ilTxHnd)       (IlTxRepetitionCounters[ilTxHnd])
           =2 #   else
           =2 #    define IlGetTxRepetitionCounter(ilTxHnd)       ((IltTxRepetitionCounter) kIlNumberOfTxRepetitions)
           =2 #   endif
           =2 #  else
           =2 #   define IlGetTxRepetitionCounter(ilTxHnd)        ((IltTxRepetitionCounter) kIlNumberOfTxRepetitions)
           =2 #  endif/* VGEN_GENY */
           =2 # endif/* IL_ENABLE_TX && IL_ENABLE_TX_SECURE_EVENT */
1240      =2  
1241      =2  /*********************************************************************************************************
             -*************
1242      =2    DecodeChannelState
1243      =2  **********************************************************************************************************
             -************/
1244      =2  /** \defgroup DecodeChannelState Decode Il_ChannelState
1245      =2      \brief    These macros shall be used to decode the return value of Il_ChannelState.
1246      =2      \param    channel      Handle of the CAN channel.
1247      =2      \return   (vuint8) 0 : The channel is not in the state.\n
1248      =2                > 0        : The channel is in the state.
1249      =2  */
1250      =2  /**\{*/
1251      =2  /** Rx is suspended  */
1252      =2  # define RxSuspended(channel) ((Il_ChannelState((channel)) & (kIlIsRxRun | kIlIsRxWait))==0)
1253      =2  /** Rx is running  */
1254      =2  # define RxEnabled(channel)   ((Il_ChannelState((channel)) & kIlIsRxRun) != 0)
1255      =2  /**\} */
1256      =2  
1257      =2  
1258      =2  /*********************************************************************************************************
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 385 

             -*************
1259      =2    IlGetStatusReturnValue
1260      =2  **********************************************************************************************************
             -************/
1261      =2  /** \defgroup IlGetStatusReturnValue Decode IlGetStatus Return Value
1262      =2      \brief    These macros shall be used to decode the return value of IlGetStatus.
1263      =2      \param    state           Il_Status returned from IlGetStatus.
1264      =2      \return   (Il_Status) 0 : The channel is not in the state.\n
1265      =2                > 0           : The channel is in the state.
1266      =2  */
1267      =2  /**\{*/
1268      =2  /** Tx is running */
1269      =2  # define IlIsTxRun(state)          (((state) & kIlIsTxRun)               ? 1 : 0)
1270      =2  /** Tx is waiting */
1271      =2  # define IlIsTxWait(state)         (((state) & kIlIsTxWait)              ? 1 : 0)
1272      =2  /** Tx is suspended */
1273      =2  # define IlIsTxSuspend(state)      (((state) & (kIlIsTxWait|kIlIsTxRun)) ? 0 : 1)
1274      =2  /** Rx is running */
1275      =2  # define IlIsRxRun(state)          (((state) & kIlIsRxRun)               ? 1 : 0)
1276      =2  /** Rx is waiting */
1277      =2  # define IlIsRxWait(state)         (((state) & kIlIsRxWait)              ? 1 : 0)
1278      =2  /** Rx is suspended */
1279      =2  # define IlIsRxSuspend(state)      (((state) & (kIlIsRxWait|kIlIsRxRun)) ? 0 : 1)
1280      =2  /**\} */
1281      =2  
1282      =2  # if defined ( VGEN_GENY )
1283      =2  /** IL Abstraction of CanGlobalInterruptDisable. */
1284      =2  #  define IlEnterCriticalFlagAccess() CanGlobalInterruptDisable()
1285      =2  /** IL Abstraction of CanGlobalInterruptRestore. */
1286      =2  #  define IlLeaveCriticalFlagAccess() CanGlobalInterruptRestore()
1287      =2  
1288      =2  #  if defined( IL_ENABLE_RX_TIMEOUT ) && defined( IL_ENABLE_RX_DYNAMIC_TIMEOUT )
           =2 /*********************************************************************************************************
             -*************
           =2   IlConvertMs2RxToutCnt
           =2 **********************************************************************************************************
             -************/
           =2 /** \brief    This method calculates the number of IlRxTask calls in a channel for a Rx timeout time.
           =2     \param    ilChannelCycles  cycle time of IlRxTask calls in milliseconds
           =2     \param    msTime           Rx timeout time time in milliseconds
           =2     \return   IltRxTimeoutCounter   The Rx timeout counter in multiples of IlRxTask calls of this channel.
           =2 **********************************************************************************************************
             -************/
           =2 #   define IlConvertMs2RxToutCnt(ilChannelCycles, msTime)         ((IltRxTimeoutCounter) ((msTime) / (ilCh
             -annelCycles)))
           =2 /*********************************************************************************************************
             -*************
           =2   IlConvertRxToutCnt2Ms
           =2 **********************************************************************************************************
             -************/
           =2 /** \brief    This method returns currently set ilRxDynamicTimeoutCounter in milliseconds.
           =2     \param    ilChannelCycles  cycle time of IlRxTask calls in milliseconds
           =2     \param    ilRxTimeoutHnd   Rx timeout handle
           =2     \return   The current Rx timeout in milliseconds for the Rx timeout handle
           =2 **********************************************************************************************************
             -************/
           =2 #   define IlConvertRxToutCnt2Ms(ilChannelCycles, ilRxTimeoutHnd) (ilRxDynamicTimeoutCounter[(ilRxTimeoutH
             -nd)] * (ilChannelCycles))
           =2 #  endif
1308      =2  
1309      =2  #  if defined( IL_ENABLE_TX_DYNAMIC_CYCLETIME )
           =2 /*********************************************************************************************************
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 386 

             -*************
           =2   IlConvertChannelCyclesAndMs2TxTicks
           =2 **********************************************************************************************************
             -************/
           =2 /** \brief    This method returns currently set ilRxDynamicTimeoutCounter in milliseconds.
           =2     \param    ilChannelCycles  cycle time of IlRxTask calls in milliseconds
           =2     \param    ilMsTime         Rx timeout handle
           =2     \return   IltTxCounter     The current Rx timeout in milliseconds for the Rx timeout handle
           =2 **********************************************************************************************************
             -************/
           =2 #   define IlConvertChannelCyclesAndMs2TxTicks(ilChannelCycles, ilMsTime)    ((IltTxCounter) ((ilMsTime) /
             - (ilChannelCycles)))
           =2 
           =2 /*********************************************************************************************************
             -*************
           =2   IlSetDynTxCycleTimeMs
           =2 **********************************************************************************************************
             -************/
           =2 /** \brief    Sets the cycle time of an il message.
           =2 
           =2               The macro is called from the application. The function has no effect, if the il message hand
             -le is not 
           =2               transmitted cyclically. This is defined in the dbc file with the attibutes GenMsgSendType an
             -d
           =2               GenSigSendType. Please refer to the technical reference for details. To activate the cyclic 
             -transmission
           =2               of an il message handle use the il API function IlStartCycle.
           =2   
           =2     \param_i ilChannelCycles : This value is the call cycle time of the IlTxTask in the current channel in
           =2                                milliseconds. The value is generated to the file il_cfg.h as define
           =2                                e.g. for channel 1 kIlTxCycleTime_1
           =2     \param   ilTxHnd       This value is the handle of the Tx message. The generated file il_par.h contain
             -s generated
           =2                            defines for the message handles.
           =2     \param   ilMsTime      This value is the time in milliseconds, until the cyclic event is raised. The v
             -alue has to
           =2                            be smaller than 65534.
           =2     \return  none
           =2     \context The macro must be called within the Il callback function ApplIlInit or in the signal oriented
             - init callback function.
           =2     \warning Do not use the macro for handles containing multiplexed signals.
           =2 **********************************************************************************************************
             -************/
           =2 #   if defined( C_MULTIPLE_RECEIVE_CHANNEL ) && (kIlNumberOfChannels > 1)
           =2 #    define IlSetDynTxCycleTimeMs(ilChannelCycles, ilTxHnd, ilMsTime)          IlSetDynTxCycleTimeRaw((ilT
             -xHnd), IlConvertChannelCyclesAndMs2TxTicks((ilChannelCycles), (ilMsTime)))
           =2 #   else
           =2 #    define IlSetDynTxCycleTimeMs(ilTxHnd, ilMsTime)                           IlSetDynTxCycleTimeRaw((ilT
             -xHnd), IlConvertChannelCyclesAndMs2TxTicks((kIlTxCycleTime), (ilMsTime)))
           =2 #   endif
           =2 
           =2 #  endif/* IL_ENABLE_TX_DYNAMIC_CYCLETIME */
1348      =2  # endif/* VGEN_GENY */
1349      =2  
1350      =2  /** \ingroup CompatibilityAUTOSAR */
1351      =2  /**\{*/
1352      =2  #  if defined ( IL_ENABLE_TX )
           =2 #   define IlGetTxConfirmationFlags(x)   (CanConfirmationFlags._c[x])
           =2 #   define IlGetTxConfirmationMask(x)    (CanGetConfirmationMask(x))
           =2 #   define IlGetTxConfirmationOffset(x)  (CanGetConfirmationOffset(x))
           =2 #  endif
1357      =2  
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 387 

1358      =2  #  if defined ( IL_ENABLE_RX ) && defined ( IL_ENABLE_RX_POLLING )
           =2 #   define IlGetRxIndicationFlags(x)     (CanIndicationFlags._c[x])
           =2 #   define IlGetRxIndicationMask(x)      (CanGetIndicationMask(x))
           =2 #   define IlGetRxIndicationOffset(x)    (CanGetIndicationOffset(x))
           =2 #  endif
1363      =2  /**\}*/
1364      =2  
1365      =2  /*********************************************************************************************************
             -*************
1366      =2    GLOBAL DATA TYPES AND STRUCTURES
1367      =2  **********************************************************************************************************
             -************/
1368      =2  typedef void (*IlTxModeCopyFct) (void);
1369      =2  typedef void (*IlIndicationFct) (void);
1370      =2  typedef void (*IlTimeoutIndicationFct) (void);
1371      =2  typedef void (*IlConfirmationFct) (void);
1372      =2  typedef vsint8 Il_Status;
1373      =2  typedef vsint8 Il_Boolean;
1374      =2  
1375      =2  # if defined ( VGEN_GENY )
1376      =2  #  if ( kIlNumberOfTxObjects < 256 )
1377      =2  typedef vuint8 IlTransmitHandle;
1378      =2  #  endif
1379      =2  #  if ( kIlNumberOfTxObjects >= 256 ) && ( kIlNumberOfTxObjects < 65536 )
           =2 typedef vuint16 IlTransmitHandle;
           =2 #  endif
1382      =2  #  if ( kIlNumberOfTxObjects >= 65536 )
           =2 #   error "The Maximum Number of supported Tx Objects is exceeded"
           =2 #  endif
1385      =2  
1386      =2  #  if ( kIlNumberOfRxObjects < 256 )
1387      =2  typedef vuint8 IlReceiveHandle;
1388      =2  #  endif
1389      =2  #  if ( kIlNumberOfRxObjects >= 256 ) && ( kIlNumberOfRxObjects < 65536 )
           =2 typedef vuint16 IlReceiveHandle;
           =2 #  endif
1392      =2  #  if ( kIlNumberOfRxObjects >= 65536 )
           =2 #   error "The Maximum Number of supported Rx Objects is exceeded"
           =2 #  endif
1395      =2  
1396      =2  #  if defined ( IL_ENABLE_RX_INDICATION_FLAG )
           =2 #   if ( kIlNumberOfRxIndicationBits < 256 )
           =2 typedef vuint8 IlReceiveFlagHandle;
           =2 #   endif
           =2 #   if ( kIlNumberOfRxIndicationBits >= 256 ) && ( kIlNumberOfRxIndicationBits < 65536 )
           =2 typedef vuint16 IlReceiveFlagHandle;
           =2 #   endif
           =2 #   if ( kIlNumberOfRxIndicationBits >= 65536 )
           =2 #    error "The Maximum Number of supported Rx Objects is exceeded"
           =2 #   endif
           =2 #  endif/* IL_ENABLE_RX_INDICATION_FLAG */
1407      =2  
1408      =2  # else/* VGEN_GENY */
           =2 
           =2 typedef vuint8 IltTxRepetitionCounter;
           =2 
           =2 typedef CanReceiveHandle IlReceiveHandle;
           =2 typedef CanTransmitHandle IlTransmitHandle;
           =2 typedef CanReceiveHandle IlReceiveFlagHandle;
           =2 
           =2 # endif/* VGEN_GENY */
1417      =2  
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 388 

1418      =2  # if defined ( C_ENABLE_CAN_CANCEL_NOTIFICATION )
1419      =2  typedef struct IlStartStopHndType
1420      =2  {
1421      =2    IlTransmitHandle start;
1422      =2    IlTransmitHandle stop;
1423      =2  } IlStartStopHnd;
1424      =2  # endif
1425      =2  
1426      =2  # if defined ( IL_ENABLE_RX_TIMEOUT )
1427      =2  #  if ( kIlNumberOfRxTimeoutCounters < 255 )
1428      =2  typedef vuint8 IlRxTimeoutHandle;
1429      =2  #  endif
1430      =2  #  if ( kIlNumberOfRxTimeoutCounters >= 255 ) && ( kIlNumberOfRxTimeoutCounters < 65535 )
           =2 typedef vuint16 IlRxTimeoutHandle;
           =2 #  endif
1433      =2  #  if ( kIlNumberOfRxTimeoutCounters >= 65535 )
           =2 #   error "The Maximum Number of supported Rx Timeout Counters is exceeded!"
           =2 #  endif
1436      =2  # endif/* IL_ENABLE_RX_TIMEOUT */
1437      =2  
1438      =2  
1439      =2  
1440      =2  # if defined( IL_ENABLE_SYS_GET_CONTEXT ) || defined( IL_ENABLE_SYS_SET_CONTEXT )|| \
1441      =2      defined( VGEN_ENABLE_MDWRAP )        || defined( VGEN_ENABLE_QWRAP )
           =2 
           =2 /* Il_Vector context structure */
           =2 typedef struct
           =2 {
           =2   vuint32 ilMagicNumber;
           =2 
           =2 #  if defined ( IL_ENABLE_RX_MULTIPLE_NODES )
           =2   vuintx ilECUMask;
           =2 #  endif
           =2 
           =2 #  if defined( C_MULTIPLE_RECEIVE_CHANNEL ) && ( kIlNumberOfChannels > 1 )
           =2   vuint8 ilChannelState[kIlNumberOfChannels];
           =2 #   if defined( IL_ENABLE_RX_POLLING ) 
           =2   vuint8 ilChannelReceive[kIlNumberOfChannels];
           =2 #   endif
           =2 #  else
           =2   vuint8 ilChannelState;
           =2 #   if defined( IL_ENABLE_RX_POLLING ) 
           =2   vuint8 ilChannelReceive;
           =2 #   endif
           =2 #  endif
           =2 
           =2 #  if defined ( IL_ENABLE_TX )
           =2 
           =2   vuint8 ilTxState[kIlNumberOfTxObjects];
           =2   IltTxCounter ilTxCyclicCounter[kIlNumberOfTxObjects];
           =2   IltTxUpdateCounter ilTxUpdateCounter[kIlNumberOfTxObjects];
           =2 #   if defined( IL_ENABLE_TX_CYCLIC_EVENT )
           =2 #    if defined( VGEN_GENY )
           =2   IlTIfActiveFlag ilIfActiveFlags;
           =2 #    else
           =2   _ilIfActiveFlags ilIfActiveFlags;
           =2 #    endif
           =2 #   endif                       /* IL_ENABLE_TX_CYCLIC_EVENT */
           =2 #   if defined( VGEN_GENY ) && defined( IL_ENABLE_TX_DYNAMIC_CYCLETIME )
           =2   IltTxCounter ilTxDynCyclicCycles[kIlNumberOfTxObjects];
           =2 #   endif
           =2 #   if defined( IL_ENABLE_TX_TIMEOUT_FLAG )
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 389 

           =2   vuint8 ilTxTimeoutFlags[kIlNumberOfTxTimeoutFlags];
           =2 #   endif
           =2 #   if defined( IL_ENABLE_TX_CONFIRMATION_FLAG )
           =2   vuint8 ilTxConfirmationFlags[kIlNumberOfTxConfirmationFlags];
           =2 #   endif
           =2 #   if defined( IL_ENABLE_TX_SECURE_EVENT )
           =2   IltTxRepetitionCounter ilTxNSendCounter[kIlNumberOfTxObjects];
           =2 #   endif
           =2 #   if defined( IL_ENABLE_TX_TIMEOUT )
           =2   IltTxTimeoutCounter ilTxTimeoutCounter[kIlNumberOfTxTimeoutCounters];
           =2 #   endif
           =2 #   if defined ( IL_ENABLE_TX_CYCLIC_EVENT ) || defined ( IL_ENABLE_TX_SECURE_EVENT ) || defined ( IL_ENAB
             -LE_TX_FAST_ON_START )
           =2   IltTxCounter ilTxEventCounter[kIlNumberOfTxObjects];
           =2 #   endif
           =2 #  endif                        /* IL_ENABLE_TX */
           =2 
           =2 #  if defined ( IL_ENABLE_RX )
           =2 #   if defined( IL_ENABLE_RX_TIMEOUT )
           =2   IltRxTimeoutCounter ilRxTimeoutCounter[kIlNumberOfRxTimeoutCounters];
           =2   vuint8 ilRxTimerFlags[kIlNumberOfTimerFlagBytes];
           =2 #    if defined ( VGEN_GENY ) && defined( IL_ENABLE_RX_DYNAMIC_TIMEOUT )
           =2   IltRxTimeoutCounter ilRxDynamicTimeoutCounter[kIlNumberOfRxTimeoutCounters];
           =2 #    endif
           =2 #   endif                       /* IL_ENABLE_RX_TIMEOUT */
           =2 #   if defined( IL_ENABLE_RX_DATACHANGED_FLAG )
           =2   vuint8 ilRxDataChangedFlags[kIlNumberOfRxDataChangedFlags];
           =2 #   endif
           =2 #   if defined( IL_ENABLE_RX_INDICATION_FLAG )
           =2   vuint8 ilRxIndicationFlags[kIlNumberOfRxIndicationFlags];
           =2 #   endif
           =2 #   if defined( IL_ENABLE_RX_FIRSTVALUE_FLAG )
           =2   vuint8 ilRxFirstvalueFlags[kIlNumberOfRxFirstvalueFlags];
           =2 #   endif
           =2 #   if defined ( IL_ENABLE_RX_TIMEOUT_FLAG )
           =2   vuint8 ilRxTimeoutFlags[kIlNumberOfRxTimeoutFlags];
           =2 #   endif
           =2 #   if !defined( VGEN_GENY ) && defined( IL_ENABLE_RX_MODE_SIGNALS )
           =2   _ilModeIndicationFlags ilModeIndicationFlags;
           =2 #   endif
           =2 #  endif                        /* IL_ENABLE_RX */
           =2 
           =2 }
           =2 tIlModuleContextStruct;
           =2 
           =2 typedef tIlModuleContextStruct *tIlModuleContextStructPtr;
           =2 
           =2 # endif/* IL_ENABLE_SYS_GET_CONTEXT || IL_ENABLE_SYS_SET_CONTEXT */
1527      =2  
1528      =2  /*********************************************************************************************************
             -*************
1529      =2    GLOBAL DATA PROTOTYPES
1530      =2  **********************************************************************************************************
             -************/
1531      =2  /** This variable contains the communication state of each channel. */
1532      =2  # if defined( C_MULTIPLE_RECEIVE_CHANNEL ) && (kIlNumberOfChannels > 1)
           =2 V_MEMRAM0 extern V_MEMRAM1 vuint8 V_MEMRAM2 ilChannelState[kIlNumberOfChannels];
           =2 # else
1535      =2  V_MEMRAM0 extern V_MEMRAM1 vuint8 V_MEMRAM2 ilChannelState;
1536      =2  # endif
1537      =2  
1538      =2  # if defined ( IL_ENABLE_RX )
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 390 

1539      =2  
1540      =2  
1541      =2  #  if defined( IL_ENABLE_RX_TIMEOUT )
1542      =2  /** This variable contains the Rx timeout counter. */
1543      =2  V_MEMRAM0 extern V_MEMRAM1 IltRxTimeoutCounter V_MEMRAM2 ilRxTimeoutCounter[kIlNumberOfRxTimeoutCounters];
1544      =2  
1545      =2  #   if defined( VGEN_GENY ) && defined( IL_ENABLE_RX_DYNAMIC_TIMEOUT )
           =2 /** This variable contains the dynamic Rx timeout counter. */
           =2 V_MEMRAM0 extern V_MEMRAM1 IltRxTimeoutCounter V_MEMRAM2 ilRxDynamicTimeoutCounter[kIlNumberOfRxTimeoutCou
             -nters];
           =2 #   endif
1549      =2  
1550      =2  
1551      =2  /** This variable contains a Rx timeout flag for each Rx timeout counter to indicate the reception of the 
             -timeout supervised message. */
1552      =2  V_MEMRAM0 extern V_MEMRAM1_NEAR vuint8 V_MEMRAM2_NEAR ilRxTimerFlags[kIlNumberOfTimerFlagBytes];
1553      =2  
1554      =2  #  endif/* IL_ENABLE_RX_TIMEOUT */
1555      =2  
1556      =2  #  if defined ( IL_ENABLE_RX_INDICATION_FLAG )
           =2 /** This variable contains each configured Rx signal indication flag, to indicate the reception of a signa
             -l. */
           =2 V_MEMRAM0 extern V_MEMRAM1_NEAR vuint8 V_MEMRAM2_NEAR ilRxIndicationFlags[kIlNumberOfRxIndicationFlags];
           =2 
           =2 #  endif
1561      =2  
1562      =2  #  if defined ( IL_ENABLE_RX_FIRSTVALUE_FLAG )
           =2 /** This variable contains each configured Rx signal firstvalue flag, to indicate the first reception of a
             - signal. */
           =2 V_MEMRAM0 extern V_MEMRAM1_NEAR vuint8 V_MEMRAM2_NEAR ilRxFirstvalueFlags[kIlNumberOfRxFirstvalueFlags];
           =2 
           =2 #  endif
1567      =2  
1568      =2  #  if defined ( IL_ENABLE_RX_TIMEOUT_FLAG )
1569      =2  /** This variable contains each configured Rx signal timeout flag. */
1570      =2  V_MEMRAM0 extern V_MEMRAM1_NEAR vuint8 V_MEMRAM2_NEAR ilRxTimeoutFlags[kIlNumberOfRxTimeoutFlags];
1571      =2  
1572      =2  #  endif
1573      =2  
1574      =2  #  if defined ( IL_ENABLE_RX_DATACHANGED_FLAG )
           =2 /** This variable contains each configured Rx signal datachanged flag, to indicate the change of the signa
             -l value. */
           =2 V_MEMRAM0 extern V_MEMRAM1_NEAR vuint8 V_MEMRAM2_NEAR ilRxDataChangedFlags[kIlNumberOfRxDataChangedFlags];
           =2 
           =2 #  endif
1579      =2  
1580      =2  #  if !defined (VGEN_GENY) && defined( IL_ENABLE_RX_MODE_SIGNALS )
           =2 /** This variable contains for each mode of Rx messages, which contain multiplexed signals a mode indicati
             -on flag. */
           =2 V_MEMRAM0 extern V_MEMRAM1_NEAR _ilModeIndicationFlags V_MEMRAM2_NEAR ilModeIndicationFlags;
           =2 
           =2 #  endif
1585      =2  
1586      =2  # endif/* IL_ENABLE_RX */
1587      =2  
1588      =2  # if defined ( IL_ENABLE_TX )
           =2 
           =2 /** This variable contains several states and functionalities bit coded for each Tx message.
           =2   76543210
           =2   |||||||+--- Send cyclic  is active
           =2   ||||||+---- cyclic-event is active
           =2   |||||+----- Tx-Timeout check active
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 391 

           =2   ||||+------ Send request for a single event
           =2   |||+------- manuell cyclic-event is active
           =2   ||+-------- Message is allowed for queueing on-init/reinit of VN
           =2   |+--------- unused
           =2   +---------- Internal send-request for IL-queue.
           =2 */
           =2 V_MEMRAM0 extern V_MEMRAM1_NEAR volatile vuint8 V_MEMRAM2_NEAR ilTxState[kIlNumberOfTxObjects];
           =2 
           =2 /** This variable contains the Tx updated counter. If the value is !=0, the transmission of messages is no
             -t allowed. */
           =2 V_MEMRAM0 extern V_MEMRAM1 IltTxUpdateCounter V_MEMRAM2 ilTxUpdateCounter[kIlNumberOfTxObjects];
           =2 
           =2 #  if defined(C_ENABLE_CAN_CANCEL_NOTIFICATION)
           =2 /** CAN handle to Il start stop handle */
           =2 V_MEMROM0 extern V_MEMROM1 IlStartStopHnd V_MEMROM2 IlCanHndToIlHnd[kIlCanNumberOfTxObjects];
           =2 #  endif
           =2 
           =2 #  if defined ( IL_ENABLE_TX_TIMEOUT )
           =2 /** This variable contains the Tx timeout counter. */
           =2 V_MEMRAM0 extern V_MEMRAM1 IltTxTimeoutCounter V_MEMRAM2 ilTxTimeoutCounter[kIlNumberOfTxTimeoutCounters];
           =2 #  endif
           =2 #  if defined( IL_ENABLE_TX_SECURE_EVENT )
           =2 /** This variable contains the number of transmit repetitions to be performed for each Tx message. */
           =2 V_MEMRAM0 extern V_MEMRAM1 IltTxRepetitionCounter V_MEMRAM2 ilTxNSendCounter[kIlNumberOfTxObjects];
           =2 #  endif
           =2 
           =2 
           =2 #  if defined( IL_ENABLE_TX_CYCLIC_EVENT )
           =2 #   if defined( IL_ENABLE_SYS_GET_CONTEXT ) || defined( IL_ENABLE_SYS_SET_CONTEXT )|| \
           =2      defined( VGEN_ENABLE_MDWRAP )        || defined( VGEN_ENABLE_QWRAP )
           =2 #    if defined( VGEN_GENY )
           =2 /** This variable contains for each Tx ifactive signal an ifactive flag. */
           =2 V_MEMRAM0 extern V_MEMRAM1_NEAR IlTIfActiveFlag V_MEMRAM2_NEAR ilIfActiveFlags;
           =2 #    else
           =2 /** This variable contains for each Tx ifactive signal an ifactive flag. */
           =2 V_MEMRAM0 extern V_MEMRAM1_NEAR _ilIfActiveFlags V_MEMRAM2_NEAR ilIfActiveFlags;
           =2 #    endif
           =2 #   endif
           =2 #  endif
           =2 
           =2 #  if defined ( IL_ENABLE_TX_TIMEOUT_FLAG )
           =2 /** This variable contains each configured Tx signal timeout flag, to indicate the timeout of a signal. */
           =2 V_MEMRAM0 extern V_MEMRAM1_NEAR vuint8 V_MEMRAM2_NEAR ilTxTimeoutFlags[kIlNumberOfTxTimeoutFlags];
           =2 #  endif
           =2 
           =2 #  if defined ( IL_ENABLE_TX_CONFIRMATION_FLAG )
           =2 /** This variable contains each configured Tx signal confirmation flag, to indicate the successful transmi
             -ssion of a signal. */
           =2 V_MEMRAM0 extern V_MEMRAM1_NEAR vuint8 V_MEMRAM2_NEAR ilTxConfirmationFlags[kIlNumberOfTxConfirmationFlags
             -];
           =2 #  endif
           =2 # endif/* IL_ENABLE_TX */
1644      =2  
1645      =2  /** This variable contains the bcd coded main version of the Il_Vector. */
1646      =2  V_MEMROM0 extern V_MEMROM1 vuint8 V_MEMROM2 kIlMainVersion;
1647      =2  /** This variable contains the bcd coded sub version of the Il_Vector. */
1648      =2  V_MEMROM0 extern V_MEMROM1 vuint8 V_MEMROM2 kIlSubVersion;
1649      =2  /** This variable contains the bcd coded release version of the Il_Vector. */
1650      =2  V_MEMROM0 extern V_MEMROM1 vuint8 V_MEMROM2 kIlReleaseVersion;
1651      =2  
1652      =2  # if defined ( IL_ENABLE_RX )
1653      =2  
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 392 

1654      =2  #  if defined( IL_ENABLE_RX_MODE_SIGNALS ) || defined( IL_ENABLE_SYS_MULTI_ECU_PHYS ) 
           =2 /** This constant contains the length of each Rx message. */
           =2 V_MEMROM0 extern V_MEMROM1 vuint8 V_MEMROM2 IlRxDataLen[kIlNumberOfRxObjects];
           =2 /** This constant references the data pointer of each Rx message buffer. */
           =2 V_MEMROM0 extern V_MEMROM1 RxDataPtr V_MEMROM2 IlRxDataPtr[kIlNumberOfRxObjects];
           =2 #  else
1660      =2  #   if !defined ( VGEN_GENY ) && ( C_VERSION_REF_IMPLEMENTATION < 0x120u )
           =2 /** If the interface does not exists for former Can Drivers, the interface must be defined by the IL and t
             -he tables have to be exported. */
           =2 #    if ! defined ( CanGetRxDataLen )
           =2 #     define CanGetRxDataLen(i)   CanRxDataLen[(i)]
           =2 /** This constant contains the length of each Can Driver Rx message. IL messages are at the beginning in t
             -he same order as in the IL. */
           =2 V_MEMROM0 extern V_MEMROM1 vuint8 V_MEMROM2 CanRxDataLen[kCanNumberOfRxObjects];
           =2 #    endif
           =2 #    if ! defined ( CanGetRxDataPtr )
           =2 #     define CanGetRxDataPtr(i)   CanRxDataPtr[(i)]
           =2 /** This constant references the data pointer of each Can Driver Rx message. IL messages are at the beginn
             -ing in the same order as in the IL. */
           =2 V_MEMROM0 extern V_MEMROM1 RxDataPtr V_MEMROM2 CanRxDataPtr[kCanNumberOfRxObjects];
           =2 #    endif
           =2 #   endif
1673      =2  #  endif
1674      =2  
1675      =2  #  if defined( IL_ENABLE_RX_DEFAULTVALUE )
1676      =2  /** This constant references the data pointer to an array with the length of the Rx message, which contain
             -s the default values for all signals. Undefined signals or gaps have the value 0. */
1677      =2  V_MEMROM0 extern V_MEMROM1 vuint8 V_MEMROM2 V_MEMROM3 *V_MEMROM1 V_MEMROM2
1678      =2    IlRxDefaultInitValue[kIlNumberOfRxObjects];
1679      =2  #  endif
1680      =2  #  if defined ( IL_ENABLE_RX_START_DEFAULTVALUE )
           =2 /** This constant references the data pointer to an array with the length of the Rx message.
           =2     The Value referenced by IlRxDefaultInitValue is valid at the transition start, if the referenced IlRxD
             -efaultStartMask has at the bit position the value 1. */
           =2 V_MEMROM0 extern V_MEMROM1 vuint8 V_MEMROM2 V_MEMROM3 *V_MEMROM1 V_MEMROM2
           =2   IlRxDefaultStartMask[kIlNumberOfRxObjects];
           =2 #  endif
1686      =2  #  if defined ( IL_ENABLE_RX_STOP_DEFAULTVALUE )
           =2 /** This constant references the data pointer to an array with the length of the Rx message.
           =2     The Value referenced by IlRxDefaultInitValue is valid at the transition stop, if the referenced IlRxDe
             -faultStopMask has at the bit position the value 1. */
           =2 V_MEMROM0 extern V_MEMROM1 vuint8 V_MEMROM2 V_MEMROM3 *V_MEMROM1 V_MEMROM2
           =2   IlRxDefaultStopMask[kIlNumberOfRxObjects];
           =2 #  endif
1692      =2  
1693      =2  #  if defined ( IL_ENABLE_RX_POLLING )
           =2 /** This constant references a IL internal indication function for each Rx messsage if the function is req
             -uired and generated, else V_NULL. */
           =2 V_MEMROM0 extern V_MEMROM1 IlIndicationFct V_MEMROM2 IlCanRxIndicationFctPtr[kIlCanNumberOfRxObjects];
           =2 #  endif
1697      =2  
1698      =2  #  if defined ( IL_ENABLE_RX_INDICATION_FLAG )
           =2 /** This constant contains the byte offset of the table ilRxIndicationFlags for each indication bit. */
           =2 V_MEMROM0 extern V_MEMROM1 vuint8 V_MEMROM2 IlIndicationOffset[kIlNumberOfRxIndicationBits];
           =2 /** This constant contains a mask for each indication bit, to decode the indication bit in the table ilRxI
             -ndicationFlags. */
           =2 V_MEMROM0 extern V_MEMROM1 vuint8 V_MEMROM2 IlIndicationMask[kIlNumberOfRxIndicationBits];
           =2 #  endif
1704      =2  
1705      =2  #  if defined(IL_ENABLE_RX_TIMEOUT)
1706      =2  /** This constant references a IL internal timeout function for each Rx timeout counter if the function is
             - required and generated, else V_NULL. */
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 393 

1707      =2  V_MEMROM0 extern V_MEMROM1 IlTimeoutIndicationFct V_MEMROM2 IlRxTimeoutFctPtr[kIlNumberOfRxTimeoutCounters
             -];
1708      =2  #    if defined(IL_ENABLE_SYS_MULTI_ECU_PHYS)
           =2 /** This constant contains Rx timeout counter for each Rx timeout counter in each identity of an ECU. */
           =2 V_MEMROM0 extern V_MEMROM1 IltRxTimeoutCounter V_MEMROM2
           =2   IlRxTimeoutTbl[kIlNumberOfIdentities][kIlNumberOfRxTimeoutCounters];
           =2 #    else
1713      =2  /** This constant contains Rx timeout counter for each Rx timeout counter, if the ECU has one identity. */
1714      =2  V_MEMROM0 extern V_MEMROM1 IltRxTimeoutCounter V_MEMROM2 IlRxTimeoutTbl[kIlNumberOfRxTimeoutCounters];
1715      =2  #    endif
1716      =2  #  endif
1717      =2  
1718      =2  #  if defined ( VGEN_GENY )
1719      =2  #   if defined( IL_ENABLE_RX_MULTI_ECU_PHYS )
           =2 /** This constant contains for each IL message in the CAN Driver table a mapping to the current active ide
             -ntity.
           =2     If the LSB2MSB bitindex(IdentityIndex) is set to 1, the Rx message is active, else not. */
           =2 V_MEMROM0 extern V_MEMROM1 tVIdentityMsk V_MEMROM2 IlCanRxIdentityAssignment[kIlCanNumberOfRxObjects];
           =2 #   endif
1724      =2  #  else
           =2 #   if defined( IL_ENABLE_RX_MULTI_ECU_PHYS )
           =2 /** This constant contains for each Can Driver message a mapping to the current active identity.
           =2     If the LSB2MSB bitindex(IdentityIndex) is set to 1, the Rx message is active, else not. */
           =2 V_MEMROM0 extern V_MEMROM1 tVIdentityMsk V_MEMROM2 IlCanRxIdentityAssignment[kCanNumberOfRxObjects];
           =2 #   endif
           =2 #  endif
1731      =2  
1732      =2  #  if defined( C_MULTIPLE_RECEIVE_CHANNEL ) && (kIlNumberOfChannels > 1)
           =2 /** This constant contains for each channel the startindex of the first message in
           =2     kIlNumberOfRxObjcets ordered arrays. The last index is kIlNumberOfRxObjcets. */
           =2 V_MEMROM0 extern V_MEMROM1 IlReceiveHandle V_MEMROM2 IlRxMsgStartIndex[kIlNumberOfChannels + 1];
           =2 #   if defined ( IL_ENABLE_RX_POLLING ) 
           =2 /** This constant contains for each channel the startindex of the first Can Driver message in
           =2     kIlCanNumberOfRxObjects ordered arrays. The last index is kIlCanNumberOfRxObjects. */
           =2 V_MEMROM0 extern V_MEMROM1 CanReceiveHandle V_MEMROM2 IlCanRxMsgStartIndex[kIlNumberOfChannels + 1];
           =2 #   endif
           =2 #   if defined( IL_ENABLE_RX_TIMEOUT )
           =2 /** This constant contains for each channel the startindex of the first timeout counter in
           =2     kIlNumberOfRxTimeoutCounters ordered arrays. The last index is kIlNumberOfRxTimeoutCounters. */
           =2 V_MEMROM0 extern V_MEMROM1 IlReceiveHandle V_MEMROM2 IlRxTimeoutCntStartIndex[kIlNumberOfChannels + 1];
           =2 #   endif
           =2 #   if defined( IL_ENABLE_RX_TIMEOUT )
           =2 /** This constant contains for each channel the startindex of the first timer flag byte in
           =2     kIlNumberOfTimerFlagBytes ordered arrays. The last index is kIlNumberOfTimerFlagBytes. */
           =2 V_MEMROM0 extern V_MEMROM1 IlReceiveHandle V_MEMROM2 IlRxTimerFlagsStartIndex[kIlNumberOfChannels + 1];
           =2 #   endif
           =2 #   if defined( IL_ENABLE_RX_TIMEOUT_FLAG )
           =2 /** This constant contains for each channel the startindex of the first timeout flag byte in
           =2     kIlNumberOfRxTimeoutFlags ordered arrays. The last index is kIlNumberOfRxTimeoutFlags. */
           =2 V_MEMROM0 extern V_MEMROM1 IlReceiveHandle V_MEMROM2 IlRxTimeoutFlagsStartIndex[kIlNumberOfChannels + 1];
           =2 #   endif
           =2 #   if defined( IL_ENABLE_RX_FIRSTVALUE_FLAG )
           =2 /** This constant contains for each channel the startindex of the first firstvalue flag byte in
           =2     kIlNumberOfRxFirstvalueFlags ordered arrays. The last index is kIlNumberOfRxFirstvalueFlags. */
           =2 V_MEMROM0 extern V_MEMROM1 IlReceiveHandle V_MEMROM2 IlRxFirstvalueFlagsStartIndex[kIlNumberOfChannels + 1
             -];
           =2 #   endif
           =2 #   if defined( IL_ENABLE_RX_INDICATION_FLAG )
           =2 /** This constant contains for each channel the startindex of the first indication flag byte in
           =2     kIlNumberOfRxIndicationFlags ordered arrays. The last index is kIlNumberOfRxIndicationFlags. */
           =2 V_MEMROM0 extern V_MEMROM1 IlReceiveHandle V_MEMROM2 IlRxIndicationFlagsStartIndex[kIlNumberOfChannels + 1
             -];
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 394 

           =2 #   endif
           =2 #   if defined( IL_ENABLE_RX_DATACHANGED_FLAG )
           =2 /** This constant contains for each channel the startindex of the first datachanged flag byte in
           =2     kIlNumberOfRxDataChangedFlags ordered arrays. The last index is kIlNumberOfRxDataChangedFlags. */
           =2 V_MEMROM0 extern V_MEMROM1 IlReceiveHandle V_MEMROM2 IlRxDataChangedFlagsStartIndex[kIlNumberOfChannels + 
             -1];
           =2 #   endif
           =2 #  endif
1772      =2  
1773      =2  # endif/* defined ( IL_ENABLE_RX ) */
1774      =2  
1775      =2  # if defined ( IL_ENABLE_TX )
           =2 
           =2 #  if defined( IL_ENABLE_TX_MODE_SIGNALS ) 
           =2 /** This constant contains the length of each Tx message. */
           =2 V_MEMROM0 extern V_MEMROM1 vuint8 V_MEMROM2 IlTxDLC[kIlNumberOfTxObjects];
           =2 /** This constant references the data pointer of each Tx message buffer. */
           =2 V_MEMROM0 extern V_MEMROM1 TxDataPtr V_MEMROM2 IlTxDataPtr[kIlNumberOfTxObjects];
           =2 #  else
           =2 #   if !defined ( VGEN_GENY ) && ( C_VERSION_REF_IMPLEMENTATION < 0x120u )
           =2 /** If the interface does not exists for former Can Drivers, the interface must be defined by the IL and t
             -he tables have to be exported. */
           =2 #    if !defined ( CanGetTxDlc )
           =2 #     define CanGetTxDlc(i)       CanTxDlc[(i)]
           =2 /** This constant contains the length of each Can Driver Tx message. IL messages are at the beginning in t
             -he same order as in the IL. */
           =2 V_MEMROM0 extern V_MEMROM1 vuint8 V_MEMROM2 CanTxDlc[kCanNumberOfTxObjects];
           =2 #    endif
           =2 #    if !defined ( CanGetTxDataPtr )
           =2 #     define CanGetTxDataPtr(i)   CanTxDataPtr[(i)]
           =2 /** This constant references the data pointer of each Can Driver Tx message buffer. IL messages are at the
             - beginning in the same order as in the IL. */
           =2 V_MEMROM0 extern V_MEMROM1 TxDataPtr V_MEMROM2 CanTxDataPtr[kCanNumberOfTxObjects];
           =2 #    endif
           =2 #   endif
           =2 #  endif
           =2 
           =2 #  if defined ( VGEN_GENY ) && defined( IL_ENABLE_TX_SECURE_EVENT ) && defined( IL_ENABLE_TX_VARYING_REPET
             -ITION )
           =2 V_MEMROM0 extern V_MEMROM1 IltTxRepetitionCounter V_MEMROM2 IlTxRepetitionCounters[kIlNumberOfTxObjects];
           =2 #  endif
           =2 
           =2 #  if defined ( IL_ENABLE_TX_START_DEFAULTVALUE )
           =2 /** This constant references the data pointer to an array with the length of the Tx message, which contain
             -s the default values for all signals. Undefined signals or gaps have the value 0. */
           =2 V_MEMROM0 extern IL_MEMROM1 vuint8 IL_MEMROM2 IL_MEMROM3 *V_MEMROM1 V_MEMROM2
           =2   IlTxDefaultStartMask[kIlNumberOfTxObjects];
           =2 #  endif
           =2 #  if defined( IL_ENABLE_TX_DEFAULTVALUE )
           =2 /** This constant references the data pointer to an array with the length of the Tx message.
           =2     The Value referenced by IlTxDefaultInitValue is valid at the transition start, if the referenced IlTxD
             -efaultStartMask has at the bit position the value 1. */
           =2 V_MEMROM0 extern IL_MEMROM1 vuint8 IL_MEMROM2 IL_MEMROM3 *V_MEMROM1 V_MEMROM2
           =2   IlTxDefaultInitValue[kIlNumberOfTxObjects];
           =2 #  endif
           =2 #  if defined ( IL_ENABLE_TX_STOP_DEFAULTVALUE )
           =2 /** This constant references the data pointer to an array with the length of the Tx message.
           =2     The Value referenced by IlTxDefaultInitValue is valid at the transition stop, if the referenced IlTxDe
             -faultStopMask has at the bit position the value 1. */
           =2 V_MEMROM0 extern IL_MEMROM1 vuint8 IL_MEMROM2 IL_MEMROM3 *V_MEMROM1 V_MEMROM2
           =2   IlTxDefaultStopMask[kIlNumberOfTxObjects];
           =2 #  endif
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 395 

           =2 
           =2 /** This constant contains the predefined sendtype of all Tx messages. */
           =2 V_MEMROM0 extern V_MEMROM1 vuint8 V_MEMROM2 IlTxType[kIlNumberOfTxObjects];
           =2 
           =2 
           =2 /** This constant contains the GenMsgCycleTime of all Tx messages in multiples of IlTxTask calls. */
           =2 V_MEMROM0 extern V_MEMROM1 IltTxCounter V_MEMROM2 IlTxCyclicCycles[kIlNumberOfTxObjects];
           =2 
           =2 /** This constant contains the GenMsgStartDelayTime of all Tx messages in multiples of IlTxTask calls. */
           =2 V_MEMROM0 extern V_MEMROM1 IltTxCounter V_MEMROM2 IlTxStartCycles[kIlNumberOfTxObjects];
           =2 
           =2 /** This constant contains the GenMsgDelayTime of all Tx messages in multiples of IlTxTask calls. */
           =2 V_MEMROM0 extern V_MEMROM1 IltTxUpdateCounter V_MEMROM2 IlTxUpdateCycles[kIlNumberOfTxObjects];
           =2 
           =2 #   if defined ( IL_ENABLE_TX_CYCLIC_EVENT ) || defined ( IL_ENABLE_TX_SECURE_EVENT ) || defined ( IL_ENAB
             -LE_TX_FAST_ON_START )
           =2 /** This constant contains the GenMsgCycleTimeFast of all Tx messages in multiples of IlTxTask calls. */
           =2 V_MEMROM0 extern V_MEMROM1 IltTxCounter V_MEMROM2 IlTxEventCycles[kIlNumberOfTxObjects];
           =2 #   endif
           =2 
           =2 #  if defined ( IL_ENABLE_TX_FAST_ON_START )
           =2 /** This constant contains the calculated GenMsgFastOnStart of all Tx messages in multiples of IlTxTask ca
             -lls.
           =2     The GenMsgStartDelayTime is taken additional into account. */
           =2 V_MEMROM0 extern V_MEMROM1 IltTxCounter V_MEMROM2 IlTxFastOnStartDuration[kIlNumberOfTxObjects];
           =2 #  endif
           =2 
           =2 #  if defined ( VGEN_GENY ) && defined ( IL_ENABLE_TX_FAST_ON_START ) && defined( IL_ENABLE_TX_MODE_SIGNAL
             -S )
           =2 /** This constant contains calculated mode delay offset times for multiplexor value specific Tx handles of
             - the IL in multiples of IlTxTask calls.
           =2     The values are used to equalize the mode cycles in the transition from the GenMsgFastOnStart time to t
             -he normal cyclic transmission. */
           =2 V_MEMROM0 extern V_MEMROM1 IltTxCounter V_MEMROM2 IlTxFastOnStartMuxDelay[kIlNumberOfTxObjects];
           =2 #  endif
           =2 
           =2 #  if defined ( IL_ENABLE_TX_POLLING )
           =2 /** This constant references a IL internal confirmation function for each Tx messsage if the function is r
             -equired and generated, else V_NULL. */
           =2 V_MEMROM0 extern V_MEMROM1 IlConfirmationFct V_MEMROM2 IlTxConfirmationFctPtr[kIlNumberOfTxObjects];
           =2 #  endif
           =2 
           =2 #  if defined( IL_ENABLE_TX_TIMEOUT )
           =2 /** This constant references for each Tx messsage the Tx timeout handle. The value in this table for the T
             -x message
           =2     is only valid, if kTxCheckTimeout is set in the ilTxState array is set. */
           =2 V_MEMROM0 extern V_MEMROM1 vuint8 V_MEMROM2 IlTxTimeoutIndirection[kIlNumberOfTxObjects];
           =2 #  endif
           =2 
           =2 #  if defined(IL_ENABLE_SYS_MULTI_ECU_PHYS)
           =2 /** This constant contains for each il Tx message the Can Driver Tx handle in each identity of an ECU. */
           =2 V_MEMROM0 extern V_MEMROM1 CanTransmitHandle V_MEMROM2
           =2   IlTxIndirection[kIlNumberOfIdentities][kIlNumberOfTxObjects];
           =2 #  else
           =2 /** This constant contains for each il Tx message the Can Driver Tx handle, if the ECU has one identity. *
             -/
           =2 V_MEMROM0 extern V_MEMROM1 CanTransmitHandle V_MEMROM2 IlTxIndirection[kIlNumberOfTxObjects];
           =2 #  endif
           =2 
           =2 #  if defined ( IL_ENABLE_TX_MODE_SIGNALS )
           =2 /** This constant references for multiplexor value specific Tx handles of the IL functions to copy the mul
             -tiplexor value specific data. */
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 396 

           =2 V_MEMROM0 extern V_MEMROM1 IlTxModeCopyFct V_MEMROM2 IlTxModeCopyFunctions[kIlNumberOfTxObjects];
           =2 #  endif
           =2 
           =2 #  if defined( IL_ENABLE_SYS_MULTI_ECU_PHYS )
           =2 /** This constant contains for each IL message a mapping to the current active identity. 
           =2     If the LSB2MSB bitindex(IdentityIndex) is set to 1, the Rx message is active, else not. */
           =2 V_MEMROM0 extern V_MEMROM1 tVIdentityMsk V_MEMROM2 IlTxIdentityAssignment[kIlNumberOfTxObjects];
           =2 #  endif
           =2 
           =2 #  if defined( C_MULTIPLE_RECEIVE_CHANNEL ) && (kIlNumberOfChannels > 1)
           =2 /** This constant contains for each channel the startindex of the first message in
           =2     kIlNumberOfTxObjcets ordered arrays. The last index is kIlNumberOfTxObjcets. */
           =2 V_MEMROM0 extern V_MEMROM1 IlTransmitHandle V_MEMROM2 IlTxMsgStartIndex[kIlNumberOfChannels + 1];
           =2 #   if defined( IL_ENABLE_TX_TIMEOUT )
           =2 /** This constant contains for each channel the startindex of the first Tx timeout counter in
           =2     kIlNumberOfTxTimeoutCounters ordered arrays. The last index is kIlNumberOfTxTimeoutCounters. */
           =2 V_MEMROM0 extern V_MEMROM1 IlTransmitHandle V_MEMROM2 IlTxTimeoutCntStartIndex[kIlNumberOfChannels + 1];
           =2 #   endif
           =2 #   if defined( IL_ENABLE_TX_CONFIRMATION_FLAG )
           =2 /** This constant contains for each channel the startindex of the first Tx confirmation flag in
           =2     kIlNumberOfTxConfirmationFlags ordered arrays. The last index is kIlNumberOfTxConfirmationFlags. */
           =2 V_MEMROM0 extern V_MEMROM1 IlTransmitHandle V_MEMROM2 IlTxConfirmationFlagsStartIndex[kIlNumberOfChannels 
             -+ 1];
           =2 #   endif
           =2 #   if defined( IL_ENABLE_TX_TIMEOUT_FLAG )
           =2 /** This constant contains for each channel the startindex of the first Tx timeout flag in
           =2     kIlNumberOfTxTimeoutFlags ordered arrays. The last index is kIlNumberOfTxTimeoutFlags. */
           =2 V_MEMROM0 extern V_MEMROM1 IlTransmitHandle V_MEMROM2 IlTxTimeoutFlagsStartIndex[kIlNumberOfChannels + 1];
           =2 #   endif
           =2 #   if defined ( VGEN_GENY ) && defined( IL_ENABLE_TX_TIMEOUT ) && defined ( IL_ENABLE_TX_VARYING_TIMEOUT 
             -)
           =2 /** This constant contains the calculated ILTxTimeout of each channel in multiples of IlTxTask calls. */
           =2 V_MEMROM0 extern V_MEMROM1 IltTxTimeoutCounter V_MEMROM2 IlTxTimeout[kIlNumberOfChannels];
           =2 #   endif
           =2 #  endif
           =2 
           =2 # endif/* defined ( IL_ENABLE_TX ) */
1907      =2  
1908      =2  
1909      =2  
1910      =2  
1911      =2  /*********************************************************************************************************
             -*************
1912      =2    GLOBAL FUNCTION PROTOTYPES
1913      =2  **********************************************************************************************************
             -************/
1914      =2  
1915      =2  /*********************************************************************************************************
             -*************
1916      =2    IlInitPowerOn
1917      =2  **********************************************************************************************************
             -************/
1918      =2  /** \brief    This method initializes the Il_Vector on all channels.\n
1919      =2                IlInit is called for every channel.
1920      =2      \return   none
1921      =2      \context  The function must be called with disabled interrupts.\n
1922      =2                The function must not interrupt IlRxTask, IlRxStateTask, IlTxTask, IlTxStateTask,
1923      =2                IlInit, IlRxStart, IlTxStart, IlRxStop, IlTxStop.
1924      =2      \note     The function is called by the Application or Ccl (Communication Control Layer).
1925      =2  **********************************************************************************************************
             -************/
1926      =2  extern void IlInitPowerOn(void);
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 397 

1927      =2  
1928      =2  /*********************************************************************************************************
             -*************
1929      =2    IlInit
1930      =2  **********************************************************************************************************
             -************/
1931      =2  /** \brief    This method initializes the Il_Vector on a channel.\n
1932      =2                Rx and Tx data buffers and flags are set to the initial state. If no default value for a mes
             -sage is
1933      =2                defined, the data buffer is set to 0x00.
1934      =2      \param_i  channel : Handle of the logical Can Driver channel.
1935      =2      \return   none
1936      =2      \context  The function must be called with disabled interrupts.\n
1937      =2                The function must not interrupt IlRxTask, IlRxStateTask, IlTxTask, IlTxStateTask,
1938      =2                IlInitPowerOn, IlRxStart, IlTxStart, IlRxStop, IlTxStop.
1939      =2      \note     The function is called by the Application, Ccl (Communication Control Layer) or IlInitPowerO
             -n.
1940      =2  **********************************************************************************************************
             -************/
1941      =2  extern void IlInit(IL_CHANNEL_ILTYPE_ONLY);
1942      =2  
1943      =2  /*********************************************************************************************************
             -*************
1944      =2    IlRxStart
1945      =2  **********************************************************************************************************
             -************/
1946      =2  /** \brief    This method enables the reception of messages.
1947      =2                The transition "start" of the Rx state machine is performed.
1948      =2      \param_i  channel : Handle of the logical Can Driver channel.
1949      =2      \return   none
1950      =2      \context  The function must be called on task level.\n
1951      =2                The function must not interrupt IlRxTask, IlRxStateTask, IlTxTask, IlTxStateTask, 
1952      =2                IlInitPowerOn, IlInit, IlTxStart, IlRxStop, IlTxStop.
1953      =2      \note     The function is called by the Application or Nm (Network Management).
1954      =2  **********************************************************************************************************
             -************/
1955      =2  extern void IlRxStart(IL_CHANNEL_ILTYPE_ONLY);
1956      =2  
1957      =2  /*********************************************************************************************************
             -*************
1958      =2    IlTxStart
1959      =2  **********************************************************************************************************
             -************/
1960      =2  /** \brief    This method enables the transmission of messages and starts the transmission of periodic mes
             -sages.
1961      =2                The transition "start" of the Tx state machine is performed.
1962      =2      \param_i  channel : Handle of the logical Can Driver channel.
1963      =2      \return   none
1964      =2      \context  The function must be called on task level.\n
1965      =2                The function must not interrupt IlRxTask, IlRxStateTask, IlTxTask, IlTxStateTask, 
1966      =2                IlInitPowerOn, IlInit, IlTxStart, IlRxStop, IlTxStop.
1967      =2      \note     The function is called by the Application or Nm (Network Management).
1968      =2  **********************************************************************************************************
             -************/
1969      =2  extern void IlTxStart(IL_CHANNEL_ILTYPE_ONLY);
1970      =2  
1971      =2  /*********************************************************************************************************
             -*************
1972      =2    IlRxStop
1973      =2  **********************************************************************************************************
             -************/
1974      =2  /** \brief    This method disables the reception of messages.
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 398 

1975      =2                The transition "stop" of the Rx state machine is performed.
1976      =2                The method is used for example to enter the Sleep Mode of an ECU.
1977      =2      \param_i  channel : Handle of the logical Can Driver channel.
1978      =2      \return   none
1979      =2      \context  The function must be called on task level.\n
1980      =2                The function must not interrupt IlRxTask, IlRxStateTask, IlTxTask, IlTxStateTask, 
1981      =2                IlInitPowerOn, IlInit, IlTxStart, IlRxStop, IlTxStop.
1982      =2      \note     The function is called by the Application or Nm (Network Management).
1983      =2  **********************************************************************************************************
             -************/
1984      =2  extern void IlRxStop(IL_CHANNEL_ILTYPE_ONLY);
1985      =2  
1986      =2  /*********************************************************************************************************
             -*************
1987      =2    IlTxStop
1988      =2  **********************************************************************************************************
             -************/
1989      =2  /** \brief    This method disables the transmission of messages (Sleep Mode).
1990      =2                The transition "stop" of the Tx state machine is performed.
1991      =2                The method is used for example to enter the Sleep Mode of an ECU.
1992      =2      \param_i  channel : Handle of the logical Can Driver channel.
1993      =2      \return   none
1994      =2      \context  The function must be called on task level.\n
1995      =2                The function must not interrupt IlInitPowerOn, IlInit, IlRxTask, IlRxStateTask, IlRxTimerTas
             -k, IlTxTask,
1996      =2                IlTxStateTask, IlTxTimerTask, IlRxStart, IlTxStart, IlRxStop
1997      =2      \note     The function is called by the Application or Nm (Network Management).
1998      =2  **********************************************************************************************************
             -************/
1999      =2  extern void IlTxStop(IL_CHANNEL_ILTYPE_ONLY);
2000      =2  
2001      =2  /*********************************************************************************************************
             -*************
2002      =2    IlRxWait
2003      =2  **********************************************************************************************************
             -************/
2004      =2  /** \brief    This method halts the timeout monitoring of reception messages.
2005      =2                The transition "wait" of the Rx state machine is performed.
2006      =2                The method is used for example when the bus-off mode of an ECU was entered.
2007      =2      \param_i  channel : Handle of the logical Can Driver channel.
2008      =2      \return   none
2009      =2      \context  The function can be called on task and interrupt level.
2010      =2      \note     The function is called by the Application or Nm (Network Management).
2011      =2  **********************************************************************************************************
             -************/
2012      =2  extern void IlRxWait(IL_CHANNEL_ILTYPE_ONLY);
2013      =2  
2014      =2  /*********************************************************************************************************
             -*************
2015      =2    IlTxWait
2016      =2  **********************************************************************************************************
             -************/
2017      =2  /** \brief    This method halts the transmission of messages.
2018      =2                The transition "wait" of the Tx state machine is performed.
2019      =2                The method is used for example when the bus-off mode of an ECU was entered.
2020      =2      \param_i  channel : Handle of the logical Can Driver channel.
2021      =2      \return   none
2022      =2      \context  The function can be called on task and interrupt level.
2023      =2      \note     The function is called by the Application or Nm (Network Management).
2024      =2  **********************************************************************************************************
             -************/
2025      =2  extern void IlTxWait(IL_CHANNEL_ILTYPE_ONLY);
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 399 

2026      =2  
2027      =2  /*********************************************************************************************************
             -*************
2028      =2    IlRxRelease
2029      =2  **********************************************************************************************************
             -************/
2030      =2  /** \brief    The transition "release" of the Rx state machine is performed.\n
2031      =2                -Restart the Rx Timeout Monitoring\n
2032      =2                -Clear the timeout flags if IL_ENABLE_SYS_RX_RESET_TIMEOUT_FLAGS_ON_ILRXRELEASE is defined.
2033      =2      \param_i  channel : Handle of the logical Can Driver channel.
2034      =2      \return   none
2035      =2      \context  The function can be called on task and interrupt level.
2036      =2      \note     The function is called by the Application or Nm (Network Management).
2037      =2  **********************************************************************************************************
             -************/
2038      =2  extern void IlRxRelease(IL_CHANNEL_ILTYPE_ONLY);
2039      =2  
2040      =2  /*********************************************************************************************************
             -*************
2041      =2    IlTxRelease
2042      =2  **********************************************************************************************************
             -************/
2043      =2  /** \brief    This method resumes the transmission of messages from the "Waiting" state.
2044      =2                The transition "release" of the Tx state machine is performed.
2045      =2      \param_i  channel : Handle of the logical Can Driver channel.
2046      =2      \return   none
2047      =2      \context  The function can be called on task and interrupt level.
2048      =2      \note     The function is called by the Application or Nm (Network Management).
2049      =2  **********************************************************************************************************
             -************/
2050      =2  extern void IlTxRelease(IL_CHANNEL_ILTYPE_ONLY);
2051      =2  
2052      =2  /*********************************************************************************************************
             -*************
2053      =2    IlRxTask
2054      =2  **********************************************************************************************************
             -************/
2055      =2  /** \brief    This method must be called periodically in the Rx task cycle time configured in the generati
             -on tool.
2056      =2                The IlRxTimerTask and IlRxStateTask are called by this method.
2057      =2      \param_i  channel : Handle of the logical Can Driver channel.
2058      =2      \return   none
2059      =2      \context  The function must be called on task level.\n
2060      =2                The function must not interrupt IlRxStateTask, IlTxTask, IlTxStateTask,
2061      =2                IlInitPowerOn, IlInit, IlRxStart, IlTxStart, IlRxStop, IlTxStop
2062      =2      \note     The function is called by the Application or Ccl (Communication Control Layer).
2063      =2  **********************************************************************************************************
             -************/
2064      =2  extern void IlRxTask(IL_CHANNEL_ILTYPE_ONLY);
2065      =2  
2066      =2  /*********************************************************************************************************
             -*************
2067      =2    IlTxTask
2068      =2  **********************************************************************************************************
             -************/
2069      =2  /** \brief    This method must be called periodically in the Tx task cycle time configured in the generati
             -on tool.
2070      =2                The IlTxTimerTask and IlTxStateTask are called by this method.
2071      =2      \param_i  channel : Handle of the logical Can Driver channel.
2072      =2      \return   none
2073      =2      \context  The function must be called on task level.\n
2074      =2                The function must not interrupt IlRxStateTask, IlTxTask, IlTxStateTask,
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 400 

2075      =2                IlInitPowerOn, IlInit, IlRxStart, IlTxStart, IlRxStop, IlTxStop
2076      =2      \note     The function is called by the Application or Ccl (Communication Control Layer).
2077      =2  **********************************************************************************************************
             -************/
2078      =2  extern void IlTxTask(IL_CHANNEL_ILTYPE_ONLY);
2079      =2  
2080      =2  /*********************************************************************************************************
             -*************
2081      =2    IlRxStateTask
2082      =2  **********************************************************************************************************
             -************/
2083      =2  /** \brief    This method is called periodically by the IlRxTask. The function can be called in a faster r
             -ate 
2084      =2                than the IlRxTask to check additionally for polled indication events.
2085      =2                The usage of the IlRxTask shall be preferred.
2086      =2      \param_i  channel : Handle of the logical Can Driver channel.
2087      =2      \return   none
2088      =2      \context  The function must be called on task level.\n
2089      =2                The function must not interrupt IlRxStateTask, IlTxTask, IlTxStateTask,
2090      =2                IlInitPowerOn, IlInit, IlRxStart, IlTxStart, IlRxStop, IlTxStop
2091      =2      \note     The function is called by the Application or IlRxTask.
2092      =2  **********************************************************************************************************
             -************/
2093      =2  extern void IlRxStateTask(IL_CHANNEL_ILTYPE_ONLY);
2094      =2  
2095      =2  /*********************************************************************************************************
             -*************
2096      =2    IlTxStateTask
2097      =2  **********************************************************************************************************
             -************/
2098      =2  /** \brief    This method is called periodically by the IlTxTask. The function can be called in a faster r
             -ate,
2099      =2                than the IlTxTask, to check additionally for polled confirmation events.
2100      =2                The usage of the IlTxTask shall be preferred.
2101      =2      \param_i  channel : Handle of the logical Can Driver channel.
2102      =2      \return   none
2103      =2      \context  The function must be called on task level.\n
2104      =2                The function must not interrupt IlRxStateTask, IlTxTask, IlTxStateTask,
2105      =2                IlInitPowerOn, IlInit, IlRxStart, IlTxStart, IlRxStop, IlTxStop
2106      =2      \note     The function is called by the Application or IlTxTask.
2107      =2  **********************************************************************************************************
             -************/
2108      =2  extern void IlTxStateTask(IL_CHANNEL_ILTYPE_ONLY);
2109      =2  
2110      =2  /*********************************************************************************************************
             -*************
2111      =2    IlRxTimerTask
2112      =2  **********************************************************************************************************
             -************/
2113      =2  /** \brief    This method is called periodically by the IlRxTask. If the application separates the handlin
             -g of
2114      =2                notification and timing and the IlRxTask is not used, this function must be called periodica
             -lly
2115      =2                in the Rx task cycle time configured in the generation tool.
2116      =2                The usage of the IlRxTask shall be preferred.
2117      =2      \param_i  channel : Handle of the logical Can Driver channel.
2118      =2      \return   none
2119      =2      \context  The function must be called on task level.\n
2120      =2                The function must not interrupt IlRxStateTask, IlTxTask, IlTxStateTask,
2121      =2                IlInitPowerOn, IlInit, IlRxStart, IlTxStart, IlRxStop, IlTxStop
2122      =2      \note     The function is called by the Application or IlRxTask.
2123      =2  **********************************************************************************************************
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 401 

             -************/
2124      =2  extern void IlRxTimerTask(IL_CHANNEL_ILTYPE_ONLY);
2125      =2  
2126      =2  /*********************************************************************************************************
             -*************
2127      =2    IlTxTimerTask
2128      =2  **********************************************************************************************************
             -************/
2129      =2  /** \brief    This method is called periodically by the IlTxTask. If the application separates the handlin
             -g of
2130      =2                notification and timing and the IlTxTask is not used, this function must be called periodica
             -lly
2131      =2                in the Tx task cycle time configured in the generation tool.
2132      =2                The usage of the IlTxTask shall be preferred.
2133      =2      \param_i  channel : Handle of the logical Can Driver channel.
2134      =2      \return   none
2135      =2      \context  The function must be called on task level.\n
2136      =2                The function must not interrupt IlRxStateTask, IlTxTask, IlTxStateTask,
2137      =2                IlInitPowerOn, IlInit, IlRxStart, IlTxStart, IlRxStop, IlTxStop
2138      =2      \note     The function is called by the Application or IlTxTask.
2139      =2  **********************************************************************************************************
             -************/
2140      =2  extern void IlTxTimerTask(IL_CHANNEL_ILTYPE_ONLY);
2141      =2  
2142      =2  # if defined ( IL_ENABLE_TX )
           =2 /*********************************************************************************************************
             -*************
           =2   IlSetEvent
           =2 **********************************************************************************************************
             -************/
           =2 /** \brief    This method serves to set a transmission request for a message.
           =2     \param    ilTxHnd  Handle of the Tx message.
           =2     \return   none
           =2     \context  The function can be called on task and interrupt level.
           =2     \note     The function is called by the Application or by IlPutTx method.
           =2 **********************************************************************************************************
             -************/
           =2 extern void IlSetEvent(IlTransmitHandle ilTxHnd) C_API_3;
           =2 # endif
2154      =2  
2155      =2  # if defined ( IL_ENABLE_TX ) && defined( IL_ENABLE_TX_SECURE_EVENT )
           =2 /*********************************************************************************************************
             -*************
           =2   IlSecureEvent
           =2 **********************************************************************************************************
             -************/
           =2 /** \brief    This method serves to set a transmission request for a message with repetitions.
           =2     \param    ilTxHnd  Handle of the Tx message.
           =2     \return   none
           =2     \context  The function can be called on task and interrupt level.
           =2     \note     The function is called by the IlPutTx method.
           =2 **********************************************************************************************************
             -************/
           =2      extern void IlSecureEvent(IlTransmitHandle ilTxHnd) C_API_3;
           =2 # endif
2167      =2  
2168      =2  # if defined ( IL_ENABLE_TX ) && defined ( IL_ENABLE_TX_CYCLIC_EVENT )
           =2 /*********************************************************************************************************
             -*************
           =2   IlStartEvent
           =2 **********************************************************************************************************
             -************/
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 402 

           =2 /** \brief    This method starts the fast cyclic transmission of a message.
           =2     \param    ilTxHnd         Handle of the Tx message.
           =2     \return   (Il_Status) 1 : the fast transmission is started\n
           =2               IL_ERROR      : the ilTxHnd is invalid
           =2     \context  The function can be called on task and interrupt level.
           =2     \note     The function is called by the IlPutTx method.
           =2 **********************************************************************************************************
             -************/
           =2      extern Il_Status IlStartEvent(IlTransmitHandle ilTxHnd) C_API_3;
           =2 # endif
2181      =2  
2182      =2  # if defined ( IL_ENABLE_TX ) && defined ( IL_ENABLE_TX_CYCLIC_EVENT )
           =2 /*********************************************************************************************************
             -*************
           =2   IlStopEvent
           =2 **********************************************************************************************************
             -************/
           =2 /** \brief    This method stops the fast cyclic transmission of a message.
           =2     \param    ilTxHnd         Handle of the Tx message.
           =2     \return   (Il_Status) 0 : the fast transmission is stopped\n
           =2               IL_ERROR      : the ilTxHnd is invalid
           =2     \context  The function can be called on task and interrupt level.
           =2     \note     The function is called by the IlPutTx method.
           =2 **********************************************************************************************************
             -************/
           =2      extern Il_Status IlStopEvent(IlTransmitHandle ilTxHnd) C_API_3;
           =2 # endif
2195      =2  
2196      =2  # if defined ( IL_ENABLE_TX_STARTSTOP_CYCLIC )
           =2 /*********************************************************************************************************
             -*************
           =2   IlStartCycle
           =2 **********************************************************************************************************
             -************/
           =2 /** \brief    This method serves to start cyclic transmission requests of a message.
           =2               Using this function can violate the predefined behavior of your module!
           =2     \param    ilTxHnd     Handle of the Tx message.
           =2     \return   IL_OK     : the cyclic transmission request is started\n
           =2               IL_QUEUED : the cyclic transmission request is already enabled\n
           =2               IL_ERROR  : the ilTxHnd is invalid
           =2     \context  The function can be called on task and interrupt level.
           =2     \note     The function is called by the Application.
           =2 **********************************************************************************************************
             -************/
           =2      extern Il_Status IlStartCycle(IlTransmitHandle ilTxHnd) C_API_3;
           =2 # endif
2211      =2  
2212      =2  # if defined ( IL_ENABLE_TX_STARTSTOP_CYCLIC )
           =2 /*********************************************************************************************************
             -*************
           =2   IlStopCycle
           =2 **********************************************************************************************************
             -************/
           =2 /** \brief    This method serves to stop the cyclic transmission request of a Tx message. Pending transmis
             -sion
           =2               requests are not taken into account.
           =2               Using this function can violate the predefined behavior of your module!
           =2     \param    ilTxHnd    Handle of the Tx message.
           =2     \return   IL_OK    : the cyclic transmission request is removed\n
           =2               IL_ERROR : the ilTxHnd is invalid
           =2     \context  The function can be called on task and interrupt level.
           =2     \note     The function is called by the Application.
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 403 

           =2 **********************************************************************************************************
             -************/
           =2      extern Il_Status IlStopCycle(IlTransmitHandle ilTxHnd) C_API_3;
           =2 # endif
2227      =2  
2228      =2  # if defined ( IL_ENABLE_TX_SEND_ON_INIT )
           =2 /*********************************************************************************************************
             -*************
           =2   IlSendOnInitMsg
           =2 **********************************************************************************************************
             -************/
           =2 /** \brief    This method serves to set a transmission request flag for all messages configured as SendOnI
             -nit messages.
           =2     \param_i  channel : Handle of the logical Can Driver channel.
           =2     \return   none
           =2     \context  The function must be called on task level.
           =2     \note     The function is called by the Application.
           =2 **********************************************************************************************************
             -************/
           =2      extern void IlSendOnInitMsg(IL_CHANNEL_ILTYPE_ONLY);
           =2 # endif
2240      =2  
2241      =2  /*********************************************************************************************************
             -*************
2242      =2    IlGetStatus
2243      =2  **********************************************************************************************************
             -************/
2244      =2  /** \brief    Gets the current state of the Interaction Layer state machine.
2245      =2      \param_i  channel : Handle of the logical Can Driver channel.
2246      =2      \return   Il_Status : the value must be decoded with the following set of macros.\n
2247      =2                The macros will return 0 (false) or 1 (true).
2248      =2                \li IlIsTxRun(state)     : Tx is running
2249      =2                \li IlIsTxWait(state)    : Tx is waiting
2250      =2                \li IlIsTxSuspend(state) : Tx is suspended
2251      =2                \li IlIsRxRun(state)     : Rx is running
2252      =2                \li IlIsRxWait(state)    : Rx is waiting
2253      =2                \li IlIsRxSuspend(state) : Rx is suspended
2254      =2      \context  The function can be called on task and interrupt level.
2255      =2      \note     The function is called by the Application.
2256      =2  **********************************************************************************************************
             -************/
2257      =2       extern Il_Status IlGetStatus(IL_CHANNEL_ILTYPE_ONLY);
2258      =2  
2259      =2  # if defined( IL_ENABLE_SEND_DIRECT )
           =2 /*********************************************************************************************************
             -*************
           =2   IlSendDirect
           =2 **********************************************************************************************************
             -************/
           =2 /** \brief    Refer to the Application Note AN-ISC-8-1045_IlSendDirect.pdf
           =2     \param    ilTxHnd  Handle of the Tx message.
           =2     \param_i  channel : Handle of the logical Can Driver channel.
           =2     \return   none
           =2     \warning  Do not use this API, without taking the application note into account.
           =2 **********************************************************************************************************
             -************/
           =2      extern void IlSendDirect(IL_CHANNEL_ILTYPE_FIRST IlTransmitHandle ilTxHnd);
           =2 # endif
2271      =2  
2272      =2  # if defined ( IL_ENABLE_SYS_GET_CONTEXT ) || defined( VGEN_ENABLE_MDWRAP )
           =2 /*********************************************************************************************************
             -*************
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 404 

           =2   IlGetModuleContext
           =2 **********************************************************************************************************
             -************/
           =2 /** \brief    This function copies the context of the component to a structure.
           =2     \param    pContext  pointer to a tIlModuleContextStructPtr context structure.
           =2     \return   none
           =2     \pre      The component context must be saved
           =2     \post     The structure contains the component state
           =2     \context  The function must be called with disabled interrupts.
           =2 **********************************************************************************************************
             -************/
           =2      extern void IlGetModuleContext(tIlModuleContextStructPtr pContext);
           =2 # endif
2285      =2  
2286      =2  # if defined ( IL_ENABLE_SYS_SET_CONTEXT ) || defined( VGEN_ENABLE_QWRAP )
           =2 /*********************************************************************************************************
             -*************
           =2   IlSetModuleContext
           =2 **********************************************************************************************************
             -************/
           =2 /** \brief    This function copies a given context to a component.
           =2     \param    pContext      pointer to a tIlModuleContextStructPtr context structure.
           =2     \return   (vuint8) 0  : the magicNumber member of the tIlModuleContextStructPtr parameter is invalid.\
             -n
           =2               (vuint8) 1  : the magicNumber member of the tIlModuleContextStructPtr parameter is valid.
           =2     \pre      The component context must be initialised.
           =2     \post     The structure contains the component state.
           =2     \context  The function must be called with disabled interrupts.
           =2 **********************************************************************************************************
             -************/
           =2      extern vuint8 IlSetModuleContext(tIlModuleContextStructPtr pContext);
           =2 # endif
2300      =2  
2301      =2  
2302      =2  
2303      =2  /* Callback functions ************************************************************************************
             -************/
2304      =2  
2305      =2  # if defined ( IL_ENABLE_SYS_INIT_FCT )
           =2 /*********************************************************************************************************
             -*************
           =2   ApplIlInit
           =2 **********************************************************************************************************
             -************/
           =2 /** \brief    This method is called to indicate the performed initialization.
           =2     \param_i  channel : Handle of the logical Can Driver channel.
           =2     \return   none
           =2     \context  The function is called by the IL in the context of IlInit.
           =2 **********************************************************************************************************
             -************/
           =2      extern void ApplIlInit(IL_CHANNEL_ILTYPE_ONLY);
           =2 # endif
2316      =2  
2317      =2  # if defined ( IL_ENABLE_SYS_RX_START_FCT )
           =2 /*********************************************************************************************************
             -*************
           =2   ApplIlRxStart
           =2 **********************************************************************************************************
             -************/
           =2 /** \brief    This method is called to indicate the performed transition start for the Rx state machine.
           =2     \param_i  channel : Handle of the logical Can Driver channel.
           =2     \return   none
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 405 

           =2     \context  The function is called by the IL in the context of IlRxStart.
           =2 **********************************************************************************************************
             -************/
           =2      extern void ApplIlRxStart(IL_CHANNEL_ILTYPE_ONLY);
           =2 # endif
2328      =2  
2329      =2  # if defined ( IL_ENABLE_SYS_TX_START_FCT )
           =2 /*********************************************************************************************************
             -*************
           =2   ApplIlTxStart
           =2 **********************************************************************************************************
             -************/
           =2 /** \brief    This method is called to indicate the performed transition start for the Tx state machine.
           =2     \param_i  channel : Handle of the logical Can Driver channel.
           =2     \return   none
           =2     \context  The function is called by the IL in the context of IlTxStart.
           =2 **********************************************************************************************************
             -************/
           =2      extern void ApplIlTxStart(IL_CHANNEL_ILTYPE_ONLY);
           =2 # endif
2340      =2  
2341      =2  # if defined ( IL_ENABLE_SYS_RX_STOP_FCT )
           =2 /*********************************************************************************************************
             -*************
           =2   ApplIlRxStop
           =2 **********************************************************************************************************
             -************/
           =2 /** \brief    This method is called to indicate the performed transition stop for the Rx state machine.
           =2     \param_i  channel : Handle of the logical Can Driver channel.
           =2     \return   none
           =2     \context  The function is called by the IL in the context of IlRxStop.
           =2 **********************************************************************************************************
             -************/
           =2      extern void ApplIlRxStop(IL_CHANNEL_ILTYPE_ONLY);
           =2 # endif
2352      =2  
2353      =2  # if defined ( IL_ENABLE_SYS_TX_STOP_FCT )
           =2 /*********************************************************************************************************
             -*************
           =2   ApplIlTxStop
           =2 **********************************************************************************************************
             -************/
           =2 /** \brief    This method is called to indicate the performed transition stop for the Tx state machine.
           =2     \param_i  channel : Handle of the logical Can Driver channel.
           =2     \return   none
           =2     \context  The function is called by the IL in the context of IlTxStop.
           =2 **********************************************************************************************************
             -************/
           =2      extern void ApplIlTxStop(IL_CHANNEL_ILTYPE_ONLY);
           =2 # endif
2364      =2  
2365      =2  # if defined ( IL_ENABLE_SYS_TESTDEBUG )
2366      =2  /*********************************************************************************************************
             -*************
2367      =2    ApplIlFatalError
2368      =2  **********************************************************************************************************
             -************/
2369      =2  /** \brief    If assertions are configured, this function is called to indicate invalid user conditions
2370      =2                (API, reentrance), inconsistent generated data, hardware errors and internal errors.
2371      =2      \param    errorNumber  numeric error code
2372      =2      \return   none
2373      =2      \context  The function is be called by the IL on task and interrupt level.
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 406 

2374      =2  **********************************************************************************************************
             -************/
2375      =2       extern void ApplIlFatalError(vuint8 errorNumber);
2376      =2  # endif
2377      =2  
2378      =2  /* API Macro wrapped internal functions ******************************************************************
             -************/
2379      =2  
2380      =2  # if defined ( IL_ENABLE_RX ) && defined ( IL_ENABLE_RX_INDICATION_FLAG )
           =2 /*********************************************************************************************************
             -*************
           =2   IlGetSignalIndicationFlag
           =2 **********************************************************************************************************
             -************/
           =2 /** \brief    This method is used by the generated IlGetClr* macros to return and clear indication flags.
           =2     \param    ilRxFlagHnd  Handle of the Rx flag.
           =2     \return   (vuint8) 0 : the indication flag is not set.\n
           =2                      > 0 : the indication flag was set.
           =2     \context  The function can be called on task and interrupt level.
           =2     \note     The function is called by the Application indirectly from the IlGetClr macros.
           =2     \warning  Do not call this Il internal API from the application!
           =2 **********************************************************************************************************
             -************/
           =2      extern vuint8 IlGetSignalIndicationFlag(IlReceiveFlagHandle ilRxFlagHnd);
           =2 # endif
2394      =2  
2395      =2  
2396      =2  # if defined( VGEN_GENY ) && defined( IL_ENABLE_TX_DYNAMIC_CYCLETIME )
           =2 /*********************************************************************************************************
             -*************
           =2   IlSetDynTxCycleTimeRaw
           =2 **********************************************************************************************************
             -************/
           =2 /** \brief    Sets the cycle time of an Il message.
           =2               The macro is called from the application. The function has no effect, if the Il message hand
             -le is not
           =2               transmitted cyclically. This is defined in the dbc database file with the attributes GenMsgS
             -endType and
           =2               GenSigSendType. Please refer to the technical reference for details. To activate the cyclic 
             -transmission
           =2               of an Il message handle use the Il API function IlStartCycle.
           =2     \param    ilTxHnd      This value is the handle of the Tx message. The generated file il_par.h contain
             -s generated
           =2                            defines for the message handles.
           =2     \param    ilTxTicks     This value is the number of calls of the IlTxTask, until the cyclic event is r
             -aised.
           =2     \return   none
           =2     \context  The function must be called within the Il callback function ApplIlInit or in the signal orie
             -nted init
           =2               callback function.
           =2     \note     The function is called by the Application.
           =2     \warning  Do not use the function for handles containing multiplexed signals
           =2 **********************************************************************************************************
             -************/
           =2      extern void IlSetDynTxCycleTimeRaw(IlTransmitHandle ilTxHnd, IltTxCounter ilTxTicks);
           =2 # endif/* VGEN_GENY && IL_ENABLE_TX_DYNAMIC_CYCLETIME */
2416      =2  
2417      =2  # if defined( VGEN_GENY ) && defined( IL_ENABLE_SYS_TX_REPETITIONS_ARE_ACTIVE_FCT )
           =2 /*********************************************************************************************************
             -*************
           =2   IlTxRepetitionsAreActive
           =2 **********************************************************************************************************
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 407 

             -************/
           =2 /** \brief    This method can be used to detect if messages with repetitions are queued for transmission o
             -n a channel.
           =2     \param_i  channel : Handle of the logical Can Driver channel.
           =2     \return   IL_TRUE   : Messages with repetitions are queued for transmission.\n
           =2               IL_FALSE  : No message with repetitions is queued for transmission.
           =2     \context  The function can be called on task and interrupt level.
           =2     \note     The function is called by the Application.
           =2     \warning  The function does not support Virtual Networks.
           =2 **********************************************************************************************************
             -************/
           =2      Il_Boolean IlTxRepetitionsAreActive(IL_CHANNEL_ILTYPE_ONLY);
           =2 # endif/* VGEN_GENY && IL_ENABLE_TX_REPETITIONS_COMPLETED */
2431      =2  
2432      =2  # if defined( VGEN_GENY ) && defined( IL_ENABLE_SYS_TX_SIGNALS_ARE_ACTIVE_FCT )
           =2 /*********************************************************************************************************
             -*************
           =2   IlTxSignalsAreActive
           =2 **********************************************************************************************************
             -************/
           =2 /** \brief    This method can be used to detect if signals are active on a channel.
           =2     \param_i  channel : Handle of the logical Can Driver channel.
           =2     \return   IL_TRUE   : Signals are in the active state.\n
           =2               IL_FALSE  : No signal is in the active state.
           =2     \context  The function can be called on task and interrupt level.
           =2     \note     The function is called by the Application.
           =2     \warning  The function does not support Virtual Networks.
           =2 **********************************************************************************************************
             -************/
           =2      Il_Boolean IlTxSignalsAreActive(IL_CHANNEL_ILTYPE_ONLY);
           =2 # endif/* VGEN_GENY && IL_ENABLE_TX_REPETITIONS_COMPLETED */
2446      =2  
2447      =2  
2448      =2  /* Stack internal functions ******************************************************************************
             -************/
2449      =2  
2450      =2  /*********************************************************************************************************
             -*************
2451      =2    IlResetRxTimeoutFlags
2452      =2  **********************************************************************************************************
             -************/
2453      =2  /** \brief    This method clears Rx timeout flags of the Application and internal ilNodeCommActiveTimeoutF
             -lags.
2454      =2      \param_i  channel : Handle of the logical Can Driver channel.
2455      =2      \return   none
2456      =2      \context  The function can be called on task and interrupt level.
2457      =2      \note     The function is called by the Application.
2458      =2      \warning  Do not call this Il internal API from the application!
2459      =2  **********************************************************************************************************
             -************/
2460      =2       extern void IlResetRxTimeoutFlags(IL_CHANNEL_ILTYPE_ONLY);
2461      =2  
2462      =2  /* Il_Vector internal functions **************************************************************************
             -************/
2463      =2  
2464      =2  # if !defined( VGEN_GENY )
           =2 #  if defined (C_ENABLE_MEMCOPY_SUPPORT)
           =2 #  else
           =2 /*********************************************************************************************************
             -*************
           =2   CanCopyFromCan
           =2 **********************************************************************************************************
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 408 

             -************/
           =2 /** \brief    This method serves to copy data from the register of the CAN controller to the message buffe
             -r.
           =2     \param    dst  Pointer to the message buffer.
           =2     \param    src  Pointer to the register of the CAN controller.
           =2     \param    len  Number of bytes to be copied
           =2     \return   none
           =2     \context  The function must be called in the call context of a Can Driver precopy function.
           =2 **********************************************************************************************************
             -************/
           =2      extern void CanCopyFromCan(void *dst, CanChipDataPtr src, vuint8 len);
           =2 #  endif
           =2 # endif/* VGEN_GENY */
2480      =2  
2481      =2  # if defined( IL_ENABLE_TX ) && defined( IL_ENABLE_TX_CYCLIC_EVENT )
           =2 /*********************************************************************************************************
             -*************
           =2   InitIfActiveFlags
           =2 **********************************************************************************************************
             -************/
           =2 /** \brief    This method clears all if active flags of a channel.
           =2     \param_i  channel : Handle of the logical Can Driver channel.
           =2     \return   none
           =2     \note     The function is called by the IlTxStart.
           =2     \warning  Do not call this Il internal API from the application!
           =2 **********************************************************************************************************
             -************/
           =2      extern void InitIfActiveFlags(IL_CHANNEL_ILTYPE_ONLY);
           =2 # endif
2493      =2  
2494      =2  # if defined( IL_ENABLE_TX )
           =2 /*********************************************************************************************************
             -*************
           =2   IlResetCanConfirmationFlags
           =2 **********************************************************************************************************
             -************/
           =2 /** \brief    This method clears all Can Driver confirmation flags of IL Tx messages of a channel.
           =2     \param_i  channel : Handle of the logical Can Driver channel.
           =2     \return   none
           =2     \note     The function is called by the IlTxStart.
           =2     \warning  Do not call this Il internal API from the application!
           =2 **********************************************************************************************************
             -************/
           =2      extern void IlResetCanConfirmationFlags(IL_CHANNEL_ILTYPE_ONLY);
           =2 # endif
2506      =2  
2507      =2  # if defined( IL_ENABLE_RX ) && defined( IL_ENABLE_RX_POLLING )
           =2 /*********************************************************************************************************
             -*************
           =2   IlResetCanIndicationFlags
           =2 **********************************************************************************************************
             -************/
           =2 /** \brief    This method clears all Can Driver indication flags of IL Rx messages of a channel.
           =2     \param_i  channel : Handle of the logical Can Driver channel.
           =2     \return   none
           =2     \note     The function is called by the IlRxStart.
           =2     \warning  Do not call this Il internal API from the application!
           =2 **********************************************************************************************************
             -************/
           =2      extern void IlResetCanIndicationFlags(IL_CHANNEL_ILTYPE_ONLY);
           =2 # endif
2519      =2  
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 409 

2520      =2  # if defined( IL_ENABLE_RX ) && !defined( VGEN_GENY ) && defined( IL_ENABLE_RX_MODE_SIGNALS )
           =2 /*********************************************************************************************************
             -*************
           =2   IlResetModeIndicationFlags
           =2 **********************************************************************************************************
             -************/
           =2 /** \brief    This method clears IL internal mode indication flags of a channel.
           =2     \param_i  channel : Handle of the logical Can Driver channel.
           =2     \return   none
           =2     \note     The function is called by the IlRxStart.
           =2     \warning  Do not call this Il internal API from the application!
           =2 **********************************************************************************************************
             -************/
           =2      extern void IlResetModeIndicationFlags(IL_CHANNEL_ILTYPE_ONLY);
           =2 # endif
2532      =2  
2533      =2  # if defined( IL_ENABLE_TX ) && defined( IL_ENABLE_TX_TIMEOUT )
           =2 /*********************************************************************************************************
             -*************
           =2   IlCheckTxTimeout
           =2 **********************************************************************************************************
             -************/
           =2 /** \brief    This method checks the IL internal Tx timeout flags, decrements Tx timeout counters, calls T
             -x timeout
           =2               callback functions and sets Tx timeout flags of a channel.
           =2     \param_i  channel : Handle of the logical Can Driver channel.
           =2     \return   none
           =2     \note     The function is called by the IlTxTimerTask.
           =2     \warning  Do not call this Il internal API from the application!
           =2 **********************************************************************************************************
             -************/
           =2      extern void IlCheckTxTimeout(IL_CHANNEL_ILTYPE_ONLY);
           =2 # endif
2546      =2  
2547      =2  # if defined( IL_ENABLE_SYS_SIGNAL_INIT_FCT )
           =2 /*********************************************************************************************************
             -*************
           =2   IlSignalInit
           =2 **********************************************************************************************************
             -************/
           =2 /** \brief    This method calls all configured init signal callback functions of a channel.
           =2     \param_i  channel : Handle of the logical Can Driver channel.
           =2     \return   none
           =2     \note     The function is called by IlInit.
           =2     \warning  Do not call this Il internal API from the application!
           =2 **********************************************************************************************************
             -************/
           =2      extern void IlSignalInit(IL_CHANNEL_ILTYPE_ONLY);
           =2 # endif
2559      =2  
2560      =2  # if defined( IL_ENABLE_RX ) && defined( IL_ENABLE_RX_SIGNAL_START_FCT )
           =2 /*********************************************************************************************************
             -*************
           =2   IlSignalRxStart
           =2 **********************************************************************************************************
             -************/
           =2 /** \brief    This method calls all configured Rx start signal callback functions of a channel.
           =2     \param_i  channel : Handle of the logical Can Driver channel.
           =2     \return   none
           =2     \note     The function is called by IlRxStart.
           =2     \warning  Do not call this Il internal API from the application!
           =2 **********************************************************************************************************
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 410 

             -************/
           =2      extern void IlSignalRxStart(IL_CHANNEL_ILTYPE_ONLY);
           =2 # endif
2572      =2  
2573      =2  # if defined( IL_ENABLE_TX ) && defined( IL_ENABLE_TX_SIGNAL_START_FCT )
           =2 /*********************************************************************************************************
             -*************
           =2   IlSignalTxStart
           =2 **********************************************************************************************************
             -************/
           =2 /** \brief    This method calls all configured Tx start signal callback functions of a channel.
           =2     \param_i  channel : Handle of the logical Can Driver channel.
           =2     \return   none
           =2     \note     The function is called by IlTxStart.
           =2     \warning  Do not call this Il internal API from the application!
           =2 **********************************************************************************************************
             -************/
           =2      extern void IlSignalTxStart(IL_CHANNEL_ILTYPE_ONLY);
           =2 # endif
2585      =2  
2586      =2  # if defined( IL_ENABLE_RX ) && defined( IL_ENABLE_RX_SIGNAL_STOP_FCT )
           =2 /*********************************************************************************************************
             -*************
           =2   IlSignalRxStop
           =2 **********************************************************************************************************
             -************/
           =2 /** \brief    This method calls all configured Rx stop signal callback functions of a channel.
           =2     \param_i  channel : Handle of the logical Can Driver channel.
           =2     \return   none
           =2     \note     The function is called by IlRxStop.
           =2     \warning  Do not call this Il internal API from the application!
           =2 **********************************************************************************************************
             -************/
           =2      extern void IlSignalRxStop(IL_CHANNEL_ILTYPE_ONLY);
           =2 # endif
2598      =2  
2599      =2  # if defined( IL_ENABLE_TX ) && defined( IL_ENABLE_TX_SIGNAL_STOP_FCT )
           =2 /*********************************************************************************************************
             -*************
           =2   IlSignalTxStop
           =2 **********************************************************************************************************
             -************/
           =2 /** \brief    This method calls all configured Tx stop signal callback functions of a channel.
           =2     \param_i  channel : Handle of the logical Can Driver channel.
           =2     \return   none
           =2     \note     The function is called by IlTxStop.
           =2     \warning  Do not call this Il internal API from the application!
           =2 **********************************************************************************************************
             -************/
           =2      extern void IlSignalTxStop(IL_CHANNEL_ILTYPE_ONLY);
           =2 # endif
2611      =2  
2612      =2  
2613      =2  
2614      =2  
2615      =2  /*********************************************************************************************************
             -*************
2616      =2    END OF FILE: Il_Def.h
2617      =2  **********************************************************************************************************
             -************/
2618      =2  #endif /* V_IL_DEF_COMPONENT_HEADER */
2619      =2  /* STOPSINGLE_OF_MULTIPLE */
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 411 

 132      =1  
 133      =1  #  if( IL_VECTOR_VERSION != 0x0508 )
           =1 #   error "Source and Header file are inconsistent!"
           =1 #  endif
 136      =1  #  if( IL_VECTOR_RELEASE_VERSION != 0x00 )
           =1 #   error "Source and Header file are inconsistent!"
           =1 #  endif
 139      =1  
 140      =1  
 141      =1  
 142      =1  /*********************************************************************************************************
             -*************
 143      =1    END OF FILE: il_inc.h
 144      =1  **********************************************************************************************************
             -************/
 145      =1  #endif /* V_IL_INC_COMPONENT_HEADER */
 146      =1  /* STOPSINGLE_OF_MULTIPLE */
  22          #include "main.h"
   1      =1  
   2      =1  #ifndef MAIN_H
   3      =1  #define MAIN_H
   4      =1  
   5      =1  /* ----- Global Define -------------------------------*/
   6      =1  #define SCALE                    1000L // Scale for temp calculations
   7      =1  #define SAMPLING_NUMBER            256 // Number of samples per calculation
   8      =1  #define OVER_ROUND                  10 // Number of shifts (>>N) to reach the
   9      =1  #define REV_B                     0x01 // Value of the REVID register for
  10      =1  #define SLOPE_REV_B               3047   // Slope of the temp transfer function
  11      =1  #define OFFSET_REV_B           265610 // Offset for the temp transfer function
  12      =1                                            // These values are for revision B
  13      =1                                         // devices with the equation
  14      =1                                         //     Vtemp = 2.67T(C) + 713mV
  15      =1  #define REV_C                     0x02 // Value of the REVID register for
  16      =1  #define SLOPE_REV_C               2261 // Slope of the temp transfer function
  17      =1  #define OFFSET_REV_C           265610L // Offset for the temp transfer function
  18      =1  /*----------------------------------------------------*/
  19      =1  
  20      =1  /* ----- Global Value --------------------------------*/
  21      =1  
  22      =1  /*----------------------------------------------------*/
  23      =1  
  24      =1  
  25      =1  /* ----- Function ------------------------------------*/
  26      =1  /*----------------------------------------------------*/
  27      =1  
  28      =1  
  29      =1  /* ----- INTERRUPT -----------------------------------*/
  30      =1  /*----------------------------------------------------*/
  31      =1  
  32      =1  /* ----- Extern Function -----------------------------*/
  33      =1  extern SEG_XDATA U8 EEPROM_Update_Mode;
  34      =1  #ifndef __PST_PolySpace__
  35      =1  #else
           =1   extern void   TIMER2_ISR(void);
           =1   extern void   CAN_ISR(void);
           =1   extern U32    get_random(void);
           =1   extern void   pst_main_loop_isr(void);
           =1   extern void   pst_interrupt_isr(void);
           =1   extern void   INT1_ISR(void);
           =1   extern void   ADC_ISR(void);
           =1 #endif
  44      =1  /*----------------------------------------------------*/
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 412 

  45      =1  
  46      =1  #endif
  23          /*--------------------------------------------------------------*/
  24          SEG_XDATA tMsg_Ext_DTC_Type ga_Ext_tDTC_Type_Msg;
  25          
  26          static SEG_XDATA volatile U8 DTC_Set_Off = FALSE;
  27          static SEG_XDATA volatile U8 DTC_Write_Set = FALSE;
  28          static SEG_XDATA volatile U8 DTC_Err_Sensor_Reset = FALSE;
  29          static SEG_XDATA volatile U8 Calibration_Data[3U] = {0x00U,0x00U,0x00U};
  30          
  31          SEG_XDATA volatile U8 CalibrationMode_OnOff = FALSE;
  32          SEG_XDATA volatile U8 OpticOffset_Set = FALSE;
  33          SEG_XDATA volatile U8 IGN_ON_Status = IGN_CLEAR;
  34          
  35          extern SEG_XDATA U8 EEPROM_Update_Mode;
  36          extern SEG_XDATA volatile U8 Optical_Axis_Data[9U];
  37          
  38          extern U16 IlGetRxSAS_Angle(void);
  39          
  40          void Init_DiagTask(void)
  41          {       
  42   1              Clear_DTC_Struct();     
  43   1              Flash_DTC_Read();
  44   1              IGN_ON_Status = IGN_CLEAR;
  45   1      
  46   1      #if defined(DIAG_TEST_MCU_WD_ERR)
                      ga_Ext_tDTC_Type_Msg.tDTC_Type[DTC_MCU_WT_ERR].Status = DTC_CONFIRM_ERROR;
                      ga_Ext_tDTC_Type_Msg.DTC_State[DTC_CODE_INTERNAL_ERROR] = DTC_CONFIRM_ERROR;
                      DTC_Write_Set = TRUE;
              #endif
  51   1      
  52   1      #if defined(DIAG_TEST_MCU_MC_ERR)
                      ga_Ext_tDTC_Type_Msg.tDTC_Type[DTC_MCU_MC_ERR].Status = DTC_CONFIRM_ERROR;
                      ga_Ext_tDTC_Type_Msg.DTC_State[DTC_CODE_INTERNAL_ERROR] = DTC_CONFIRM_ERROR;
                      DTC_Write_Set = TRUE;
              #endif
  57   1      
  58   1      #if defined(DIAG_TEST_ISP_FV_ERR)
                      ga_Ext_tDTC_Type_Msg.tDTC_Type[DTC_SENSOR_FV_ERR].Status = DTC_CURRENT_ERROR;
                      ga_Ext_tDTC_Type_Msg.DTC_State[DTC_CODE_SENSOR_ERROR] = DTC_CURRENT_ERROR;
                      DTC_Write_Set = TRUE;
              #endif
  63   1      
  64   1      #if defined(DIAG_TEST_ISP_FC_ERR)
                      ga_Ext_tDTC_Type_Msg.tDTC_Type[DTC_SENSOR_FC_ERR].Status = DTC_CURRENT_ERROR;
                      ga_Ext_tDTC_Type_Msg.DTC_State[DTC_CODE_SENSOR_ERROR] = DTC_CURRENT_ERROR;
                      DTC_Write_Set = TRUE;
              #endif
  69   1      
  70   1      #if defined(DIAG_TEST_ISP_CM_ERR)
                      ga_Ext_tDTC_Type_Msg.tDTC_Type[DTC_SENSOR_COMM_ERR].Status = DTC_CURRENT_ERROR;
                      ga_Ext_tDTC_Type_Msg.DTC_State[DTC_CODE_SENSOR_ERROR] = DTC_CURRENT_ERROR;
                      DTC_Write_Set = TRUE;
              #endif
  75   1      
  76   1      #if defined(DIAG_TEST_ISP_IS_ERR)
                      ga_Ext_tDTC_Type_Msg.tDTC_Type[DTC_SENSOR_ISPSTAT_ERR].Status = DTC_CURRENT_ERROR;
                      ga_Ext_tDTC_Type_Msg.DTC_State[DTC_CODE_SENSOR_ERROR] = DTC_CURRENT_ERROR;
                      DTC_Write_Set = TRUE;
              #endif
  81   1      
  82   1      #if defined(DIAG_TEST_ISP_IT_ERR)
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 413 

                      ga_Ext_tDTC_Type_Msg.tDTC_Type[DTC_SENOSR_INIT_ERR].Status = DTC_CURRENT_ERROR;
                      ga_Ext_tDTC_Type_Msg.DTC_State[DTC_CODE_SENSOR_ERROR] = DTC_CURRENT_ERROR;
                      DTC_Write_Set = TRUE;
              #endif
  87   1      }
  88          
  89          void Clear_DTC_Struct(void)
  90          {
  91   1              U8 i = 0U;
  92   1              for(i = 0; i < DTC_CODE_COUNT;i++)
  93   1              {
  94   2                      ga_Ext_tDTC_Type_Msg.tDTC_Type[i].Status = 0xFFU;
  95   2                      ga_Ext_tDTC_Type_Msg.tDTC_Type[i].Count = 0x00U;
  96   2              }
  97   1              ga_Ext_tDTC_Type_Msg.DTC_Clear_Count[DTC_CODE_INTERNAL_ERROR] = 0x00U;
  98   1              ga_Ext_tDTC_Type_Msg.DTC_Clear_Count[DTC_CODE_SENSOR_ERROR] = 0x00U;
  99   1              ga_Ext_tDTC_Type_Msg.DTC_Clear_Count[DTC_CODE_OUTPUT_ERROR] = 0x00U;
 100   1              ga_Ext_tDTC_Type_Msg.DTC_State[DTC_CODE_INTERNAL_ERROR] = FALSE;
 101   1              ga_Ext_tDTC_Type_Msg.DTC_State[DTC_CODE_SENSOR_ERROR] = FALSE;
 102   1              ga_Ext_tDTC_Type_Msg.DTC_State[DTC_CODE_OUTPUT_ERROR] = FALSE;
 103   1      }
 104          
 105          void Clear_DTC_Status(void)
 106          {
 107   1              U8 i = 0U;
 108   1              for(i = DTC_SENSOR_FV_ERR; i < DTC_CODE_COUNT;i++)
 109   1              {
 110   2                      ga_Ext_tDTC_Type_Msg.tDTC_Type[i].Status = 0xFFU;
 111   2                      ga_Ext_tDTC_Type_Msg.tDTC_Type[i].Count = 0x00U;
 112   2              }
 113   1      }
 114          
 115          void Operate_DiagTask(void)
 116          {
 117   1              SEG_XDATA U8 ID = SYS_MANU_DATE;
 118   1              SEG_XDATA U8 On_Time = FALSE;
 119   1              U8 Reserved_Address = 0U;
 120   1              U8 i = 0U;
 121   1      
 122   1              WDT_Clear();
 123   1      
 124   1              On_Time = Delay_Time_Get(TID_DIAG_ECU_RESET);
 125   1              if ( On_Time == TRUE)
 126   1              {
 127   2                      MCU_Reset();
 128   2              }
 129   1              WDT_Clear();
 130   1              On_Time = Delay_Time_Get(TID_FIRME_UPDATE);
 131   1              if ( On_Time == TRUE)
 132   1              {
 133   2                      PSBANK = 0x30;
 134   2                      Reserved_Address = *(U8 SEG_CODE*)(0xFC00U);
 135   2              }
 136   1              WDT_Clear();
 137   1      
 138   1              On_Time = Delay_Time_Get(TID_DTC_WRITE);
 139   1              if ( On_Time == TRUE)
 140   1              {
 141   2                      if ( DTC_Write_Set == TRUE)
 142   2                      {
 143   3                              Flash_DTC_Write();
 144   3                              DTC_Write_Set = FALSE;
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 414 

 145   3                      }
 146   2      
 147   2                      if (DTC_Err_Sensor_Reset == TRUE) 
 148   2                      {
 149   3                              DTC_Err_Sensor_Reset = FALSE;
 150   3                              //Delay_Time_Set(TID_SENSOR_RESET,DT_SENSOR_RESET);
 151   3                              Delay_Time_Expire(TID_OVERLAY_GUIDELINE);
 152   3                              //Delay_Time_Expire(TID_SENSOR_IDLE_PERIOD);
 153   3                              Delay_Time_Expire(TID_FRAME_VALIDE);
 154   3                              Delay_Time_Expire(TID_FRAME_COUNT);
 155   3                              Delay_Time_Expire(TID_I2C_COMM_CHECK);
 156   3      
 157   3                              for (i = DTC_SENSOR_FV_ERR; i < DTC_CODE_COUNT; i++)
 158   3                              {
 159   4                                      ga_Ext_tDTC_Type_Msg.tDTC_Type[i].Count = 0x00U;
 160   4                              }
 161   3      
 162   3                              SMBUS0_Init();
 163   3                              Isp_InterInit();
 164   3                      }
 165   2              }
 166   1              
 167   1      
 168   1              if (IGN_ON_Status == IGN_ON)
 169   1              {
 170   2                      if ( ga_Ext_tDTC_Type_Msg.DTC_State[DTC_CODE_INTERNAL_ERROR] == DTC_CONFIRM_ERROR )
 171   2                      {
 172   3                              ga_Ext_tDTC_Type_Msg.DTC_Clear_Count[DTC_CODE_INTERNAL_ERROR]++;
 173   3                              if ( ga_Ext_tDTC_Type_Msg.DTC_Clear_Count[DTC_CODE_INTERNAL_ERROR] > 30U)
 174   3                              {
 175   4                                      ga_Ext_tDTC_Type_Msg.tDTC_Type[DTC_MCU_WT_ERR].Status = DTC_CLEAR;
 176   4                                      ga_Ext_tDTC_Type_Msg.tDTC_Type[DTC_MCU_MC_ERR].Status = DTC_CLEAR;
 177   4              
 178   4                                      ga_Ext_tDTC_Type_Msg.DTC_Clear_Count[DTC_CODE_INTERNAL_ERROR] = 0x00U;
 179   4                                      ga_Ext_tDTC_Type_Msg.DTC_State[DTC_CODE_INTERNAL_ERROR] = DTC_CLEAR;
 180   4                              }
 181   3                              DTC_Write_Set = TRUE;
 182   3                      }       
 183   2      
 184   2                      if ( ga_Ext_tDTC_Type_Msg.DTC_State[DTC_CODE_SENSOR_ERROR] == DTC_CONFIRM_ERROR )
 185   2                      {
 186   3                              ga_Ext_tDTC_Type_Msg.DTC_Clear_Count[DTC_CODE_SENSOR_ERROR]++;
 187   3                              if ( ga_Ext_tDTC_Type_Msg.DTC_Clear_Count[DTC_CODE_SENSOR_ERROR] > 30U)
 188   3                              {
 189   4                                      ga_Ext_tDTC_Type_Msg.tDTC_Type[DTC_SENSOR_FV_ERR].Status = DTC_CLEAR;
 190   4                                      ga_Ext_tDTC_Type_Msg.tDTC_Type[DTC_SENSOR_FC_ERR].Status = DTC_CLEAR;
 191   4                                      ga_Ext_tDTC_Type_Msg.tDTC_Type[DTC_SENSOR_ISPSTAT_ERR].Status = DTC_CLEAR;
 192   4                                      ga_Ext_tDTC_Type_Msg.tDTC_Type[DTC_SENSOR_COMM_ERR].Status = DTC_CLEAR;
 193   4                                      ga_Ext_tDTC_Type_Msg.tDTC_Type[DTC_SENOSR_INIT_ERR].Status = DTC_CLEAR;
 194   4      
 195   4                                      ga_Ext_tDTC_Type_Msg.DTC_Clear_Count[DTC_CODE_SENSOR_ERROR] = 0x00U;
 196   4                                      ga_Ext_tDTC_Type_Msg.DTC_State[DTC_CODE_SENSOR_ERROR] = DTC_CLEAR;
 197   4                              }
 198   3                              DTC_Write_Set = TRUE;
 199   3                      }       
 200   2      
 201   2                      if ( ga_Ext_tDTC_Type_Msg.DTC_State[DTC_CODE_OUTPUT_ERROR] == DTC_CONFIRM_ERROR )
 202   2                      {
 203   3                              ga_Ext_tDTC_Type_Msg.DTC_Clear_Count[DTC_CODE_OUTPUT_ERROR]++;
 204   3                              if ( ga_Ext_tDTC_Type_Msg.DTC_Clear_Count[DTC_CODE_OUTPUT_ERROR] > 30U)
 205   3                              {
 206   4                                      ga_Ext_tDTC_Type_Msg.tDTC_Type[DTC_VIDEO_OUT_CUT_ERR].Status = DTC_CLEAR;
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 415 

 207   4                                      ga_Ext_tDTC_Type_Msg.tDTC_Type[DTC_VIDEO_OVER_VOL_ERR].Status = DTC_CLEAR;
 208   4              
 209   4                                      ga_Ext_tDTC_Type_Msg.DTC_Clear_Count[DTC_CODE_OUTPUT_ERROR] = 0x00U;
 210   4                                      ga_Ext_tDTC_Type_Msg.DTC_State[DTC_CODE_OUTPUT_ERROR] = DTC_CLEAR;
 211   4                              }
 212   3                              DTC_Write_Set = TRUE;
 213   3                      }       
 214   2                      IGN_ON_Status = IGN_PRE_ON;
 215   2              }
 216   1      }
 217          
 218          void Record_DTC_Error(U8 ID)
 219          {
 220   1              SEG_XDATA U8 is_error = FALSE;
 221   1      
 222   1              if (DTC_Set_Off == FALSE)
 223   1              {
 224   2                      if (ga_Ext_tDTC_Type_Msg.tDTC_Type[ID].Status != DTC_CURRENT_ERROR )
 225   2                      {
 226   3                              ga_Ext_tDTC_Type_Msg.tDTC_Type[ID].Count++;
 227   3                              if ( ID == DTC_MCU_WT_ERR ) 
 228   3                              {
 229   4                                      if (ga_Ext_tDTC_Type_Msg.tDTC_Type[DTC_MCU_WT_ERR].Count > 30U ){ is_error = TRUE;}
 230   4                              }
 231   3                              if ( ID == DTC_MCU_MC_ERR )
 232   3                              {
 233   4                                      if (ga_Ext_tDTC_Type_Msg.tDTC_Type[DTC_MCU_MC_ERR].Count > 30U ){ is_error = TRUE;}
 234   4                              }
 235   3                              if ( ID == DTC_SENSOR_FV_ERR ) 
 236   3                              {
 237   4                                      if (ga_Ext_tDTC_Type_Msg.tDTC_Type[DTC_SENSOR_FV_ERR].Count > 19U ){ is_error = TRUE;}
 238   4                              }
 239   3                              if ( ID == DTC_SENSOR_FC_ERR )
 240   3                              {
 241   4                                      if (ga_Ext_tDTC_Type_Msg.tDTC_Type[DTC_SENSOR_FC_ERR].Count > 19U ){ is_error = TRUE;}
 242   4                              }
 243   3                              if ( ID == DTC_SENSOR_ISPSTAT_ERR ) 
 244   3                              {
 245   4                                      if (ga_Ext_tDTC_Type_Msg.tDTC_Type[DTC_SENSOR_ISPSTAT_ERR].Count > 19U ){ is_error = TRUE;}
 246   4                              }
 247   3                              if ( ID == DTC_SENSOR_COMM_ERR )
 248   3                              {
 249   4                                      if (ga_Ext_tDTC_Type_Msg.tDTC_Type[DTC_SENSOR_COMM_ERR].Count > 19U ){ is_error = TRUE;}
 250   4                              }
 251   3                              if ( ID == DTC_SENOSR_INIT_ERR ) 
 252   3                              {
 253   4                                      if (ga_Ext_tDTC_Type_Msg.tDTC_Type[DTC_SENOSR_INIT_ERR].Count > 0U ){ is_error = TRUE;}
 254   4                              }
 255   3                              if ( ID == DTC_VIDEO_OUT_CUT_ERR )
 256   3                              {
 257   4                                      if (ga_Ext_tDTC_Type_Msg.tDTC_Type[DTC_VIDEO_OUT_CUT_ERR].Count > 0U ){ is_error = TRUE;}
 258   4                              }
 259   3                              if ( ID == DTC_VIDEO_OVER_VOL_ERR )
 260   3                              {
 261   4                                      if (ga_Ext_tDTC_Type_Msg.tDTC_Type[DTC_VIDEO_OVER_VOL_ERR].Count > 0U ){ is_error = TRUE;}
 262   4                              }       
 263   3                              
 264   3                              if ( is_error == TRUE)
 265   3                              {
 266   4                                      WDT_Clear();
 267   4                                      ga_Ext_tDTC_Type_Msg.tDTC_Type[ID].Count = 0x00U;
 268   4                                      if ( (ID == DTC_MCU_WT_ERR) || (ID == DTC_MCU_MC_ERR) )
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 416 

 269   4                                      {
 270   5                                              ga_Ext_tDTC_Type_Msg.tDTC_Type[ID].Status = DTC_CONFIRM_ERROR;
 271   5                                              ga_Ext_tDTC_Type_Msg.DTC_State[DTC_CODE_INTERNAL_ERROR] = DTC_CONFIRM_ERROR;
 272   5                                              ga_Ext_tDTC_Type_Msg.DTC_Clear_Count[DTC_CODE_INTERNAL_ERROR] = 0x00U;
 273   5                                      }
 274   4                                      else
 275   4                                      {
 276   5                                              ga_Ext_tDTC_Type_Msg.tDTC_Type[ID].Status = DTC_CURRENT_ERROR;
 277   5                                              if ( (ID == DTC_SENSOR_FV_ERR) || (ID == DTC_SENSOR_FC_ERR) ||
 278   5                                                   (ID == DTC_SENSOR_ISPSTAT_ERR) || (ID == DTC_SENSOR_COMM_ERR) || (ID == DTC_SENOSR_INIT_ERR) )
 279   5                                              {
 280   6                                                      if ((DTC_Err_Sensor_Reset == FALSE) &&
 281   6                                                         (ga_Ext_tDTC_Type_Msg.DTC_State[DTC_CODE_SENSOR_ERROR] != DTC_CURRENT_ERROR))
 282   6                                                      {
 283   7                                                              DTC_Err_Sensor_Reset = TRUE;
 284   7                                                      }
 285   6      
 286   6                                                      ga_Ext_tDTC_Type_Msg.DTC_State[DTC_CODE_SENSOR_ERROR] = DTC_CURRENT_ERROR;
 287   6                                                      ga_Ext_tDTC_Type_Msg.DTC_Clear_Count[DTC_CODE_SENSOR_ERROR] = 0x00U;
 288   6                                              }
 289   5                                              else if ( (ID == DTC_VIDEO_OUT_CUT_ERR) || (ID == DTC_VIDEO_OVER_VOL_ERR) )
 290   5                                              {
 291   6                                                      ga_Ext_tDTC_Type_Msg.DTC_State[DTC_CODE_OUTPUT_ERROR] = DTC_CURRENT_ERROR;
 292   6                                                      ga_Ext_tDTC_Type_Msg.DTC_Clear_Count[DTC_CODE_OUTPUT_ERROR] = 0x00U;
 293   6                                              }
 294   5                                              else{}
 295   5                                      }
 296   4                                      DTC_Write_Set = TRUE;
 297   4                              }
 298   3                      }
 299   2              }
 300   1      }
 301          
 302          void Record_DTC_Clear(U8 ID)
 303          {
 304   1      #if defined(DTC_RECORD_CLEAR)
 305   1              
 306   1              if (ga_Ext_tDTC_Type_Msg.tDTC_Type[ID].Status == DTC_CLEAR )
 307   1              {
 308   2                      if ( ga_Ext_tDTC_Type_Msg.tDTC_Type[ID].Count != 0x00U)
 309   2                      {
 310   3                              ga_Ext_tDTC_Type_Msg.tDTC_Type[ID].Count = 0x00U;
 311   3                              //DTC_Write_Set = TRUE;
 312   3                      }
 313   2              }       
 314   1              else if (ga_Ext_tDTC_Type_Msg.tDTC_Type[ID].Status == DTC_CURRENT_ERROR )// && tDTC_Type[ID].Status == DT
             -C_CONFIRM_ERROR)
 315   1              {
 316   2                      ga_Ext_tDTC_Type_Msg.tDTC_Type[ID].Count = 0x00U;
 317   2                      ga_Ext_tDTC_Type_Msg.tDTC_Type[ID].Status = DTC_CONFIRM_ERROR;
 318   2                      
 319   2                      if ( (ID == DTC_MCU_WT_ERR) || (ID == DTC_MCU_MC_ERR) )
 320   2                      {
 321   3                              ga_Ext_tDTC_Type_Msg.DTC_Clear_Count[DTC_CODE_INTERNAL_ERROR] = 0x00U;
 322   3                              ga_Ext_tDTC_Type_Msg.DTC_State[DTC_CODE_INTERNAL_ERROR] = DTC_CONFIRM_ERROR;
 323   3                      }
 324   2                      else if ( (ID == DTC_SENSOR_FV_ERR) || (ID == DTC_SENSOR_FC_ERR) ||
 325   2                           (ID == DTC_SENSOR_ISPSTAT_ERR) || (ID == DTC_SENSOR_COMM_ERR) || (ID == DTC_SENOSR_INIT_ERR) )
 326   2                      {
 327   3                              ga_Ext_tDTC_Type_Msg.DTC_Clear_Count[DTC_CODE_SENSOR_ERROR] = 0x00U;
 328   3                              ga_Ext_tDTC_Type_Msg.DTC_State[DTC_CODE_SENSOR_ERROR] = DTC_CONFIRM_ERROR;
 329   3                      }
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 417 

 330   2                      else if ( (ID == DTC_VIDEO_OUT_CUT_ERR) || (ID == DTC_VIDEO_OVER_VOL_ERR) )
 331   2                      {
 332   3                              ga_Ext_tDTC_Type_Msg.DTC_Clear_Count[DTC_CODE_OUTPUT_ERROR] = 0x00U;
 333   3                              ga_Ext_tDTC_Type_Msg.DTC_State[DTC_CODE_OUTPUT_ERROR] = DTC_CONFIRM_ERROR;
 334   3                      }
 335   2                      else{}
 336   2                      DTC_Write_Set = TRUE;
 337   2              }       
 338   1              else
 339   1              {
 340   2                      ga_Ext_tDTC_Type_Msg.tDTC_Type[ID].Count = 0x00U;
 341   2              }
 342   1      #endif
 343   1      }
 344          void Diag_Ecu_Reset(void)
 345          {
 346   1              EEPROM_Update_Mode = FALSE;
 347   1              Delay_Time_Set(TID_DIAG_ECU_RESET,DT_DIAG_ECU_RESET);
 348   1      }
 349          
 350          void Diag_Clear_DTC(void)
 351          {       
 352   1              FLASH_Erase_Buf((FLADDR)DTCCODE_ADDRESS,BANK2);
 353   1              Clear_DTC_Struct();
 354   1      }
 355          
 356          U8 Diag_Read_Dtc(U8 index)
 357          {
 358   1              SEG_XDATA U8 ret = 0U;
 359   1              if ( index == 0x01U)
 360   1              {
 361   2                      if ( ga_Ext_tDTC_Type_Msg.DTC_State[DTC_CODE_INTERNAL_ERROR] != 0xFFU )
 362   2                      {
 363   3                              ret = ga_Ext_tDTC_Type_Msg.DTC_State[DTC_CODE_INTERNAL_ERROR];
 364   3                      }
 365   2                      else
 366   2                      {
 367   3                              ret = FALSE;
 368   3                      }
 369   2              }
 370   1              if (index == 0x02U)
 371   1              {
 372   2                      if ( ga_Ext_tDTC_Type_Msg.DTC_State[DTC_CODE_SENSOR_ERROR] != 0xFFU )
 373   2                      {
 374   3                              ret = ga_Ext_tDTC_Type_Msg.DTC_State[DTC_CODE_SENSOR_ERROR];
 375   3                      }
 376   2                      else
 377   2                      {
 378   3                              ret = FALSE;
 379   3                      }
 380   2              }
 381   1              if ( index == 0x03U )
 382   1              {
 383   2                      if (  ga_Ext_tDTC_Type_Msg.DTC_State[DTC_CODE_OUTPUT_ERROR] != 0xFFU )
 384   2                      {
 385   3                              ret = ga_Ext_tDTC_Type_Msg.DTC_State[DTC_CODE_OUTPUT_ERROR];
 386   3                      }
 387   2                      else
 388   2                      {
 389   3                              ret = FALSE;
 390   3                      }
 391   2              }
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 418 

 392   1      
 393   1              return ret;
 394   1      }
 395          
 396          void Diag_Read_Sys(U8 ID, U8 *Buf,U8 Length)
 397          {
 398   1              U8 ret = 0U;
 399   1              U16 ret16 = 0x0000;
 400   1              SEG_XDATA U8 Flash_Data[3U] = {0,};
 401   1              SEG_XDATA U8 temp_buf[HMC_SPEC_TOTAL_COUNT] = {0,};
 402   1      
 403   1              memset(Buf, (char)0x00 ,Length);
 404   1      
 405   1              if ( ID == 0x02U )
 406   1              {
 407   2                      Buf[0] = USE_CASE_1BYTE;
 408   2                      Buf[1] = USE_CASE_2BYTE;
 409   2                      Buf[2] = USE_CASE_3BYTE;
 410   2                      Buf[3] = USE_CASE_4BYTE;
 411   2              
 412   2                      Flash_Data[0] = Optical_Axis_Data[0] + Optical_Axis_Data[6];
 413   2                      Flash_Data[1] = Optical_Axis_Data[1] + Optical_Axis_Data[7];
 414   2      
 415   2                      if (Flash_Data[0] < 0x80U) {
 416   3                      Buf[HMC_SPEC_OPTIC_X_HIGH_PID] = 0x00U;
 417   3                      } else {
 418   3                              Buf[HMC_SPEC_OPTIC_X_HIGH_PID] = 0xFFU;
 419   3                      }
 420   2                      Buf[HMC_SPEC_OPTIC_X_LOW_PID]  = Flash_Data[0];
 421   2      
 422   2                      if (Flash_Data[1] < 0x80U) {
 423   3                      Buf[HMC_SPEC_OPTIC_Y_HIGH_PID] = 0x00U;
 424   3                      } else {
 425   3                              Buf[HMC_SPEC_OPTIC_Y_HIGH_PID] = 0xFFU;
 426   3                      }
 427   2                      Buf[HMC_SPEC_OPTIC_Y_LOW_PID]  = Flash_Data[1];
 428   2      
 429   2                      if ( (Optical_Axis_Data[3U] == 0xFFU) && (Optical_Axis_Data[4U] == 0xFFU) )
 430   2                      {
 431   3                              if ( Optical_Axis_Data[5U] == 0xFFU )
 432   3                              {
 433   4                                      //Default
 434   4                                      Optical_Axis_Data[3U] = 0x00U;
 435   4                                      Optical_Axis_Data[4U] = 0x00U;
 436   4                              }
 437   3                      }
 438   2                      Buf[HMC_SPEC_RELATIVE_OPTIC_X_PID]  = Optical_Axis_Data[3U];
 439   2                      Buf[HMC_SPEC_RELATIVE_OPTIC_Y_PID]  = Optical_Axis_Data[4U];
 440   2      
 441   2                      Buf[HMC_SPEC_COUNTRY_CFG_PID] = tCAN_Rx_Msg[USE_LANGUAGEINFO].Pre_Data;
 442   2                      Buf[HMC_SPEC_TEMPERATURE_PID] = Get_Temperature();//¿Âµµ °è»ê 
 443   2      
 444   2                      ret16 = (U16)IlGetRxSAS_Angle();
 445   2      
 446   2                      Buf[HMC_SPEC_SAS_ANGLE_HIGH_PID] = (U8)(ret16 >> 8U ) & 0xFFU;
 447   2                      Buf[HMC_SPEC_SAS_ANGLE_LOW_PID] = (U8)ret16 & 0xFFU;
 448   2      
 449   2                      if      ( ga_Ext_tDTC_Type_Msg.tDTC_Type[DTC_MCU_WT_ERR].Status == DTC_CURRENT_ERROR) {Buf[HMC_SPEC_DTC_
             -CURRENT_LOW_PID] |= 0x01U;}
 450   2                      else if ( ga_Ext_tDTC_Type_Msg.tDTC_Type[DTC_MCU_WT_ERR].Status == DTC_CONFIRM_ERROR) {Buf[HMC_SPEC_DTC_
             -CONFIRM_LOW_PID] |= 0x01U;}
 451   2                      else{}
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 419 

 452   2      
 453   2                      if      ( ga_Ext_tDTC_Type_Msg.tDTC_Type[DTC_MCU_MC_ERR].Status == DTC_CURRENT_ERROR) {Buf[HMC_SPEC_DTC_
             -CURRENT_LOW_PID] |= 0x02U;}
 454   2                      else if ( ga_Ext_tDTC_Type_Msg.tDTC_Type[DTC_MCU_MC_ERR].Status == DTC_CONFIRM_ERROR) {Buf[HMC_SPEC_DTC_
             -CONFIRM_LOW_PID] |= 0x02U;}
 455   2                      else{}
 456   2      
 457   2                      if      ( ga_Ext_tDTC_Type_Msg.tDTC_Type[DTC_SENSOR_FV_ERR].Status == DTC_CURRENT_ERROR) {Buf[HMC_SPEC_D
             -TC_CURRENT_LOW_PID] |= 0x04U;}
 458   2                      else if ( ga_Ext_tDTC_Type_Msg.tDTC_Type[DTC_SENSOR_FV_ERR].Status == DTC_CONFIRM_ERROR) {Buf[HMC_SPEC_D
             -TC_CONFIRM_LOW_PID] |= 0x04U;}
 459   2                      else{}
 460   2      
 461   2                      if      ( ga_Ext_tDTC_Type_Msg.tDTC_Type[DTC_SENSOR_FC_ERR].Status == DTC_CURRENT_ERROR) {Buf[HMC_SPEC_D
             -TC_CURRENT_LOW_PID] |= 0x08U;}
 462   2                      else if ( ga_Ext_tDTC_Type_Msg.tDTC_Type[DTC_SENSOR_FC_ERR].Status == DTC_CONFIRM_ERROR) {Buf[HMC_SPEC_D
             -TC_CONFIRM_LOW_PID] |= 0x08U;}
 463   2                      else{}
 464   2      
 465   2                      if      ( ga_Ext_tDTC_Type_Msg.tDTC_Type[DTC_SENSOR_ISPSTAT_ERR].Status == DTC_CURRENT_ERROR) {Buf[HMC_S
             -PEC_DTC_CURRENT_LOW_PID] |= 0x10U;}
 466   2                      else if ( ga_Ext_tDTC_Type_Msg.tDTC_Type[DTC_SENSOR_ISPSTAT_ERR].Status == DTC_CONFIRM_ERROR) {Buf[HMC_S
             -PEC_DTC_CONFIRM_LOW_PID] |= 0x10U;}
 467   2                      else{}
 468   2      
 469   2                      if      ( ga_Ext_tDTC_Type_Msg.tDTC_Type[DTC_SENSOR_COMM_ERR].Status == DTC_CURRENT_ERROR) {Buf[HMC_SPEC
             -_DTC_CURRENT_LOW_PID] |= 0x20U;}
 470   2                      else if ( ga_Ext_tDTC_Type_Msg.tDTC_Type[DTC_SENSOR_COMM_ERR].Status == DTC_CONFIRM_ERROR) {Buf[HMC_SPEC
             -_DTC_CONFIRM_LOW_PID] |= 0x20U;}
 471   2                      else{}
 472   2      
 473   2                      if      ( ga_Ext_tDTC_Type_Msg.tDTC_Type[DTC_SENOSR_INIT_ERR].Status == DTC_CURRENT_ERROR) {Buf[HMC_SPEC
             -_DTC_CURRENT_LOW_PID] |= 0x40U;}
 474   2                      else if ( ga_Ext_tDTC_Type_Msg.tDTC_Type[DTC_SENOSR_INIT_ERR].Status == DTC_CONFIRM_ERROR) {Buf[HMC_SPEC
             -_DTC_CONFIRM_LOW_PID] |= 0x40U;}
 475   2                      else{}
 476   2      
 477   2                      if      ( ga_Ext_tDTC_Type_Msg.tDTC_Type[DTC_VIDEO_OUT_CUT_ERR].Status == DTC_CURRENT_ERROR) {Buf[HMC_SP
             -EC_DTC_CURRENT_LOW_PID] |= 0x80U;}
 478   2                      else if ( ga_Ext_tDTC_Type_Msg.tDTC_Type[DTC_VIDEO_OUT_CUT_ERR].Status == DTC_CONFIRM_ERROR) {Buf[HMC_SP
             -EC_DTC_CONFIRM_LOW_PID] |= 0x80U;}
 479   2                      else{}
 480   2      
 481   2                      if      ( ga_Ext_tDTC_Type_Msg.tDTC_Type[DTC_VIDEO_OVER_VOL_ERR].Status == DTC_CURRENT_ERROR) {Buf[HMC_S
             -PEC_DTC_CURRENT_HIGH_PID] |= 0x01U;}
 482   2                      else if ( ga_Ext_tDTC_Type_Msg.tDTC_Type[DTC_VIDEO_OVER_VOL_ERR].Status == DTC_CONFIRM_ERROR) {Buf[HMC_S
             -PEC_DTC_CONFIRM_HIGH_PID] |= 0x01U;}
 483   2                      else{}
 484   2              }
 485   1              else
 486   1              {
 487   2                      SYS_Flash_Read(ID,Buf,Length);
 488   2              }
 489   1              ret = 0x04;
 490   1              memcpy(temp_buf,Buf,Length);
 491   1      }
 492          
 493          void Firmware_Update(void)
 494          {
 495   1              Delay_Time_Set(TID_FIRME_UPDATE,DT_FIRME_UPDATE);
 496   1      }
 497          
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 420 

 498          void Diag_Eeprom_Update(void)
 499          {
 500   1              Isp_Off();
 501   1              EEPROM_Update_Mode = TRUE;
 502   1              MCU_F_ENABLE = 0x01U;
 503   1      
 504   1              EIE1 &= (U8)(~0x04U);                       // Enable ADC0 conversion complete int.
 505   1              EIE1 &= (U8)(~0x01U);
 506   1      }
 507          
 508          void Diag_Write_Transfer_Data(U8 *Buf)
 509          {
 510   1              SEG_XDATA U32    address = (U32)0x00U;
 511   1              static SEG_XDATA U32 cnt   = (U32)0x00U;
 512   1              static SEG_XDATA U32 erase_cnt   = (U32)0x00U;
 513   1              static SEG_XDATA U32 lotation = (U32)0x01U;
 514   1              static SEG_XDATA volatile U8 Buf1[256] = {0U,};
 515   1              static SEG_XDATA volatile U8 Buf2[256] = {0U,};
 516   1              static SEG_XDATA volatile U8 buf1_index = 253U;
 517   1              static SEG_XDATA volatile U8 buf2_index = 3U;
 518   1              static SEG_XDATA volatile U8 loop_index = 0U;
 519   1              SEG_XDATA U8 Write_Buf[256] = {0U,};
 520   1      
 521   1              if ((cnt % (U32)16) == (U32)0)
 522   1              {
 523   2                      Flash_EraseSector(erase_cnt*(U32)0x1000U);      
 524   2                      erase_cnt++;
 525   2                      Wait_ms(100U);
 526   2              }
 527   1              if ( cnt == 0x00U)
 528   1              {
 529   2                      memset(Buf1, (char)0xFFU ,256U);        
 530   2                      memset(Buf2, (char)0xFFU ,256U);        
 531   2                      memcpy(Buf1,&Buf[1U],253U);
 532   2              }
 533   1              else
 534   1              {
 535   2                      if ( loop_index == 0U)
 536   2                      {
 537   3                              if ( buf1_index == 1U)
 538   3                              {
 539   4                                      memcpy(&Buf1[buf1_index],&Buf[1U],253U);
 540   4                                      //memcpy(Buf1,Buf,256U);
 541   4                                      buf1_index = 254U;
 542   4                                      buf2_index = 2U;
 543   4                                      loop_index = 1U;
 544   4                                      lotation++;
 545   4                              }
 546   3                              else
 547   3                              {
 548   4                                      memcpy(Buf2,&Buf[1U],253U);
 549   4                                      memcpy(&Buf1[buf1_index],Buf2,buf2_index);
 550   4                                      
 551   4                                      address = (cnt-lotation)*(U32)256;
 552   4                                      memcpy(Write_Buf,Buf1,256U);
 553   4      
 554   4                                      Flash_Write(address,Write_Buf,(U16)256);
 555   4      
 556   4                                      memset(Buf1, (char)0xFFU ,256U);        
 557   4                                      memcpy(Buf1,&Buf2[buf2_index],buf1_index);
 558   4                                      memset(Buf2, (char)0xFFU ,256U);        
 559   4                                      buf1_index-=3U;
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 421 

 560   4                                      buf2_index+=3U;
 561   4                              }
 562   3                      }
 563   2                      
 564   2                      else if ( loop_index == 1U)
 565   2                      {
 566   3                              if ( buf1_index == 2U)
 567   3                              {
 568   4                                      memcpy(&Buf1[buf1_index],(Buf+1U),253U);
 569   4                                      buf1_index = 255U;
 570   4                                      buf2_index = 1U;
 571   4                                      loop_index = 2U;
 572   4                                      lotation++;
 573   4                              }
 574   3                              else
 575   3                              {       
 576   4                                      memcpy(Buf2,&Buf[1U],253U);
 577   4                                      memcpy(&Buf1[buf1_index],Buf2,buf2_index);
 578   4                                      
 579   4                                      address = (cnt-lotation)*(U32)256;
 580   4                                      memcpy(Write_Buf,Buf1,256U);
 581   4      
 582   4                                      Flash_Write(address,Write_Buf,(U16)256);
 583   4      
 584   4                                      memset(Buf1, (char)0xFFU ,256U);        
 585   4                                      memcpy(Buf1,&Buf2[buf2_index],buf1_index);
 586   4                                      memset(Buf2, (char)0xFFU ,256U);        
 587   4                                      buf1_index-=3U;
 588   4                                      buf2_index+=3U;
 589   4                              }
 590   3                                      
 591   3                      }
 592   2                      else if ( loop_index == 2U )
 593   2                      {
 594   3                              if ( buf1_index == 0U)
 595   3                              {
 596   4                                      memcpy(&Buf1[buf1_index],&Buf[1U],253U);
 597   4                                      buf1_index = 253U;
 598   4                                      buf2_index = 3U;
 599   4                                      loop_index = 0U;
 600   4                                      lotation++;
 601   4                              }
 602   3                              else
 603   3                              {
 604   4                                      memcpy(Buf2,&Buf[1U],253U);
 605   4                                      memcpy(&Buf1[buf1_index],Buf2,buf2_index);
 606   4                                      
 607   4                                      address = (cnt-lotation)*(U32)256;
 608   4                                      memcpy(Write_Buf,Buf1,256U);
 609   4      
 610   4                                      Flash_Write(address,Write_Buf,(U16)256);
 611   4      
 612   4                                      memset(Buf1, (char)0xFFU ,256U);        
 613   4                                      memcpy(Buf1,&Buf2[buf2_index],buf1_index);
 614   4                                      memset(Buf2, (char)0xFFU ,256U);        
 615   4                                      buf1_index-=3U;
 616   4                                      buf2_index+=3U;
 617   4                              }
 618   3                      }
 619   2                      else
 620   2                      {
 621   3                      }
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 422 

 622   2                      
 623   2              }
 624   1              cnt++;
 625   1      }
 626          
 627          void Diag_Sensor_Reset(void)
 628          {
 629   1              Init_IspTask();
 630   1      }
 631          
 632          void Diag_Guid_OnOff(U8 OnOff)
 633          {
 634   1              isp_guide_on_off(OnOff);
 635   1      }
 636          
 637          void Diag_Calibration_Mode_start(void)
 638          {
 639   1              DIAG_CALIBRATION_MODE_ACTIVE(TRUE);
 640   1              
 641   1              memset(Optical_Axis_Data, (char)0xFFU ,9U);
 642   1      
 643   1              FLASH_Read_Buf(Optical_Axis_Data,(FLADDR)OPTIC_ADDRESS,9U,BANK2);
 644   1      
 645   1              if ( (Optical_Axis_Data[0] == 0xFFU) && (Optical_Axis_Data[1] == 0xFFU) )
 646   1              {
 647   2                      if ( Optical_Axis_Data[2] == 0xFFU )
 648   2                      {
 649   3                              //Default
 650   3                              Optical_Axis_Data[0] = 0x00U;
 651   3                              Optical_Axis_Data[1] = 0x00U;
 652   3                      }
 653   2              }
 654   1      
 655   1              if ( (Optical_Axis_Data[6] == 0xFFU) && (Optical_Axis_Data[7] == 0xFFU) )
 656   1              {
 657   2                      if ( Optical_Axis_Data[8] == 0xFFU )
 658   2                      {
 659   3                              //Default
 660   3                              Optical_Axis_Data[6] = 0x00U;
 661   3                              Optical_Axis_Data[7] = 0x00U;
 662   3                      }
 663   2              }
 664   1      
 665   1              //memcpy(Calibration_Data, &Optical_Axis_Data[6],3U);
 666   1      }
 667          
 668          void Diag_Calibration_Mode(U8 Ctrl_Para)
 669          {
 670   1              SEG_XDATA volatile U8 i,Cs = 0U;
 671   1              SEG_XDATA volatile U8 X_Axis;
 672   1              SEG_XDATA volatile U8 Y_Axis;
 673   1      
 674   1              if (DIAG_CALIBRATION_MODE_STATE == TRUE)
 675   1              {
 676   2                      switch (Ctrl_Para)
 677   2                      {
 678   3                              case CALIBRATION_MODE_START:
 679   3                                      Diag_Calibration_Mode_start();
 680   3                                      DIAG_OPTIC_OFFSET_SET_ACTIVE(TRUE);
 681   3                                      Diag_DTC_Set_Off();
 682   3                                      break;
 683   3      
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 423 

 684   3                              case CALIBRATION_MODE_STOP: // Save data & Mode Stop
 685   3                                      FLASH_Erase_Buf((FLADDR)OPTIC_ADDRESS, BANK2);
 686   3                                      FLASH_Write_Buf((FLADDR)OPTIC_ADDRESS, Optical_Axis_Data, 0x09U, BANK2);
 687   3      
 688   3                                      DIAG_OPTIC_OFFSET_SET_ACTIVE(TRUE);
 689   3                                      DIAG_CALIBRATION_MODE_ACTIVE(FALSE);
 690   3                                      Diag_DTC_Set_On();
 691   3                                      break;
 692   3      
 693   3                              case CALIBRATION_MOVE_DEFAULT:
 694   3                                      Calibration_Data[0] = 0x00U;
 695   3                                      Calibration_Data[1] = 0x00U;
 696   3      
 697   3                                      break;
 698   3      
 699   3                              case CALIBRATION_MOVE_LEFT:
 700   3                                      X_Axis = Optical_Axis_Data[0] + Optical_Axis_Data[6];
 701   3      
 702   3                                      if ((X_Axis <= OPTIC_X_LIMIT_MINUS) && (X_Axis >= 0x80U))
 703   3                                      {
 704   4                                              X_Axis = OPTIC_X_LIMIT_MINUS - Optical_Axis_Data[0];
 705   4                                              Calibration_Data[0] = X_Axis;
 706   4                                      }
 707   3                                      else
 708   3                                      {
 709   4                                              Calibration_Data[0] = Optical_Axis_Data[6] - 0x01U;
 710   4                                      }
 711   3                                      Calibration_Data[1] = Optical_Axis_Data[7];
 712   3      
 713   3                                      break;
 714   3      
 715   3                              case CALIBRATION_MOVE_RIGHT:
 716   3                                      X_Axis = Optical_Axis_Data[0] + Optical_Axis_Data[6];
 717   3      
 718   3                                      if ((X_Axis >= OPTIC_X_LIMIT_PLUS) && (X_Axis < 0x80U))
 719   3                                      {
 720   4                                              X_Axis = OPTIC_X_LIMIT_PLUS - Optical_Axis_Data[0];
 721   4                                              Calibration_Data[0] = X_Axis;
 722   4                                      }
 723   3                                      else
 724   3                                      {
 725   4                                              Calibration_Data[0] = Optical_Axis_Data[6] + 0x01U;
 726   4                                      }
 727   3                                      Calibration_Data[1] = Optical_Axis_Data[7];
 728   3      
 729   3                                      break;
 730   3      
 731   3                              case CALIBRATION_MOVE_UP:
 732   3                                      Y_Axis = Optical_Axis_Data[1] + Optical_Axis_Data[7];
 733   3      
 734   3                                      if ((Y_Axis >= OPTIC_Y_LIMIT_PLUS) && (Y_Axis < 0x80U))
 735   3                                      {
 736   4                                              Y_Axis = OPTIC_Y_LIMIT_PLUS - Optical_Axis_Data[1];
 737   4                                              Calibration_Data[1] = Y_Axis;
 738   4                                      }
 739   3                                      else
 740   3                                      {
 741   4                                              Calibration_Data[1] = Optical_Axis_Data[7] + 0x01U;
 742   4                                      }
 743   3                                      Calibration_Data[0] = Optical_Axis_Data[6];
 744   3      
 745   3                                      break;
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 424 

 746   3      
 747   3                              case CALIBRATION_MOVE_DOWN:                             
 748   3                                      Y_Axis = Optical_Axis_Data[1] + Optical_Axis_Data[7];
 749   3      
 750   3                                      if ((Y_Axis <= OPTIC_Y_LIMIT_MINUS) && (Y_Axis >= 0x80U))
 751   3                                      {
 752   4                                              Y_Axis = OPTIC_Y_LIMIT_MINUS - Optical_Axis_Data[1];
 753   4                                              Calibration_Data[1] = Y_Axis;
 754   4                                      }
 755   3                                      else
 756   3                                      {
 757   4                                              Calibration_Data[1] = Optical_Axis_Data[7] - 0x01U;
 758   4                                      }
 759   3                                      Calibration_Data[0] = Optical_Axis_Data[6];
 760   3      
 761   3                                      break;
 762   3      
 763   3                              default:
 764   3      
 765   3                                      break;
 766   3                      }
 767   2                      
 768   2                      if ((Ctrl_Para >= CALIBRATION_MOVE_DEFAULT) && (Ctrl_Para <= CALIBRATION_MOVE_DOWN))
 769   2                      {
 770   3                              for (i = 0; i < 2U; i++)
 771   3                              {
 772   4                                      Cs ^= Calibration_Data[0 + i];
 773   4                              }
 774   3                              Calibration_Data[2] = Cs;
 775   3      
 776   3                              memcpy(&Optical_Axis_Data[6],&Calibration_Data[0],3U);
 777   3      
 778   3                              DIAG_OPTIC_OFFSET_SET_ACTIVE(TRUE);
 779   3                      }       
 780   2              }
 781   1              else
 782   1              {
 783   2                      if (Ctrl_Para == CALIBRATION_MODE_START)
 784   2                      {
 785   3                              Diag_Calibration_Mode_start();
 786   3                              Diag_DTC_Set_Off();
 787   3                      }
 788   2              }
 789   1      }
 790          
 791          void Diag_Exit_Update(void)
 792          {
 793   1              //MCU_Reset();
 794   1      }
 795          
 796          void Diag_DTC_Set_On(void)
 797          {
 798   1              DTC_Set_Off = FALSE;
 799   1      }
 800          
 801          void Diag_DTC_Set_Off(void)
 802          {
 803   1              DTC_Set_Off = TRUE;
 804   1      }
 805          
 806          void Flash_DTC_Write(void)
 807          {
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 425 

 808   1              SEG_XDATA volatile U8 ret,i,Cs = 0x00U;
 809   1              SEG_XDATA volatile U8 Write_Buf[sizeof(tMsg_Ext_DTC_Type)+1U] = {0,};
 810   1              SEG_XDATA volatile U8 Read_Buf[sizeof(tMsg_Ext_DTC_Type)+1U] = {0,};
 811   1              SEG_XDATA FLADDR Write_Address = 0x0000U;
 812   1              SEG_XDATA FLADDR Read_Address = 0x0000U;
 813   1              SEG_XDATA FLADDR temp_Address1 = 0x0000U;
 814   1              SEG_XDATA FLADDR temp_Address2 = 0x0000U;
 815   1      
 816   1              memset(Write_Buf,0x00U,sizeof(Write_Buf));
 817   1              memset(Read_Buf,0x00U,sizeof(Read_Buf));
 818   1      
 819   1              memcpy(Write_Buf,&ga_Ext_tDTC_Type_Msg,sizeof(tMsg_Ext_DTC_Type));
 820   1      
 821   1              for (i = 0U; i < sizeof(tMsg_Ext_DTC_Type); i++ )
 822   1              {
 823   2                      Cs ^= Write_Buf[i];
 824   2              }
 825   1              Write_Buf[sizeof(tMsg_Ext_DTC_Type)] = Cs;
 826   1      
 827   1              FLASH_Read_Buf(Read_Buf,(FLADDR)DTCCODE_ADDRESS,1U,BANK2);
 828   1              FLASH_Erase_Buf((FLADDR)DTCCODE_ADDRESS,BANK2);
 829   1      
 830   1              if ( Read_Buf[0] == 0xFFU)
 831   1              {
 832   2                      Read_Buf[0] = 0x00U;
 833   2              }
 834   1      
 835   1              temp_Address1 = (FLADDR)Read_Buf[0U]*(FLADDR)sizeof(tMsg_Ext_DTC_Type);
 836   1              temp_Address2 = temp_Address1 + (FLADDR)1U;
 837   1              Write_Address = (FLADDR)(DTCCODE_ADDRESS + temp_Address2);
 838   1              Read_Address = Write_Address;
 839   1      
 840   1              while(1)
 841   1              {
 842   2                      FLASH_Write_Buf(Write_Address,Write_Buf,sizeof(tMsg_Ext_DTC_Type)+1U,BANK2);
 843   2                      FLASH_Read_Buf(Read_Buf,Read_Address,sizeof(tMsg_Ext_DTC_Type)+1U,BANK2);
 844   2      
 845   2                      ret = (U8)memcmp(&Read_Buf,&Write_Buf,sizeof(Write_Buf));       
 846   2                      if ( ret != 0x00U)
 847   2                      {
 848   3                              temp_Address1 = (FLADDR)sizeof(tMsg_Ext_DTC_Type)+(FLADDR)1U;
 849   3                              Write_Address += temp_Address1;
 850   3                              Read_Address = Write_Address;
 851   3                                      
 852   3                              if ( Write_Address >= (DTCCODE_ADDRESS+236U) )
 853   3                              {
 854   4                                      Write_Address = DTCCODE_ADDRESS+1U;
 855   4                                      Read_Address  = DTCCODE_ADDRESS+1U;
 856   4                              }
 857   3                      }
 858   2                      else
 859   2                      {
 860   3                              break;
 861   3                      }
 862   2              }
 863   1      }
 864          /*---This function use for Read DTC data from flash--------------*/ 
 865          /*
 866                  *Read data from Flash, 
 867                  *Process and check data integrity, 
 868                  *Then copy data to variable ga_Ext_tDTC_Type_Msg if data is valid.
 869          */
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 426 

 870          void Flash_DTC_Read(void)
 871          {
 872   1              SEG_XDATA volatile U8 i,Cs = 0x00U;
 873   1      
 874   1          // Khai báo mang volatile có kích thuoc là sizeof(tMsg_Ext_DTC_Type)+1U và khoi tao gia tri là 0
 875   1              SEG_XDATA volatile U8 Read_Buf[sizeof(tMsg_Ext_DTC_Type)+1U] = {0,};
 876   1      
 877   1          // Khai báo bien Read_Address và hai bien tam temp_Address1, temp_Address2 là bien cuc bo
 878   1              SEG_XDATA volatile FLADDR Read_Address = 0x0000U;
 879   1              SEG_XDATA FLADDR temp_Address1 = 0x0000U;
 880   1              SEG_XDATA FLADDR temp_Address2 = 0x0000U;
 881   1              //FLADDR : 0 ~ 0xFFFF (unsigned int) 
 882   1          // Ðat tat ca các byte trong mang Read_Buf va giá tri 0
 883   1              memset(Read_Buf, (char)0x00U ,sizeof(tMsg_Ext_DTC_Type)+1U);
 884   1      
 885   1          // Ðac mot byte tu dia chi DTCCODE_ADDRESS trong bo nho Flash vào mang Read_Buf
 886   1              //DTCCODE_ADDRESS = 0xFF00U;
 887   1              FLASH_Read_Buf(Read_Buf,(FLADDR)DTCCODE_ADDRESS,1U,BANK2);
 888   1      
 889   1          // Neu byte doc duoc là 0xFFU, gán giá tri 0 cho byte do
 890   1              if ( Read_Buf[0] == 0xFFU)
 891   1              {
 892   2                      Read_Buf[0] = 0x00U;
 893   2              }
 894   1      
 895   1          // Tính toán dia chi temp_Address1 và temp_Address2
 896   1      
 897   1              temp_Address1 = (FLADDR)Read_Buf[0U]*(FLADDR)sizeof(tMsg_Ext_DTC_Type);
 898   1              temp_Address2 = temp_Address1 + (FLADDR)1U;
 899   1          // Tính toán ð?a ch? Read_Address
 900   1              Read_Address = (FLADDR)DTCCODE_ADDRESS + temp_Address2;
 901   1              // = fc25 
 902   1          // Ð?c m?t kh?i d? li?u t? ð?a ch? Read_Address trong b? nh? Flash vào m?ng Read_Buf
 903   1              FLASH_Read_Buf(Read_Buf,Read_Address,sizeof(Read_Buf),BANK2);
 904   1      
 905   1          // Tính toán giá tr? XOR c?a t?t c? các byte trong m?ng Read_Buf, k?t qu? lýu vào bi?n Cs
 906   1              for (i = 0U; i < sizeof(tMsg_Ext_DTC_Type); i++ )
 907   1              {
 908   2                      Cs ^= Read_Buf[i];
 909   2              }
 910   1      
 911   1          // Ki?m tra xem giá tr? tính ðý?c t? XOR có b?ng giá tr? cu?i cùng trong m?ng Read_Buf hay không
 912   1              if ( Cs == Read_Buf[sizeof(tMsg_Ext_DTC_Type)])
 913   1              {
 914   2              // N?u b?ng, sao chép d? li?u t? m?ng Read_Buf vào bi?n ga_Ext_tDTC_Type_Msg
 915   2                      memcpy(&ga_Ext_tDTC_Type_Msg,Read_Buf,sizeof(tMsg_Ext_DTC_Type));
 916   2              }
 917   1      }
 918          void Diag_Write_Sys(U8 *Write_Buf,U8 Length)
 919          {
 920   1              SEG_XDATA volatile U8 i,Cs,Cs_size,len;
 921   1              SEG_XDATA volatile U8 Buf[SYS_WRITE_CODE_SIZE] = {0,};
 922   1              
 923   1              len = Length;
 924   1              Cs_size = SYS_WRITE_CODE_SIZE-1U;
 925   1              FLASH_Erase_Buf((FLADDR)SYSINFO_ADDRESS,BANK2);
 926   1              memset(Buf, (char)0x00U ,SYS_WRITE_CODE_SIZE);
 927   1              memcpy(&Buf[0U],Write_Buf,SYS_WRITE_CODE_SIZE);
 928   1      
 929   1              for (i = 0; i < Cs_size; i++)
 930   1              {
 931   2                      Cs ^= Buf[i];
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 427 

 932   2              }
 933   1              Buf[Cs_size] = Cs;
 934   1              FLASH_Write_Buf((FLADDR)SYSINFO_ADDRESS,Buf,SYS_WRITE_CODE_SIZE,BANK2);
 935   1      
 936   1      }
 937          
 938          void Diag_Extra_Data_Process(U8 *Write_Buf)
 939          {
 940   1              SEG_XDATA volatile U8 i,Cs;
 941   1              SEG_XDATA volatile U8 Buf[6] = {0,};
 942   1              
 943   1              if ( Write_Buf[0] == OPTIC_SETTING )
 944   1              {
 945   2                      FLASH_Erase_Buf((FLADDR)OPTIC_ADDRESS,BANK2);
 946   2      
 947   2                      memset(Buf, (char)0x00U ,6U);
 948   2                      memcpy(Buf,&Write_Buf[1U],2U);
 949   2                      memcpy(&Buf[3],&Write_Buf[3U],2U);
 950   2      
 951   2                      for (i = 0; i < 2U; i++)
 952   2                      {
 953   3                              Cs ^= Buf[i];
 954   3                      }
 955   2                      Buf[2U] = Cs;
 956   2      
 957   2                      for (i = 3; i < 5U; i++)
 958   2                      {
 959   3                              Cs ^= Buf[i];
 960   3                      }
 961   2                      Buf[5U] = Cs;
 962   2      
 963   2                      FLASH_Write_Buf((FLADDR)OPTIC_ADDRESS,Buf,0x06U,BANK2);
 964   2                      Diag_Ecu_Reset();
 965   2              }
 966   1              else if ( Write_Buf[0] == ERASE_ONESPEC )
 967   1              {
 968   2                      FLASH_Erase_Buf((FLADDR)ONESPEC_ADDRESS,BANK2);
 969   2                      Diag_Ecu_Reset();
 970   2              }
 971   1              else if ( Write_Buf[0] == ERASE_FLASH_ALL )
 972   1              {
 973   2                      Isp_Off();
 974   2                      EEPROM_Update_Mode = TRUE;
 975   2                      MCU_F_ENABLE = 0x01;
 976   2                      Wait_ms(30U);
 977   2      
 978   2                      for ( i = 0 ; i < 50U; i++)
 979   2                      {
 980   3                              Flash_EraseSector((U32)i*(U32)0x1000U); 
 981   3                              WDT_Clear();
 982   3                      }
 983   2              }
 984   1              else{}
 985   1      }
 986          
 987          void SYS_Flash_Read(U8 ID,U8 *Read_Buf,U8 Length)
 988          {
 989   1              SEG_XDATA volatile U8 i,Cs;
 990   1              SEG_XDATA volatile U8 Buf[SYS_CODE_SIZE+1U] = {0,};
 991   1      
 992   1              memset(Buf, (char)0x00U ,Length);
 993   1      
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 428 

 994   1              FLASH_Read_Buf(Buf,(FLADDR)SYSINFO_ADDRESS,sizeof(Buf),BANK2);
 995   1      
 996   1              for (i = 0; i < SYS_CODE_SIZE; i++)
 997   1              {
 998   2                      Cs ^= Buf[i];
 999   2              }
1000   1              Cs = Buf[SYS_CODE_SIZE];
1001   1              if ( Cs == Buf[SYS_CODE_SIZE])
1002   1              {
1003   2                      switch(ID)
1004   2                      {
1005   3                              case SYS_HMC_SPEC:
1006   3                                      memcpy(Read_Buf,&Buf[0U],Length);
1007   3                              break;
1008   3                              case SYS_PART_NUMBER:
1009   3                                      memcpy(Read_Buf,&Buf[SYS_PART_NUMBER_L],Length);
1010   3                              break;
1011   3                              case SYS_MANU_DATE:
1012   3                                      memcpy(Read_Buf,&Buf[SYS_MANU_DATE_L],Length);
1013   3                              break;
1014   3                              case SYS_HW_VERSION:
1015   3                                      memcpy(Read_Buf,&Buf[SYS_HW_VERSION_L],Length);
1016   3                              break;
1017   3                              case SYS_SW_VERSION:
1018   3                                      memcpy(Read_Buf,&Buf[SYS_SW_VERSION_L],Length);
1019   3                              break;
1020   3                              case SYS_CAN_VERSION:
1021   3                                      memcpy(Read_Buf,&Buf[SYS_CAN_VERSION_L],Length);
1022   3                              break;
1023   3                              default:
1024   3                              break;
1025   3                      }
1026   2              }
1027   1      }
1028          
1029          void Diag_Read_Address(U8 *Read_Buf, U32 DataAddr, U16 DataLen) //Version code read from access
1030          {
1031   1              SEG_XDATA volatile U8 DataBuf[16] = {0,};
1032   1              SEG_XDATA volatile U8 CodeBank1 = 0x00U;
1033   1              SEG_XDATA volatile U8 CodeBank2 = 0x00U;
1034   1              SEG_XDATA volatile FLADDR Read_Address1 = 0x0000U;
1035   1              SEG_XDATA volatile FLADDR Read_Address2 = 0x0000U;
1036   1              SEG_XDATA volatile U16 Length1 = 0x0000U;
1037   1              SEG_XDATA volatile U16 Length2 = 0x0000U;
1038   1      
1039   1              //memset(CodeBuf, (char)0xFFU ,sizeof(CodeBuf));
1040   1              CodeBank1 = DataAddr/0x8000;
1041   1              CodeBank2 = (DataAddr + DataLen -1)/0x8000;
1042   1              
1043   1              if (CodeBank1 == 0x00U)
1044   1              {
1045   2                      CodeBank1 = 0x01U;
1046   2                      CodeBank2 = 0x01U;
1047   2              }
1048   1      
1049   1              if (CodeBank1 == CodeBank2)
1050   1              {
1051   2                      Read_Address1 = DataAddr - ((CodeBank1 - 1) * 0x8000);
1052   2                      Length1 = DataLen;
1053   2                      CodeBank1 *= BANK1;
1054   2                      FLASH_Read_Buf(DataBuf, (FLADDR)Read_Address1, Length1, CodeBank1);
1055   2              }
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 429 

1056   1              else
1057   1              {
1058   2                      Read_Address1 = DataAddr - ((CodeBank1 - 1) * 0x8000);
1059   2                      Length1 = (CodeBank2 * 0x8000) - DataAddr;
1060   2                      CodeBank1 *= BANK1;
1061   2      
1062   2                      Read_Address2 = 0x8000U;
1063   2                      Length2 = DataLen - Length1;
1064   2                      CodeBank2 *= BANK1;
1065   2      
1066   2                      FLASH_Read_Buf(DataBuf, (FLADDR)Read_Address1, Length1, CodeBank1);
1067   2                      FLASH_Read_Buf((DataBuf + Length1), (FLADDR)Read_Address2, Length2, CodeBank2);
1068   2              }
1069   1      
1070   1              memcpy(Read_Buf, DataBuf, DataLen);
1071   1      }
1072          
1073          U16   Diag_Get_Time(void)
1074          {
1075   1              U16 Cur_Time = 0x0000U;
1076   1              Cur_Time = Get_Time();
1077   1              return Cur_Time;
1078   1      }
1079          
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 430 

ASSEMBLY LISTING OF GENERATED OBJECT CODE


             ; FUNCTION Init_DiagTask (BEGIN)
                                           ; SOURCE LINE # 40
                                           ; SOURCE LINE # 41
                                           ; SOURCE LINE # 42
0000 120000      R     LCALL   Clear_DTC_Struct
                                           ; SOURCE LINE # 43
0003 120000      R     LCALL   Flash_DTC_Read
                                           ; SOURCE LINE # 44
0006 E4                CLR     A
0007 900000      R     MOV     DPTR,#IGN_ON_Status
000A F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 87
000B 22                RET     
             ; FUNCTION Init_DiagTask (END)

             ; FUNCTION Clear_DTC_Struct (BEGIN)
                                           ; SOURCE LINE # 89
                                           ; SOURCE LINE # 90
                                           ; SOURCE LINE # 91
;---- Variable 'i' assigned to Register 'R7' ----
0000 E4                CLR     A
0001 FF                MOV     R7,A
                                           ; SOURCE LINE # 92
0002         ?C0002:
0002 EF                MOV     A,R7
0003 C3                CLR     C
0004 9409              SUBB    A,#09H
0006 5020              JNC     ?C0003
                                           ; SOURCE LINE # 93
                                           ; SOURCE LINE # 94
0008 EF                MOV     A,R7
0009 25E0              ADD     A,ACC
000B 2400        R     ADD     A,#LOW ga_Ext_tDTC_Type_Msg
000D F582              MOV     DPL,A
000F E4                CLR     A
0010 3400        R     ADDC    A,#HIGH ga_Ext_tDTC_Type_Msg
0012 F583              MOV     DPH,A
0014 74FF              MOV     A,#0FFH
0016 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 95
0017 EF                MOV     A,R7
0018 25E0              ADD     A,ACC
001A 2400        R     ADD     A,#LOW ga_Ext_tDTC_Type_Msg+01H
001C F582              MOV     DPL,A
001E E4                CLR     A
001F 3400        R     ADDC    A,#HIGH ga_Ext_tDTC_Type_Msg+01H
0021 F583              MOV     DPH,A
0023 E4                CLR     A
0024 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 96
0025 0F                INC     R7
0026 80DA              SJMP    ?C0002
0028         ?C0003:
                                           ; SOURCE LINE # 97
0028 E4                CLR     A
0029 900000      R     MOV     DPTR,#ga_Ext_tDTC_Type_Msg+012H
002C F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 98
002D A3                INC     DPTR
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 431 

002E F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 99
002F A3                INC     DPTR
0030 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 100
0031 A3                INC     DPTR
0032 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 101
0033 A3                INC     DPTR
0034 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 102
0035 A3                INC     DPTR
0036 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 103
0037 22                RET     
             ; FUNCTION Clear_DTC_Struct (END)

             ; FUNCTION Clear_DTC_Status (BEGIN)
                                           ; SOURCE LINE # 105
                                           ; SOURCE LINE # 106
                                           ; SOURCE LINE # 107
;---- Variable 'i' assigned to Register 'R7' ----
0000 E4                CLR     A
0001 FF                MOV     R7,A
                                           ; SOURCE LINE # 108
0002 7F02              MOV     R7,#02H
0004         ?C0006:
0004 EF                MOV     A,R7
0005 C3                CLR     C
0006 9409              SUBB    A,#09H
0008 5020              JNC     ?C0009
                                           ; SOURCE LINE # 109
                                           ; SOURCE LINE # 110
000A EF                MOV     A,R7
000B 25E0              ADD     A,ACC
000D 2400        R     ADD     A,#LOW ga_Ext_tDTC_Type_Msg
000F F582              MOV     DPL,A
0011 E4                CLR     A
0012 3400        R     ADDC    A,#HIGH ga_Ext_tDTC_Type_Msg
0014 F583              MOV     DPH,A
0016 74FF              MOV     A,#0FFH
0018 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 111
0019 EF                MOV     A,R7
001A 25E0              ADD     A,ACC
001C 2400        R     ADD     A,#LOW ga_Ext_tDTC_Type_Msg+01H
001E F582              MOV     DPL,A
0020 E4                CLR     A
0021 3400        R     ADDC    A,#HIGH ga_Ext_tDTC_Type_Msg+01H
0023 F583              MOV     DPH,A
0025 E4                CLR     A
0026 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 112
0027 0F                INC     R7
0028 80DA              SJMP    ?C0006
                                           ; SOURCE LINE # 113
002A         ?C0009:
002A 22                RET     
             ; FUNCTION Clear_DTC_Status (END)

             ; FUNCTION Operate_DiagTask (BEGIN)
                                           ; SOURCE LINE # 115
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 432 

                                           ; SOURCE LINE # 116
                                           ; SOURCE LINE # 117
0000 900000      R     MOV     DPTR,#ID
0003 748B              MOV     A,#08BH
0005 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 118
0006 E4                CLR     A
0007 A3                INC     DPTR
0008 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 119
0009 A3                INC     DPTR
000A F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 120
000B A3                INC     DPTR
000C F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 122
000D 120000      E     LCALL   WDT_Clear
                                           ; SOURCE LINE # 124
0010 7F08              MOV     R7,#08H
0012 120000      E     LCALL   _Delay_Time_Get
0015 900000      R     MOV     DPTR,#On_Time
0018 EF                MOV     A,R7
0019 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 125
001A B40103            CJNE    A,#01H,?C0010
                                           ; SOURCE LINE # 126
                                           ; SOURCE LINE # 127
001D 120000      E     LCALL   MCU_Reset
                                           ; SOURCE LINE # 128
0020         ?C0010:
                                           ; SOURCE LINE # 129
0020 120000      E     LCALL   WDT_Clear
                                           ; SOURCE LINE # 130
0023 7F09              MOV     R7,#09H
0025 120000      E     LCALL   _Delay_Time_Get
0028 900000      R     MOV     DPTR,#On_Time
002B EF                MOV     A,R7
002C F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 131
002D B4010C            CJNE    A,#01H,?C0011
                                           ; SOURCE LINE # 132
                                           ; SOURCE LINE # 133
0030 75F530            MOV     PSBANK,#030H
                                           ; SOURCE LINE # 134
0033 90FC00            MOV     DPTR,#0FC00H
0036 E4                CLR     A
0037 93                MOVC    A,@A+DPTR
0038 900000      R     MOV     DPTR,#Reserved_Address
003B F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 135
003C         ?C0011:
                                           ; SOURCE LINE # 136
003C 120000      E     LCALL   WDT_Clear
                                           ; SOURCE LINE # 138
003F 7F07              MOV     R7,#07H
0041 120000      E     LCALL   _Delay_Time_Get
0044 900000      R     MOV     DPTR,#On_Time
0047 EF                MOV     A,R7
0048 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 139
0049 6401              XRL     A,#01H
004B 7058              JNZ     ?C0012
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 433 

                                           ; SOURCE LINE # 140
                                           ; SOURCE LINE # 141
004D 900000      R     MOV     DPTR,#DTC_Write_Set
0050 E0                MOVX    A,@DPTR
0051 B40108            CJNE    A,#01H,?C0013
                                           ; SOURCE LINE # 142
                                           ; SOURCE LINE # 143
0054 120000      R     LCALL   Flash_DTC_Write
                                           ; SOURCE LINE # 144
0057 E4                CLR     A
0058 900000      R     MOV     DPTR,#DTC_Write_Set
005B F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 145
005C         ?C0013:
                                           ; SOURCE LINE # 147
005C 900000      R     MOV     DPTR,#DTC_Err_Sensor_Reset
005F E0                MOVX    A,@DPTR
0060 6401              XRL     A,#01H
0062 7041              JNZ     ?C0012
                                           ; SOURCE LINE # 148
                                           ; SOURCE LINE # 149
0064 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 151
0065 7F03              MOV     R7,#03H
0067 120000      E     LCALL   _Delay_Time_Expire
                                           ; SOURCE LINE # 153
006A 7F01              MOV     R7,#01H
006C 120000      E     LCALL   _Delay_Time_Expire
                                           ; SOURCE LINE # 154
006F 7F02              MOV     R7,#02H
0071 120000      E     LCALL   _Delay_Time_Expire
                                           ; SOURCE LINE # 155
0074 7F05              MOV     R7,#05H
0076 120000      E     LCALL   _Delay_Time_Expire
                                           ; SOURCE LINE # 157
0079 900000      R     MOV     DPTR,#i
007C 7402              MOV     A,#02H
007E F0                MOVX    @DPTR,A
007F         ?C0015:
007F 900000      R     MOV     DPTR,#i
0082 E0                MOVX    A,@DPTR
0083 FF                MOV     R7,A
0084 C3                CLR     C
0085 9409              SUBB    A,#09H
0087 5016              JNC     ?C0016
                                           ; SOURCE LINE # 158
                                           ; SOURCE LINE # 159
0089 EF                MOV     A,R7
008A 25E0              ADD     A,ACC
008C 2400        R     ADD     A,#LOW ga_Ext_tDTC_Type_Msg+01H
008E F582              MOV     DPL,A
0090 E4                CLR     A
0091 3400        R     ADDC    A,#HIGH ga_Ext_tDTC_Type_Msg+01H
0093 F583              MOV     DPH,A
0095 E4                CLR     A
0096 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 160
0097 900000      R     MOV     DPTR,#i
009A E0                MOVX    A,@DPTR
009B 04                INC     A
009C F0                MOVX    @DPTR,A
009D 80E0              SJMP    ?C0015
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 434 

009F         ?C0016:
                                           ; SOURCE LINE # 162
009F 120000      E     LCALL   SMBUS0_Init
                                           ; SOURCE LINE # 163
00A2 120000      E     LCALL   Isp_InterInit
                                           ; SOURCE LINE # 164
                                           ; SOURCE LINE # 165
00A5         ?C0012:
                                           ; SOURCE LINE # 168
00A5 900000      R     MOV     DPTR,#IGN_ON_Status
00A8 E0                MOVX    A,@DPTR
00A9 6401              XRL     A,#01H
00AB 6003              JZ      $ + 5H
00AD 020000      R     LJMP    ?C0025
                                           ; SOURCE LINE # 169
                                           ; SOURCE LINE # 170
00B0 900000      R     MOV     DPTR,#ga_Ext_tDTC_Type_Msg+015H
00B3 E0                MOVX    A,@DPTR
00B4 B40827            CJNE    A,#08H,?C0019
                                           ; SOURCE LINE # 171
                                           ; SOURCE LINE # 172
00B7 900000      R     MOV     DPTR,#ga_Ext_tDTC_Type_Msg+012H
00BA E0                MOVX    A,@DPTR
00BB 04                INC     A
00BC F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 173
00BD E0                MOVX    A,@DPTR
00BE D3                SETB    C
00BF 941E              SUBB    A,#01EH
00C1 4015              JC      ?C0020
                                           ; SOURCE LINE # 174
                                           ; SOURCE LINE # 175
00C3 900000      R     MOV     DPTR,#ga_Ext_tDTC_Type_Msg
00C6 74FF              MOV     A,#0FFH
00C8 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 176
00C9 900000      R     MOV     DPTR,#ga_Ext_tDTC_Type_Msg+02H
00CC F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 178
00CD E4                CLR     A
00CE 900000      R     MOV     DPTR,#ga_Ext_tDTC_Type_Msg+012H
00D1 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 179
00D2 900000      R     MOV     DPTR,#ga_Ext_tDTC_Type_Msg+015H
00D5 74FF              MOV     A,#0FFH
00D7 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 180
00D8         ?C0020:
                                           ; SOURCE LINE # 181
00D8 900000      R     MOV     DPTR,#DTC_Write_Set
00DB 7401              MOV     A,#01H
00DD F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 182
00DE         ?C0019:
                                           ; SOURCE LINE # 184
00DE 900000      R     MOV     DPTR,#ga_Ext_tDTC_Type_Msg+016H
00E1 E0                MOVX    A,@DPTR
00E2 B40833            CJNE    A,#08H,?C0021
                                           ; SOURCE LINE # 185
                                           ; SOURCE LINE # 186
00E5 900000      R     MOV     DPTR,#ga_Ext_tDTC_Type_Msg+013H
00E8 E0                MOVX    A,@DPTR
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 435 

00E9 04                INC     A
00EA F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 187
00EB E0                MOVX    A,@DPTR
00EC D3                SETB    C
00ED 941E              SUBB    A,#01EH
00EF 4021              JC      ?C0022
                                           ; SOURCE LINE # 188
                                           ; SOURCE LINE # 189
00F1 900000      R     MOV     DPTR,#ga_Ext_tDTC_Type_Msg+04H
00F4 74FF              MOV     A,#0FFH
00F6 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 190
00F7 900000      R     MOV     DPTR,#ga_Ext_tDTC_Type_Msg+06H
00FA F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 191
00FB 900000      R     MOV     DPTR,#ga_Ext_tDTC_Type_Msg+08H
00FE F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 192
00FF 900000      R     MOV     DPTR,#ga_Ext_tDTC_Type_Msg+0AH
0102 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 193
0103 900000      R     MOV     DPTR,#ga_Ext_tDTC_Type_Msg+0CH
0106 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 195
0107 E4                CLR     A
0108 900000      R     MOV     DPTR,#ga_Ext_tDTC_Type_Msg+013H
010B F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 196
010C 900000      R     MOV     DPTR,#ga_Ext_tDTC_Type_Msg+016H
010F 74FF              MOV     A,#0FFH
0111 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 197
0112         ?C0022:
                                           ; SOURCE LINE # 198
0112 900000      R     MOV     DPTR,#DTC_Write_Set
0115 7401              MOV     A,#01H
0117 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 199
0118         ?C0021:
                                           ; SOURCE LINE # 201
0118 900000      R     MOV     DPTR,#ga_Ext_tDTC_Type_Msg+017H
011B E0                MOVX    A,@DPTR
011C B40827            CJNE    A,#08H,?C0023
                                           ; SOURCE LINE # 202
                                           ; SOURCE LINE # 203
011F 900000      R     MOV     DPTR,#ga_Ext_tDTC_Type_Msg+014H
0122 E0                MOVX    A,@DPTR
0123 04                INC     A
0124 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 204
0125 E0                MOVX    A,@DPTR
0126 D3                SETB    C
0127 941E              SUBB    A,#01EH
0129 4015              JC      ?C0024
                                           ; SOURCE LINE # 205
                                           ; SOURCE LINE # 206
012B 900000      R     MOV     DPTR,#ga_Ext_tDTC_Type_Msg+0EH
012E 74FF              MOV     A,#0FFH
0130 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 207
0131 900000      R     MOV     DPTR,#ga_Ext_tDTC_Type_Msg+010H
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 436 

0134 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 209
0135 E4                CLR     A
0136 900000      R     MOV     DPTR,#ga_Ext_tDTC_Type_Msg+014H
0139 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 210
013A 900000      R     MOV     DPTR,#ga_Ext_tDTC_Type_Msg+017H
013D 74FF              MOV     A,#0FFH
013F F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 211
0140         ?C0024:
                                           ; SOURCE LINE # 212
0140 900000      R     MOV     DPTR,#DTC_Write_Set
0143 7401              MOV     A,#01H
0145 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 213
0146         ?C0023:
                                           ; SOURCE LINE # 214
0146 900000      R     MOV     DPTR,#IGN_ON_Status
0149 7402              MOV     A,#02H
014B F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 215
                                           ; SOURCE LINE # 216
014C         ?C0025:
014C 22                RET     
             ; FUNCTION Operate_DiagTask (END)

             ; FUNCTION _Record_DTC_Error (BEGIN)
                                           ; SOURCE LINE # 218
0000 900000      R     MOV     DPTR,#ID
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 219
                                           ; SOURCE LINE # 220
;---- Variable 'is_error' assigned to Register 'R7' ----
0005 E4                CLR     A
0006 FF                MOV     R7,A
                                           ; SOURCE LINE # 222
0007 900000      R     MOV     DPTR,#DTC_Set_Off
000A E0                MOVX    A,@DPTR
000B 6003              JZ      $ + 5H
000D 020000      R     LJMP    ?C0057
                                           ; SOURCE LINE # 223
                                           ; SOURCE LINE # 224
0010 900000      R     MOV     DPTR,#ID
0013 E0                MOVX    A,@DPTR
0014 25E0              ADD     A,ACC
0016 2400        R     ADD     A,#LOW ga_Ext_tDTC_Type_Msg
0018 F582              MOV     DPL,A
001A E4                CLR     A
001B 3400        R     ADDC    A,#HIGH ga_Ext_tDTC_Type_Msg
001D F583              MOV     DPH,A
001F E0                MOVX    A,@DPTR
0020 6409              XRL     A,#09H
0022 7003              JNZ     $ + 5H
0024 020000      R     LJMP    ?C0057
                                           ; SOURCE LINE # 225
                                           ; SOURCE LINE # 226
0027 900000      R     MOV     DPTR,#ID
002A E0                MOVX    A,@DPTR
002B FE                MOV     R6,A
002C 25E0              ADD     A,ACC
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 437 

002E 2400        R     ADD     A,#LOW ga_Ext_tDTC_Type_Msg+01H
0030 F582              MOV     DPL,A
0032 E4                CLR     A
0033 3400        R     ADDC    A,#HIGH ga_Ext_tDTC_Type_Msg+01H
0035 F583              MOV     DPH,A
0037 E0                MOVX    A,@DPTR
0038 04                INC     A
0039 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 227
003A EE                MOV     A,R6
003B 700A              JNZ     ?C0028
                                           ; SOURCE LINE # 228
                                           ; SOURCE LINE # 229
003D 900000      R     MOV     DPTR,#ga_Ext_tDTC_Type_Msg+01H
0040 E0                MOVX    A,@DPTR
0041 D3                SETB    C
0042 941E              SUBB    A,#01EH
0044 4001              JC      ?C0028
0046 0F                INC     R7
                                           ; SOURCE LINE # 230
0047         ?C0028:
                                           ; SOURCE LINE # 231
0047 900000      R     MOV     DPTR,#ID
004A E0                MOVX    A,@DPTR
004B FE                MOV     R6,A
004C B4010B            CJNE    A,#01H,?C0030
                                           ; SOURCE LINE # 232
                                           ; SOURCE LINE # 233
004F 900000      R     MOV     DPTR,#ga_Ext_tDTC_Type_Msg+03H
0052 E0                MOVX    A,@DPTR
0053 D3                SETB    C
0054 941E              SUBB    A,#01EH
0056 4002              JC      ?C0030
0058 7F01              MOV     R7,#01H
                                           ; SOURCE LINE # 234
005A         ?C0030:
                                           ; SOURCE LINE # 235
005A EE                MOV     A,R6
005B B4020B            CJNE    A,#02H,?C0032
                                           ; SOURCE LINE # 236
                                           ; SOURCE LINE # 237
005E 900000      R     MOV     DPTR,#ga_Ext_tDTC_Type_Msg+05H
0061 E0                MOVX    A,@DPTR
0062 D3                SETB    C
0063 9413              SUBB    A,#013H
0065 4002              JC      ?C0032
0067 7F01              MOV     R7,#01H
                                           ; SOURCE LINE # 238
0069         ?C0032:
                                           ; SOURCE LINE # 239
0069 900000      R     MOV     DPTR,#ID
006C E0                MOVX    A,@DPTR
006D B4030B            CJNE    A,#03H,?C0034
                                           ; SOURCE LINE # 240
                                           ; SOURCE LINE # 241
0070 900000      R     MOV     DPTR,#ga_Ext_tDTC_Type_Msg+07H
0073 E0                MOVX    A,@DPTR
0074 D3                SETB    C
0075 9413              SUBB    A,#013H
0077 4002              JC      ?C0034
0079 7F01              MOV     R7,#01H
                                           ; SOURCE LINE # 242
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 438 

007B         ?C0034:
                                           ; SOURCE LINE # 243
007B 900000      R     MOV     DPTR,#ID
007E E0                MOVX    A,@DPTR
007F FE                MOV     R6,A
0080 B4040B            CJNE    A,#04H,?C0036
                                           ; SOURCE LINE # 244
                                           ; SOURCE LINE # 245
0083 900000      R     MOV     DPTR,#ga_Ext_tDTC_Type_Msg+09H
0086 E0                MOVX    A,@DPTR
0087 D3                SETB    C
0088 9413              SUBB    A,#013H
008A 4002              JC      ?C0036
008C 7F01              MOV     R7,#01H
                                           ; SOURCE LINE # 246
008E         ?C0036:
                                           ; SOURCE LINE # 247
008E EE                MOV     A,R6
008F B4050B            CJNE    A,#05H,?C0038
                                           ; SOURCE LINE # 248
                                           ; SOURCE LINE # 249
0092 900000      R     MOV     DPTR,#ga_Ext_tDTC_Type_Msg+0BH
0095 E0                MOVX    A,@DPTR
0096 D3                SETB    C
0097 9413              SUBB    A,#013H
0099 4002              JC      ?C0038
009B 7F01              MOV     R7,#01H
                                           ; SOURCE LINE # 250
009D         ?C0038:
                                           ; SOURCE LINE # 251
009D 900000      R     MOV     DPTR,#ID
00A0 E0                MOVX    A,@DPTR
00A1 B4060B            CJNE    A,#06H,?C0040
                                           ; SOURCE LINE # 252
                                           ; SOURCE LINE # 253
00A4 900000      R     MOV     DPTR,#ga_Ext_tDTC_Type_Msg+0DH
00A7 E0                MOVX    A,@DPTR
00A8 D3                SETB    C
00A9 9400              SUBB    A,#00H
00AB 4002              JC      ?C0040
00AD 7F01              MOV     R7,#01H
                                           ; SOURCE LINE # 254
00AF         ?C0040:
                                           ; SOURCE LINE # 255
00AF 900000      R     MOV     DPTR,#ID
00B2 E0                MOVX    A,@DPTR
00B3 FE                MOV     R6,A
00B4 B4070B            CJNE    A,#07H,?C0042
                                           ; SOURCE LINE # 256
                                           ; SOURCE LINE # 257
00B7 900000      R     MOV     DPTR,#ga_Ext_tDTC_Type_Msg+0FH
00BA E0                MOVX    A,@DPTR
00BB D3                SETB    C
00BC 9400              SUBB    A,#00H
00BE 4002              JC      ?C0042
00C0 7F01              MOV     R7,#01H
                                           ; SOURCE LINE # 258
00C2         ?C0042:
                                           ; SOURCE LINE # 259
00C2 EE                MOV     A,R6
00C3 B4080B            CJNE    A,#08H,?C0044
                                           ; SOURCE LINE # 260
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 439 

                                           ; SOURCE LINE # 261
00C6 900000      R     MOV     DPTR,#ga_Ext_tDTC_Type_Msg+011H
00C9 E0                MOVX    A,@DPTR
00CA D3                SETB    C
00CB 9400              SUBB    A,#00H
00CD 4002              JC      ?C0044
00CF 7F01              MOV     R7,#01H
                                           ; SOURCE LINE # 262
00D1         ?C0044:
                                           ; SOURCE LINE # 264
00D1 EF                MOV     A,R7
00D2 6401              XRL     A,#01H
00D4 6003              JZ      $ + 5H
00D6 020000      R     LJMP    ?C0057
                                           ; SOURCE LINE # 265
                                           ; SOURCE LINE # 266
00D9 120000      E     LCALL   WDT_Clear
                                           ; SOURCE LINE # 267
00DC 900000      R     MOV     DPTR,#ID
00DF E0                MOVX    A,@DPTR
00E0 FF                MOV     R7,A
00E1 25E0              ADD     A,ACC
00E3 2400        R     ADD     A,#LOW ga_Ext_tDTC_Type_Msg+01H
00E5 F582              MOV     DPL,A
00E7 E4                CLR     A
00E8 3400        R     ADDC    A,#HIGH ga_Ext_tDTC_Type_Msg+01H
00EA F583              MOV     DPH,A
00EC E4                CLR     A
00ED F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 268
00EE EF                MOV     A,R7
00EF 6003              JZ      ?C0048
00F1 B4011A            CJNE    A,#01H,?C0047
00F4         ?C0048:
                                           ; SOURCE LINE # 269
                                           ; SOURCE LINE # 270
00F4 EF                MOV     A,R7
00F5 25E0              ADD     A,ACC
00F7 2400        R     ADD     A,#LOW ga_Ext_tDTC_Type_Msg
00F9 F582              MOV     DPL,A
00FB E4                CLR     A
00FC 3400        R     ADDC    A,#HIGH ga_Ext_tDTC_Type_Msg
00FE F583              MOV     DPH,A
0100 7408              MOV     A,#08H
0102 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 271
0103 900000      R     MOV     DPTR,#ga_Ext_tDTC_Type_Msg+015H
0106 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 272
0107 E4                CLR     A
0108 900000      R     MOV     DPTR,#ga_Ext_tDTC_Type_Msg+012H
010B F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 273
010C 8064              SJMP    ?C0049
010E         ?C0047:
                                           ; SOURCE LINE # 275
                                           ; SOURCE LINE # 276
010E EF                MOV     A,R7
010F 25E0              ADD     A,ACC
0111 2400        R     ADD     A,#LOW ga_Ext_tDTC_Type_Msg
0113 F582              MOV     DPL,A
0115 E4                CLR     A
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 440 

0116 3400        R     ADDC    A,#HIGH ga_Ext_tDTC_Type_Msg
0118 F583              MOV     DPH,A
011A 7409              MOV     A,#09H
011C F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 277
011D EF                MOV     A,R7
011E 6402              XRL     A,#02H
0120 6017              JZ      ?C0051
0122 900000      R     MOV     DPTR,#ID
0125 E0                MOVX    A,@DPTR
0126 FF                MOV     R7,A
0127 6403              XRL     A,#03H
0129 600E              JZ      ?C0051
012B EF                MOV     A,R7
012C 6404              XRL     A,#04H
012E 6009              JZ      ?C0051
0130 EF                MOV     A,R7
0131 6405              XRL     A,#05H
0133 6004              JZ      ?C0051
0135 EF                MOV     A,R7
0136 B40621            CJNE    A,#06H,?C0050
0139         ?C0051:
                                           ; SOURCE LINE # 279
                                           ; SOURCE LINE # 280
0139 900000      R     MOV     DPTR,#DTC_Err_Sensor_Reset
013C E0                MOVX    A,@DPTR
013D 700E              JNZ     ?C0052
013F 900000      R     MOV     DPTR,#ga_Ext_tDTC_Type_Msg+016H
0142 E0                MOVX    A,@DPTR
0143 6409              XRL     A,#09H
0145 6006              JZ      ?C0052
                                           ; SOURCE LINE # 282
                                           ; SOURCE LINE # 283
0147 900000      R     MOV     DPTR,#DTC_Err_Sensor_Reset
014A 7401              MOV     A,#01H
014C F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 284
014D         ?C0052:
                                           ; SOURCE LINE # 286
014D 900000      R     MOV     DPTR,#ga_Ext_tDTC_Type_Msg+016H
0150 7409              MOV     A,#09H
0152 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 287
0153 E4                CLR     A
0154 900000      R     MOV     DPTR,#ga_Ext_tDTC_Type_Msg+013H
0157 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 288
0158 8018              SJMP    ?C0049
015A         ?C0050:
                                           ; SOURCE LINE # 289
015A 900000      R     MOV     DPTR,#ID
015D E0                MOVX    A,@DPTR
015E FF                MOV     R7,A
015F 6407              XRL     A,#07H
0161 6004              JZ      ?C0055
0163 EF                MOV     A,R7
0164 B4080B            CJNE    A,#08H,?C0049
0167         ?C0055:
                                           ; SOURCE LINE # 290
                                           ; SOURCE LINE # 291
0167 900000      R     MOV     DPTR,#ga_Ext_tDTC_Type_Msg+017H
016A 7409              MOV     A,#09H
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 441 

016C F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 292
016D E4                CLR     A
016E 900000      R     MOV     DPTR,#ga_Ext_tDTC_Type_Msg+014H
0171 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 293
                                           ; SOURCE LINE # 294
                                           ; SOURCE LINE # 295
0172         ?C0049:
                                           ; SOURCE LINE # 296
0172 900000      R     MOV     DPTR,#DTC_Write_Set
0175 7401              MOV     A,#01H
0177 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 297
                                           ; SOURCE LINE # 298
                                           ; SOURCE LINE # 299
                                           ; SOURCE LINE # 300
0178         ?C0057:
0178 22                RET     
             ; FUNCTION _Record_DTC_Error (END)

             ; FUNCTION _Record_DTC_Clear (BEGIN)
                                           ; SOURCE LINE # 302
;---- Variable 'ID' assigned to Register 'R7' ----
                                           ; SOURCE LINE # 303
                                           ; SOURCE LINE # 306
0000 EF                MOV     A,R7
0001 25E0              ADD     A,ACC
0003 2400        R     ADD     A,#LOW ga_Ext_tDTC_Type_Msg
0005 F582              MOV     DPL,A
0007 E4                CLR     A
0008 3400        R     ADDC    A,#HIGH ga_Ext_tDTC_Type_Msg
000A F583              MOV     DPH,A
000C E0                MOVX    A,@DPTR
000D FE                MOV     R6,A
000E B4FF21            CJNE    A,#0FFH,?C0058
                                           ; SOURCE LINE # 307
                                           ; SOURCE LINE # 308
0011 EF                MOV     A,R7
0012 25E0              ADD     A,ACC
0014 2400        R     ADD     A,#LOW ga_Ext_tDTC_Type_Msg+01H
0016 F582              MOV     DPL,A
0018 E4                CLR     A
0019 3400        R     ADDC    A,#HIGH ga_Ext_tDTC_Type_Msg+01H
001B F583              MOV     DPH,A
001D E0                MOVX    A,@DPTR
001E 7003              JNZ     $ + 5H
0020 020000      R     LJMP    ?C0072
                                           ; SOURCE LINE # 309
                                           ; SOURCE LINE # 310
0023 EF                MOV     A,R7
0024 25E0              ADD     A,ACC
0026 2400        R     ADD     A,#LOW ga_Ext_tDTC_Type_Msg+01H
0028 F582              MOV     DPL,A
002A E4                CLR     A
002B 3400        R     ADDC    A,#HIGH ga_Ext_tDTC_Type_Msg+01H
002D F583              MOV     DPH,A
002F E4                CLR     A
0030 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 312
                                           ; SOURCE LINE # 313
0031 22                RET     
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 442 

0032         ?C0058:
                                           ; SOURCE LINE # 314
0032 EE                MOV     A,R6
0033 6409              XRL     A,#09H
0035 7070              JNZ     ?C0061
                                           ; SOURCE LINE # 315
                                           ; SOURCE LINE # 316
0037 EF                MOV     A,R7
0038 25E0              ADD     A,ACC
003A 2400        R     ADD     A,#LOW ga_Ext_tDTC_Type_Msg+01H
003C F582              MOV     DPL,A
003E E4                CLR     A
003F 3400        R     ADDC    A,#HIGH ga_Ext_tDTC_Type_Msg+01H
0041 F583              MOV     DPH,A
0043 E4                CLR     A
0044 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 317
0045 EF                MOV     A,R7
0046 25E0              ADD     A,ACC
0048 2400        R     ADD     A,#LOW ga_Ext_tDTC_Type_Msg
004A F582              MOV     DPL,A
004C E4                CLR     A
004D 3400        R     ADDC    A,#HIGH ga_Ext_tDTC_Type_Msg
004F F583              MOV     DPH,A
0051 7408              MOV     A,#08H
0053 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 319
0054 EF                MOV     A,R7
0055 6003              JZ      ?C0063
0057 B4010D            CJNE    A,#01H,?C0062
005A         ?C0063:
                                           ; SOURCE LINE # 320
                                           ; SOURCE LINE # 321
005A E4                CLR     A
005B 900000      R     MOV     DPTR,#ga_Ext_tDTC_Type_Msg+012H
005E F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 322
005F 900000      R     MOV     DPTR,#ga_Ext_tDTC_Type_Msg+015H
0062 7408              MOV     A,#08H
0064 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 323
0065 8039              SJMP    ?C0064
0067         ?C0062:
                                           ; SOURCE LINE # 324
0067 EF                MOV     A,R7
0068 6402              XRL     A,#02H
006A 6013              JZ      ?C0066
006C EF                MOV     A,R7
006D 6403              XRL     A,#03H
006F 600E              JZ      ?C0066
0071 EF                MOV     A,R7
0072 6404              XRL     A,#04H
0074 6009              JZ      ?C0066
0076 EF                MOV     A,R7
0077 6405              XRL     A,#05H
0079 6004              JZ      ?C0066
007B EF                MOV     A,R7
007C B4060D            CJNE    A,#06H,?C0065
007F         ?C0066:
                                           ; SOURCE LINE # 326
                                           ; SOURCE LINE # 327
007F E4                CLR     A
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 443 

0080 900000      R     MOV     DPTR,#ga_Ext_tDTC_Type_Msg+013H
0083 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 328
0084 900000      R     MOV     DPTR,#ga_Ext_tDTC_Type_Msg+016H
0087 7408              MOV     A,#08H
0089 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 329
008A 8014              SJMP    ?C0064
008C         ?C0065:
                                           ; SOURCE LINE # 330
008C EF                MOV     A,R7
008D 6407              XRL     A,#07H
008F 6004              JZ      ?C0069
0091 EF                MOV     A,R7
0092 B4080B            CJNE    A,#08H,?C0064
0095         ?C0069:
                                           ; SOURCE LINE # 331
                                           ; SOURCE LINE # 332
0095 E4                CLR     A
0096 900000      R     MOV     DPTR,#ga_Ext_tDTC_Type_Msg+014H
0099 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 333
009A 900000      R     MOV     DPTR,#ga_Ext_tDTC_Type_Msg+017H
009D 7408              MOV     A,#08H
009F F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 334
                                           ; SOURCE LINE # 335
00A0         ?C0064:
                                           ; SOURCE LINE # 336
00A0 900000      R     MOV     DPTR,#DTC_Write_Set
00A3 7401              MOV     A,#01H
00A5 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 337
00A6 22                RET     
00A7         ?C0061:
                                           ; SOURCE LINE # 339
                                           ; SOURCE LINE # 340
00A7 EF                MOV     A,R7
00A8 25E0              ADD     A,ACC
00AA 2400        R     ADD     A,#LOW ga_Ext_tDTC_Type_Msg+01H
00AC F582              MOV     DPL,A
00AE E4                CLR     A
00AF 3400        R     ADDC    A,#HIGH ga_Ext_tDTC_Type_Msg+01H
00B1 F583              MOV     DPH,A
00B3 E4                CLR     A
00B4 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 341
                                           ; SOURCE LINE # 343
00B5         ?C0072:
00B5 22                RET     
             ; FUNCTION _Record_DTC_Clear (END)

             ; FUNCTION Diag_Ecu_Reset (BEGIN)
                                           ; SOURCE LINE # 344
                                           ; SOURCE LINE # 345
                                           ; SOURCE LINE # 346
0000 E4                CLR     A
0001 900000      E     MOV     DPTR,#EEPROM_Update_Mode
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 347
0005 7D64              MOV     R5,#064H
0007 FC                MOV     R4,A
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 444 

0008 7F08              MOV     R7,#08H
000A 120000      E     LCALL   _Delay_Time_Set
                                           ; SOURCE LINE # 348
000D 22                RET     
             ; FUNCTION Diag_Ecu_Reset (END)

             ; FUNCTION Diag_Clear_DTC (BEGIN)
                                           ; SOURCE LINE # 350
                                           ; SOURCE LINE # 351
                                           ; SOURCE LINE # 352
0000 7D20              MOV     R5,#020H
0002 7F00              MOV     R7,#00H
0004 7EFF              MOV     R6,#0FFH
0006 120000      E     LCALL   _FLASH_Erase_Buf
                                           ; SOURCE LINE # 353
0009 120000      R     LCALL   Clear_DTC_Struct
                                           ; SOURCE LINE # 354
000C 22                RET     
             ; FUNCTION Diag_Clear_DTC (END)

             ; FUNCTION _Diag_Read_Dtc (BEGIN)
                                           ; SOURCE LINE # 356
;---- Variable 'index' assigned to Register 'R7' ----
                                           ; SOURCE LINE # 357
                                           ; SOURCE LINE # 358
;---- Variable 'ret' assigned to Register 'R6' ----
0000 E4                CLR     A
0001 FE                MOV     R6,A
                                           ; SOURCE LINE # 359
0002 EF                MOV     A,R7
0003 B4010F            CJNE    A,#01H,?C0075
                                           ; SOURCE LINE # 360
                                           ; SOURCE LINE # 361
0006 900000      R     MOV     DPTR,#ga_Ext_tDTC_Type_Msg+015H
0009 E0                MOVX    A,@DPTR
000A FD                MOV     R5,A
000B F4                CPL     A
000C 6005              JZ      ?C0076
                                           ; SOURCE LINE # 362
                                           ; SOURCE LINE # 363
000E CE                XCH     A,R6
000F ED                MOV     A,R5
0010 CE                XCH     A,R6
                                           ; SOURCE LINE # 364
0011 8002              SJMP    ?C0075
0013         ?C0076:
                                           ; SOURCE LINE # 366
                                           ; SOURCE LINE # 367
0013 E4                CLR     A
0014 FE                MOV     R6,A
                                           ; SOURCE LINE # 368
                                           ; SOURCE LINE # 369
0015         ?C0075:
                                           ; SOURCE LINE # 370
0015 EF                MOV     A,R7
0016 B4020F            CJNE    A,#02H,?C0078
                                           ; SOURCE LINE # 371
                                           ; SOURCE LINE # 372
0019 900000      R     MOV     DPTR,#ga_Ext_tDTC_Type_Msg+016H
001C E0                MOVX    A,@DPTR
001D FD                MOV     R5,A
001E F4                CPL     A
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 445 

001F 6005              JZ      ?C0079
                                           ; SOURCE LINE # 373
                                           ; SOURCE LINE # 374
0021 CE                XCH     A,R6
0022 ED                MOV     A,R5
0023 CE                XCH     A,R6
                                           ; SOURCE LINE # 375
0024 8002              SJMP    ?C0078
0026         ?C0079:
                                           ; SOURCE LINE # 377
                                           ; SOURCE LINE # 378
0026 E4                CLR     A
0027 FE                MOV     R6,A
                                           ; SOURCE LINE # 379
                                           ; SOURCE LINE # 380
0028         ?C0078:
                                           ; SOURCE LINE # 381
0028 EF                MOV     A,R7
0029 B4030F            CJNE    A,#03H,?C0081
                                           ; SOURCE LINE # 382
                                           ; SOURCE LINE # 383
002C 900000      R     MOV     DPTR,#ga_Ext_tDTC_Type_Msg+017H
002F E0                MOVX    A,@DPTR
0030 FF                MOV     R7,A
0031 F4                CPL     A
0032 6005              JZ      ?C0082
                                           ; SOURCE LINE # 384
                                           ; SOURCE LINE # 385
0034 CE                XCH     A,R6
0035 EF                MOV     A,R7
0036 CE                XCH     A,R6
                                           ; SOURCE LINE # 386
0037 8002              SJMP    ?C0081
0039         ?C0082:
                                           ; SOURCE LINE # 388
                                           ; SOURCE LINE # 389
0039 E4                CLR     A
003A FE                MOV     R6,A
                                           ; SOURCE LINE # 390
                                           ; SOURCE LINE # 391
003B         ?C0081:
                                           ; SOURCE LINE # 393
003B CF                XCH     A,R7
003C EE                MOV     A,R6
003D CF                XCH     A,R7
                                           ; SOURCE LINE # 394
003E         ?C0084:
003E 22                RET     
             ; FUNCTION _Diag_Read_Dtc (END)

             ; FUNCTION _Diag_Read_Sys (BEGIN)
                                           ; SOURCE LINE # 396
0000 900000      R     MOV     DPTR,#ID
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
0005 A3                INC     DPTR
0006 EB                MOV     A,R3
0007 F0                MOVX    @DPTR,A
0008 A3                INC     DPTR
0009 EA                MOV     A,R2
000A F0                MOVX    @DPTR,A
000B A3                INC     DPTR
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 446 

000C E9                MOV     A,R1
000D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 397
                                           ; SOURCE LINE # 398
000E E4                CLR     A
000F 900000      R     MOV     DPTR,#ret
0012 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 399
0013 A3                INC     DPTR
0014 F0                MOVX    @DPTR,A
0015 A3                INC     DPTR
0016 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 400
0017 7800        R     MOV     R0,#LOW Flash_Data
0019 7C00        R     MOV     R4,#HIGH Flash_Data
001B 7D01              MOV     R5,#01H
001D 7BFF              MOV     R3,#0FFH
001F 7A00        R     MOV     R2,#HIGH _?ix1000
0021 7900        R     MOV     R1,#LOW _?ix1000
0023 FE                MOV     R6,A
0024 7F03              MOV     R7,#03H
0026 120000      E     LCALL   ?C?COPY
                                           ; SOURCE LINE # 401
0029 7800        R     MOV     R0,#LOW temp_buf
002B 7C00        R     MOV     R4,#HIGH temp_buf
002D 7D01              MOV     R5,#01H
002F 7BFF              MOV     R3,#0FFH
0031 7A00        R     MOV     R2,#HIGH _?ix1001
0033 7900        R     MOV     R1,#LOW _?ix1001
0035 7E00              MOV     R6,#00H
0037 7F12              MOV     R7,#012H
0039 120000      E     LCALL   ?C?COPY
                                           ; SOURCE LINE # 403
003C 900000      R     MOV     DPTR,#Length
003F E0                MOVX    A,@DPTR
0040 FF                MOV     R7,A
0041 7E00              MOV     R6,#00H
0043 7D00              MOV     R5,#00H
0045 900000      R     MOV     DPTR,#Buf
0048 E0                MOVX    A,@DPTR
0049 FB                MOV     R3,A
004A A3                INC     DPTR
004B E0                MOVX    A,@DPTR
004C FA                MOV     R2,A
004D A3                INC     DPTR
004E E0                MOVX    A,@DPTR
004F F9                MOV     R1,A
0050 120000      E     LCALL   ?C?MEMSET
                                           ; SOURCE LINE # 405
0053 900000      R     MOV     DPTR,#ID
0056 E0                MOVX    A,@DPTR
0057 6402              XRL     A,#02H
0059 6003              JZ      $ + 5H
005B 020000      R     LJMP    ?C0085
                                           ; SOURCE LINE # 406
                                           ; SOURCE LINE # 407
005E A3                INC     DPTR
005F E0                MOVX    A,@DPTR
0060 FB                MOV     R3,A
0061 A3                INC     DPTR
0062 E0                MOVX    A,@DPTR
0063 FA                MOV     R2,A
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 447 

0064 A3                INC     DPTR
0065 E0                MOVX    A,@DPTR
0066 F9                MOV     R1,A
0067 74FF              MOV     A,#0FFH
0069 120000      E     LCALL   ?C?CSTPTR
                                           ; SOURCE LINE # 408
006C 900000      R     MOV     DPTR,#Buf
006F E0                MOVX    A,@DPTR
0070 FB                MOV     R3,A
0071 A3                INC     DPTR
0072 E0                MOVX    A,@DPTR
0073 FA                MOV     R2,A
0074 A3                INC     DPTR
0075 E0                MOVX    A,@DPTR
0076 F9                MOV     R1,A
0077 900001            MOV     DPTR,#01H
007A 74FC              MOV     A,#0FCH
007C 120000      E     LCALL   ?C?CSTOPTR
                                           ; SOURCE LINE # 409
007F 900002            MOV     DPTR,#02H
0082 E4                CLR     A
0083 120000      E     LCALL   ?C?CSTOPTR
                                           ; SOURCE LINE # 410
0086 900003            MOV     DPTR,#03H
0089 E4                CLR     A
008A 120000      E     LCALL   ?C?CSTOPTR
                                           ; SOURCE LINE # 412
008D 900000      E     MOV     DPTR,#Optical_Axis_Data+06H
0090 E0                MOVX    A,@DPTR
0091 FF                MOV     R7,A
0092 900000      E     MOV     DPTR,#Optical_Axis_Data
0095 E0                MOVX    A,@DPTR
0096 2F                ADD     A,R7
0097 900000      R     MOV     DPTR,#Flash_Data
009A F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 413
009B 900000      E     MOV     DPTR,#Optical_Axis_Data+07H
009E E0                MOVX    A,@DPTR
009F FF                MOV     R7,A
00A0 900000      E     MOV     DPTR,#Optical_Axis_Data+01H
00A3 E0                MOVX    A,@DPTR
00A4 2F                ADD     A,R7
00A5 900000      R     MOV     DPTR,#Flash_Data+01H
00A8 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 415
00A9 900000      R     MOV     DPTR,#Flash_Data
00AC E0                MOVX    A,@DPTR
00AD FF                MOV     R7,A
00AE C3                CLR     C
00AF 9480              SUBB    A,#080H
00B1 5014              JNC     ?C0086
                                           ; SOURCE LINE # 416
00B3 900000      R     MOV     DPTR,#Buf
00B6 E0                MOVX    A,@DPTR
00B7 FB                MOV     R3,A
00B8 A3                INC     DPTR
00B9 E0                MOVX    A,@DPTR
00BA FA                MOV     R2,A
00BB A3                INC     DPTR
00BC E0                MOVX    A,@DPTR
00BD F9                MOV     R1,A
00BE 900004            MOV     DPTR,#04H
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 448 

00C1 E4                CLR     A
00C2 120000      E     LCALL   ?C?CSTOPTR
                                           ; SOURCE LINE # 417
00C5 8013              SJMP    ?C0087
00C7         ?C0086:
                                           ; SOURCE LINE # 418
00C7 900000      R     MOV     DPTR,#Buf
00CA E0                MOVX    A,@DPTR
00CB FB                MOV     R3,A
00CC A3                INC     DPTR
00CD E0                MOVX    A,@DPTR
00CE FA                MOV     R2,A
00CF A3                INC     DPTR
00D0 E0                MOVX    A,@DPTR
00D1 F9                MOV     R1,A
00D2 900004            MOV     DPTR,#04H
00D5 74FF              MOV     A,#0FFH
00D7 120000      E     LCALL   ?C?CSTOPTR
                                           ; SOURCE LINE # 419
00DA         ?C0087:
                                           ; SOURCE LINE # 420
00DA 900000      R     MOV     DPTR,#Buf
00DD E0                MOVX    A,@DPTR
00DE FB                MOV     R3,A
00DF A3                INC     DPTR
00E0 E0                MOVX    A,@DPTR
00E1 FA                MOV     R2,A
00E2 A3                INC     DPTR
00E3 E0                MOVX    A,@DPTR
00E4 F9                MOV     R1,A
00E5 900005            MOV     DPTR,#05H
00E8 EF                MOV     A,R7
00E9 120000      E     LCALL   ?C?CSTOPTR
                                           ; SOURCE LINE # 422
00EC 900000      R     MOV     DPTR,#Flash_Data+01H
00EF E0                MOVX    A,@DPTR
00F0 FF                MOV     R7,A
00F1 C3                CLR     C
00F2 9480              SUBB    A,#080H
00F4 5009              JNC     ?C0088
                                           ; SOURCE LINE # 423
00F6 900006            MOV     DPTR,#06H
00F9 E4                CLR     A
00FA 120000      E     LCALL   ?C?CSTOPTR
                                           ; SOURCE LINE # 424
00FD 8008              SJMP    ?C0089
00FF         ?C0088:
                                           ; SOURCE LINE # 425
00FF 900006            MOV     DPTR,#06H
0102 74FF              MOV     A,#0FFH
0104 120000      E     LCALL   ?C?CSTOPTR
                                           ; SOURCE LINE # 426
0107         ?C0089:
                                           ; SOURCE LINE # 427
0107 900007            MOV     DPTR,#07H
010A EF                MOV     A,R7
010B 120000      E     LCALL   ?C?CSTOPTR
                                           ; SOURCE LINE # 429
010E 900000      E     MOV     DPTR,#Optical_Axis_Data+03H
0111 E0                MOVX    A,@DPTR
0112 B4FF11            CJNE    A,#0FFH,?C0090
0115 A3                INC     DPTR
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 449 

0116 E0                MOVX    A,@DPTR
0117 B4FF0C            CJNE    A,#0FFH,?C0090
                                           ; SOURCE LINE # 430
                                           ; SOURCE LINE # 431
011A A3                INC     DPTR
011B E0                MOVX    A,@DPTR
011C B4FF07            CJNE    A,#0FFH,?C0090
                                           ; SOURCE LINE # 432
                                           ; SOURCE LINE # 434
011F E4                CLR     A
0120 900000      E     MOV     DPTR,#Optical_Axis_Data+03H
0123 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 435
0124 A3                INC     DPTR
0125 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 436
                                           ; SOURCE LINE # 437
0126         ?C0090:
                                           ; SOURCE LINE # 438
0126 900000      E     MOV     DPTR,#Optical_Axis_Data+03H
0129 E0                MOVX    A,@DPTR
012A FF                MOV     R7,A
012B 900000      R     MOV     DPTR,#Buf
012E E0                MOVX    A,@DPTR
012F FB                MOV     R3,A
0130 A3                INC     DPTR
0131 E0                MOVX    A,@DPTR
0132 FA                MOV     R2,A
0133 A3                INC     DPTR
0134 E0                MOVX    A,@DPTR
0135 F9                MOV     R1,A
0136 900010            MOV     DPTR,#010H
0139 EF                MOV     A,R7
013A 120000      E     LCALL   ?C?CSTOPTR
                                           ; SOURCE LINE # 439
013D 900000      E     MOV     DPTR,#Optical_Axis_Data+04H
0140 E0                MOVX    A,@DPTR
0141 900011            MOV     DPTR,#011H
0144 120000      E     LCALL   ?C?CSTOPTR
                                           ; SOURCE LINE # 441
0147 900000      E     MOV     DPTR,#tCAN_Rx_Msg+0DH
014A E0                MOVX    A,@DPTR
014B 900008            MOV     DPTR,#08H
014E 120000      E     LCALL   ?C?CSTOPTR
                                           ; SOURCE LINE # 442
0151 120000      E     LCALL   Get_Temperature
0154 900000      R     MOV     DPTR,#Buf
0157 E0                MOVX    A,@DPTR
0158 FB                MOV     R3,A
0159 A3                INC     DPTR
015A E0                MOVX    A,@DPTR
015B FA                MOV     R2,A
015C A3                INC     DPTR
015D E0                MOVX    A,@DPTR
015E F9                MOV     R1,A
015F 900009            MOV     DPTR,#09H
0162 EF                MOV     A,R7
0163 120000      E     LCALL   ?C?CSTOPTR
                                           ; SOURCE LINE # 444
0166 120000      E     LCALL   IlGetRxSAS_Angle
0169 900000      R     MOV     DPTR,#ret16
016C EE                MOV     A,R6
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 450 

016D F0                MOVX    @DPTR,A
016E A3                INC     DPTR
016F EF                MOV     A,R7
0170 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 446
0171 900000      R     MOV     DPTR,#ret16
0174 E0                MOVX    A,@DPTR
0175 FC                MOV     R4,A
0176 A3                INC     DPTR
0177 E0                MOVX    A,@DPTR
0178 FD                MOV     R5,A
0179 EC                MOV     A,R4
017A FF                MOV     R7,A
017B 900000      R     MOV     DPTR,#Buf
017E E0                MOVX    A,@DPTR
017F FB                MOV     R3,A
0180 A3                INC     DPTR
0181 E0                MOVX    A,@DPTR
0182 FA                MOV     R2,A
0183 A3                INC     DPTR
0184 E0                MOVX    A,@DPTR
0185 F9                MOV     R1,A
0186 90000A            MOV     DPTR,#0AH
0189 EF                MOV     A,R7
018A 120000      E     LCALL   ?C?CSTOPTR
                                           ; SOURCE LINE # 447
018D ED                MOV     A,R5
018E 90000B            MOV     DPTR,#0BH
0191 120000      E     LCALL   ?C?CSTOPTR
                                           ; SOURCE LINE # 449
0194 900000      R     MOV     DPTR,#ga_Ext_tDTC_Type_Msg
0197 E0                MOVX    A,@DPTR
0198 FF                MOV     R7,A
0199 B4091A            CJNE    A,#09H,?C0092
019C 900000      R     MOV     DPTR,#Buf
019F E0                MOVX    A,@DPTR
01A0 FB                MOV     R3,A
01A1 A3                INC     DPTR
01A2 E0                MOVX    A,@DPTR
01A3 FA                MOV     R2,A
01A4 A3                INC     DPTR
01A5 E0                MOVX    A,@DPTR
01A6 240D              ADD     A,#0DH
01A8 F9                MOV     R1,A
01A9 E4                CLR     A
01AA 3A                ADDC    A,R2
01AB FA                MOV     R2,A
01AC 120000      E     LCALL   ?C?CLDPTR
01AF 4401              ORL     A,#01H
01B1 120000      E     LCALL   ?C?CSTPTR
01B4 801C              SJMP    ?C0093
01B6         ?C0092:
                                           ; SOURCE LINE # 450
01B6 EF                MOV     A,R7
01B7 B40818            CJNE    A,#08H,?C0093
01BA 900000      R     MOV     DPTR,#Buf
01BD E0                MOVX    A,@DPTR
01BE FB                MOV     R3,A
01BF A3                INC     DPTR
01C0 E0                MOVX    A,@DPTR
01C1 FA                MOV     R2,A
01C2 A3                INC     DPTR
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 451 

01C3 E0                MOVX    A,@DPTR
01C4 240F              ADD     A,#0FH
01C6 F9                MOV     R1,A
01C7 E4                CLR     A
01C8 3A                ADDC    A,R2
01C9 FA                MOV     R2,A
01CA 120000      E     LCALL   ?C?CLDPTR
01CD 4401              ORL     A,#01H
01CF 120000      E     LCALL   ?C?CSTPTR
                                           ; SOURCE LINE # 451
01D2         ?C0093:
                                           ; SOURCE LINE # 453
01D2 900000      R     MOV     DPTR,#ga_Ext_tDTC_Type_Msg+02H
01D5 E0                MOVX    A,@DPTR
01D6 FF                MOV     R7,A
01D7 B4091A            CJNE    A,#09H,?C0096
01DA 900000      R     MOV     DPTR,#Buf
01DD E0                MOVX    A,@DPTR
01DE FB                MOV     R3,A
01DF A3                INC     DPTR
01E0 E0                MOVX    A,@DPTR
01E1 FA                MOV     R2,A
01E2 A3                INC     DPTR
01E3 E0                MOVX    A,@DPTR
01E4 240D              ADD     A,#0DH
01E6 F9                MOV     R1,A
01E7 E4                CLR     A
01E8 3A                ADDC    A,R2
01E9 FA                MOV     R2,A
01EA 120000      E     LCALL   ?C?CLDPTR
01ED 4402              ORL     A,#02H
01EF 120000      E     LCALL   ?C?CSTPTR
01F2 801C              SJMP    ?C0097
01F4         ?C0096:
                                           ; SOURCE LINE # 454
01F4 EF                MOV     A,R7
01F5 B40818            CJNE    A,#08H,?C0097
01F8 900000      R     MOV     DPTR,#Buf
01FB E0                MOVX    A,@DPTR
01FC FB                MOV     R3,A
01FD A3                INC     DPTR
01FE E0                MOVX    A,@DPTR
01FF FA                MOV     R2,A
0200 A3                INC     DPTR
0201 E0                MOVX    A,@DPTR
0202 240F              ADD     A,#0FH
0204 F9                MOV     R1,A
0205 E4                CLR     A
0206 3A                ADDC    A,R2
0207 FA                MOV     R2,A
0208 120000      E     LCALL   ?C?CLDPTR
020B 4402              ORL     A,#02H
020D 120000      E     LCALL   ?C?CSTPTR
                                           ; SOURCE LINE # 455
0210         ?C0097:
                                           ; SOURCE LINE # 457
0210 900000      R     MOV     DPTR,#ga_Ext_tDTC_Type_Msg+04H
0213 E0                MOVX    A,@DPTR
0214 FF                MOV     R7,A
0215 B4091A            CJNE    A,#09H,?C0100
0218 900000      R     MOV     DPTR,#Buf
021B E0                MOVX    A,@DPTR
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 452 

021C FB                MOV     R3,A
021D A3                INC     DPTR
021E E0                MOVX    A,@DPTR
021F FA                MOV     R2,A
0220 A3                INC     DPTR
0221 E0                MOVX    A,@DPTR
0222 240D              ADD     A,#0DH
0224 F9                MOV     R1,A
0225 E4                CLR     A
0226 3A                ADDC    A,R2
0227 FA                MOV     R2,A
0228 120000      E     LCALL   ?C?CLDPTR
022B 4404              ORL     A,#04H
022D 120000      E     LCALL   ?C?CSTPTR
0230 801C              SJMP    ?C0101
0232         ?C0100:
                                           ; SOURCE LINE # 458
0232 EF                MOV     A,R7
0233 B40818            CJNE    A,#08H,?C0101
0236 900000      R     MOV     DPTR,#Buf
0239 E0                MOVX    A,@DPTR
023A FB                MOV     R3,A
023B A3                INC     DPTR
023C E0                MOVX    A,@DPTR
023D FA                MOV     R2,A
023E A3                INC     DPTR
023F E0                MOVX    A,@DPTR
0240 240F              ADD     A,#0FH
0242 F9                MOV     R1,A
0243 E4                CLR     A
0244 3A                ADDC    A,R2
0245 FA                MOV     R2,A
0246 120000      E     LCALL   ?C?CLDPTR
0249 4404              ORL     A,#04H
024B 120000      E     LCALL   ?C?CSTPTR
                                           ; SOURCE LINE # 459
024E         ?C0101:
                                           ; SOURCE LINE # 461
024E 900000      R     MOV     DPTR,#ga_Ext_tDTC_Type_Msg+06H
0251 E0                MOVX    A,@DPTR
0252 FF                MOV     R7,A
0253 B4091A            CJNE    A,#09H,?C0104
0256 900000      R     MOV     DPTR,#Buf
0259 E0                MOVX    A,@DPTR
025A FB                MOV     R3,A
025B A3                INC     DPTR
025C E0                MOVX    A,@DPTR
025D FA                MOV     R2,A
025E A3                INC     DPTR
025F E0                MOVX    A,@DPTR
0260 240D              ADD     A,#0DH
0262 F9                MOV     R1,A
0263 E4                CLR     A
0264 3A                ADDC    A,R2
0265 FA                MOV     R2,A
0266 120000      E     LCALL   ?C?CLDPTR
0269 4408              ORL     A,#08H
026B 120000      E     LCALL   ?C?CSTPTR
026E 801C              SJMP    ?C0105
0270         ?C0104:
                                           ; SOURCE LINE # 462
0270 EF                MOV     A,R7
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 453 

0271 B40818            CJNE    A,#08H,?C0105
0274 900000      R     MOV     DPTR,#Buf
0277 E0                MOVX    A,@DPTR
0278 FB                MOV     R3,A
0279 A3                INC     DPTR
027A E0                MOVX    A,@DPTR
027B FA                MOV     R2,A
027C A3                INC     DPTR
027D E0                MOVX    A,@DPTR
027E 240F              ADD     A,#0FH
0280 F9                MOV     R1,A
0281 E4                CLR     A
0282 3A                ADDC    A,R2
0283 FA                MOV     R2,A
0284 120000      E     LCALL   ?C?CLDPTR
0287 4408              ORL     A,#08H
0289 120000      E     LCALL   ?C?CSTPTR
                                           ; SOURCE LINE # 463
028C         ?C0105:
                                           ; SOURCE LINE # 465
028C 900000      R     MOV     DPTR,#ga_Ext_tDTC_Type_Msg+08H
028F E0                MOVX    A,@DPTR
0290 FF                MOV     R7,A
0291 B4091A            CJNE    A,#09H,?C0108
0294 900000      R     MOV     DPTR,#Buf
0297 E0                MOVX    A,@DPTR
0298 FB                MOV     R3,A
0299 A3                INC     DPTR
029A E0                MOVX    A,@DPTR
029B FA                MOV     R2,A
029C A3                INC     DPTR
029D E0                MOVX    A,@DPTR
029E 240D              ADD     A,#0DH
02A0 F9                MOV     R1,A
02A1 E4                CLR     A
02A2 3A                ADDC    A,R2
02A3 FA                MOV     R2,A
02A4 120000      E     LCALL   ?C?CLDPTR
02A7 4410              ORL     A,#010H
02A9 120000      E     LCALL   ?C?CSTPTR
02AC 801C              SJMP    ?C0109
02AE         ?C0108:
                                           ; SOURCE LINE # 466
02AE EF                MOV     A,R7
02AF B40818            CJNE    A,#08H,?C0109
02B2 900000      R     MOV     DPTR,#Buf
02B5 E0                MOVX    A,@DPTR
02B6 FB                MOV     R3,A
02B7 A3                INC     DPTR
02B8 E0                MOVX    A,@DPTR
02B9 FA                MOV     R2,A
02BA A3                INC     DPTR
02BB E0                MOVX    A,@DPTR
02BC 240F              ADD     A,#0FH
02BE F9                MOV     R1,A
02BF E4                CLR     A
02C0 3A                ADDC    A,R2
02C1 FA                MOV     R2,A
02C2 120000      E     LCALL   ?C?CLDPTR
02C5 4410              ORL     A,#010H
02C7 120000      E     LCALL   ?C?CSTPTR
                                           ; SOURCE LINE # 467
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 454 

02CA         ?C0109:
                                           ; SOURCE LINE # 469
02CA 900000      R     MOV     DPTR,#ga_Ext_tDTC_Type_Msg+0AH
02CD E0                MOVX    A,@DPTR
02CE FF                MOV     R7,A
02CF B4091A            CJNE    A,#09H,?C0112
02D2 900000      R     MOV     DPTR,#Buf
02D5 E0                MOVX    A,@DPTR
02D6 FB                MOV     R3,A
02D7 A3                INC     DPTR
02D8 E0                MOVX    A,@DPTR
02D9 FA                MOV     R2,A
02DA A3                INC     DPTR
02DB E0                MOVX    A,@DPTR
02DC 240D              ADD     A,#0DH
02DE F9                MOV     R1,A
02DF E4                CLR     A
02E0 3A                ADDC    A,R2
02E1 FA                MOV     R2,A
02E2 120000      E     LCALL   ?C?CLDPTR
02E5 4420              ORL     A,#020H
02E7 120000      E     LCALL   ?C?CSTPTR
02EA 801C              SJMP    ?C0113
02EC         ?C0112:
                                           ; SOURCE LINE # 470
02EC EF                MOV     A,R7
02ED B40818            CJNE    A,#08H,?C0113
02F0 900000      R     MOV     DPTR,#Buf
02F3 E0                MOVX    A,@DPTR
02F4 FB                MOV     R3,A
02F5 A3                INC     DPTR
02F6 E0                MOVX    A,@DPTR
02F7 FA                MOV     R2,A
02F8 A3                INC     DPTR
02F9 E0                MOVX    A,@DPTR
02FA 240F              ADD     A,#0FH
02FC F9                MOV     R1,A
02FD E4                CLR     A
02FE 3A                ADDC    A,R2
02FF FA                MOV     R2,A
0300 120000      E     LCALL   ?C?CLDPTR
0303 4420              ORL     A,#020H
0305 120000      E     LCALL   ?C?CSTPTR
                                           ; SOURCE LINE # 471
0308         ?C0113:
                                           ; SOURCE LINE # 473
0308 900000      R     MOV     DPTR,#ga_Ext_tDTC_Type_Msg+0CH
030B E0                MOVX    A,@DPTR
030C FF                MOV     R7,A
030D B4091A            CJNE    A,#09H,?C0116
0310 900000      R     MOV     DPTR,#Buf
0313 E0                MOVX    A,@DPTR
0314 FB                MOV     R3,A
0315 A3                INC     DPTR
0316 E0                MOVX    A,@DPTR
0317 FA                MOV     R2,A
0318 A3                INC     DPTR
0319 E0                MOVX    A,@DPTR
031A 240D              ADD     A,#0DH
031C F9                MOV     R1,A
031D E4                CLR     A
031E 3A                ADDC    A,R2
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 455 

031F FA                MOV     R2,A
0320 120000      E     LCALL   ?C?CLDPTR
0323 4440              ORL     A,#040H
0325 120000      E     LCALL   ?C?CSTPTR
0328 801C              SJMP    ?C0117
032A         ?C0116:
                                           ; SOURCE LINE # 474
032A EF                MOV     A,R7
032B B40818            CJNE    A,#08H,?C0117
032E 900000      R     MOV     DPTR,#Buf
0331 E0                MOVX    A,@DPTR
0332 FB                MOV     R3,A
0333 A3                INC     DPTR
0334 E0                MOVX    A,@DPTR
0335 FA                MOV     R2,A
0336 A3                INC     DPTR
0337 E0                MOVX    A,@DPTR
0338 240F              ADD     A,#0FH
033A F9                MOV     R1,A
033B E4                CLR     A
033C 3A                ADDC    A,R2
033D FA                MOV     R2,A
033E 120000      E     LCALL   ?C?CLDPTR
0341 4440              ORL     A,#040H
0343 120000      E     LCALL   ?C?CSTPTR
                                           ; SOURCE LINE # 475
0346         ?C0117:
                                           ; SOURCE LINE # 477
0346 900000      R     MOV     DPTR,#ga_Ext_tDTC_Type_Msg+0EH
0349 E0                MOVX    A,@DPTR
034A FF                MOV     R7,A
034B B4091A            CJNE    A,#09H,?C0120
034E 900000      R     MOV     DPTR,#Buf
0351 E0                MOVX    A,@DPTR
0352 FB                MOV     R3,A
0353 A3                INC     DPTR
0354 E0                MOVX    A,@DPTR
0355 FA                MOV     R2,A
0356 A3                INC     DPTR
0357 E0                MOVX    A,@DPTR
0358 240D              ADD     A,#0DH
035A F9                MOV     R1,A
035B E4                CLR     A
035C 3A                ADDC    A,R2
035D FA                MOV     R2,A
035E 120000      E     LCALL   ?C?CLDPTR
0361 4480              ORL     A,#080H
0363 120000      E     LCALL   ?C?CSTPTR
0366 801C              SJMP    ?C0121
0368         ?C0120:
                                           ; SOURCE LINE # 478
0368 EF                MOV     A,R7
0369 B40818            CJNE    A,#08H,?C0121
036C 900000      R     MOV     DPTR,#Buf
036F E0                MOVX    A,@DPTR
0370 FB                MOV     R3,A
0371 A3                INC     DPTR
0372 E0                MOVX    A,@DPTR
0373 FA                MOV     R2,A
0374 A3                INC     DPTR
0375 E0                MOVX    A,@DPTR
0376 240F              ADD     A,#0FH
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 456 

0378 F9                MOV     R1,A
0379 E4                CLR     A
037A 3A                ADDC    A,R2
037B FA                MOV     R2,A
037C 120000      E     LCALL   ?C?CLDPTR
037F 4480              ORL     A,#080H
0381 120000      E     LCALL   ?C?CSTPTR
                                           ; SOURCE LINE # 479
0384         ?C0121:
                                           ; SOURCE LINE # 481
0384 900000      R     MOV     DPTR,#ga_Ext_tDTC_Type_Msg+010H
0387 E0                MOVX    A,@DPTR
0388 FF                MOV     R7,A
0389 B4091A            CJNE    A,#09H,?C0124
038C 900000      R     MOV     DPTR,#Buf
038F E0                MOVX    A,@DPTR
0390 FB                MOV     R3,A
0391 A3                INC     DPTR
0392 E0                MOVX    A,@DPTR
0393 FA                MOV     R2,A
0394 A3                INC     DPTR
0395 E0                MOVX    A,@DPTR
0396 240C              ADD     A,#0CH
0398 F9                MOV     R1,A
0399 E4                CLR     A
039A 3A                ADDC    A,R2
039B FA                MOV     R2,A
039C 120000      E     LCALL   ?C?CLDPTR
039F 4401              ORL     A,#01H
03A1 120000      E     LCALL   ?C?CSTPTR
03A4 8035              SJMP    ?C0128
03A6         ?C0124:
                                           ; SOURCE LINE # 482
03A6 EF                MOV     A,R7
03A7 B40831            CJNE    A,#08H,?C0128
03AA 900000      R     MOV     DPTR,#Buf
03AD E0                MOVX    A,@DPTR
03AE FB                MOV     R3,A
03AF A3                INC     DPTR
03B0 E0                MOVX    A,@DPTR
03B1 FA                MOV     R2,A
03B2 A3                INC     DPTR
03B3 E0                MOVX    A,@DPTR
03B4 240E              ADD     A,#0EH
03B6 F9                MOV     R1,A
03B7 E4                CLR     A
03B8 3A                ADDC    A,R2
03B9 FA                MOV     R2,A
03BA 120000      E     LCALL   ?C?CLDPTR
03BD 4401              ORL     A,#01H
03BF 120000      E     LCALL   ?C?CSTPTR
03C2 8017              SJMP    ?C0128
                                           ; SOURCE LINE # 483
                                           ; SOURCE LINE # 484
03C4         ?C0085:
                                           ; SOURCE LINE # 486
                                           ; SOURCE LINE # 487
03C4 900000      R     MOV     DPTR,#ID
03C7 E0                MOVX    A,@DPTR
03C8 FF                MOV     R7,A
03C9 A3                INC     DPTR
03CA E0                MOVX    A,@DPTR
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 457 

03CB FB                MOV     R3,A
03CC A3                INC     DPTR
03CD E0                MOVX    A,@DPTR
03CE FA                MOV     R2,A
03CF A3                INC     DPTR
03D0 E0                MOVX    A,@DPTR
03D1 F9                MOV     R1,A
03D2 A3                INC     DPTR
03D3 E0                MOVX    A,@DPTR
03D4 900000      R     MOV     DPTR,#?_SYS_Flash_Read?BYTE+04H
03D7 F0                MOVX    @DPTR,A
03D8 120000      R     LCALL   _SYS_Flash_Read
                                           ; SOURCE LINE # 488
03DB         ?C0128:
                                           ; SOURCE LINE # 489
03DB 900000      R     MOV     DPTR,#ret
03DE 7404              MOV     A,#04H
03E0 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 490
03E1 900000      R     MOV     DPTR,#Length
03E4 E0                MOVX    A,@DPTR
03E5 FF                MOV     R7,A
03E6 7E00              MOV     R6,#00H
03E8 7800        R     MOV     R0,#LOW temp_buf
03EA 7C00        R     MOV     R4,#HIGH temp_buf
03EC 7D01              MOV     R5,#01H
03EE 900000      R     MOV     DPTR,#Buf
03F1 E0                MOVX    A,@DPTR
03F2 FB                MOV     R3,A
03F3 A3                INC     DPTR
03F4 E0                MOVX    A,@DPTR
03F5 FA                MOV     R2,A
03F6 A3                INC     DPTR
03F7 E0                MOVX    A,@DPTR
03F8 F9                MOV     R1,A
03F9 120000      E     LCALL   ?C?COPY
                                           ; SOURCE LINE # 491
03FC 22                RET     
             ; FUNCTION _Diag_Read_Sys (END)

             ; FUNCTION Firmware_Update (BEGIN)
                                           ; SOURCE LINE # 493
                                           ; SOURCE LINE # 494
                                           ; SOURCE LINE # 495
0000 7D1E              MOV     R5,#01EH
0002 7C00              MOV     R4,#00H
0004 7F09              MOV     R7,#09H
0006 120000      E     LCALL   _Delay_Time_Set
                                           ; SOURCE LINE # 496
0009 22                RET     
             ; FUNCTION Firmware_Update (END)

             ; FUNCTION Diag_Eeprom_Update (BEGIN)
                                           ; SOURCE LINE # 498
                                           ; SOURCE LINE # 499
                                           ; SOURCE LINE # 500
0000 120000      E     LCALL   Isp_Off
                                           ; SOURCE LINE # 501
0003 900000      E     MOV     DPTR,#EEPROM_Update_Mode
0006 7401              MOV     A,#01H
0008 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 502
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 458 

0009 D294              SETB    MCU_F_ENABLE
                                           ; SOURCE LINE # 504
000B 53E6FB            ANL     EIE1,#0FBH
                                           ; SOURCE LINE # 505
000E 53E6FE            ANL     EIE1,#0FEH
                                           ; SOURCE LINE # 506
0011 22                RET     
             ; FUNCTION Diag_Eeprom_Update (END)

             ; FUNCTION _Diag_Write_Transfer_Data (BEGIN)
                                           ; SOURCE LINE # 508
0000 900000      R     MOV     DPTR,#Buf
0003 EB                MOV     A,R3
0004 F0                MOVX    @DPTR,A
0005 A3                INC     DPTR
0006 EA                MOV     A,R2
0007 F0                MOVX    @DPTR,A
0008 A3                INC     DPTR
0009 E9                MOV     A,R1
000A F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 509
                                           ; SOURCE LINE # 510
000B A3                INC     DPTR
000C 120000      E     LCALL   ?C?LSTKXDATA
000F 00                DB      00H
0010 00                DB      00H
0011 00                DB      00H
0012 00                DB      00H
                                           ; SOURCE LINE # 519
0013 7800        R     MOV     R0,#LOW Write_Buf
0015 7C00        R     MOV     R4,#HIGH Write_Buf
0017 7D01              MOV     R5,#01H
0019 7BFF              MOV     R3,#0FFH
001B 7A00        R     MOV     R2,#HIGH _?ix1002
001D 7900        R     MOV     R1,#LOW _?ix1002
001F 7E01              MOV     R6,#01H
0021 7F00              MOV     R7,#00H
0023 120000      E     LCALL   ?C?COPY
                                           ; SOURCE LINE # 521
0026 900000      R     MOV     DPTR,#cnt
0029 E0                MOVX    A,@DPTR
002A FC                MOV     R4,A
002B A3                INC     DPTR
002C E0                MOVX    A,@DPTR
002D FD                MOV     R5,A
002E A3                INC     DPTR
002F E0                MOVX    A,@DPTR
0030 FE                MOV     R6,A
0031 A3                INC     DPTR
0032 E0                MOVX    A,@DPTR
0033 540F              ANL     A,#0FH
0035 FF                MOV     R7,A
0036 E4                CLR     A
0037 FE                MOV     R6,A
0038 FD                MOV     R5,A
0039 FC                MOV     R4,A
003A FB                MOV     R3,A
003B FA                MOV     R2,A
003C F9                MOV     R1,A
003D F8                MOV     R0,A
003E C3                CLR     C
003F 120000      E     LCALL   ?C?ULCMP
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 459 

0042 7045              JNZ     ?C0132
                                           ; SOURCE LINE # 522
                                           ; SOURCE LINE # 523
0044 FF                MOV     R7,A
0045 7E10              MOV     R6,#010H
0047 FD                MOV     R5,A
0048 FC                MOV     R4,A
0049 900000      R     MOV     DPTR,#erase_cnt
004C E0                MOVX    A,@DPTR
004D F8                MOV     R0,A
004E A3                INC     DPTR
004F E0                MOVX    A,@DPTR
0050 F9                MOV     R1,A
0051 A3                INC     DPTR
0052 E0                MOVX    A,@DPTR
0053 FA                MOV     R2,A
0054 A3                INC     DPTR
0055 E0                MOVX    A,@DPTR
0056 FB                MOV     R3,A
0057 120000      E     LCALL   ?C?LMUL
005A 120000      E     LCALL   _Flash_EraseSector
                                           ; SOURCE LINE # 524
005D 900000      R     MOV     DPTR,#erase_cnt
0060 E0                MOVX    A,@DPTR
0061 FC                MOV     R4,A
0062 A3                INC     DPTR
0063 E0                MOVX    A,@DPTR
0064 FD                MOV     R5,A
0065 A3                INC     DPTR
0066 E0                MOVX    A,@DPTR
0067 FE                MOV     R6,A
0068 A3                INC     DPTR
0069 E0                MOVX    A,@DPTR
006A FF                MOV     R7,A
006B E4                CLR     A
006C FA                MOV     R2,A
006D F9                MOV     R1,A
006E F8                MOV     R0,A
006F EF                MOV     A,R7
0070 2401              ADD     A,#01H
0072 FF                MOV     R7,A
0073 EA                MOV     A,R2
0074 3E                ADDC    A,R6
0075 FE                MOV     R6,A
0076 E9                MOV     A,R1
0077 3D                ADDC    A,R5
0078 FD                MOV     R5,A
0079 E8                MOV     A,R0
007A 3C                ADDC    A,R4
007B FC                MOV     R4,A
007C 900000      R     MOV     DPTR,#erase_cnt
007F 120000      E     LCALL   ?C?LSTXDATA
                                           ; SOURCE LINE # 525
0082 7F64              MOV     R7,#064H
0084 7E00              MOV     R6,#00H
0086 120000      E     LCALL   _Wait_ms
                                           ; SOURCE LINE # 526
0089         ?C0132:
                                           ; SOURCE LINE # 527
0089 E4                CLR     A
008A FF                MOV     R7,A
008B FE                MOV     R6,A
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 460 

008C FD                MOV     R5,A
008D FC                MOV     R4,A
008E 900000      R     MOV     DPTR,#cnt
0091 E0                MOVX    A,@DPTR
0092 F8                MOV     R0,A
0093 A3                INC     DPTR
0094 E0                MOVX    A,@DPTR
0095 F9                MOV     R1,A
0096 A3                INC     DPTR
0097 E0                MOVX    A,@DPTR
0098 FA                MOV     R2,A
0099 A3                INC     DPTR
009A E0                MOVX    A,@DPTR
009B FB                MOV     R3,A
009C C3                CLR     C
009D 120000      E     LCALL   ?C?ULCMP
00A0 704D              JNZ     ?C0133
                                           ; SOURCE LINE # 528
                                           ; SOURCE LINE # 529
00A2 7E01              MOV     R6,#01H
00A4 FF                MOV     R7,A
00A5 7DFF              MOV     R5,#0FFH
00A7 7B01              MOV     R3,#01H
00A9 7A00        R     MOV     R2,#HIGH Buf1
00AB 7900        R     MOV     R1,#LOW Buf1
00AD 120000      E     LCALL   ?C?MEMSET
                                           ; SOURCE LINE # 530
00B0 7E01              MOV     R6,#01H
00B2 7F00              MOV     R7,#00H
00B4 7DFF              MOV     R5,#0FFH
00B6 7B01              MOV     R3,#01H
00B8 7A00        R     MOV     R2,#HIGH Buf2
00BA 7900        R     MOV     R1,#LOW Buf2
00BC 120000      E     LCALL   ?C?MEMSET
                                           ; SOURCE LINE # 531
00BF 900000      R     MOV     DPTR,#Buf
00C2 E0                MOVX    A,@DPTR
00C3 FB                MOV     R3,A
00C4 A3                INC     DPTR
00C5 E0                MOVX    A,@DPTR
00C6 FA                MOV     R2,A
00C7 A3                INC     DPTR
00C8 E0                MOVX    A,@DPTR
00C9 2401              ADD     A,#01H
00CB F9                MOV     R1,A
00CC E4                CLR     A
00CD 3A                ADDC    A,R2
00CE FA                MOV     R2,A
00CF EA                MOV     A,R2
00D0 C0E0              PUSH    ACC
00D2 E9                MOV     A,R1
00D3 C0E0              PUSH    ACC
00D5 7A00        R     MOV     R2,#HIGH Buf1
00D7 7900        R     MOV     R1,#LOW Buf1
00D9 7800        R     MOV     R0,#LOW Buf1
00DB 7C00        R     MOV     R4,#HIGH Buf1
00DD 7D01              MOV     R5,#01H
00DF D0E0              POP     ACC
00E1 F9                MOV     R1,A
00E2 D0E0              POP     ACC
00E4 FA                MOV     R2,A
00E5 7E00              MOV     R6,#00H
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 461 

00E7 7FFD              MOV     R7,#0FDH
00E9 120000      E     LCALL   ?C?COPY
                                           ; SOURCE LINE # 532
00EC 020000      R     LJMP    ?C0134
00EF         ?C0133:
                                           ; SOURCE LINE # 534
                                           ; SOURCE LINE # 535
00EF 900000      R     MOV     DPTR,#loop_index
00F2 E0                MOVX    A,@DPTR
00F3 6003              JZ      $ + 5H
00F5 020000      R     LJMP    ?C0135
                                           ; SOURCE LINE # 536
                                           ; SOURCE LINE # 537
00F8 900000      R     MOV     DPTR,#buf1_index
00FB E0                MOVX    A,@DPTR
00FC 6401              XRL     A,#01H
00FE 7062              JNZ     ?C0136
                                           ; SOURCE LINE # 538
                                           ; SOURCE LINE # 539
0100 900000      R     MOV     DPTR,#Buf
0103 E0                MOVX    A,@DPTR
0104 FB                MOV     R3,A
0105 A3                INC     DPTR
0106 E0                MOVX    A,@DPTR
0107 FA                MOV     R2,A
0108 A3                INC     DPTR
0109 E0                MOVX    A,@DPTR
010A 2401              ADD     A,#01H
010C F9                MOV     R1,A
010D E4                CLR     A
010E 3A                ADDC    A,R2
010F FA                MOV     R2,A
0110 E9                MOV     A,R1
0111 C0E0              PUSH    ACC
0113 900000      R     MOV     DPTR,#buf1_index
0116 E0                MOVX    A,@DPTR
0117 2400        R     ADD     A,#LOW Buf1
0119 F9                MOV     R1,A
011A E4                CLR     A
011B 3400        R     ADDC    A,#HIGH Buf1
011D C8                XCH     A,R0
011E E9                MOV     A,R1
011F C8                XCH     A,R0
0120 FC                MOV     R4,A
0121 7D01              MOV     R5,#01H
0123 D0E0              POP     ACC
0125 F9                MOV     R1,A
0126 7E00              MOV     R6,#00H
0128 7FFD              MOV     R7,#0FDH
012A 120000      E     LCALL   ?C?COPY
                                           ; SOURCE LINE # 541
012D 900000      R     MOV     DPTR,#buf1_index
0130 74FE              MOV     A,#0FEH
0132 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 542
0133 A3                INC     DPTR
0134 7402              MOV     A,#02H
0136 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 543
0137 A3                INC     DPTR
0138 14                DEC     A
0139 F0                MOVX    @DPTR,A
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 462 

                                           ; SOURCE LINE # 544
013A 900000      R     MOV     DPTR,#lotation
013D E0                MOVX    A,@DPTR
013E FC                MOV     R4,A
013F A3                INC     DPTR
0140 E0                MOVX    A,@DPTR
0141 FD                MOV     R5,A
0142 A3                INC     DPTR
0143 E0                MOVX    A,@DPTR
0144 FE                MOV     R6,A
0145 A3                INC     DPTR
0146 E0                MOVX    A,@DPTR
0147 FF                MOV     R7,A
0148 E4                CLR     A
0149 FA                MOV     R2,A
014A F9                MOV     R1,A
014B F8                MOV     R0,A
014C EF                MOV     A,R7
014D 2401              ADD     A,#01H
014F FF                MOV     R7,A
0150 EA                MOV     A,R2
0151 3E                ADDC    A,R6
0152 FE                MOV     R6,A
0153 E9                MOV     A,R1
0154 3D                ADDC    A,R5
0155 FD                MOV     R5,A
0156 E8                MOV     A,R0
0157 3C                ADDC    A,R4
0158 FC                MOV     R4,A
0159 900000      R     MOV     DPTR,#lotation
015C 120000      E     LCALL   ?C?LSTXDATA
                                           ; SOURCE LINE # 545
015F 020000      R     LJMP    ?C0134
0162         ?C0136:
                                           ; SOURCE LINE # 547
                                           ; SOURCE LINE # 548
0162 900000      R     MOV     DPTR,#Buf
0165 E0                MOVX    A,@DPTR
0166 FB                MOV     R3,A
0167 A3                INC     DPTR
0168 E0                MOVX    A,@DPTR
0169 FA                MOV     R2,A
016A A3                INC     DPTR
016B E0                MOVX    A,@DPTR
016C 2401              ADD     A,#01H
016E F9                MOV     R1,A
016F E4                CLR     A
0170 3A                ADDC    A,R2
0171 FA                MOV     R2,A
0172 EA                MOV     A,R2
0173 C0E0              PUSH    ACC
0175 E9                MOV     A,R1
0176 C0E0              PUSH    ACC
0178 7A00        R     MOV     R2,#HIGH Buf2
017A 7900        R     MOV     R1,#LOW Buf2
017C 7800        R     MOV     R0,#LOW Buf2
017E 7C00        R     MOV     R4,#HIGH Buf2
0180 7D01              MOV     R5,#01H
0182 D0E0              POP     ACC
0184 F9                MOV     R1,A
0185 D0E0              POP     ACC
0187 FA                MOV     R2,A
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 463 

0188 7E00              MOV     R6,#00H
018A 7FFD              MOV     R7,#0FDH
018C 120000      E     LCALL   ?C?COPY
                                           ; SOURCE LINE # 549
018F 900000      R     MOV     DPTR,#buf2_index
0192 E0                MOVX    A,@DPTR
0193 FF                MOV     R7,A
0194 7E00              MOV     R6,#00H
0196 900000      R     MOV     DPTR,#buf1_index
0199 E0                MOVX    A,@DPTR
019A 2400        R     ADD     A,#LOW Buf1
019C F9                MOV     R1,A
019D E4                CLR     A
019E 3400        R     ADDC    A,#HIGH Buf1
01A0 C8                XCH     A,R0
01A1 E9                MOV     A,R1
01A2 C8                XCH     A,R0
01A3 FC                MOV     R4,A
01A4 7D01              MOV     R5,#01H
01A6 7B01              MOV     R3,#01H
01A8 7A00        R     MOV     R2,#HIGH Buf2
01AA 7900        R     MOV     R1,#LOW Buf2
01AC 120000      E     LCALL   ?C?COPY
                                           ; SOURCE LINE # 551
01AF 900000      R     MOV     DPTR,#lotation
01B2 E0                MOVX    A,@DPTR
01B3 F8                MOV     R0,A
01B4 A3                INC     DPTR
01B5 E0                MOVX    A,@DPTR
01B6 F9                MOV     R1,A
01B7 A3                INC     DPTR
01B8 E0                MOVX    A,@DPTR
01B9 FA                MOV     R2,A
01BA A3                INC     DPTR
01BB E0                MOVX    A,@DPTR
01BC FB                MOV     R3,A
01BD 900000      R     MOV     DPTR,#cnt
01C0 E0                MOVX    A,@DPTR
01C1 FC                MOV     R4,A
01C2 A3                INC     DPTR
01C3 E0                MOVX    A,@DPTR
01C4 FD                MOV     R5,A
01C5 A3                INC     DPTR
01C6 E0                MOVX    A,@DPTR
01C7 FE                MOV     R6,A
01C8 A3                INC     DPTR
01C9 E0                MOVX    A,@DPTR
01CA C3                CLR     C
01CB 9B                SUBB    A,R3
01CC FF                MOV     R7,A
01CD EE                MOV     A,R6
01CE 9A                SUBB    A,R2
01CF FE                MOV     R6,A
01D0 ED                MOV     A,R5
01D1 99                SUBB    A,R1
01D2 FD                MOV     R5,A
01D3 EC                MOV     A,R4
01D4 98                SUBB    A,R0
01D5 FC                MOV     R4,A
01D6 E4                CLR     A
01D7 FB                MOV     R3,A
01D8 7A01              MOV     R2,#01H
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 464 

01DA F9                MOV     R1,A
01DB F8                MOV     R0,A
01DC 120000      E     LCALL   ?C?LMUL
01DF 900000      R     MOV     DPTR,#address
01E2 120000      E     LCALL   ?C?LSTXDATA
                                           ; SOURCE LINE # 552
01E5 7800        R     MOV     R0,#LOW Write_Buf
01E7 7C00        R     MOV     R4,#HIGH Write_Buf
01E9 7D01              MOV     R5,#01H
01EB 7B01              MOV     R3,#01H
01ED 7A00        R     MOV     R2,#HIGH Buf1
01EF 7900        R     MOV     R1,#LOW Buf1
01F1 7E01              MOV     R6,#01H
01F3 7F00              MOV     R7,#00H
01F5 120000      E     LCALL   ?C?COPY
                                           ; SOURCE LINE # 554
01F8 900000      R     MOV     DPTR,#address
01FB E0                MOVX    A,@DPTR
01FC FC                MOV     R4,A
01FD A3                INC     DPTR
01FE E0                MOVX    A,@DPTR
01FF FD                MOV     R5,A
0200 A3                INC     DPTR
0201 E0                MOVX    A,@DPTR
0202 FE                MOV     R6,A
0203 A3                INC     DPTR
0204 E0                MOVX    A,@DPTR
0205 FF                MOV     R7,A
0206 7B01              MOV     R3,#01H
0208 7A00        R     MOV     R2,#HIGH Write_Buf
020A 7900        R     MOV     R1,#LOW Write_Buf
020C 900000      E     MOV     DPTR,#?_Flash_Write?BYTE+07H
020F 7401              MOV     A,#01H
0211 F0                MOVX    @DPTR,A
0212 A3                INC     DPTR
0213 E4                CLR     A
0214 F0                MOVX    @DPTR,A
0215 120000      E     LCALL   _Flash_Write
                                           ; SOURCE LINE # 556
0218 7E01              MOV     R6,#01H
021A 7F00              MOV     R7,#00H
021C 7DFF              MOV     R5,#0FFH
021E 7B01              MOV     R3,#01H
0220 7A00        R     MOV     R2,#HIGH Buf1
0222 7900        R     MOV     R1,#LOW Buf1
0224 120000      E     LCALL   ?C?MEMSET
                                           ; SOURCE LINE # 557
0227 900000      R     MOV     DPTR,#buf1_index
022A E0                MOVX    A,@DPTR
022B FF                MOV     R7,A
022C 7E00              MOV     R6,#00H
022E A3                INC     DPTR
022F E0                MOVX    A,@DPTR
0230 2400        R     ADD     A,#LOW Buf2
0232 F9                MOV     R1,A
0233 E4                CLR     A
0234 3400        R     ADDC    A,#HIGH Buf2
0236 FA                MOV     R2,A
0237 7B01              MOV     R3,#01H
0239 EA                MOV     A,R2
023A C0E0              PUSH    ACC
023C E9                MOV     A,R1
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 465 

023D C0E0              PUSH    ACC
023F 7A00        R     MOV     R2,#HIGH Buf1
0241 7900        R     MOV     R1,#LOW Buf1
0243 7800        R     MOV     R0,#LOW Buf1
0245 7C00        R     MOV     R4,#HIGH Buf1
0247 7D01              MOV     R5,#01H
0249 D0E0              POP     ACC
024B F9                MOV     R1,A
024C D0E0              POP     ACC
024E FA                MOV     R2,A
024F 120000      E     LCALL   ?C?COPY
                                           ; SOURCE LINE # 558
0252 7E01              MOV     R6,#01H
0254 7F00              MOV     R7,#00H
0256 7DFF              MOV     R5,#0FFH
0258 7B01              MOV     R3,#01H
025A 7A00        R     MOV     R2,#HIGH Buf2
025C 7900        R     MOV     R1,#LOW Buf2
025E 120000      E     LCALL   ?C?MEMSET
                                           ; SOURCE LINE # 559
0261 900000      R     MOV     DPTR,#buf1_index
0264 E0                MOVX    A,@DPTR
0265 24FD              ADD     A,#0FDH
0267 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 560
0268 A3                INC     DPTR
0269 E0                MOVX    A,@DPTR
026A 2403              ADD     A,#03H
026C F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 561
                                           ; SOURCE LINE # 562
026D 020000      R     LJMP    ?C0134
0270         ?C0135:
                                           ; SOURCE LINE # 564
0270 900000      R     MOV     DPTR,#loop_index
0273 E0                MOVX    A,@DPTR
0274 6401              XRL     A,#01H
0276 6003              JZ      $ + 5H
0278 020000      R     LJMP    ?C0139
                                           ; SOURCE LINE # 565
                                           ; SOURCE LINE # 566
027B 900000      R     MOV     DPTR,#buf1_index
027E E0                MOVX    A,@DPTR
027F 6402              XRL     A,#02H
0281 7062              JNZ     ?C0140
                                           ; SOURCE LINE # 567
                                           ; SOURCE LINE # 568
0283 900000      R     MOV     DPTR,#Buf
0286 E0                MOVX    A,@DPTR
0287 FB                MOV     R3,A
0288 A3                INC     DPTR
0289 E0                MOVX    A,@DPTR
028A FA                MOV     R2,A
028B A3                INC     DPTR
028C E0                MOVX    A,@DPTR
028D 2401              ADD     A,#01H
028F F9                MOV     R1,A
0290 E4                CLR     A
0291 3A                ADDC    A,R2
0292 FA                MOV     R2,A
0293 E9                MOV     A,R1
0294 C0E0              PUSH    ACC
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 466 

0296 900000      R     MOV     DPTR,#buf1_index
0299 E0                MOVX    A,@DPTR
029A 2400        R     ADD     A,#LOW Buf1
029C F9                MOV     R1,A
029D E4                CLR     A
029E 3400        R     ADDC    A,#HIGH Buf1
02A0 C8                XCH     A,R0
02A1 E9                MOV     A,R1
02A2 C8                XCH     A,R0
02A3 FC                MOV     R4,A
02A4 7D01              MOV     R5,#01H
02A6 D0E0              POP     ACC
02A8 F9                MOV     R1,A
02A9 7E00              MOV     R6,#00H
02AB 7FFD              MOV     R7,#0FDH
02AD 120000      E     LCALL   ?C?COPY
                                           ; SOURCE LINE # 569
02B0 900000      R     MOV     DPTR,#buf1_index
02B3 74FF              MOV     A,#0FFH
02B5 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 570
02B6 A3                INC     DPTR
02B7 7401              MOV     A,#01H
02B9 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 571
02BA A3                INC     DPTR
02BB 04                INC     A
02BC F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 572
02BD 900000      R     MOV     DPTR,#lotation
02C0 E0                MOVX    A,@DPTR
02C1 FC                MOV     R4,A
02C2 A3                INC     DPTR
02C3 E0                MOVX    A,@DPTR
02C4 FD                MOV     R5,A
02C5 A3                INC     DPTR
02C6 E0                MOVX    A,@DPTR
02C7 FE                MOV     R6,A
02C8 A3                INC     DPTR
02C9 E0                MOVX    A,@DPTR
02CA FF                MOV     R7,A
02CB E4                CLR     A
02CC FA                MOV     R2,A
02CD F9                MOV     R1,A
02CE F8                MOV     R0,A
02CF EF                MOV     A,R7
02D0 2401              ADD     A,#01H
02D2 FF                MOV     R7,A
02D3 EA                MOV     A,R2
02D4 3E                ADDC    A,R6
02D5 FE                MOV     R6,A
02D6 E9                MOV     A,R1
02D7 3D                ADDC    A,R5
02D8 FD                MOV     R5,A
02D9 E8                MOV     A,R0
02DA 3C                ADDC    A,R4
02DB FC                MOV     R4,A
02DC 900000      R     MOV     DPTR,#lotation
02DF 120000      E     LCALL   ?C?LSTXDATA
                                           ; SOURCE LINE # 573
02E2 020000      R     LJMP    ?C0134
02E5         ?C0140:
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 467 

                                           ; SOURCE LINE # 575
                                           ; SOURCE LINE # 576
02E5 900000      R     MOV     DPTR,#Buf
02E8 E0                MOVX    A,@DPTR
02E9 FB                MOV     R3,A
02EA A3                INC     DPTR
02EB E0                MOVX    A,@DPTR
02EC FA                MOV     R2,A
02ED A3                INC     DPTR
02EE E0                MOVX    A,@DPTR
02EF 2401              ADD     A,#01H
02F1 F9                MOV     R1,A
02F2 E4                CLR     A
02F3 3A                ADDC    A,R2
02F4 FA                MOV     R2,A
02F5 EA                MOV     A,R2
02F6 C0E0              PUSH    ACC
02F8 E9                MOV     A,R1
02F9 C0E0              PUSH    ACC
02FB 7A00        R     MOV     R2,#HIGH Buf2
02FD 7900        R     MOV     R1,#LOW Buf2
02FF 7800        R     MOV     R0,#LOW Buf2
0301 7C00        R     MOV     R4,#HIGH Buf2
0303 7D01              MOV     R5,#01H
0305 D0E0              POP     ACC
0307 F9                MOV     R1,A
0308 D0E0              POP     ACC
030A FA                MOV     R2,A
030B 7E00              MOV     R6,#00H
030D 7FFD              MOV     R7,#0FDH
030F 120000      E     LCALL   ?C?COPY
                                           ; SOURCE LINE # 577
0312 900000      R     MOV     DPTR,#buf2_index
0315 E0                MOVX    A,@DPTR
0316 FF                MOV     R7,A
0317 7E00              MOV     R6,#00H
0319 900000      R     MOV     DPTR,#buf1_index
031C E0                MOVX    A,@DPTR
031D 2400        R     ADD     A,#LOW Buf1
031F F9                MOV     R1,A
0320 E4                CLR     A
0321 3400        R     ADDC    A,#HIGH Buf1
0323 C8                XCH     A,R0
0324 E9                MOV     A,R1
0325 C8                XCH     A,R0
0326 FC                MOV     R4,A
0327 7D01              MOV     R5,#01H
0329 7B01              MOV     R3,#01H
032B 7A00        R     MOV     R2,#HIGH Buf2
032D 7900        R     MOV     R1,#LOW Buf2
032F 120000      E     LCALL   ?C?COPY
                                           ; SOURCE LINE # 579
0332 900000      R     MOV     DPTR,#lotation
0335 E0                MOVX    A,@DPTR
0336 F8                MOV     R0,A
0337 A3                INC     DPTR
0338 E0                MOVX    A,@DPTR
0339 F9                MOV     R1,A
033A A3                INC     DPTR
033B E0                MOVX    A,@DPTR
033C FA                MOV     R2,A
033D A3                INC     DPTR
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 468 

033E E0                MOVX    A,@DPTR
033F FB                MOV     R3,A
0340 900000      R     MOV     DPTR,#cnt
0343 E0                MOVX    A,@DPTR
0344 FC                MOV     R4,A
0345 A3                INC     DPTR
0346 E0                MOVX    A,@DPTR
0347 FD                MOV     R5,A
0348 A3                INC     DPTR
0349 E0                MOVX    A,@DPTR
034A FE                MOV     R6,A
034B A3                INC     DPTR
034C E0                MOVX    A,@DPTR
034D C3                CLR     C
034E 9B                SUBB    A,R3
034F FF                MOV     R7,A
0350 EE                MOV     A,R6
0351 9A                SUBB    A,R2
0352 FE                MOV     R6,A
0353 ED                MOV     A,R5
0354 99                SUBB    A,R1
0355 FD                MOV     R5,A
0356 EC                MOV     A,R4
0357 98                SUBB    A,R0
0358 FC                MOV     R4,A
0359 E4                CLR     A
035A FB                MOV     R3,A
035B 7A01              MOV     R2,#01H
035D F9                MOV     R1,A
035E F8                MOV     R0,A
035F 120000      E     LCALL   ?C?LMUL
0362 900000      R     MOV     DPTR,#address
0365 120000      E     LCALL   ?C?LSTXDATA
                                           ; SOURCE LINE # 580
0368 7800        R     MOV     R0,#LOW Write_Buf
036A 7C00        R     MOV     R4,#HIGH Write_Buf
036C 7D01              MOV     R5,#01H
036E 7B01              MOV     R3,#01H
0370 7A00        R     MOV     R2,#HIGH Buf1
0372 7900        R     MOV     R1,#LOW Buf1
0374 7E01              MOV     R6,#01H
0376 7F00              MOV     R7,#00H
0378 120000      E     LCALL   ?C?COPY
                                           ; SOURCE LINE # 582
037B 900000      R     MOV     DPTR,#address
037E E0                MOVX    A,@DPTR
037F FC                MOV     R4,A
0380 A3                INC     DPTR
0381 E0                MOVX    A,@DPTR
0382 FD                MOV     R5,A
0383 A3                INC     DPTR
0384 E0                MOVX    A,@DPTR
0385 FE                MOV     R6,A
0386 A3                INC     DPTR
0387 E0                MOVX    A,@DPTR
0388 FF                MOV     R7,A
0389 7B01              MOV     R3,#01H
038B 7A00        R     MOV     R2,#HIGH Write_Buf
038D 7900        R     MOV     R1,#LOW Write_Buf
038F 900000      E     MOV     DPTR,#?_Flash_Write?BYTE+07H
0392 7401              MOV     A,#01H
0394 F0                MOVX    @DPTR,A
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 469 

0395 A3                INC     DPTR
0396 E4                CLR     A
0397 F0                MOVX    @DPTR,A
0398 120000      E     LCALL   _Flash_Write
                                           ; SOURCE LINE # 584
039B 7E01              MOV     R6,#01H
039D 7F00              MOV     R7,#00H
039F 7DFF              MOV     R5,#0FFH
03A1 7B01              MOV     R3,#01H
03A3 7A00        R     MOV     R2,#HIGH Buf1
03A5 7900        R     MOV     R1,#LOW Buf1
03A7 120000      E     LCALL   ?C?MEMSET
                                           ; SOURCE LINE # 585
03AA 900000      R     MOV     DPTR,#buf1_index
03AD E0                MOVX    A,@DPTR
03AE FF                MOV     R7,A
03AF 7E00              MOV     R6,#00H
03B1 A3                INC     DPTR
03B2 E0                MOVX    A,@DPTR
03B3 2400        R     ADD     A,#LOW Buf2
03B5 F9                MOV     R1,A
03B6 E4                CLR     A
03B7 3400        R     ADDC    A,#HIGH Buf2
03B9 FA                MOV     R2,A
03BA 7B01              MOV     R3,#01H
03BC EA                MOV     A,R2
03BD C0E0              PUSH    ACC
03BF E9                MOV     A,R1
03C0 C0E0              PUSH    ACC
03C2 7A00        R     MOV     R2,#HIGH Buf1
03C4 7900        R     MOV     R1,#LOW Buf1
03C6 7800        R     MOV     R0,#LOW Buf1
03C8 7C00        R     MOV     R4,#HIGH Buf1
03CA 7D01              MOV     R5,#01H
03CC D0E0              POP     ACC
03CE F9                MOV     R1,A
03CF D0E0              POP     ACC
03D1 FA                MOV     R2,A
03D2 120000      E     LCALL   ?C?COPY
                                           ; SOURCE LINE # 586
03D5 7E01              MOV     R6,#01H
03D7 7F00              MOV     R7,#00H
03D9 7DFF              MOV     R5,#0FFH
03DB 7B01              MOV     R3,#01H
03DD 7A00        R     MOV     R2,#HIGH Buf2
03DF 7900        R     MOV     R1,#LOW Buf2
03E1 120000      E     LCALL   ?C?MEMSET
                                           ; SOURCE LINE # 587
03E4 900000      R     MOV     DPTR,#buf1_index
03E7 E0                MOVX    A,@DPTR
03E8 24FD              ADD     A,#0FDH
03EA F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 588
03EB A3                INC     DPTR
03EC E0                MOVX    A,@DPTR
03ED 2403              ADD     A,#03H
03EF F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 589
                                           ; SOURCE LINE # 591
03F0 020000      R     LJMP    ?C0134
03F3         ?C0139:
                                           ; SOURCE LINE # 592
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 470 

03F3 900000      R     MOV     DPTR,#loop_index
03F6 E0                MOVX    A,@DPTR
03F7 6402              XRL     A,#02H
03F9 6003              JZ      $ + 5H
03FB 020000      R     LJMP    ?C0134
                                           ; SOURCE LINE # 593
                                           ; SOURCE LINE # 594
03FE 900000      R     MOV     DPTR,#buf1_index
0401 E0                MOVX    A,@DPTR
0402 7062              JNZ     ?C0144
                                           ; SOURCE LINE # 595
                                           ; SOURCE LINE # 596
0404 900000      R     MOV     DPTR,#Buf
0407 E0                MOVX    A,@DPTR
0408 FB                MOV     R3,A
0409 A3                INC     DPTR
040A E0                MOVX    A,@DPTR
040B FA                MOV     R2,A
040C A3                INC     DPTR
040D E0                MOVX    A,@DPTR
040E 2401              ADD     A,#01H
0410 F9                MOV     R1,A
0411 E4                CLR     A
0412 3A                ADDC    A,R2
0413 FA                MOV     R2,A
0414 E9                MOV     A,R1
0415 C0E0              PUSH    ACC
0417 900000      R     MOV     DPTR,#buf1_index
041A E0                MOVX    A,@DPTR
041B 2400        R     ADD     A,#LOW Buf1
041D F9                MOV     R1,A
041E E4                CLR     A
041F 3400        R     ADDC    A,#HIGH Buf1
0421 C8                XCH     A,R0
0422 E9                MOV     A,R1
0423 C8                XCH     A,R0
0424 FC                MOV     R4,A
0425 7D01              MOV     R5,#01H
0427 D0E0              POP     ACC
0429 F9                MOV     R1,A
042A 7E00              MOV     R6,#00H
042C 7FFD              MOV     R7,#0FDH
042E 120000      E     LCALL   ?C?COPY
                                           ; SOURCE LINE # 597
0431 900000      R     MOV     DPTR,#buf1_index
0434 74FD              MOV     A,#0FDH
0436 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 598
0437 A3                INC     DPTR
0438 7403              MOV     A,#03H
043A F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 599
043B E4                CLR     A
043C A3                INC     DPTR
043D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 600
043E 900000      R     MOV     DPTR,#lotation
0441 E0                MOVX    A,@DPTR
0442 FC                MOV     R4,A
0443 A3                INC     DPTR
0444 E0                MOVX    A,@DPTR
0445 FD                MOV     R5,A
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 471 

0446 A3                INC     DPTR
0447 E0                MOVX    A,@DPTR
0448 FE                MOV     R6,A
0449 A3                INC     DPTR
044A E0                MOVX    A,@DPTR
044B FF                MOV     R7,A
044C E4                CLR     A
044D FA                MOV     R2,A
044E F9                MOV     R1,A
044F F8                MOV     R0,A
0450 EF                MOV     A,R7
0451 2401              ADD     A,#01H
0453 FF                MOV     R7,A
0454 EA                MOV     A,R2
0455 3E                ADDC    A,R6
0456 FE                MOV     R6,A
0457 E9                MOV     A,R1
0458 3D                ADDC    A,R5
0459 FD                MOV     R5,A
045A E8                MOV     A,R0
045B 3C                ADDC    A,R4
045C FC                MOV     R4,A
045D 900000      R     MOV     DPTR,#lotation
0460 120000      E     LCALL   ?C?LSTXDATA
                                           ; SOURCE LINE # 601
0463 020000      R     LJMP    ?C0134
0466         ?C0144:
                                           ; SOURCE LINE # 603
                                           ; SOURCE LINE # 604
0466 900000      R     MOV     DPTR,#Buf
0469 E0                MOVX    A,@DPTR
046A FB                MOV     R3,A
046B A3                INC     DPTR
046C E0                MOVX    A,@DPTR
046D FA                MOV     R2,A
046E A3                INC     DPTR
046F E0                MOVX    A,@DPTR
0470 2401              ADD     A,#01H
0472 F9                MOV     R1,A
0473 E4                CLR     A
0474 3A                ADDC    A,R2
0475 FA                MOV     R2,A
0476 EA                MOV     A,R2
0477 C0E0              PUSH    ACC
0479 E9                MOV     A,R1
047A C0E0              PUSH    ACC
047C 7A00        R     MOV     R2,#HIGH Buf2
047E 7900        R     MOV     R1,#LOW Buf2
0480 7800        R     MOV     R0,#LOW Buf2
0482 7C00        R     MOV     R4,#HIGH Buf2
0484 7D01              MOV     R5,#01H
0486 D0E0              POP     ACC
0488 F9                MOV     R1,A
0489 D0E0              POP     ACC
048B FA                MOV     R2,A
048C 7E00              MOV     R6,#00H
048E 7FFD              MOV     R7,#0FDH
0490 120000      E     LCALL   ?C?COPY
                                           ; SOURCE LINE # 605
0493 900000      R     MOV     DPTR,#buf2_index
0496 E0                MOVX    A,@DPTR
0497 FF                MOV     R7,A
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 472 

0498 7E00              MOV     R6,#00H
049A 900000      R     MOV     DPTR,#buf1_index
049D E0                MOVX    A,@DPTR
049E 2400        R     ADD     A,#LOW Buf1
04A0 F9                MOV     R1,A
04A1 E4                CLR     A
04A2 3400        R     ADDC    A,#HIGH Buf1
04A4 C8                XCH     A,R0
04A5 E9                MOV     A,R1
04A6 C8                XCH     A,R0
04A7 FC                MOV     R4,A
04A8 7D01              MOV     R5,#01H
04AA 7B01              MOV     R3,#01H
04AC 7A00        R     MOV     R2,#HIGH Buf2
04AE 7900        R     MOV     R1,#LOW Buf2
04B0 120000      E     LCALL   ?C?COPY
                                           ; SOURCE LINE # 607
04B3 900000      R     MOV     DPTR,#lotation
04B6 E0                MOVX    A,@DPTR
04B7 F8                MOV     R0,A
04B8 A3                INC     DPTR
04B9 E0                MOVX    A,@DPTR
04BA F9                MOV     R1,A
04BB A3                INC     DPTR
04BC E0                MOVX    A,@DPTR
04BD FA                MOV     R2,A
04BE A3                INC     DPTR
04BF E0                MOVX    A,@DPTR
04C0 FB                MOV     R3,A
04C1 900000      R     MOV     DPTR,#cnt
04C4 E0                MOVX    A,@DPTR
04C5 FC                MOV     R4,A
04C6 A3                INC     DPTR
04C7 E0                MOVX    A,@DPTR
04C8 FD                MOV     R5,A
04C9 A3                INC     DPTR
04CA E0                MOVX    A,@DPTR
04CB FE                MOV     R6,A
04CC A3                INC     DPTR
04CD E0                MOVX    A,@DPTR
04CE C3                CLR     C
04CF 9B                SUBB    A,R3
04D0 FF                MOV     R7,A
04D1 EE                MOV     A,R6
04D2 9A                SUBB    A,R2
04D3 FE                MOV     R6,A
04D4 ED                MOV     A,R5
04D5 99                SUBB    A,R1
04D6 FD                MOV     R5,A
04D7 EC                MOV     A,R4
04D8 98                SUBB    A,R0
04D9 FC                MOV     R4,A
04DA E4                CLR     A
04DB FB                MOV     R3,A
04DC 7A01              MOV     R2,#01H
04DE F9                MOV     R1,A
04DF F8                MOV     R0,A
04E0 120000      E     LCALL   ?C?LMUL
04E3 900000      R     MOV     DPTR,#address
04E6 120000      E     LCALL   ?C?LSTXDATA
                                           ; SOURCE LINE # 608
04E9 7800        R     MOV     R0,#LOW Write_Buf
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 473 

04EB 7C00        R     MOV     R4,#HIGH Write_Buf
04ED 7D01              MOV     R5,#01H
04EF 7B01              MOV     R3,#01H
04F1 7A00        R     MOV     R2,#HIGH Buf1
04F3 7900        R     MOV     R1,#LOW Buf1
04F5 7E01              MOV     R6,#01H
04F7 7F00              MOV     R7,#00H
04F9 120000      E     LCALL   ?C?COPY
                                           ; SOURCE LINE # 610
04FC 900000      R     MOV     DPTR,#address
04FF E0                MOVX    A,@DPTR
0500 FC                MOV     R4,A
0501 A3                INC     DPTR
0502 E0                MOVX    A,@DPTR
0503 FD                MOV     R5,A
0504 A3                INC     DPTR
0505 E0                MOVX    A,@DPTR
0506 FE                MOV     R6,A
0507 A3                INC     DPTR
0508 E0                MOVX    A,@DPTR
0509 FF                MOV     R7,A
050A 7B01              MOV     R3,#01H
050C 7A00        R     MOV     R2,#HIGH Write_Buf
050E 7900        R     MOV     R1,#LOW Write_Buf
0510 900000      E     MOV     DPTR,#?_Flash_Write?BYTE+07H
0513 7401              MOV     A,#01H
0515 F0                MOVX    @DPTR,A
0516 A3                INC     DPTR
0517 E4                CLR     A
0518 F0                MOVX    @DPTR,A
0519 120000      E     LCALL   _Flash_Write
                                           ; SOURCE LINE # 612
051C 7E01              MOV     R6,#01H
051E 7F00              MOV     R7,#00H
0520 7DFF              MOV     R5,#0FFH
0522 7B01              MOV     R3,#01H
0524 7A00        R     MOV     R2,#HIGH Buf1
0526 7900        R     MOV     R1,#LOW Buf1
0528 120000      E     LCALL   ?C?MEMSET
                                           ; SOURCE LINE # 613
052B 900000      R     MOV     DPTR,#buf1_index
052E E0                MOVX    A,@DPTR
052F FF                MOV     R7,A
0530 7E00              MOV     R6,#00H
0532 A3                INC     DPTR
0533 E0                MOVX    A,@DPTR
0534 2400        R     ADD     A,#LOW Buf2
0536 F9                MOV     R1,A
0537 E4                CLR     A
0538 3400        R     ADDC    A,#HIGH Buf2
053A FA                MOV     R2,A
053B 7B01              MOV     R3,#01H
053D EA                MOV     A,R2
053E C0E0              PUSH    ACC
0540 E9                MOV     A,R1
0541 C0E0              PUSH    ACC
0543 7A00        R     MOV     R2,#HIGH Buf1
0545 7900        R     MOV     R1,#LOW Buf1
0547 7800        R     MOV     R0,#LOW Buf1
0549 7C00        R     MOV     R4,#HIGH Buf1
054B 7D01              MOV     R5,#01H
054D D0E0              POP     ACC
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 474 

054F F9                MOV     R1,A
0550 D0E0              POP     ACC
0552 FA                MOV     R2,A
0553 120000      E     LCALL   ?C?COPY
                                           ; SOURCE LINE # 614
0556 7E01              MOV     R6,#01H
0558 7F00              MOV     R7,#00H
055A 7DFF              MOV     R5,#0FFH
055C 7B01              MOV     R3,#01H
055E 7A00        R     MOV     R2,#HIGH Buf2
0560 7900        R     MOV     R1,#LOW Buf2
0562 120000      E     LCALL   ?C?MEMSET
                                           ; SOURCE LINE # 615
0565 900000      R     MOV     DPTR,#buf1_index
0568 E0                MOVX    A,@DPTR
0569 24FD              ADD     A,#0FDH
056B F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 616
056C A3                INC     DPTR
056D E0                MOVX    A,@DPTR
056E 2403              ADD     A,#03H
0570 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 617
                                           ; SOURCE LINE # 618
                                           ; SOURCE LINE # 620
                                           ; SOURCE LINE # 621
                                           ; SOURCE LINE # 623
0571         ?C0134:
                                           ; SOURCE LINE # 624
0571 900000      R     MOV     DPTR,#cnt
0574 E0                MOVX    A,@DPTR
0575 FC                MOV     R4,A
0576 A3                INC     DPTR
0577 E0                MOVX    A,@DPTR
0578 FD                MOV     R5,A
0579 A3                INC     DPTR
057A E0                MOVX    A,@DPTR
057B FE                MOV     R6,A
057C A3                INC     DPTR
057D E0                MOVX    A,@DPTR
057E FF                MOV     R7,A
057F E4                CLR     A
0580 FA                MOV     R2,A
0581 F9                MOV     R1,A
0582 F8                MOV     R0,A
0583 EF                MOV     A,R7
0584 2401              ADD     A,#01H
0586 FF                MOV     R7,A
0587 EA                MOV     A,R2
0588 3E                ADDC    A,R6
0589 FE                MOV     R6,A
058A E9                MOV     A,R1
058B 3D                ADDC    A,R5
058C FD                MOV     R5,A
058D E8                MOV     A,R0
058E 3C                ADDC    A,R4
058F FC                MOV     R4,A
0590 900000      R     MOV     DPTR,#cnt
0593 120000      E     LCALL   ?C?LSTXDATA
                                           ; SOURCE LINE # 625
0596 22                RET     
             ; FUNCTION _Diag_Write_Transfer_Data (END)
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 475 


             ; FUNCTION Diag_Sensor_Reset (BEGIN)
                                           ; SOURCE LINE # 627
                                           ; SOURCE LINE # 628
                                           ; SOURCE LINE # 629
0000 120000      E     LCALL   Init_IspTask
                                           ; SOURCE LINE # 630
0003 22                RET     
             ; FUNCTION Diag_Sensor_Reset (END)

             ; FUNCTION _Diag_Guid_OnOff (BEGIN)
                                           ; SOURCE LINE # 632
;---- Variable 'OnOff' assigned to Register 'R7' ----
                                           ; SOURCE LINE # 633
                                           ; SOURCE LINE # 634
0000 120000      E     LCALL   _isp_guide_on_off
                                           ; SOURCE LINE # 635
0003 22                RET     
             ; FUNCTION _Diag_Guid_OnOff (END)

             ; FUNCTION Diag_Calibration_Mode_start (BEGIN)
                                           ; SOURCE LINE # 637
                                           ; SOURCE LINE # 638
                                           ; SOURCE LINE # 639
0000 900000      R     MOV     DPTR,#CalibrationMode_OnOff
0003 7401              MOV     A,#01H
0005 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 641
0006 7E00              MOV     R6,#00H
0008 7F09              MOV     R7,#09H
000A 7DFF              MOV     R5,#0FFH
000C FB                MOV     R3,A
000D 7A00        E     MOV     R2,#HIGH Optical_Axis_Data
000F 7900        E     MOV     R1,#LOW Optical_Axis_Data
0011 120000      E     LCALL   ?C?MEMSET
                                           ; SOURCE LINE # 643
0014 7B01              MOV     R3,#01H
0016 7A00        E     MOV     R2,#HIGH Optical_Axis_Data
0018 7900        E     MOV     R1,#LOW Optical_Axis_Data
001A 900000      E     MOV     DPTR,#?_FLASH_Read_Buf?BYTE+05H
001D E4                CLR     A
001E F0                MOVX    @DPTR,A
001F A3                INC     DPTR
0020 7409              MOV     A,#09H
0022 F0                MOVX    @DPTR,A
0023 A3                INC     DPTR
0024 7420              MOV     A,#020H
0026 F0                MOVX    @DPTR,A
0027 7D00              MOV     R5,#00H
0029 7CFE              MOV     R4,#0FEH
002B 120000      E     LCALL   _FLASH_Read_Buf
                                           ; SOURCE LINE # 645
002E 900000      E     MOV     DPTR,#Optical_Axis_Data
0031 E0                MOVX    A,@DPTR
0032 B4FF11            CJNE    A,#0FFH,?C0150
0035 A3                INC     DPTR
0036 E0                MOVX    A,@DPTR
0037 B4FF0C            CJNE    A,#0FFH,?C0150
                                           ; SOURCE LINE # 646
                                           ; SOURCE LINE # 647
003A A3                INC     DPTR
003B E0                MOVX    A,@DPTR
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 476 

003C B4FF07            CJNE    A,#0FFH,?C0150
                                           ; SOURCE LINE # 648
                                           ; SOURCE LINE # 650
003F E4                CLR     A
0040 900000      E     MOV     DPTR,#Optical_Axis_Data
0043 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 651
0044 A3                INC     DPTR
0045 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 652
                                           ; SOURCE LINE # 653
0046         ?C0150:
                                           ; SOURCE LINE # 655
0046 900000      E     MOV     DPTR,#Optical_Axis_Data+06H
0049 E0                MOVX    A,@DPTR
004A B4FF11            CJNE    A,#0FFH,?C0154
004D A3                INC     DPTR
004E E0                MOVX    A,@DPTR
004F B4FF0C            CJNE    A,#0FFH,?C0154
                                           ; SOURCE LINE # 656
                                           ; SOURCE LINE # 657
0052 A3                INC     DPTR
0053 E0                MOVX    A,@DPTR
0054 B4FF07            CJNE    A,#0FFH,?C0154
                                           ; SOURCE LINE # 658
                                           ; SOURCE LINE # 660
0057 E4                CLR     A
0058 900000      E     MOV     DPTR,#Optical_Axis_Data+06H
005B F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 661
005C A3                INC     DPTR
005D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 662
                                           ; SOURCE LINE # 663
                                           ; SOURCE LINE # 666
005E         ?C0154:
005E 22                RET     
             ; FUNCTION Diag_Calibration_Mode_start (END)

             ; FUNCTION _Diag_Calibration_Mode (BEGIN)
                                           ; SOURCE LINE # 668
0000 900000      R     MOV     DPTR,#Ctrl_Para
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 669
                                           ; SOURCE LINE # 670
0005 E4                CLR     A
0006 900000      R     MOV     DPTR,#Cs
0009 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 674
000A 900000      R     MOV     DPTR,#CalibrationMode_OnOff
000D E0                MOVX    A,@DPTR
000E 6401              XRL     A,#01H
0010 6003              JZ      $ + 5H
0012 020000      R     LJMP    ?C0155
                                           ; SOURCE LINE # 675
                                           ; SOURCE LINE # 676
0015 900000      R     MOV     DPTR,#Ctrl_Para
0018 E0                MOVX    A,@DPTR
0019 B40700            CJNE    A,#07H,?C0237
001C         ?C0237:
001C 4003              JC      $ + 5H
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 477 

001E 020000      R     LJMP    ?C0156
0021 900000      R     MOV     DPTR,#?C0238
0024 F8                MOV     R0,A
0025 28                ADD     A,R0
0026 28                ADD     A,R0
0027 73                JMP     @A+DPTR
0028         ?C0238:
0028 020000      R     LJMP    ?C0157
002B 020000      R     LJMP    ?C0158
002E 020000      R     LJMP    ?C0159
0031 020000      R     LJMP    ?C0160
0034 020000      R     LJMP    ?C0163
0037 020000      R     LJMP    ?C0166
003A 020000      R     LJMP    ?C0169
                                           ; SOURCE LINE # 677
                                           ; SOURCE LINE # 678
003D         ?C0157:
                                           ; SOURCE LINE # 679
003D 120000      R     LCALL   Diag_Calibration_Mode_start
                                           ; SOURCE LINE # 680
0040 900000      R     MOV     DPTR,#OpticOffset_Set
0043 7401              MOV     A,#01H
0045 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 681
0046 120000      R     LCALL   Diag_DTC_Set_Off
                                           ; SOURCE LINE # 682
0049 020000      R     LJMP    ?C0156
                                           ; SOURCE LINE # 684
004C         ?C0158:
                                           ; SOURCE LINE # 685
004C 7D20              MOV     R5,#020H
004E 7F00              MOV     R7,#00H
0050 7EFE              MOV     R6,#0FEH
0052 120000      E     LCALL   _FLASH_Erase_Buf
                                           ; SOURCE LINE # 686
0055 7B01              MOV     R3,#01H
0057 7A00        E     MOV     R2,#HIGH Optical_Axis_Data
0059 7900        E     MOV     R1,#LOW Optical_Axis_Data
005B 900000      E     MOV     DPTR,#?_FLASH_Write_Buf?BYTE+05H
005E E4                CLR     A
005F F0                MOVX    @DPTR,A
0060 A3                INC     DPTR
0061 7409              MOV     A,#09H
0063 F0                MOVX    @DPTR,A
0064 A3                INC     DPTR
0065 7420              MOV     A,#020H
0067 F0                MOVX    @DPTR,A
0068 7F00              MOV     R7,#00H
006A 7EFE              MOV     R6,#0FEH
006C 120000      E     LCALL   _FLASH_Write_Buf
                                           ; SOURCE LINE # 688
006F 900000      R     MOV     DPTR,#OpticOffset_Set
0072 7401              MOV     A,#01H
0074 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 689
0075 E4                CLR     A
0076 900000      R     MOV     DPTR,#CalibrationMode_OnOff
0079 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 690
007A 120000      R     LCALL   Diag_DTC_Set_On
                                           ; SOURCE LINE # 691
007D 020000      R     LJMP    ?C0156
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 478 

                                           ; SOURCE LINE # 693
0080         ?C0159:
                                           ; SOURCE LINE # 694
0080 E4                CLR     A
0081 900000      R     MOV     DPTR,#Calibration_Data
0084 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 695
0085 A3                INC     DPTR
0086 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 697
0087 020000      R     LJMP    ?C0156
                                           ; SOURCE LINE # 699
008A         ?C0160:
                                           ; SOURCE LINE # 700
008A 900000      E     MOV     DPTR,#Optical_Axis_Data+06H
008D E0                MOVX    A,@DPTR
008E FF                MOV     R7,A
008F 900000      E     MOV     DPTR,#Optical_Axis_Data
0092 E0                MOVX    A,@DPTR
0093 2F                ADD     A,R7
0094 900000      R     MOV     DPTR,#X_Axis
0097 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 702
0098 E0                MOVX    A,@DPTR
0099 D3                SETB    C
009A 94E8              SUBB    A,#0E8H
009C 5019              JNC     ?C0161
009E E0                MOVX    A,@DPTR
009F C3                CLR     C
00A0 9480              SUBB    A,#080H
00A2 4013              JC      ?C0161
                                           ; SOURCE LINE # 703
                                           ; SOURCE LINE # 704
00A4 900000      E     MOV     DPTR,#Optical_Axis_Data
00A7 E0                MOVX    A,@DPTR
00A8 FF                MOV     R7,A
00A9 74E8              MOV     A,#0E8H
00AB 9F                SUBB    A,R7
00AC 900000      R     MOV     DPTR,#X_Axis
00AF F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 705
00B0 E0                MOVX    A,@DPTR
00B1 900000      R     MOV     DPTR,#Calibration_Data
00B4 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 706
00B5 8009              SJMP    ?C0162
00B7         ?C0161:
                                           ; SOURCE LINE # 708
                                           ; SOURCE LINE # 709
00B7 900000      E     MOV     DPTR,#Optical_Axis_Data+06H
00BA E0                MOVX    A,@DPTR
00BB 14                DEC     A
00BC 900000      R     MOV     DPTR,#Calibration_Data
00BF F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 710
00C0         ?C0162:
                                           ; SOURCE LINE # 711
00C0 900000      E     MOV     DPTR,#Optical_Axis_Data+07H
00C3 E0                MOVX    A,@DPTR
00C4 900000      R     MOV     DPTR,#Calibration_Data+01H
00C7 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 713
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 479 

00C8 020000      R     LJMP    ?C0156
                                           ; SOURCE LINE # 715
00CB         ?C0163:
                                           ; SOURCE LINE # 716
00CB 900000      E     MOV     DPTR,#Optical_Axis_Data+06H
00CE E0                MOVX    A,@DPTR
00CF FF                MOV     R7,A
00D0 900000      E     MOV     DPTR,#Optical_Axis_Data
00D3 E0                MOVX    A,@DPTR
00D4 2F                ADD     A,R7
00D5 900000      R     MOV     DPTR,#X_Axis
00D8 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 718
00D9 E0                MOVX    A,@DPTR
00DA C3                CLR     C
00DB 9418              SUBB    A,#018H
00DD 4019              JC      ?C0164
00DF E0                MOVX    A,@DPTR
00E0 9480              SUBB    A,#080H
00E2 5014              JNC     ?C0164
                                           ; SOURCE LINE # 719
                                           ; SOURCE LINE # 720
00E4 900000      E     MOV     DPTR,#Optical_Axis_Data
00E7 E0                MOVX    A,@DPTR
00E8 FF                MOV     R7,A
00E9 C3                CLR     C
00EA 7418              MOV     A,#018H
00EC 9F                SUBB    A,R7
00ED 900000      R     MOV     DPTR,#X_Axis
00F0 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 721
00F1 E0                MOVX    A,@DPTR
00F2 900000      R     MOV     DPTR,#Calibration_Data
00F5 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 722
00F6 8009              SJMP    ?C0165
00F8         ?C0164:
                                           ; SOURCE LINE # 724
                                           ; SOURCE LINE # 725
00F8 900000      E     MOV     DPTR,#Optical_Axis_Data+06H
00FB E0                MOVX    A,@DPTR
00FC 04                INC     A
00FD 900000      R     MOV     DPTR,#Calibration_Data
0100 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 726
0101         ?C0165:
                                           ; SOURCE LINE # 727
0101 900000      E     MOV     DPTR,#Optical_Axis_Data+07H
0104 E0                MOVX    A,@DPTR
0105 900000      R     MOV     DPTR,#Calibration_Data+01H
0108 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 729
0109 807E              SJMP    ?C0156
                                           ; SOURCE LINE # 731
010B         ?C0166:
                                           ; SOURCE LINE # 732
010B 900000      E     MOV     DPTR,#Optical_Axis_Data+07H
010E E0                MOVX    A,@DPTR
010F FF                MOV     R7,A
0110 900000      E     MOV     DPTR,#Optical_Axis_Data+01H
0113 E0                MOVX    A,@DPTR
0114 2F                ADD     A,R7
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 480 

0115 900000      R     MOV     DPTR,#Y_Axis
0118 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 734
0119 E0                MOVX    A,@DPTR
011A C3                CLR     C
011B 9420              SUBB    A,#020H
011D 4019              JC      ?C0167
011F E0                MOVX    A,@DPTR
0120 9480              SUBB    A,#080H
0122 5014              JNC     ?C0167
                                           ; SOURCE LINE # 735
                                           ; SOURCE LINE # 736
0124 900000      E     MOV     DPTR,#Optical_Axis_Data+01H
0127 E0                MOVX    A,@DPTR
0128 FF                MOV     R7,A
0129 C3                CLR     C
012A 7420              MOV     A,#020H
012C 9F                SUBB    A,R7
012D 900000      R     MOV     DPTR,#Y_Axis
0130 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 737
0131 E0                MOVX    A,@DPTR
0132 900000      R     MOV     DPTR,#Calibration_Data+01H
0135 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 738
0136 8009              SJMP    ?C0168
0138         ?C0167:
                                           ; SOURCE LINE # 740
                                           ; SOURCE LINE # 741
0138 900000      E     MOV     DPTR,#Optical_Axis_Data+07H
013B E0                MOVX    A,@DPTR
013C 04                INC     A
013D 900000      R     MOV     DPTR,#Calibration_Data+01H
0140 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 742
0141         ?C0168:
                                           ; SOURCE LINE # 743
0141 900000      E     MOV     DPTR,#Optical_Axis_Data+06H
0144 E0                MOVX    A,@DPTR
0145 900000      R     MOV     DPTR,#Calibration_Data
0148 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 745
0149 803E              SJMP    ?C0156
                                           ; SOURCE LINE # 747
014B         ?C0169:
                                           ; SOURCE LINE # 748
014B 900000      E     MOV     DPTR,#Optical_Axis_Data+07H
014E E0                MOVX    A,@DPTR
014F FF                MOV     R7,A
0150 900000      E     MOV     DPTR,#Optical_Axis_Data+01H
0153 E0                MOVX    A,@DPTR
0154 2F                ADD     A,R7
0155 900000      R     MOV     DPTR,#Y_Axis
0158 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 750
0159 E0                MOVX    A,@DPTR
015A D3                SETB    C
015B 94E0              SUBB    A,#0E0H
015D 5019              JNC     ?C0170
015F E0                MOVX    A,@DPTR
0160 C3                CLR     C
0161 9480              SUBB    A,#080H
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 481 

0163 4013              JC      ?C0170
                                           ; SOURCE LINE # 751
                                           ; SOURCE LINE # 752
0165 900000      E     MOV     DPTR,#Optical_Axis_Data+01H
0168 E0                MOVX    A,@DPTR
0169 FF                MOV     R7,A
016A 74E0              MOV     A,#0E0H
016C 9F                SUBB    A,R7
016D 900000      R     MOV     DPTR,#Y_Axis
0170 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 753
0171 E0                MOVX    A,@DPTR
0172 900000      R     MOV     DPTR,#Calibration_Data+01H
0175 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 754
0176 8009              SJMP    ?C0171
0178         ?C0170:
                                           ; SOURCE LINE # 756
                                           ; SOURCE LINE # 757
0178 900000      E     MOV     DPTR,#Optical_Axis_Data+07H
017B E0                MOVX    A,@DPTR
017C 14                DEC     A
017D 900000      R     MOV     DPTR,#Calibration_Data+01H
0180 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 758
0181         ?C0171:
                                           ; SOURCE LINE # 759
0181 900000      E     MOV     DPTR,#Optical_Axis_Data+06H
0184 E0                MOVX    A,@DPTR
0185 900000      R     MOV     DPTR,#Calibration_Data
0188 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 761
                                           ; SOURCE LINE # 763
                                           ; SOURCE LINE # 765
                                           ; SOURCE LINE # 766
0189         ?C0156:
                                           ; SOURCE LINE # 768
0189 900000      R     MOV     DPTR,#Ctrl_Para
018C E0                MOVX    A,@DPTR
018D FF                MOV     R7,A
018E C3                CLR     C
018F 9402              SUBB    A,#02H
0191 4064              JC      ?C0179
0193 EF                MOV     A,R7
0194 D3                SETB    C
0195 9406              SUBB    A,#06H
0197 505E              JNC     ?C0179
                                           ; SOURCE LINE # 769
                                           ; SOURCE LINE # 770
0199 E4                CLR     A
019A A3                INC     DPTR
019B F0                MOVX    @DPTR,A
019C         ?C0174:
019C 900000      R     MOV     DPTR,#i
019F E0                MOVX    A,@DPTR
01A0 C3                CLR     C
01A1 9402              SUBB    A,#02H
01A3 5020              JNC     ?C0175
                                           ; SOURCE LINE # 771
                                           ; SOURCE LINE # 772
01A5 A3                INC     DPTR
01A6 E0                MOVX    A,@DPTR
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 482 

01A7 FF                MOV     R7,A
01A8 900000      R     MOV     DPTR,#i
01AB E0                MOVX    A,@DPTR
01AC 2400        R     ADD     A,#LOW Calibration_Data
01AE F582              MOV     DPL,A
01B0 E4                CLR     A
01B1 3400        R     ADDC    A,#HIGH Calibration_Data
01B3 F583              MOV     DPH,A
01B5 E0                MOVX    A,@DPTR
01B6 FE                MOV     R6,A
01B7 EF                MOV     A,R7
01B8 6E                XRL     A,R6
01B9 900000      R     MOV     DPTR,#Cs
01BC F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 773
01BD 900000      R     MOV     DPTR,#i
01C0 E0                MOVX    A,@DPTR
01C1 04                INC     A
01C2 F0                MOVX    @DPTR,A
01C3 80D7              SJMP    ?C0174
01C5         ?C0175:
                                           ; SOURCE LINE # 774
01C5 900000      R     MOV     DPTR,#Cs
01C8 E0                MOVX    A,@DPTR
01C9 900000      R     MOV     DPTR,#Calibration_Data+02H
01CC F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 776
01CD 7A00        E     MOV     R2,#HIGH Optical_Axis_Data+06H
01CF 7900        E     MOV     R1,#LOW Optical_Axis_Data+06H
01D1 7800        E     MOV     R0,#LOW Optical_Axis_Data+06H
01D3 7C00        E     MOV     R4,#HIGH Optical_Axis_Data+06H
01D5 7D01              MOV     R5,#01H
01D7 7B01              MOV     R3,#01H
01D9 7A00        R     MOV     R2,#HIGH Calibration_Data
01DB 7900        R     MOV     R1,#LOW Calibration_Data
01DD 7E00              MOV     R6,#00H
01DF 7F03              MOV     R7,#03H
01E1 120000      E     LCALL   ?C?COPY
                                           ; SOURCE LINE # 778
01E4 900000      R     MOV     DPTR,#OpticOffset_Set
01E7 7401              MOV     A,#01H
01E9 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 779
                                           ; SOURCE LINE # 780
01EA 22                RET     
01EB         ?C0155:
                                           ; SOURCE LINE # 782
                                           ; SOURCE LINE # 783
01EB 900000      R     MOV     DPTR,#Ctrl_Para
01EE E0                MOVX    A,@DPTR
01EF 7006              JNZ     ?C0179
                                           ; SOURCE LINE # 784
                                           ; SOURCE LINE # 785
01F1 120000      R     LCALL   Diag_Calibration_Mode_start
                                           ; SOURCE LINE # 786
01F4 120000      R     LCALL   Diag_DTC_Set_Off
                                           ; SOURCE LINE # 787
                                           ; SOURCE LINE # 788
                                           ; SOURCE LINE # 789
01F7         ?C0179:
01F7 22                RET     
             ; FUNCTION _Diag_Calibration_Mode (END)
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 483 


             ; FUNCTION Diag_Exit_Update (BEGIN)
                                           ; SOURCE LINE # 791
                                           ; SOURCE LINE # 792
                                           ; SOURCE LINE # 794
0000 22                RET     
             ; FUNCTION Diag_Exit_Update (END)

             ; FUNCTION Diag_DTC_Set_On (BEGIN)
                                           ; SOURCE LINE # 796
                                           ; SOURCE LINE # 797
                                           ; SOURCE LINE # 798
0000 E4                CLR     A
0001 900000      R     MOV     DPTR,#DTC_Set_Off
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 799
0005 22                RET     
             ; FUNCTION Diag_DTC_Set_On (END)

             ; FUNCTION Diag_DTC_Set_Off (BEGIN)
                                           ; SOURCE LINE # 801
                                           ; SOURCE LINE # 802
                                           ; SOURCE LINE # 803
0000 900000      R     MOV     DPTR,#DTC_Set_Off
0003 7401              MOV     A,#01H
0005 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 804
0006 22                RET     
             ; FUNCTION Diag_DTC_Set_Off (END)

             ; FUNCTION Flash_DTC_Write (BEGIN)
                                           ; SOURCE LINE # 806
                                           ; SOURCE LINE # 807
                                           ; SOURCE LINE # 808
0000 E4                CLR     A
0001 900000      R     MOV     DPTR,#Cs
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 809
0005 7A00        R     MOV     R2,#HIGH Write_Buf
0007 7900        R     MOV     R1,#LOW Write_Buf
0009 7800        R     MOV     R0,#LOW Write_Buf
000B 7C00        R     MOV     R4,#HIGH Write_Buf
000D 7D01              MOV     R5,#01H
000F 7BFF              MOV     R3,#0FFH
0011 7A00        R     MOV     R2,#HIGH _?ix1003
0013 7900        R     MOV     R1,#LOW _?ix1003
0015 FE                MOV     R6,A
0016 7F1A              MOV     R7,#01AH
0018 120000      E     LCALL   ?C?COPY
                                           ; SOURCE LINE # 810
001B 7A00        R     MOV     R2,#HIGH Read_Buf
001D 7900        R     MOV     R1,#LOW Read_Buf
001F 7800        R     MOV     R0,#LOW Read_Buf
0021 7C00        R     MOV     R4,#HIGH Read_Buf
0023 7D01              MOV     R5,#01H
0025 7BFF              MOV     R3,#0FFH
0027 7A00        R     MOV     R2,#HIGH _?ix1004
0029 7900        R     MOV     R1,#LOW _?ix1004
002B 7E00              MOV     R6,#00H
002D 7F1A              MOV     R7,#01AH
002F 120000      E     LCALL   ?C?COPY
                                           ; SOURCE LINE # 811
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 484 

0032 E4                CLR     A
0033 900000      R     MOV     DPTR,#Write_Address
0036 F0                MOVX    @DPTR,A
0037 A3                INC     DPTR
0038 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 812
0039 A3                INC     DPTR
003A F0                MOVX    @DPTR,A
003B A3                INC     DPTR
003C F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 813
003D A3                INC     DPTR
003E F0                MOVX    @DPTR,A
003F A3                INC     DPTR
0040 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 814
0041 A3                INC     DPTR
0042 F0                MOVX    @DPTR,A
0043 A3                INC     DPTR
0044 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 816
0045 FE                MOV     R6,A
0046 7F1A              MOV     R7,#01AH
0048 FD                MOV     R5,A
0049 7B01              MOV     R3,#01H
004B 7A00        R     MOV     R2,#HIGH Write_Buf
004D 7900        R     MOV     R1,#LOW Write_Buf
004F 120000      E     LCALL   ?C?MEMSET
                                           ; SOURCE LINE # 817
0052 7E00              MOV     R6,#00H
0054 7F1A              MOV     R7,#01AH
0056 7D00              MOV     R5,#00H
0058 7B01              MOV     R3,#01H
005A 7A00        R     MOV     R2,#HIGH Read_Buf
005C 7900        R     MOV     R1,#LOW Read_Buf
005E 120000      E     LCALL   ?C?MEMSET
                                           ; SOURCE LINE # 819
0061 7A00        R     MOV     R2,#HIGH Write_Buf
0063 7900        R     MOV     R1,#LOW Write_Buf
0065 7800        R     MOV     R0,#LOW Write_Buf
0067 7C00        R     MOV     R4,#HIGH Write_Buf
0069 7D01              MOV     R5,#01H
006B 7B01              MOV     R3,#01H
006D 7A00        R     MOV     R2,#HIGH ga_Ext_tDTC_Type_Msg
006F 7900        R     MOV     R1,#LOW ga_Ext_tDTC_Type_Msg
0071 7E00              MOV     R6,#00H
0073 7F19              MOV     R7,#019H
0075 120000      E     LCALL   ?C?COPY
                                           ; SOURCE LINE # 821
0078 E4                CLR     A
0079 900000      R     MOV     DPTR,#i
007C F0                MOVX    @DPTR,A
007D         ?C0183:
007D 900000      R     MOV     DPTR,#i
0080 E0                MOVX    A,@DPTR
0081 C3                CLR     C
0082 9419              SUBB    A,#019H
0084 5020              JNC     ?C0184
                                           ; SOURCE LINE # 822
                                           ; SOURCE LINE # 823
0086 A3                INC     DPTR
0087 E0                MOVX    A,@DPTR
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 485 

0088 FF                MOV     R7,A
0089 900000      R     MOV     DPTR,#i
008C E0                MOVX    A,@DPTR
008D 2400        R     ADD     A,#LOW Write_Buf
008F F582              MOV     DPL,A
0091 E4                CLR     A
0092 3400        R     ADDC    A,#HIGH Write_Buf
0094 F583              MOV     DPH,A
0096 E0                MOVX    A,@DPTR
0097 FE                MOV     R6,A
0098 EF                MOV     A,R7
0099 6E                XRL     A,R6
009A 900000      R     MOV     DPTR,#Cs
009D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 824
009E 900000      R     MOV     DPTR,#i
00A1 E0                MOVX    A,@DPTR
00A2 04                INC     A
00A3 F0                MOVX    @DPTR,A
00A4 80D7              SJMP    ?C0183
00A6         ?C0184:
                                           ; SOURCE LINE # 825
00A6 900000      R     MOV     DPTR,#Cs
00A9 E0                MOVX    A,@DPTR
00AA 900000      R     MOV     DPTR,#Write_Buf+019H
00AD F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 827
00AE 7B01              MOV     R3,#01H
00B0 7A00        R     MOV     R2,#HIGH Read_Buf
00B2 7900        R     MOV     R1,#LOW Read_Buf
00B4 900000      E     MOV     DPTR,#?_FLASH_Read_Buf?BYTE+05H
00B7 E4                CLR     A
00B8 F0                MOVX    @DPTR,A
00B9 A3                INC     DPTR
00BA 04                INC     A
00BB F0                MOVX    @DPTR,A
00BC A3                INC     DPTR
00BD 7420              MOV     A,#020H
00BF F0                MOVX    @DPTR,A
00C0 7D00              MOV     R5,#00H
00C2 7CFF              MOV     R4,#0FFH
00C4 120000      E     LCALL   _FLASH_Read_Buf
                                           ; SOURCE LINE # 828
00C7 7D20              MOV     R5,#020H
00C9 7F00              MOV     R7,#00H
00CB 7EFF              MOV     R6,#0FFH
00CD 120000      E     LCALL   _FLASH_Erase_Buf
                                           ; SOURCE LINE # 830
00D0 900000      R     MOV     DPTR,#Read_Buf
00D3 E0                MOVX    A,@DPTR
00D4 B4FF02            CJNE    A,#0FFH,?C0186
                                           ; SOURCE LINE # 831
                                           ; SOURCE LINE # 832
00D7 E4                CLR     A
00D8 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 833
00D9         ?C0186:
                                           ; SOURCE LINE # 835
00D9 900000      R     MOV     DPTR,#Read_Buf
00DC E0                MOVX    A,@DPTR
00DD FF                MOV     R7,A
00DE 7E00              MOV     R6,#00H
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 486 

00E0 7C00              MOV     R4,#00H
00E2 7D19              MOV     R5,#019H
00E4 120000      E     LCALL   ?C?IMUL
00E7 900000      R     MOV     DPTR,#temp_Address1
00EA EE                MOV     A,R6
00EB F0                MOVX    @DPTR,A
00EC A3                INC     DPTR
00ED EF                MOV     A,R7
00EE F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 836
00EF E0                MOVX    A,@DPTR
00F0 2401              ADD     A,#01H
00F2 FF                MOV     R7,A
00F3 900000      R     MOV     DPTR,#temp_Address1
00F6 E0                MOVX    A,@DPTR
00F7 3400              ADDC    A,#00H
00F9 FE                MOV     R6,A
00FA 900000      R     MOV     DPTR,#temp_Address2
00FD F0                MOVX    @DPTR,A
00FE A3                INC     DPTR
00FF EF                MOV     A,R7
0100 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 837
0101 2400              ADD     A,#00H
0103 FF                MOV     R7,A
0104 EE                MOV     A,R6
0105 34FF              ADDC    A,#0FFH
0107 FE                MOV     R6,A
0108 900000      R     MOV     DPTR,#Write_Address
010B F0                MOVX    @DPTR,A
010C A3                INC     DPTR
010D EF                MOV     A,R7
010E F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 838
010F A3                INC     DPTR
0110 EE                MOV     A,R6
0111 F0                MOVX    @DPTR,A
0112 A3                INC     DPTR
0113 EF                MOV     A,R7
0114 F0                MOVX    @DPTR,A
0115         ?C0187:
                                           ; SOURCE LINE # 840
                                           ; SOURCE LINE # 841
                                           ; SOURCE LINE # 842
0115 900000      R     MOV     DPTR,#Write_Address
0118 E0                MOVX    A,@DPTR
0119 FE                MOV     R6,A
011A A3                INC     DPTR
011B E0                MOVX    A,@DPTR
011C FF                MOV     R7,A
011D 7B01              MOV     R3,#01H
011F 7A00        R     MOV     R2,#HIGH Write_Buf
0121 7900        R     MOV     R1,#LOW Write_Buf
0123 900000      E     MOV     DPTR,#?_FLASH_Write_Buf?BYTE+05H
0126 E4                CLR     A
0127 F0                MOVX    @DPTR,A
0128 A3                INC     DPTR
0129 741A              MOV     A,#01AH
012B F0                MOVX    @DPTR,A
012C A3                INC     DPTR
012D 7420              MOV     A,#020H
012F F0                MOVX    @DPTR,A
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 487 

0130 120000      E     LCALL   _FLASH_Write_Buf
                                           ; SOURCE LINE # 843
0133 7B01              MOV     R3,#01H
0135 7A00        R     MOV     R2,#HIGH Read_Buf
0137 7900        R     MOV     R1,#LOW Read_Buf
0139 900000      R     MOV     DPTR,#Read_Address
013C E0                MOVX    A,@DPTR
013D FC                MOV     R4,A
013E A3                INC     DPTR
013F E0                MOVX    A,@DPTR
0140 FD                MOV     R5,A
0141 900000      E     MOV     DPTR,#?_FLASH_Read_Buf?BYTE+05H
0144 E4                CLR     A
0145 F0                MOVX    @DPTR,A
0146 A3                INC     DPTR
0147 741A              MOV     A,#01AH
0149 F0                MOVX    @DPTR,A
014A A3                INC     DPTR
014B 7420              MOV     A,#020H
014D F0                MOVX    @DPTR,A
014E 120000      E     LCALL   _FLASH_Read_Buf
                                           ; SOURCE LINE # 845
0151 7A00        R     MOV     R2,#HIGH Read_Buf
0153 7900        R     MOV     R1,#LOW Read_Buf
0155 7800        R     MOV     R0,#LOW Read_Buf
0157 7C00        R     MOV     R4,#HIGH Read_Buf
0159 7D01              MOV     R5,#01H
015B 7B01              MOV     R3,#01H
015D 7A00        R     MOV     R2,#HIGH Write_Buf
015F 7900        R     MOV     R1,#LOW Write_Buf
0161 7E00              MOV     R6,#00H
0163 7F1A              MOV     R7,#01AH
0165 120000      E     LCALL   ?C?MEMCMP
0168 900000      R     MOV     DPTR,#ret
016B EF                MOV     A,R7
016C F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 846
016D E0                MOVX    A,@DPTR
016E 6045              JZ      ?C0192
                                           ; SOURCE LINE # 847
                                           ; SOURCE LINE # 848
0170 900000      R     MOV     DPTR,#temp_Address1
0173 E4                CLR     A
0174 F0                MOVX    @DPTR,A
0175 A3                INC     DPTR
0176 741A              MOV     A,#01AH
0178 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 849
0179 900000      R     MOV     DPTR,#Write_Address+01H
017C E0                MOVX    A,@DPTR
017D 241A              ADD     A,#01AH
017F F0                MOVX    @DPTR,A
0180 900000      R     MOV     DPTR,#Write_Address
0183 E0                MOVX    A,@DPTR
0184 3400              ADDC    A,#00H
0186 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 850
0187 E0                MOVX    A,@DPTR
0188 FE                MOV     R6,A
0189 A3                INC     DPTR
018A E0                MOVX    A,@DPTR
018B FF                MOV     R7,A
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 488 

018C A3                INC     DPTR
018D EE                MOV     A,R6
018E F0                MOVX    @DPTR,A
018F A3                INC     DPTR
0190 EF                MOV     A,R7
0191 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 852
0192 C3                CLR     C
0193 94EC              SUBB    A,#0ECH
0195 EE                MOV     A,R6
0196 94FF              SUBB    A,#0FFH
0198 5003              JNC     $ + 5H
019A 020000      R     LJMP    ?C0187
                                           ; SOURCE LINE # 853
                                           ; SOURCE LINE # 854
019D 900000      R     MOV     DPTR,#Write_Address
01A0 74FF              MOV     A,#0FFH
01A2 F0                MOVX    @DPTR,A
01A3 A3                INC     DPTR
01A4 7401              MOV     A,#01H
01A6 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 855
01A7 A3                INC     DPTR
01A8 74FF              MOV     A,#0FFH
01AA F0                MOVX    @DPTR,A
01AB A3                INC     DPTR
01AC 7401              MOV     A,#01H
01AE F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 856
                                           ; SOURCE LINE # 857
01AF 020000      R     LJMP    ?C0187
                                           ; SOURCE LINE # 859
                                           ; SOURCE LINE # 860
                                           ; SOURCE LINE # 861
                                           ; SOURCE LINE # 862
01B2 020000      R     LJMP    ?C0187
                                           ; SOURCE LINE # 863
01B5         ?C0192:
01B5 22                RET     
             ; FUNCTION Flash_DTC_Write (END)

             ; FUNCTION Flash_DTC_Read (BEGIN)
                                           ; SOURCE LINE # 870
                                           ; SOURCE LINE # 871
                                           ; SOURCE LINE # 872
0000 E4                CLR     A
0001 900000      R     MOV     DPTR,#Cs
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 875
0005 7A00        R     MOV     R2,#HIGH Read_Buf
0007 7900        R     MOV     R1,#LOW Read_Buf
0009 7800        R     MOV     R0,#LOW Read_Buf
000B 7C00        R     MOV     R4,#HIGH Read_Buf
000D 7D01              MOV     R5,#01H
000F 7BFF              MOV     R3,#0FFH
0011 7A00        R     MOV     R2,#HIGH _?ix1005
0013 7900        R     MOV     R1,#LOW _?ix1005
0015 FE                MOV     R6,A
0016 7F1A              MOV     R7,#01AH
0018 120000      E     LCALL   ?C?COPY
                                           ; SOURCE LINE # 878
001B E4                CLR     A
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 489 

001C 900000      R     MOV     DPTR,#Read_Address
001F F0                MOVX    @DPTR,A
0020 A3                INC     DPTR
0021 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 879
0022 900000      R     MOV     DPTR,#temp_Address1
0025 F0                MOVX    @DPTR,A
0026 A3                INC     DPTR
0027 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 880
0028 A3                INC     DPTR
0029 F0                MOVX    @DPTR,A
002A A3                INC     DPTR
002B F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 883
002C FE                MOV     R6,A
002D 7F1A              MOV     R7,#01AH
002F FD                MOV     R5,A
0030 7B01              MOV     R3,#01H
0032 7A00        R     MOV     R2,#HIGH Read_Buf
0034 7900        R     MOV     R1,#LOW Read_Buf
0036 120000      E     LCALL   ?C?MEMSET
                                           ; SOURCE LINE # 887
0039 7B01              MOV     R3,#01H
003B 7A00        R     MOV     R2,#HIGH Read_Buf
003D 7900        R     MOV     R1,#LOW Read_Buf
003F 900000      E     MOV     DPTR,#?_FLASH_Read_Buf?BYTE+05H
0042 E4                CLR     A
0043 F0                MOVX    @DPTR,A
0044 A3                INC     DPTR
0045 04                INC     A
0046 F0                MOVX    @DPTR,A
0047 A3                INC     DPTR
0048 7420              MOV     A,#020H
004A F0                MOVX    @DPTR,A
004B 7D00              MOV     R5,#00H
004D 7CFF              MOV     R4,#0FFH
004F 120000      E     LCALL   _FLASH_Read_Buf
                                           ; SOURCE LINE # 890
0052 900000      R     MOV     DPTR,#Read_Buf
0055 E0                MOVX    A,@DPTR
0056 B4FF02            CJNE    A,#0FFH,?C0193
                                           ; SOURCE LINE # 891
                                           ; SOURCE LINE # 892
0059 E4                CLR     A
005A F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 893
005B         ?C0193:
                                           ; SOURCE LINE # 897
005B 900000      R     MOV     DPTR,#Read_Buf
005E E0                MOVX    A,@DPTR
005F FF                MOV     R7,A
0060 7E00              MOV     R6,#00H
0062 7C00              MOV     R4,#00H
0064 7D19              MOV     R5,#019H
0066 120000      E     LCALL   ?C?IMUL
0069 900000      R     MOV     DPTR,#temp_Address1
006C EE                MOV     A,R6
006D F0                MOVX    @DPTR,A
006E A3                INC     DPTR
006F EF                MOV     A,R7
0070 F0                MOVX    @DPTR,A
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 490 

                                           ; SOURCE LINE # 898
0071 E0                MOVX    A,@DPTR
0072 2401              ADD     A,#01H
0074 FF                MOV     R7,A
0075 900000      R     MOV     DPTR,#temp_Address1
0078 E0                MOVX    A,@DPTR
0079 3400              ADDC    A,#00H
007B FE                MOV     R6,A
007C 900000      R     MOV     DPTR,#temp_Address2
007F F0                MOVX    @DPTR,A
0080 A3                INC     DPTR
0081 EF                MOV     A,R7
0082 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 900
0083 2400              ADD     A,#00H
0085 FF                MOV     R7,A
0086 EE                MOV     A,R6
0087 34FF              ADDC    A,#0FFH
0089 900000      R     MOV     DPTR,#Read_Address
008C F0                MOVX    @DPTR,A
008D A3                INC     DPTR
008E EF                MOV     A,R7
008F F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 903
0090 7B01              MOV     R3,#01H
0092 7A00        R     MOV     R2,#HIGH Read_Buf
0094 7900        R     MOV     R1,#LOW Read_Buf
0096 900000      R     MOV     DPTR,#Read_Address
0099 E0                MOVX    A,@DPTR
009A FC                MOV     R4,A
009B A3                INC     DPTR
009C E0                MOVX    A,@DPTR
009D FD                MOV     R5,A
009E 900000      E     MOV     DPTR,#?_FLASH_Read_Buf?BYTE+05H
00A1 E4                CLR     A
00A2 F0                MOVX    @DPTR,A
00A3 A3                INC     DPTR
00A4 741A              MOV     A,#01AH
00A6 F0                MOVX    @DPTR,A
00A7 A3                INC     DPTR
00A8 7420              MOV     A,#020H
00AA F0                MOVX    @DPTR,A
00AB 120000      E     LCALL   _FLASH_Read_Buf
                                           ; SOURCE LINE # 906
00AE E4                CLR     A
00AF 900000      R     MOV     DPTR,#i
00B2 F0                MOVX    @DPTR,A
00B3         ?C0194:
00B3 900000      R     MOV     DPTR,#i
00B6 E0                MOVX    A,@DPTR
00B7 C3                CLR     C
00B8 9419              SUBB    A,#019H
00BA 5020              JNC     ?C0195
                                           ; SOURCE LINE # 907
                                           ; SOURCE LINE # 908
00BC A3                INC     DPTR
00BD E0                MOVX    A,@DPTR
00BE FF                MOV     R7,A
00BF 900000      R     MOV     DPTR,#i
00C2 E0                MOVX    A,@DPTR
00C3 2400        R     ADD     A,#LOW Read_Buf
00C5 F582              MOV     DPL,A
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 491 

00C7 E4                CLR     A
00C8 3400        R     ADDC    A,#HIGH Read_Buf
00CA F583              MOV     DPH,A
00CC E0                MOVX    A,@DPTR
00CD FE                MOV     R6,A
00CE EF                MOV     A,R7
00CF 6E                XRL     A,R6
00D0 900000      R     MOV     DPTR,#Cs
00D3 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 909
00D4 900000      R     MOV     DPTR,#i
00D7 E0                MOVX    A,@DPTR
00D8 04                INC     A
00D9 F0                MOVX    @DPTR,A
00DA 80D7              SJMP    ?C0194
00DC         ?C0195:
                                           ; SOURCE LINE # 912
00DC 900000      R     MOV     DPTR,#Read_Buf+019H
00DF E0                MOVX    A,@DPTR
00E0 FF                MOV     R7,A
00E1 900000      R     MOV     DPTR,#Cs
00E4 E0                MOVX    A,@DPTR
00E5 6F                XRL     A,R7
00E6 7012              JNZ     ?C0198
                                           ; SOURCE LINE # 913
                                           ; SOURCE LINE # 915
00E8 7800        R     MOV     R0,#LOW ga_Ext_tDTC_Type_Msg
00EA 7C00        R     MOV     R4,#HIGH ga_Ext_tDTC_Type_Msg
00EC 7D01              MOV     R5,#01H
00EE 7B01              MOV     R3,#01H
00F0 7A00        R     MOV     R2,#HIGH Read_Buf
00F2 7900        R     MOV     R1,#LOW Read_Buf
00F4 FE                MOV     R6,A
00F5 7F19              MOV     R7,#019H
00F7 120000      E     LCALL   ?C?COPY
                                           ; SOURCE LINE # 916
                                           ; SOURCE LINE # 917
00FA         ?C0198:
00FA 22                RET     
             ; FUNCTION Flash_DTC_Read (END)

             ; FUNCTION _Diag_Write_Sys (BEGIN)
                                           ; SOURCE LINE # 918
0000 900000      R     MOV     DPTR,#Write_Buf
0003 EB                MOV     A,R3
0004 F0                MOVX    @DPTR,A
0005 A3                INC     DPTR
0006 EA                MOV     A,R2
0007 F0                MOVX    @DPTR,A
0008 A3                INC     DPTR
0009 E9                MOV     A,R1
000A F0                MOVX    @DPTR,A
000B A3                INC     DPTR
000C ED                MOV     A,R5
000D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 919
                                           ; SOURCE LINE # 921
000E 7A00        R     MOV     R2,#HIGH Buf
0010 7900        R     MOV     R1,#LOW Buf
0012 7800        R     MOV     R0,#LOW Buf
0014 7C00        R     MOV     R4,#HIGH Buf
0016 7D01              MOV     R5,#01H
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 492 

0018 7BFF              MOV     R3,#0FFH
001A 7A00        R     MOV     R2,#HIGH _?ix1006
001C 7900        R     MOV     R1,#LOW _?ix1006
001E 7E00              MOV     R6,#00H
0020 7F27              MOV     R7,#027H
0022 120000      E     LCALL   ?C?COPY
                                           ; SOURCE LINE # 923
0025 900000      R     MOV     DPTR,#Length
0028 E0                MOVX    A,@DPTR
0029 900000      R     MOV     DPTR,#len
002C F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 924
002D 900000      R     MOV     DPTR,#Cs_size
0030 7426              MOV     A,#026H
0032 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 925
0033 7D20              MOV     R5,#020H
0035 7F00              MOV     R7,#00H
0037 7EFC              MOV     R6,#0FCH
0039 120000      E     LCALL   _FLASH_Erase_Buf
                                           ; SOURCE LINE # 926
003C 7E00              MOV     R6,#00H
003E 7F27              MOV     R7,#027H
0040 7D00              MOV     R5,#00H
0042 7B01              MOV     R3,#01H
0044 7A00        R     MOV     R2,#HIGH Buf
0046 7900        R     MOV     R1,#LOW Buf
0048 120000      E     LCALL   ?C?MEMSET
                                           ; SOURCE LINE # 927
004B 7A00        R     MOV     R2,#HIGH Buf
004D 7900        R     MOV     R1,#LOW Buf
004F 7800        R     MOV     R0,#LOW Buf
0051 7C00        R     MOV     R4,#HIGH Buf
0053 7D01              MOV     R5,#01H
0055 900000      R     MOV     DPTR,#Write_Buf
0058 E0                MOVX    A,@DPTR
0059 FB                MOV     R3,A
005A A3                INC     DPTR
005B E0                MOVX    A,@DPTR
005C FA                MOV     R2,A
005D A3                INC     DPTR
005E E0                MOVX    A,@DPTR
005F F9                MOV     R1,A
0060 7E00              MOV     R6,#00H
0062 7F27              MOV     R7,#027H
0064 120000      E     LCALL   ?C?COPY
                                           ; SOURCE LINE # 929
0067 E4                CLR     A
0068 900000      R     MOV     DPTR,#i
006B F0                MOVX    @DPTR,A
006C         ?C0199:
006C 900000      R     MOV     DPTR,#Cs_size
006F E0                MOVX    A,@DPTR
0070 FF                MOV     R7,A
0071 900000      R     MOV     DPTR,#i
0074 E0                MOVX    A,@DPTR
0075 C3                CLR     C
0076 9F                SUBB    A,R7
0077 5020              JNC     ?C0200
                                           ; SOURCE LINE # 930
                                           ; SOURCE LINE # 931
0079 A3                INC     DPTR
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 493 

007A E0                MOVX    A,@DPTR
007B FF                MOV     R7,A
007C 900000      R     MOV     DPTR,#i
007F E0                MOVX    A,@DPTR
0080 2400        R     ADD     A,#LOW Buf
0082 F582              MOV     DPL,A
0084 E4                CLR     A
0085 3400        R     ADDC    A,#HIGH Buf
0087 F583              MOV     DPH,A
0089 E0                MOVX    A,@DPTR
008A FE                MOV     R6,A
008B EF                MOV     A,R7
008C 6E                XRL     A,R6
008D 900000      R     MOV     DPTR,#Cs
0090 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 932
0091 900000      R     MOV     DPTR,#i
0094 E0                MOVX    A,@DPTR
0095 04                INC     A
0096 F0                MOVX    @DPTR,A
0097 80D3              SJMP    ?C0199
0099         ?C0200:
                                           ; SOURCE LINE # 933
0099 900000      R     MOV     DPTR,#Cs
009C E0                MOVX    A,@DPTR
009D FF                MOV     R7,A
009E A3                INC     DPTR
009F E0                MOVX    A,@DPTR
00A0 2400        R     ADD     A,#LOW Buf
00A2 F582              MOV     DPL,A
00A4 E4                CLR     A
00A5 3400        R     ADDC    A,#HIGH Buf
00A7 F583              MOV     DPH,A
00A9 EF                MOV     A,R7
00AA F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 934
00AB 7B01              MOV     R3,#01H
00AD 7A00        R     MOV     R2,#HIGH Buf
00AF 7900        R     MOV     R1,#LOW Buf
00B1 900000      E     MOV     DPTR,#?_FLASH_Write_Buf?BYTE+05H
00B4 E4                CLR     A
00B5 F0                MOVX    @DPTR,A
00B6 A3                INC     DPTR
00B7 7427              MOV     A,#027H
00B9 F0                MOVX    @DPTR,A
00BA A3                INC     DPTR
00BB 7420              MOV     A,#020H
00BD F0                MOVX    @DPTR,A
00BE 7F00              MOV     R7,#00H
00C0 7EFC              MOV     R6,#0FCH
00C2 120000      E     LCALL   _FLASH_Write_Buf
                                           ; SOURCE LINE # 936
00C5 22                RET     
             ; FUNCTION _Diag_Write_Sys (END)

             ; FUNCTION _Diag_Extra_Data_Process (BEGIN)
                                           ; SOURCE LINE # 938
0000 900000      R     MOV     DPTR,#Write_Buf
0003 EB                MOV     A,R3
0004 F0                MOVX    @DPTR,A
0005 A3                INC     DPTR
0006 EA                MOV     A,R2
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 494 

0007 F0                MOVX    @DPTR,A
0008 A3                INC     DPTR
0009 E9                MOV     A,R1
000A F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 939
                                           ; SOURCE LINE # 941
000B 7A00        R     MOV     R2,#HIGH Buf
000D 7900        R     MOV     R1,#LOW Buf
000F 7800        R     MOV     R0,#LOW Buf
0011 7C00        R     MOV     R4,#HIGH Buf
0013 7D01              MOV     R5,#01H
0015 7BFF              MOV     R3,#0FFH
0017 7A00        R     MOV     R2,#HIGH _?ix1007
0019 7900        R     MOV     R1,#LOW _?ix1007
001B 7E00              MOV     R6,#00H
001D 7F06              MOV     R7,#06H
001F 120000      E     LCALL   ?C?COPY
                                           ; SOURCE LINE # 943
0022 900000      R     MOV     DPTR,#Write_Buf
0025 E0                MOVX    A,@DPTR
0026 FB                MOV     R3,A
0027 A3                INC     DPTR
0028 E0                MOVX    A,@DPTR
0029 FA                MOV     R2,A
002A A3                INC     DPTR
002B E0                MOVX    A,@DPTR
002C F9                MOV     R1,A
002D 120000      E     LCALL   ?C?CLDPTR
0030 6003              JZ      $ + 5H
0032 020000      R     LJMP    ?C0203
                                           ; SOURCE LINE # 944
                                           ; SOURCE LINE # 945
0035 7D20              MOV     R5,#020H
0037 FF                MOV     R7,A
0038 7EFE              MOV     R6,#0FEH
003A 120000      E     LCALL   _FLASH_Erase_Buf
                                           ; SOURCE LINE # 947
003D 7E00              MOV     R6,#00H
003F 7F06              MOV     R7,#06H
0041 7D00              MOV     R5,#00H
0043 7B01              MOV     R3,#01H
0045 7A00        R     MOV     R2,#HIGH Buf
0047 7900        R     MOV     R1,#LOW Buf
0049 120000      E     LCALL   ?C?MEMSET
                                           ; SOURCE LINE # 948
004C 900000      R     MOV     DPTR,#Write_Buf
004F E0                MOVX    A,@DPTR
0050 FB                MOV     R3,A
0051 A3                INC     DPTR
0052 E0                MOVX    A,@DPTR
0053 FA                MOV     R2,A
0054 A3                INC     DPTR
0055 E0                MOVX    A,@DPTR
0056 2401              ADD     A,#01H
0058 F9                MOV     R1,A
0059 E4                CLR     A
005A 3A                ADDC    A,R2
005B FA                MOV     R2,A
005C EA                MOV     A,R2
005D C0E0              PUSH    ACC
005F E9                MOV     A,R1
0060 C0E0              PUSH    ACC
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 495 

0062 7A00        R     MOV     R2,#HIGH Buf
0064 7900        R     MOV     R1,#LOW Buf
0066 7800        R     MOV     R0,#LOW Buf
0068 7C00        R     MOV     R4,#HIGH Buf
006A 7D01              MOV     R5,#01H
006C D0E0              POP     ACC
006E F9                MOV     R1,A
006F D0E0              POP     ACC
0071 FA                MOV     R2,A
0072 7E00              MOV     R6,#00H
0074 7F02              MOV     R7,#02H
0076 120000      E     LCALL   ?C?COPY
                                           ; SOURCE LINE # 949
0079 900000      R     MOV     DPTR,#Write_Buf
007C E0                MOVX    A,@DPTR
007D FB                MOV     R3,A
007E A3                INC     DPTR
007F E0                MOVX    A,@DPTR
0080 FA                MOV     R2,A
0081 A3                INC     DPTR
0082 E0                MOVX    A,@DPTR
0083 2403              ADD     A,#03H
0085 F9                MOV     R1,A
0086 E4                CLR     A
0087 3A                ADDC    A,R2
0088 FA                MOV     R2,A
0089 EA                MOV     A,R2
008A C0E0              PUSH    ACC
008C E9                MOV     A,R1
008D C0E0              PUSH    ACC
008F 7A00        R     MOV     R2,#HIGH Buf+03H
0091 7900        R     MOV     R1,#LOW Buf+03H
0093 7800        R     MOV     R0,#LOW Buf+03H
0095 7C00        R     MOV     R4,#HIGH Buf+03H
0097 7D01              MOV     R5,#01H
0099 D0E0              POP     ACC
009B F9                MOV     R1,A
009C D0E0              POP     ACC
009E FA                MOV     R2,A
009F 7E00              MOV     R6,#00H
00A1 7F02              MOV     R7,#02H
00A3 120000      E     LCALL   ?C?COPY
                                           ; SOURCE LINE # 951
00A6 E4                CLR     A
00A7 900000      R     MOV     DPTR,#i
00AA F0                MOVX    @DPTR,A
00AB         ?C0204:
00AB 900000      R     MOV     DPTR,#i
00AE E0                MOVX    A,@DPTR
00AF C3                CLR     C
00B0 9402              SUBB    A,#02H
00B2 5020              JNC     ?C0205
                                           ; SOURCE LINE # 952
                                           ; SOURCE LINE # 953
00B4 A3                INC     DPTR
00B5 E0                MOVX    A,@DPTR
00B6 FF                MOV     R7,A
00B7 900000      R     MOV     DPTR,#i
00BA E0                MOVX    A,@DPTR
00BB 2400        R     ADD     A,#LOW Buf
00BD F582              MOV     DPL,A
00BF E4                CLR     A
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 496 

00C0 3400        R     ADDC    A,#HIGH Buf
00C2 F583              MOV     DPH,A
00C4 E0                MOVX    A,@DPTR
00C5 FE                MOV     R6,A
00C6 EF                MOV     A,R7
00C7 6E                XRL     A,R6
00C8 900000      R     MOV     DPTR,#Cs
00CB F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 954
00CC 900000      R     MOV     DPTR,#i
00CF E0                MOVX    A,@DPTR
00D0 04                INC     A
00D1 F0                MOVX    @DPTR,A
00D2 80D7              SJMP    ?C0204
00D4         ?C0205:
                                           ; SOURCE LINE # 955
00D4 900000      R     MOV     DPTR,#Cs
00D7 E0                MOVX    A,@DPTR
00D8 900000      R     MOV     DPTR,#Buf+02H
00DB F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 957
00DC 900000      R     MOV     DPTR,#i
00DF 7403              MOV     A,#03H
00E1 F0                MOVX    @DPTR,A
00E2         ?C0207:
00E2 900000      R     MOV     DPTR,#i
00E5 E0                MOVX    A,@DPTR
00E6 C3                CLR     C
00E7 9405              SUBB    A,#05H
00E9 5020              JNC     ?C0208
                                           ; SOURCE LINE # 958
                                           ; SOURCE LINE # 959
00EB A3                INC     DPTR
00EC E0                MOVX    A,@DPTR
00ED FF                MOV     R7,A
00EE 900000      R     MOV     DPTR,#i
00F1 E0                MOVX    A,@DPTR
00F2 2400        R     ADD     A,#LOW Buf
00F4 F582              MOV     DPL,A
00F6 E4                CLR     A
00F7 3400        R     ADDC    A,#HIGH Buf
00F9 F583              MOV     DPH,A
00FB E0                MOVX    A,@DPTR
00FC FE                MOV     R6,A
00FD EF                MOV     A,R7
00FE 6E                XRL     A,R6
00FF 900000      R     MOV     DPTR,#Cs
0102 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 960
0103 900000      R     MOV     DPTR,#i
0106 E0                MOVX    A,@DPTR
0107 04                INC     A
0108 F0                MOVX    @DPTR,A
0109 80D7              SJMP    ?C0207
010B         ?C0208:
                                           ; SOURCE LINE # 961
010B 900000      R     MOV     DPTR,#Cs
010E E0                MOVX    A,@DPTR
010F 900000      R     MOV     DPTR,#Buf+05H
0112 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 963
0113 7B01              MOV     R3,#01H
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 497 

0115 7A00        R     MOV     R2,#HIGH Buf
0117 7900        R     MOV     R1,#LOW Buf
0119 900000      E     MOV     DPTR,#?_FLASH_Write_Buf?BYTE+05H
011C E4                CLR     A
011D F0                MOVX    @DPTR,A
011E A3                INC     DPTR
011F 7406              MOV     A,#06H
0121 F0                MOVX    @DPTR,A
0122 A3                INC     DPTR
0123 7420              MOV     A,#020H
0125 F0                MOVX    @DPTR,A
0126 7F00              MOV     R7,#00H
0128 7EFE              MOV     R6,#0FEH
012A 120000      E     LCALL   _FLASH_Write_Buf
                                           ; SOURCE LINE # 964
012D 120000      R     LCALL   Diag_Ecu_Reset
                                           ; SOURCE LINE # 965
0130 22                RET     
0131         ?C0203:
                                           ; SOURCE LINE # 966
0131 900000      R     MOV     DPTR,#Write_Buf
0134 E0                MOVX    A,@DPTR
0135 FB                MOV     R3,A
0136 A3                INC     DPTR
0137 E0                MOVX    A,@DPTR
0138 FA                MOV     R2,A
0139 A3                INC     DPTR
013A E0                MOVX    A,@DPTR
013B F9                MOV     R1,A
013C 120000      E     LCALL   ?C?CLDPTR
013F B4010D            CJNE    A,#01H,?C0211
                                           ; SOURCE LINE # 967
                                           ; SOURCE LINE # 968
0142 7D20              MOV     R5,#020H
0144 7F00              MOV     R7,#00H
0146 7EFA              MOV     R6,#0FAH
0148 120000      E     LCALL   _FLASH_Erase_Buf
                                           ; SOURCE LINE # 969
014B 120000      R     LCALL   Diag_Ecu_Reset
                                           ; SOURCE LINE # 970
014E 22                RET     
014F         ?C0211:
                                           ; SOURCE LINE # 971
014F 900000      R     MOV     DPTR,#Write_Buf
0152 E0                MOVX    A,@DPTR
0153 FB                MOV     R3,A
0154 A3                INC     DPTR
0155 E0                MOVX    A,@DPTR
0156 FA                MOV     R2,A
0157 A3                INC     DPTR
0158 E0                MOVX    A,@DPTR
0159 F9                MOV     R1,A
015A 120000      E     LCALL   ?C?CLDPTR
015D 6402              XRL     A,#02H
015F 7039              JNZ     ?C0218
                                           ; SOURCE LINE # 972
                                           ; SOURCE LINE # 973
0161 120000      E     LCALL   Isp_Off
                                           ; SOURCE LINE # 974
0164 900000      E     MOV     DPTR,#EEPROM_Update_Mode
0167 7401              MOV     A,#01H
0169 F0                MOVX    @DPTR,A
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 498 

                                           ; SOURCE LINE # 975
016A D294              SETB    MCU_F_ENABLE
                                           ; SOURCE LINE # 976
016C 7F1E              MOV     R7,#01EH
016E 7E00              MOV     R6,#00H
0170 120000      E     LCALL   _Wait_ms
                                           ; SOURCE LINE # 978
0173 E4                CLR     A
0174 900000      R     MOV     DPTR,#i
0177 F0                MOVX    @DPTR,A
0178         ?C0214:
0178 900000      R     MOV     DPTR,#i
017B E0                MOVX    A,@DPTR
017C C3                CLR     C
017D 9432              SUBB    A,#032H
017F 5019              JNC     ?C0218
                                           ; SOURCE LINE # 979
                                           ; SOURCE LINE # 980
0181 E0                MOVX    A,@DPTR
0182 FF                MOV     R7,A
0183 7E00              MOV     R6,#00H
0185 7C10              MOV     R4,#010H
0187 7D00              MOV     R5,#00H
0189 120000      E     LCALL   ?C?LIMUL
018C 120000      E     LCALL   _Flash_EraseSector
                                           ; SOURCE LINE # 981
018F 120000      E     LCALL   WDT_Clear
                                           ; SOURCE LINE # 982
0192 900000      R     MOV     DPTR,#i
0195 E0                MOVX    A,@DPTR
0196 04                INC     A
0197 F0                MOVX    @DPTR,A
0198 80DE              SJMP    ?C0214
                                           ; SOURCE LINE # 983
                                           ; SOURCE LINE # 984
                                           ; SOURCE LINE # 985
019A         ?C0218:
019A 22                RET     
             ; FUNCTION _Diag_Extra_Data_Process (END)

             ; FUNCTION _SYS_Flash_Read (BEGIN)
                                           ; SOURCE LINE # 987
0000 900000      R     MOV     DPTR,#ID
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
0005 A3                INC     DPTR
0006 EB                MOV     A,R3
0007 F0                MOVX    @DPTR,A
0008 A3                INC     DPTR
0009 EA                MOV     A,R2
000A F0                MOVX    @DPTR,A
000B A3                INC     DPTR
000C E9                MOV     A,R1
000D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 988
                                           ; SOURCE LINE # 990
000E 7A00        R     MOV     R2,#HIGH Buf
0010 7900        R     MOV     R1,#LOW Buf
0012 7800        R     MOV     R0,#LOW Buf
0014 7C00        R     MOV     R4,#HIGH Buf
0016 7D01              MOV     R5,#01H
0018 7BFF              MOV     R3,#0FFH
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 499 

001A 7A00        R     MOV     R2,#HIGH _?ix1008
001C 7900        R     MOV     R1,#LOW _?ix1008
001E 7E00              MOV     R6,#00H
0020 7F26              MOV     R7,#026H
0022 120000      E     LCALL   ?C?COPY
                                           ; SOURCE LINE # 992
0025 900000      R     MOV     DPTR,#Length
0028 E0                MOVX    A,@DPTR
0029 FF                MOV     R7,A
002A 7E00              MOV     R6,#00H
002C 7D00              MOV     R5,#00H
002E 7B01              MOV     R3,#01H
0030 7A00        R     MOV     R2,#HIGH Buf
0032 7900        R     MOV     R1,#LOW Buf
0034 120000      E     LCALL   ?C?MEMSET
                                           ; SOURCE LINE # 994
0037 7B01              MOV     R3,#01H
0039 7A00        R     MOV     R2,#HIGH Buf
003B 7900        R     MOV     R1,#LOW Buf
003D 900000      E     MOV     DPTR,#?_FLASH_Read_Buf?BYTE+05H
0040 E4                CLR     A
0041 F0                MOVX    @DPTR,A
0042 A3                INC     DPTR
0043 7426              MOV     A,#026H
0045 F0                MOVX    @DPTR,A
0046 A3                INC     DPTR
0047 7420              MOV     A,#020H
0049 F0                MOVX    @DPTR,A
004A 7D00              MOV     R5,#00H
004C 7CFC              MOV     R4,#0FCH
004E 120000      E     LCALL   _FLASH_Read_Buf
                                           ; SOURCE LINE # 996
0051 E4                CLR     A
0052 900000      R     MOV     DPTR,#i
0055 F0                MOVX    @DPTR,A
0056         ?C0219:
0056 900000      R     MOV     DPTR,#i
0059 E0                MOVX    A,@DPTR
005A C3                CLR     C
005B 9425              SUBB    A,#025H
005D 5020              JNC     ?C0220
                                           ; SOURCE LINE # 997
                                           ; SOURCE LINE # 998
005F A3                INC     DPTR
0060 E0                MOVX    A,@DPTR
0061 FF                MOV     R7,A
0062 900000      R     MOV     DPTR,#i
0065 E0                MOVX    A,@DPTR
0066 2400        R     ADD     A,#LOW Buf
0068 F582              MOV     DPL,A
006A E4                CLR     A
006B 3400        R     ADDC    A,#HIGH Buf
006D F583              MOV     DPH,A
006F E0                MOVX    A,@DPTR
0070 FE                MOV     R6,A
0071 EF                MOV     A,R7
0072 6E                XRL     A,R6
0073 900000      R     MOV     DPTR,#Cs
0076 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 999
0077 900000      R     MOV     DPTR,#i
007A E0                MOVX    A,@DPTR
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 500 

007B 04                INC     A
007C F0                MOVX    @DPTR,A
007D 80D7              SJMP    ?C0219
007F         ?C0220:
                                           ; SOURCE LINE # 1000
007F 900000      R     MOV     DPTR,#Buf+025H
0082 E0                MOVX    A,@DPTR
0083 900000      R     MOV     DPTR,#Cs
0086 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1001
0087 900000      R     MOV     DPTR,#Buf+025H
008A E0                MOVX    A,@DPTR
008B FF                MOV     R7,A
008C 900000      R     MOV     DPTR,#Cs
008F E0                MOVX    A,@DPTR
0090 6F                XRL     A,R7
0091 6003              JZ      $ + 5H
0093 020000      R     LJMP    ?C0231
                                           ; SOURCE LINE # 1002
                                           ; SOURCE LINE # 1003
0096 900000      R     MOV     DPTR,#ID
0099 E0                MOVX    A,@DPTR
009A 7003              JNZ     $ + 5H
009C 020000      R     LJMP    ?C0229
009F 2479              ADD     A,#079H
00A1 6038              JZ      ?C0225
00A3 24FC              ADD     A,#0FCH
00A5 6056              JZ      ?C0226
00A7 24F8              ADD     A,#0F8H
00A9 6074              JZ      ?C0227
00AB 24FE              ADD     A,#0FEH
00AD 7003              JNZ     $ + 5H
00AF 020000      R     LJMP    ?C0228
00B2 2493              ADD     A,#093H
00B4 6003              JZ      $ + 5H
00B6 020000      R     LJMP    ?C0231
                                           ; SOURCE LINE # 1004
                                           ; SOURCE LINE # 1005
00B9         ?C0224:
                                           ; SOURCE LINE # 1006
00B9 900000      R     MOV     DPTR,#Length
00BC E0                MOVX    A,@DPTR
00BD FF                MOV     R7,A
00BE 7E00              MOV     R6,#00H
00C0 900000      R     MOV     DPTR,#Read_Buf
00C3 E0                MOVX    A,@DPTR
00C4 FB                MOV     R3,A
00C5 A3                INC     DPTR
00C6 E0                MOVX    A,@DPTR
00C7 FA                MOV     R2,A
00C8 A3                INC     DPTR
00C9 E0                MOVX    A,@DPTR
00CA F8                MOV     R0,A
00CB CC                XCH     A,R4
00CC EA                MOV     A,R2
00CD CC                XCH     A,R4
00CE CD                XCH     A,R5
00CF EB                MOV     A,R3
00D0 CD                XCH     A,R5
00D1 7B01              MOV     R3,#01H
00D3 7A00        R     MOV     R2,#HIGH Buf
00D5 7900        R     MOV     R1,#LOW Buf
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 501 

00D7 120000      E     LCALL   ?C?COPY
                                           ; SOURCE LINE # 1007
00DA 22                RET     
                                           ; SOURCE LINE # 1008
00DB         ?C0225:
                                           ; SOURCE LINE # 1009
00DB 900000      R     MOV     DPTR,#Length
00DE E0                MOVX    A,@DPTR
00DF FF                MOV     R7,A
00E0 7E00              MOV     R6,#00H
00E2 900000      R     MOV     DPTR,#Read_Buf
00E5 E0                MOVX    A,@DPTR
00E6 FB                MOV     R3,A
00E7 A3                INC     DPTR
00E8 E0                MOVX    A,@DPTR
00E9 FA                MOV     R2,A
00EA A3                INC     DPTR
00EB E0                MOVX    A,@DPTR
00EC F8                MOV     R0,A
00ED CC                XCH     A,R4
00EE EA                MOV     A,R2
00EF CC                XCH     A,R4
00F0 CD                XCH     A,R5
00F1 EB                MOV     A,R3
00F2 CD                XCH     A,R5
00F3 7B01              MOV     R3,#01H
00F5 7A00        R     MOV     R2,#HIGH Buf
00F7 7900        R     MOV     R1,#LOW Buf
00F9 120000      E     LCALL   ?C?COPY
                                           ; SOURCE LINE # 1010
00FC 22                RET     
                                           ; SOURCE LINE # 1011
00FD         ?C0226:
                                           ; SOURCE LINE # 1012
00FD 900000      R     MOV     DPTR,#Length
0100 E0                MOVX    A,@DPTR
0101 FF                MOV     R7,A
0102 7E00              MOV     R6,#00H
0104 900000      R     MOV     DPTR,#Read_Buf
0107 E0                MOVX    A,@DPTR
0108 FB                MOV     R3,A
0109 A3                INC     DPTR
010A E0                MOVX    A,@DPTR
010B FA                MOV     R2,A
010C A3                INC     DPTR
010D E0                MOVX    A,@DPTR
010E F8                MOV     R0,A
010F CC                XCH     A,R4
0110 EA                MOV     A,R2
0111 CC                XCH     A,R4
0112 CD                XCH     A,R5
0113 EB                MOV     A,R3
0114 CD                XCH     A,R5
0115 7B01              MOV     R3,#01H
0117 7A00        R     MOV     R2,#HIGH Buf+0AH
0119 7900        R     MOV     R1,#LOW Buf+0AH
011B 120000      E     LCALL   ?C?COPY
                                           ; SOURCE LINE # 1013
011E 22                RET     
                                           ; SOURCE LINE # 1014
011F         ?C0227:
                                           ; SOURCE LINE # 1015
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 502 

011F 900000      R     MOV     DPTR,#Length
0122 E0                MOVX    A,@DPTR
0123 FF                MOV     R7,A
0124 7E00              MOV     R6,#00H
0126 900000      R     MOV     DPTR,#Read_Buf
0129 E0                MOVX    A,@DPTR
012A FB                MOV     R3,A
012B A3                INC     DPTR
012C E0                MOVX    A,@DPTR
012D FA                MOV     R2,A
012E A3                INC     DPTR
012F E0                MOVX    A,@DPTR
0130 F8                MOV     R0,A
0131 CC                XCH     A,R4
0132 EA                MOV     A,R2
0133 CC                XCH     A,R4
0134 CD                XCH     A,R5
0135 EB                MOV     A,R3
0136 CD                XCH     A,R5
0137 7B01              MOV     R3,#01H
0139 7A00        R     MOV     R2,#HIGH Buf+012H
013B 7900        R     MOV     R1,#LOW Buf+012H
013D 120000      E     LCALL   ?C?COPY
                                           ; SOURCE LINE # 1016
0140 22                RET     
                                           ; SOURCE LINE # 1017
0141         ?C0228:
                                           ; SOURCE LINE # 1018
0141 900000      R     MOV     DPTR,#Length
0144 E0                MOVX    A,@DPTR
0145 FF                MOV     R7,A
0146 7E00              MOV     R6,#00H
0148 900000      R     MOV     DPTR,#Read_Buf
014B E0                MOVX    A,@DPTR
014C FB                MOV     R3,A
014D A3                INC     DPTR
014E E0                MOVX    A,@DPTR
014F FA                MOV     R2,A
0150 A3                INC     DPTR
0151 E0                MOVX    A,@DPTR
0152 F8                MOV     R0,A
0153 CC                XCH     A,R4
0154 EA                MOV     A,R2
0155 CC                XCH     A,R4
0156 CD                XCH     A,R5
0157 EB                MOV     A,R3
0158 CD                XCH     A,R5
0159 7B01              MOV     R3,#01H
015B 7A00        R     MOV     R2,#HIGH Buf+015H
015D 7900        R     MOV     R1,#LOW Buf+015H
015F 120000      E     LCALL   ?C?COPY
                                           ; SOURCE LINE # 1019
0162 22                RET     
                                           ; SOURCE LINE # 1020
0163         ?C0229:
                                           ; SOURCE LINE # 1021
0163 900000      R     MOV     DPTR,#Length
0166 E0                MOVX    A,@DPTR
0167 FF                MOV     R7,A
0168 7E00              MOV     R6,#00H
016A 900000      R     MOV     DPTR,#Read_Buf
016D E0                MOVX    A,@DPTR
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 503 

016E FB                MOV     R3,A
016F A3                INC     DPTR
0170 E0                MOVX    A,@DPTR
0171 FA                MOV     R2,A
0172 A3                INC     DPTR
0173 E0                MOVX    A,@DPTR
0174 F8                MOV     R0,A
0175 CC                XCH     A,R4
0176 EA                MOV     A,R2
0177 CC                XCH     A,R4
0178 CD                XCH     A,R5
0179 EB                MOV     A,R3
017A CD                XCH     A,R5
017B 7B01              MOV     R3,#01H
017D 7A00        R     MOV     R2,#HIGH Buf+018H
017F 7900        R     MOV     R1,#LOW Buf+018H
0181 120000      E     LCALL   ?C?COPY
                                           ; SOURCE LINE # 1022
                                           ; SOURCE LINE # 1023
                                           ; SOURCE LINE # 1024
                                           ; SOURCE LINE # 1025
                                           ; SOURCE LINE # 1026
                                           ; SOURCE LINE # 1027
0184         ?C0231:
0184 22                RET     
             ; FUNCTION _SYS_Flash_Read (END)

             ; FUNCTION _Diag_Read_Address (BEGIN)
                                           ; SOURCE LINE # 1029
0000 900000      R     MOV     DPTR,#Read_Buf
0003 EB                MOV     A,R3
0004 F0                MOVX    @DPTR,A
0005 A3                INC     DPTR
0006 EA                MOV     A,R2
0007 F0                MOVX    @DPTR,A
0008 A3                INC     DPTR
0009 E9                MOV     A,R1
000A F0                MOVX    @DPTR,A
000B A3                INC     DPTR
000C 120000      E     LCALL   ?C?LSTXDATA
                                           ; SOURCE LINE # 1030
                                           ; SOURCE LINE # 1031
000F 7A00        R     MOV     R2,#HIGH DataBuf
0011 7900        R     MOV     R1,#LOW DataBuf
0013 7800        R     MOV     R0,#LOW DataBuf
0015 7C00        R     MOV     R4,#HIGH DataBuf
0017 7D01              MOV     R5,#01H
0019 7BFF              MOV     R3,#0FFH
001B 7A00        R     MOV     R2,#HIGH _?ix1009
001D 7900        R     MOV     R1,#LOW _?ix1009
001F 7E00              MOV     R6,#00H
0021 7F10              MOV     R7,#010H
0023 120000      E     LCALL   ?C?COPY
                                           ; SOURCE LINE # 1032
0026 E4                CLR     A
0027 900000      R     MOV     DPTR,#CodeBank1
002A F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1033
002B A3                INC     DPTR
002C F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1034
002D A3                INC     DPTR
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 504 

002E F0                MOVX    @DPTR,A
002F A3                INC     DPTR
0030 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1035
0031 900000      R     MOV     DPTR,#Read_Address2
0034 F0                MOVX    @DPTR,A
0035 A3                INC     DPTR
0036 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1036
0037 900000      R     MOV     DPTR,#Length1
003A F0                MOVX    @DPTR,A
003B A3                INC     DPTR
003C F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1037
003D 900000      R     MOV     DPTR,#Length2
0040 F0                MOVX    @DPTR,A
0041 A3                INC     DPTR
0042 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1040
0043 FB                MOV     R3,A
0044 7A80              MOV     R2,#080H
0046 F9                MOV     R1,A
0047 F8                MOV     R0,A
0048 900000      R     MOV     DPTR,#DataAddr
004B E0                MOVX    A,@DPTR
004C FC                MOV     R4,A
004D A3                INC     DPTR
004E E0                MOVX    A,@DPTR
004F FD                MOV     R5,A
0050 A3                INC     DPTR
0051 E0                MOVX    A,@DPTR
0052 FE                MOV     R6,A
0053 A3                INC     DPTR
0054 E0                MOVX    A,@DPTR
0055 FF                MOV     R7,A
0056 120000      E     LCALL   ?C?ULDIV
0059 900000      R     MOV     DPTR,#CodeBank1
005C EF                MOV     A,R7
005D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1041
005E 900000      R     MOV     DPTR,#DataLen
0061 E0                MOVX    A,@DPTR
0062 FE                MOV     R6,A
0063 A3                INC     DPTR
0064 E0                MOVX    A,@DPTR
0065 FF                MOV     R7,A
0066 E4                CLR     A
0067 FC                MOV     R4,A
0068 FD                MOV     R5,A
0069 900000      R     MOV     DPTR,#DataAddr
006C E0                MOVX    A,@DPTR
006D F8                MOV     R0,A
006E A3                INC     DPTR
006F E0                MOVX    A,@DPTR
0070 F9                MOV     R1,A
0071 A3                INC     DPTR
0072 E0                MOVX    A,@DPTR
0073 FA                MOV     R2,A
0074 A3                INC     DPTR
0075 E0                MOVX    A,@DPTR
0076 2F                ADD     A,R7
0077 FF                MOV     R7,A
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 505 

0078 EA                MOV     A,R2
0079 3E                ADDC    A,R6
007A FE                MOV     R6,A
007B ED                MOV     A,R5
007C 39                ADDC    A,R1
007D FD                MOV     R5,A
007E EC                MOV     A,R4
007F 38                ADDC    A,R0
0080 FC                MOV     R4,A
0081 EF                MOV     A,R7
0082 24FF              ADD     A,#0FFH
0084 FF                MOV     R7,A
0085 EE                MOV     A,R6
0086 34FF              ADDC    A,#0FFH
0088 FE                MOV     R6,A
0089 ED                MOV     A,R5
008A 34FF              ADDC    A,#0FFH
008C FD                MOV     R5,A
008D EC                MOV     A,R4
008E 34FF              ADDC    A,#0FFH
0090 FC                MOV     R4,A
0091 E4                CLR     A
0092 FB                MOV     R3,A
0093 7A80              MOV     R2,#080H
0095 F9                MOV     R1,A
0096 F8                MOV     R0,A
0097 120000      E     LCALL   ?C?ULDIV
009A 900000      R     MOV     DPTR,#CodeBank2
009D EF                MOV     A,R7
009E F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1043
009F 900000      R     MOV     DPTR,#CodeBank1
00A2 E0                MOVX    A,@DPTR
00A3 7004              JNZ     ?C0232
                                           ; SOURCE LINE # 1044
                                           ; SOURCE LINE # 1045
00A5 04                INC     A
00A6 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1046
00A7 A3                INC     DPTR
00A8 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1047
00A9         ?C0232:
                                           ; SOURCE LINE # 1049
00A9 900000      R     MOV     DPTR,#CodeBank2
00AC E0                MOVX    A,@DPTR
00AD FF                MOV     R7,A
00AE 900000      R     MOV     DPTR,#CodeBank1
00B1 E0                MOVX    A,@DPTR
00B2 6F                XRL     A,R7
00B3 7069              JNZ     ?C0233
                                           ; SOURCE LINE # 1050
                                           ; SOURCE LINE # 1051
00B5 E0                MOVX    A,@DPTR
00B6 24FF              ADD     A,#0FFH
00B8 FF                MOV     R7,A
00B9 E4                CLR     A
00BA 34FF              ADDC    A,#0FFH
00BC EF                MOV     A,R7
00BD C4                SWAP    A
00BE 33                RLC     A
00BF 33                RLC     A
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 506 

00C0 33                RLC     A
00C1 5480              ANL     A,#080H
00C3 FA                MOV     R2,A
00C4 900000      R     MOV     DPTR,#DataAddr
00C7 E0                MOVX    A,@DPTR
00C8 A3                INC     DPTR
00C9 E0                MOVX    A,@DPTR
00CA A3                INC     DPTR
00CB E0                MOVX    A,@DPTR
00CC FE                MOV     R6,A
00CD A3                INC     DPTR
00CE E0                MOVX    A,@DPTR
00CF C3                CLR     C
00D0 9400              SUBB    A,#00H
00D2 FF                MOV     R7,A
00D3 EE                MOV     A,R6
00D4 9A                SUBB    A,R2
00D5 900000      R     MOV     DPTR,#Read_Address1
00D8 F0                MOVX    @DPTR,A
00D9 A3                INC     DPTR
00DA EF                MOV     A,R7
00DB F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1052
00DC 900000      R     MOV     DPTR,#DataLen
00DF E0                MOVX    A,@DPTR
00E0 FF                MOV     R7,A
00E1 A3                INC     DPTR
00E2 E0                MOVX    A,@DPTR
00E3 900000      R     MOV     DPTR,#Length1
00E6 CF                XCH     A,R7
00E7 F0                MOVX    @DPTR,A
00E8 A3                INC     DPTR
00E9 EF                MOV     A,R7
00EA F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1053
00EB 900000      R     MOV     DPTR,#CodeBank1
00EE E0                MOVX    A,@DPTR
00EF C4                SWAP    A
00F0 54F0              ANL     A,#0F0H
00F2 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1054
00F3 7B01              MOV     R3,#01H
00F5 7A00        R     MOV     R2,#HIGH DataBuf
00F7 7900        R     MOV     R1,#LOW DataBuf
00F9 900000      R     MOV     DPTR,#Read_Address1
00FC E0                MOVX    A,@DPTR
00FD FC                MOV     R4,A
00FE A3                INC     DPTR
00FF E0                MOVX    A,@DPTR
0100 FD                MOV     R5,A
0101 900000      R     MOV     DPTR,#Length1
0104 E0                MOVX    A,@DPTR
0105 FF                MOV     R7,A
0106 A3                INC     DPTR
0107 E0                MOVX    A,@DPTR
0108 900000      E     MOV     DPTR,#?_FLASH_Read_Buf?BYTE+05H
010B CF                XCH     A,R7
010C F0                MOVX    @DPTR,A
010D A3                INC     DPTR
010E EF                MOV     A,R7
010F F0                MOVX    @DPTR,A
0110 900000      R     MOV     DPTR,#CodeBank1
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 507 

0113 E0                MOVX    A,@DPTR
0114 900000      E     MOV     DPTR,#?_FLASH_Read_Buf?BYTE+07H
0117 F0                MOVX    @DPTR,A
0118 120000      E     LCALL   _FLASH_Read_Buf
                                           ; SOURCE LINE # 1055
011B 020000      R     LJMP    ?C0234
011E         ?C0233:
                                           ; SOURCE LINE # 1057
                                           ; SOURCE LINE # 1058
011E 900000      R     MOV     DPTR,#CodeBank1
0121 E0                MOVX    A,@DPTR
0122 24FF              ADD     A,#0FFH
0124 FF                MOV     R7,A
0125 E4                CLR     A
0126 34FF              ADDC    A,#0FFH
0128 EF                MOV     A,R7
0129 C4                SWAP    A
012A 33                RLC     A
012B 33                RLC     A
012C 33                RLC     A
012D 5480              ANL     A,#080H
012F FA                MOV     R2,A
0130 900000      R     MOV     DPTR,#DataAddr
0133 E0                MOVX    A,@DPTR
0134 A3                INC     DPTR
0135 E0                MOVX    A,@DPTR
0136 A3                INC     DPTR
0137 E0                MOVX    A,@DPTR
0138 FE                MOV     R6,A
0139 A3                INC     DPTR
013A E0                MOVX    A,@DPTR
013B C3                CLR     C
013C 9400              SUBB    A,#00H
013E FF                MOV     R7,A
013F EE                MOV     A,R6
0140 9A                SUBB    A,R2
0141 900000      R     MOV     DPTR,#Read_Address1
0144 F0                MOVX    @DPTR,A
0145 A3                INC     DPTR
0146 EF                MOV     A,R7
0147 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1059
0148 900000      R     MOV     DPTR,#DataAddr
014B E0                MOVX    A,@DPTR
014C A3                INC     DPTR
014D E0                MOVX    A,@DPTR
014E A3                INC     DPTR
014F E0                MOVX    A,@DPTR
0150 FE                MOV     R6,A
0151 A3                INC     DPTR
0152 E0                MOVX    A,@DPTR
0153 FD                MOV     R5,A
0154 CC                XCH     A,R4
0155 EE                MOV     A,R6
0156 CC                XCH     A,R4
0157 900000      R     MOV     DPTR,#CodeBank2
015A E0                MOVX    A,@DPTR
015B C4                SWAP    A
015C 33                RLC     A
015D 33                RLC     A
015E 33                RLC     A
015F 5480              ANL     A,#080H
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 508 

0161 FE                MOV     R6,A
0162 C3                CLR     C
0163 E4                CLR     A
0164 9D                SUBB    A,R5
0165 FF                MOV     R7,A
0166 EE                MOV     A,R6
0167 9C                SUBB    A,R4
0168 900000      R     MOV     DPTR,#Length1
016B F0                MOVX    @DPTR,A
016C A3                INC     DPTR
016D EF                MOV     A,R7
016E F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1060
016F 900000      R     MOV     DPTR,#CodeBank1
0172 E0                MOVX    A,@DPTR
0173 C4                SWAP    A
0174 54F0              ANL     A,#0F0H
0176 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1062
0177 900000      R     MOV     DPTR,#Read_Address2
017A 7480              MOV     A,#080H
017C F0                MOVX    @DPTR,A
017D A3                INC     DPTR
017E E4                CLR     A
017F F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1063
0180 900000      R     MOV     DPTR,#Length1
0183 E0                MOVX    A,@DPTR
0184 FE                MOV     R6,A
0185 A3                INC     DPTR
0186 E0                MOVX    A,@DPTR
0187 FF                MOV     R7,A
0188 C3                CLR     C
0189 900000      R     MOV     DPTR,#DataLen+01H
018C E0                MOVX    A,@DPTR
018D 9F                SUBB    A,R7
018E FF                MOV     R7,A
018F 900000      R     MOV     DPTR,#DataLen
0192 E0                MOVX    A,@DPTR
0193 9E                SUBB    A,R6
0194 900000      R     MOV     DPTR,#Length2
0197 F0                MOVX    @DPTR,A
0198 A3                INC     DPTR
0199 EF                MOV     A,R7
019A F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1064
019B 900000      R     MOV     DPTR,#CodeBank2
019E E0                MOVX    A,@DPTR
019F C4                SWAP    A
01A0 54F0              ANL     A,#0F0H
01A2 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1066
01A3 7B01              MOV     R3,#01H
01A5 7A00        R     MOV     R2,#HIGH DataBuf
01A7 7900        R     MOV     R1,#LOW DataBuf
01A9 A3                INC     DPTR
01AA E0                MOVX    A,@DPTR
01AB FC                MOV     R4,A
01AC A3                INC     DPTR
01AD E0                MOVX    A,@DPTR
01AE FD                MOV     R5,A
01AF 900000      R     MOV     DPTR,#Length1
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 509 

01B2 E0                MOVX    A,@DPTR
01B3 FF                MOV     R7,A
01B4 A3                INC     DPTR
01B5 E0                MOVX    A,@DPTR
01B6 900000      E     MOV     DPTR,#?_FLASH_Read_Buf?BYTE+05H
01B9 CF                XCH     A,R7
01BA F0                MOVX    @DPTR,A
01BB A3                INC     DPTR
01BC EF                MOV     A,R7
01BD F0                MOVX    @DPTR,A
01BE 900000      R     MOV     DPTR,#CodeBank1
01C1 E0                MOVX    A,@DPTR
01C2 900000      E     MOV     DPTR,#?_FLASH_Read_Buf?BYTE+07H
01C5 F0                MOVX    @DPTR,A
01C6 120000      E     LCALL   _FLASH_Read_Buf
                                           ; SOURCE LINE # 1067
01C9 900000      R     MOV     DPTR,#Length1
01CC E0                MOVX    A,@DPTR
01CD FE                MOV     R6,A
01CE A3                INC     DPTR
01CF E0                MOVX    A,@DPTR
01D0 2400        R     ADD     A,#LOW DataBuf
01D2 F9                MOV     R1,A
01D3 7400        R     MOV     A,#HIGH DataBuf
01D5 3E                ADDC    A,R6
01D6 FA                MOV     R2,A
01D7 7B01              MOV     R3,#01H
01D9 900000      R     MOV     DPTR,#Read_Address2
01DC E0                MOVX    A,@DPTR
01DD FC                MOV     R4,A
01DE A3                INC     DPTR
01DF E0                MOVX    A,@DPTR
01E0 FD                MOV     R5,A
01E1 900000      R     MOV     DPTR,#Length2
01E4 E0                MOVX    A,@DPTR
01E5 FF                MOV     R7,A
01E6 A3                INC     DPTR
01E7 E0                MOVX    A,@DPTR
01E8 900000      E     MOV     DPTR,#?_FLASH_Read_Buf?BYTE+05H
01EB CF                XCH     A,R7
01EC F0                MOVX    @DPTR,A
01ED A3                INC     DPTR
01EE EF                MOV     A,R7
01EF F0                MOVX    @DPTR,A
01F0 900000      R     MOV     DPTR,#CodeBank2
01F3 E0                MOVX    A,@DPTR
01F4 900000      E     MOV     DPTR,#?_FLASH_Read_Buf?BYTE+07H
01F7 F0                MOVX    @DPTR,A
01F8 120000      E     LCALL   _FLASH_Read_Buf
                                           ; SOURCE LINE # 1068
01FB         ?C0234:
                                           ; SOURCE LINE # 1070
01FB 900000      R     MOV     DPTR,#DataLen
01FE E0                MOVX    A,@DPTR
01FF FE                MOV     R6,A
0200 A3                INC     DPTR
0201 E0                MOVX    A,@DPTR
0202 FF                MOV     R7,A
0203 900000      R     MOV     DPTR,#Read_Buf
0206 E0                MOVX    A,@DPTR
0207 FB                MOV     R3,A
0208 A3                INC     DPTR
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 510 

0209 E0                MOVX    A,@DPTR
020A FA                MOV     R2,A
020B A3                INC     DPTR
020C E0                MOVX    A,@DPTR
020D F8                MOV     R0,A
020E CC                XCH     A,R4
020F EA                MOV     A,R2
0210 CC                XCH     A,R4
0211 CD                XCH     A,R5
0212 EB                MOV     A,R3
0213 CD                XCH     A,R5
0214 7B01              MOV     R3,#01H
0216 7A00        R     MOV     R2,#HIGH DataBuf
0218 7900        R     MOV     R1,#LOW DataBuf
021A 120000      E     LCALL   ?C?COPY
                                           ; SOURCE LINE # 1071
021D 22                RET     
             ; FUNCTION _Diag_Read_Address (END)

             ; FUNCTION Diag_Get_Time (BEGIN)
                                           ; SOURCE LINE # 1073
                                           ; SOURCE LINE # 1074
                                           ; SOURCE LINE # 1075
0000 E4                CLR     A
0001 900000      R     MOV     DPTR,#Cur_Time
0004 F0                MOVX    @DPTR,A
0005 A3                INC     DPTR
0006 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1076
0007 120000      E     LCALL   Get_Time
000A 900000      R     MOV     DPTR,#Cur_Time
000D EE                MOV     A,R6
000E F0                MOVX    @DPTR,A
000F A3                INC     DPTR
0010 EF                MOV     A,R7
0011 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1077
                                           ; SOURCE LINE # 1078
0012         ?C0236:
0012 22                RET     
             ; FUNCTION Diag_Get_Time (END)

C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 511 

NAME                                    CLASS   MSPACE  TYPE    OFFSET  SIZE
====                                    =====   ======  ====    ======  ====


U8 . . . . . . . . . . . . . . . . . .  TYPEDEF  -----  U_CHAR   -----  1
U16. . . . . . . . . . . . . . . . . .  TYPEDEF  -----  U_INT    -----  2
U32. . . . . . . . . . . . . . . . . .  TYPEDEF  -----  U_LONG   -----  4
S8 . . . . . . . . . . . . . . . . . .  TYPEDEF  -----  CHAR     -----  1
S16. . . . . . . . . . . . . . . . . .  TYPEDEF  -----  INT      -----  2
S32. . . . . . . . . . . . . . . . . .  TYPEDEF  -----  LONG     -----  4
UU16 . . . . . . . . . . . . . . . . .  * TAG *  -----  UNION    -----  2
  U16. . . . . . . . . . . . . . . . .  MEMBER   -----  U_INT    0000H  2
  S16. . . . . . . . . . . . . . . . .  MEMBER   -----  INT      0000H  2
  U8 . . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  2
  S8 . . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  2
UU16 . . . . . . . . . . . . . . . . .  TYPEDEF  -----  UNION    -----  2
  U16. . . . . . . . . . . . . . . . .  MEMBER   -----  U_INT    0000H  2
  S16. . . . . . . . . . . . . . . . .  MEMBER   -----  INT      0000H  2
  U8 . . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  2
  S8 . . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  2
UU32 . . . . . . . . . . . . . . . . .  * TAG *  -----  UNION    -----  4
  U32. . . . . . . . . . . . . . . . .  MEMBER   -----  U_LONG   0000H  4
  S32. . . . . . . . . . . . . . . . .  MEMBER   -----  LONG     0000H  4
  UU16 . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  4
  U16. . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  4
  S16. . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  4
  U8 . . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  4
  S8 . . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  4
UU32 . . . . . . . . . . . . . . . . .  TYPEDEF  -----  UNION    -----  4
  U32. . . . . . . . . . . . . . . . .  MEMBER   -----  U_LONG   0000H  4
  S32. . . . . . . . . . . . . . . . .  MEMBER   -----  LONG     0000H  4
  UU16 . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  4
  U16. . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  4
  S16. . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  4
  U8 . . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  4
  S8 . . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  4
EIE1 . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00E6H  1
PSBANK . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00F5H  1
MCU_F_ENABLE . . . . . . . . . . . . .  ABSBIT   -----  BIT      0094H  1
MCU_Reset. . . . . . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
tMsg_Time_s. . . . . . . . . . . . . .  TYPEDEF  -----  STRUCT   -----  13
  Set. . . . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0000H  1
  Delay_Time . . . . . . . . . . . . .  MEMBER   -----  U_LONG   0001H  4
  Cur_Time . . . . . . . . . . . . . .  MEMBER   -----  U_LONG   0005H  4
  End_Time . . . . . . . . . . . . . .  MEMBER   -----  U_LONG   0009H  4
tMsg_Global_Tick . . . . . . . . . . .  TYPEDEF  -----  STRUCT   -----  9
  Tick_1ms . . . . . . . . . . . . . .  MEMBER   -----  U_LONG   0000H  4
  Limit. . . . . . . . . . . . . . . .  MEMBER   -----  U_LONG   0004H  4
  Over_Set . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0008H  1
_Wait_ms . . . . . . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
_Delay_Time_Set. . . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
_Delay_Time_Get. . . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
_Delay_Time_Expire . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
Get_Time . . . . . . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
WDT_Clear. . . . . . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
_Flash_EraseSector . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
_Flash_Write . . . . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
SMBUS0_Init. . . . . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
Get_Temperature. . . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
tMsg_I2C_Tx_Data_s . . . . . . . . . .  TYPEDEF  -----  STRUCT   -----  9
  Slave. . . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0000H  1
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 512 

NAME                                    CLASS   MSPACE  TYPE    OFFSET  SIZE
====                                    =====   ======  ====    ======  ====


  Length . . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0001H  1
  TRX_Flag . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0002H  1
  Addr . . . . . . . . . . . . . . . .  MEMBER   -----  U_INT    0003H  2
  TxData . . . . . . . . . . . . . . .  MEMBER   -----  U_INT    0005H  2
  RxData . . . . . . . . . . . . . . .  MEMBER   -----  U_INT    0007H  2
tMsg_CAN_Tx_Data_s . . . . . . . . . .  TYPEDEF  -----  STRUCT   -----  9
  Slave. . . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0000H  1
  Length . . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0001H  1
  TRX_Flag . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0002H  1
  Addr . . . . . . . . . . . . . . . .  MEMBER   -----  U_INT    0003H  2
  TxData . . . . . . . . . . . . . . .  MEMBER   -----  U_INT    0005H  2
  RxData . . . . . . . . . . . . . . .  MEMBER   -----  U_INT    0007H  2
tMsg_CAN_Rx_Data_s . . . . . . . . . .  TYPEDEF  -----  STRUCT   -----  8
  Is_Change. . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0000H  1
  Change_Count . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0001H  1
  Time_Out . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0002H  1
  Cur_Data . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0003H  1
  Mid_Data . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0004H  1
  Pre_Data . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0005H  1
  Chatter_Time . . . . . . . . . . . .  MEMBER   -----  U_INT    0006H  2
tMsg_CAN_SAS_Data_s. . . . . . . . . .  TYPEDEF  -----  STRUCT   -----  8
  Is_Change. . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0000H  1
  Pre_Sign . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0001H  1
  Angle. . . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0002H  1
  Angle_Pre_Sign . . . . . . . . . . .  MEMBER   -----  U_CHAR   0003H  1
  Time_Out . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0004H  1
  Pre_Data . . . . . . . . . . . . . .  MEMBER   -----  U_INT    0005H  2
  Tuning_Type. . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0007H  1
tMsg_CAN_State_s . . . . . . . . . . .  TYPEDEF  -----  STRUCT   -----  5
  Is_Change. . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0000H  1
  Pre_Sign . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0001H  1
  Angle. . . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0002H  1
  Pre_Data . . . . . . . . . . . . . .  MEMBER   -----  U_INT    0003H  2
Init_DiagTask. . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
Operate_DiagTask . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  ID . . . . . . . . . . . . . . . . .  AUTO     XDATA  U_CHAR   0000H  1
  On_Time. . . . . . . . . . . . . . .  AUTO     XDATA  U_CHAR   0001H  1
  Reserved_Address . . . . . . . . . .  AUTO     XDATA  U_CHAR   0002H  1
  i. . . . . . . . . . . . . . . . . .  AUTO     XDATA  U_CHAR   0003H  1
Diag_Ecu_Reset . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
Diag_Clear_DTC . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
_Diag_Read_Dtc . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  index. . . . . . . . . . . . . . . .  * REG *  DATA   U_CHAR   0007H  1
  ret. . . . . . . . . . . . . . . . .  * REG *  DATA   U_CHAR   0006H  1
Diag_Sensor_Reset. . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
_Diag_Guid_OnOff . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  OnOff. . . . . . . . . . . . . . . .  * REG *  DATA   U_CHAR   0007H  1
Clear_DTC_Struct . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  i. . . . . . . . . . . . . . . . . .  * REG *  DATA   U_CHAR   0007H  1
Clear_DTC_Status . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  i. . . . . . . . . . . . . . . . . .  * REG *  DATA   U_CHAR   0007H  1
_Record_DTC_Error. . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  ID . . . . . . . . . . . . . . . . .  AUTO     XDATA  U_CHAR   0000H  1
  is_error . . . . . . . . . . . . . .  * REG *  DATA   U_CHAR   0007H  1
_Record_DTC_Clear. . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  ID . . . . . . . . . . . . . . . . .  * REG *  DATA   U_CHAR   0007H  1
_Diag_Read_Sys . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 513 

NAME                                    CLASS   MSPACE  TYPE    OFFSET  SIZE
====                                    =====   ======  ====    ======  ====


  ID . . . . . . . . . . . . . . . . .  AUTO     XDATA  U_CHAR   0000H  1
  Buf. . . . . . . . . . . . . . . . .  AUTO     XDATA  PTR      0001H  3
  Length . . . . . . . . . . . . . . .  AUTO     XDATA  U_CHAR   0004H  1
  ret. . . . . . . . . . . . . . . . .  AUTO     XDATA  U_CHAR   0005H  1
  ret16. . . . . . . . . . . . . . . .  AUTO     XDATA  U_INT    0006H  2
  Flash_Data . . . . . . . . . . . . .  AUTO     XDATA  ARRAY    0008H  3
  temp_buf . . . . . . . . . . . . . .  AUTO     XDATA  ARRAY    000BH  18
_Diag_Write_Sys. . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  Write_Buf. . . . . . . . . . . . . .  AUTO     XDATA  PTR      0000H  3
  Length . . . . . . . . . . . . . . .  AUTO     XDATA  U_CHAR   0003H  1
  i. . . . . . . . . . . . . . . . . .  AUTO     XDATA  U_CHAR   0004H  1
  Cs . . . . . . . . . . . . . . . . .  AUTO     XDATA  U_CHAR   0005H  1
  Cs_size. . . . . . . . . . . . . . .  AUTO     XDATA  U_CHAR   0006H  1
  len. . . . . . . . . . . . . . . . .  AUTO     XDATA  U_CHAR   0007H  1
  Buf. . . . . . . . . . . . . . . . .  AUTO     XDATA  ARRAY    0008H  39
Firmware_Update. . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
_Diag_Write_Transfer_Data. . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  Buf. . . . . . . . . . . . . . . . .  AUTO     XDATA  PTR      0000H  3
  address. . . . . . . . . . . . . . .  AUTO     XDATA  U_LONG   0003H  4
  cnt. . . . . . . . . . . . . . . . .  STATIC   XDATA  U_LONG   0000H  4
  erase_cnt. . . . . . . . . . . . . .  STATIC   XDATA  U_LONG   0004H  4
  lotation . . . . . . . . . . . . . .  STATIC   XDATA  U_LONG   0008H  4
  Buf1 . . . . . . . . . . . . . . . .  STATIC   XDATA  ARRAY    000CH  256
  Buf2 . . . . . . . . . . . . . . . .  STATIC   XDATA  ARRAY    010CH  256
  buf1_index . . . . . . . . . . . . .  STATIC   XDATA  U_CHAR   020CH  1
  buf2_index . . . . . . . . . . . . .  STATIC   XDATA  U_CHAR   020DH  1
  loop_index . . . . . . . . . . . . .  STATIC   XDATA  U_CHAR   020EH  1
  Write_Buf. . . . . . . . . . . . . .  AUTO     XDATA  ARRAY    0007H  256
Diag_DTC_Set_On. . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
Diag_DTC_Set_Off . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
Flash_DTC_Write. . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  ret. . . . . . . . . . . . . . . . .  AUTO     XDATA  U_CHAR   0000H  1
  i. . . . . . . . . . . . . . . . . .  AUTO     XDATA  U_CHAR   0001H  1
  Cs . . . . . . . . . . . . . . . . .  AUTO     XDATA  U_CHAR   0002H  1
  Write_Buf. . . . . . . . . . . . . .  AUTO     XDATA  ARRAY    0003H  26
  Read_Buf . . . . . . . . . . . . . .  AUTO     XDATA  ARRAY    001DH  26
  Write_Address. . . . . . . . . . . .  AUTO     XDATA  U_INT    0037H  2
  Read_Address . . . . . . . . . . . .  AUTO     XDATA  U_INT    0039H  2
  temp_Address1. . . . . . . . . . . .  AUTO     XDATA  U_INT    003BH  2
  temp_Address2. . . . . . . . . . . .  AUTO     XDATA  U_INT    003DH  2
Flash_DTC_Read . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  i. . . . . . . . . . . . . . . . . .  AUTO     XDATA  U_CHAR   0000H  1
  Cs . . . . . . . . . . . . . . . . .  AUTO     XDATA  U_CHAR   0001H  1
  Read_Buf . . . . . . . . . . . . . .  AUTO     XDATA  ARRAY    0002H  26
  Read_Address . . . . . . . . . . . .  AUTO     XDATA  U_INT    001CH  2
  temp_Address1. . . . . . . . . . . .  AUTO     XDATA  U_INT    001EH  2
  temp_Address2. . . . . . . . . . . .  AUTO     XDATA  U_INT    0020H  2
Diag_Exit_Update . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
Diag_Get_Time. . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  Cur_Time . . . . . . . . . . . . . .  AUTO     XDATA  U_INT    0000H  2
_SYS_Flash_Read. . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  ID . . . . . . . . . . . . . . . . .  AUTO     XDATA  U_CHAR   0000H  1
  Read_Buf . . . . . . . . . . . . . .  AUTO     XDATA  PTR      0001H  3
  Length . . . . . . . . . . . . . . .  AUTO     XDATA  U_CHAR   0004H  1
  i. . . . . . . . . . . . . . . . . .  AUTO     XDATA  U_CHAR   0005H  1
  Cs . . . . . . . . . . . . . . . . .  AUTO     XDATA  U_CHAR   0006H  1
  Buf. . . . . . . . . . . . . . . . .  AUTO     XDATA  ARRAY    0007H  38
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 514 

NAME                                    CLASS   MSPACE  TYPE    OFFSET  SIZE
====                                    =====   ======  ====    ======  ====


_Diag_Read_Address . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  Read_Buf . . . . . . . . . . . . . .  AUTO     XDATA  PTR      0000H  3
  DataAddr . . . . . . . . . . . . . .  AUTO     XDATA  U_LONG   0003H  4
  DataLen. . . . . . . . . . . . . . .  AUTO     XDATA  U_INT    0007H  2
  DataBuf. . . . . . . . . . . . . . .  AUTO     XDATA  ARRAY    0009H  16
  CodeBank1. . . . . . . . . . . . . .  AUTO     XDATA  U_CHAR   0019H  1
  CodeBank2. . . . . . . . . . . . . .  AUTO     XDATA  U_CHAR   001AH  1
  Read_Address1. . . . . . . . . . . .  AUTO     XDATA  U_INT    001BH  2
  Read_Address2. . . . . . . . . . . .  AUTO     XDATA  U_INT    001DH  2
  Length1. . . . . . . . . . . . . . .  AUTO     XDATA  U_INT    001FH  2
  Length2. . . . . . . . . . . . . . .  AUTO     XDATA  U_INT    0021H  2
_Diag_Extra_Data_Process . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  Write_Buf. . . . . . . . . . . . . .  AUTO     XDATA  PTR      0000H  3
  i. . . . . . . . . . . . . . . . . .  AUTO     XDATA  U_CHAR   0003H  1
  Cs . . . . . . . . . . . . . . . . .  AUTO     XDATA  U_CHAR   0004H  1
  Buf. . . . . . . . . . . . . . . . .  AUTO     XDATA  ARRAY    0005H  6
Diag_Eeprom_Update . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
Diag_Calibration_Mode_start. . . . . .  PUBLIC   CODE   PROC     0000H  -----
_Diag_Calibration_Mode . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  Ctrl_Para. . . . . . . . . . . . . .  AUTO     XDATA  U_CHAR   0000H  1
  i. . . . . . . . . . . . . . . . . .  AUTO     XDATA  U_CHAR   0001H  1
  Cs . . . . . . . . . . . . . . . . .  AUTO     XDATA  U_CHAR   0002H  1
  X_Axis . . . . . . . . . . . . . . .  AUTO     XDATA  U_CHAR   0003H  1
  Y_Axis . . . . . . . . . . . . . . .  AUTO     XDATA  U_CHAR   0004H  1
tCAN_Rx_Msg. . . . . . . . . . . . . .  EXTERN   XDATA  ARRAY    -----  88
CalibrationMode_OnOff. . . . . . . . .  PUBLIC   XDATA  U_CHAR   020FH  1
OpticOffset_Set. . . . . . . . . . . .  PUBLIC   XDATA  U_CHAR   0210H  1
tMsg_DTC_Type. . . . . . . . . . . . .  TYPEDEF  -----  STRUCT   -----  2
  Status . . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0000H  1
  Count. . . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0001H  1
tMsg_Ext_DTC_Type. . . . . . . . . . .  TYPEDEF  -----  STRUCT   -----  25
  tDTC_Type. . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  18
  DTC_Clear_Count. . . . . . . . . . .  MEMBER   -----  ARRAY    0012H  3
  DTC_State. . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0015H  3
  Checksum . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0018H  1
tMsg_Update. . . . . . . . . . . . . .  TYPEDEF  -----  STRUCT   -----  15
  update_set . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0000H  1
  write_count. . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0001H  1
  erase_set. . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0002H  1
  total_write_cnt. . . . . . . . . . .  MEMBER   -----  U_LONG   0003H  4
  write_cnt. . . . . . . . . . . . . .  MEMBER   -----  U_LONG   0007H  4
  size . . . . . . . . . . . . . . . .  MEMBER   -----  U_LONG   000BH  4
ga_Ext_tDTC_Type_Msg . . . . . . . . .  PUBLIC   XDATA  STRUCT   0211H  25
FLADDR . . . . . . . . . . . . . . . .  TYPEDEF  -----  U_INT    -----  2
_FLASH_Write_Buf . . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
_FLASH_Read_Buf. . . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
_FLASH_Erase_Buf . . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
Init_IspTask . . . . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
Isp_InterInit. . . . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
Isp_Off. . . . . . . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
_isp_guide_on_off. . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
tMsg_ISP_Function. . . . . . . . . . .  TYPEDEF  -----  STRUCT   -----  12
  IGNSw. . . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0000H  1
  Pre_Gear . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0001H  1
  Cur_Gear . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0002H  1
  Pre_RVM_CamOff . . . . . . . . . . .  MEMBER   -----  U_CHAR   0003H  1
  Cur_RVM_CamOff . . . . . . . . . . .  MEMBER   -----  U_CHAR   0004H  1
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 515 

NAME                                    CLASS   MSPACE  TYPE    OFFSET  SIZE
====                                    =====   ======  ====    ======  ====


  Pre_RVM_SW . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0005H  1
  Cur_RVM_SW . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0006H  1
  Pre_SW_IND . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0007H  1
  Cur_SW_IND . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0008H  1
  Pre_ViewMode . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0009H  1
  Cur_ViewMode . . . . . . . . . . . .  MEMBER   -----  U_CHAR   000AH  1
  RVM_SW_Status. . . . . . . . . . . .  MEMBER   -----  U_CHAR   000BH  1
size_t . . . . . . . . . . . . . . . .  TYPEDEF  -----  U_INT    -----  2
vuint8 . . . . . . . . . . . . . . . .  TYPEDEF  -----  U_CHAR   -----  1
vsint8 . . . . . . . . . . . . . . . .  TYPEDEF  -----  CHAR     -----  1
vuint16. . . . . . . . . . . . . . . .  TYPEDEF  -----  U_INT    -----  2
vsint16. . . . . . . . . . . . . . . .  TYPEDEF  -----  INT      -----  2
vuint32. . . . . . . . . . . . . . . .  TYPEDEF  -----  U_LONG   -----  4
vsint32. . . . . . . . . . . . . . . .  TYPEDEF  -----  LONG     -----  4
TxDataPtr. . . . . . . . . . . . . . .  TYPEDEF  -----  PTR      -----  3
RxDataPtr. . . . . . . . . . . . . . .  TYPEDEF  -----  PTR      -----  3
vbittype . . . . . . . . . . . . . . .  TYPEDEF  -----  U_CHAR   -----  1
_c_bits8 . . . . . . . . . . . . . . .  * TAG *  -----  STRUCT   -----  1
  b0 . . . . . . . . . . . . . . . . .  MEMBER   -----  FIELD    0000H  1.0
  b1 . . . . . . . . . . . . . . . . .  MEMBER   -----  FIELD    0000H  1.1
  b2 . . . . . . . . . . . . . . . . .  MEMBER   -----  FIELD    0000H  1.2
  b3 . . . . . . . . . . . . . . . . .  MEMBER   -----  FIELD    0000H  1.3
  b4 . . . . . . . . . . . . . . . . .  MEMBER   -----  FIELD    0000H  1.4
  b5 . . . . . . . . . . . . . . . . .  MEMBER   -----  FIELD    0000H  1.5
  b6 . . . . . . . . . . . . . . . . .  MEMBER   -----  FIELD    0000H  1.6
  b7 . . . . . . . . . . . . . . . . .  MEMBER   -----  FIELD    0000H  1.7
_c_bits16. . . . . . . . . . . . . . .  * TAG *  -----  STRUCT   -----  2
  b0 . . . . . . . . . . . . . . . . .  MEMBER   -----  FIELD    0000H  1.0
  b1 . . . . . . . . . . . . . . . . .  MEMBER   -----  FIELD    0000H  1.1
  b2 . . . . . . . . . . . . . . . . .  MEMBER   -----  FIELD    0000H  1.2
  b3 . . . . . . . . . . . . . . . . .  MEMBER   -----  FIELD    0000H  1.3
  b4 . . . . . . . . . . . . . . . . .  MEMBER   -----  FIELD    0000H  1.4
  b5 . . . . . . . . . . . . . . . . .  MEMBER   -----  FIELD    0000H  1.5
  b6 . . . . . . . . . . . . . . . . .  MEMBER   -----  FIELD    0000H  1.6
  b7 . . . . . . . . . . . . . . . . .  MEMBER   -----  FIELD    0000H  1.7
  b10. . . . . . . . . . . . . . . . .  MEMBER   -----  FIELD    0001H  1.0
  b11. . . . . . . . . . . . . . . . .  MEMBER   -----  FIELD    0001H  1.1
  b12. . . . . . . . . . . . . . . . .  MEMBER   -----  FIELD    0001H  1.2
  b13. . . . . . . . . . . . . . . . .  MEMBER   -----  FIELD    0001H  1.3
  b14. . . . . . . . . . . . . . . . .  MEMBER   -----  FIELD    0001H  1.4
  b15. . . . . . . . . . . . . . . . .  MEMBER   -----  FIELD    0001H  1.5
  b16. . . . . . . . . . . . . . . . .  MEMBER   -----  FIELD    0001H  1.6
  b17. . . . . . . . . . . . . . . . .  MEMBER   -----  FIELD    0001H  1.7
_c_bits32. . . . . . . . . . . . . . .  * TAG *  -----  STRUCT   -----  4
  b0 . . . . . . . . . . . . . . . . .  MEMBER   -----  FIELD    0000H  1.0
  b1 . . . . . . . . . . . . . . . . .  MEMBER   -----  FIELD    0000H  1.1
  b2 . . . . . . . . . . . . . . . . .  MEMBER   -----  FIELD    0000H  1.2
  b3 . . . . . . . . . . . . . . . . .  MEMBER   -----  FIELD    0000H  1.3
  b4 . . . . . . . . . . . . . . . . .  MEMBER   -----  FIELD    0000H  1.4
  b5 . . . . . . . . . . . . . . . . .  MEMBER   -----  FIELD    0000H  1.5
  b6 . . . . . . . . . . . . . . . . .  MEMBER   -----  FIELD    0000H  1.6
  b7 . . . . . . . . . . . . . . . . .  MEMBER   -----  FIELD    0000H  1.7
  b10. . . . . . . . . . . . . . . . .  MEMBER   -----  FIELD    0001H  1.0
  b11. . . . . . . . . . . . . . . . .  MEMBER   -----  FIELD    0001H  1.1
  b12. . . . . . . . . . . . . . . . .  MEMBER   -----  FIELD    0001H  1.2
  b13. . . . . . . . . . . . . . . . .  MEMBER   -----  FIELD    0001H  1.3
  b14. . . . . . . . . . . . . . . . .  MEMBER   -----  FIELD    0001H  1.4
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 516 

NAME                                    CLASS   MSPACE  TYPE    OFFSET  SIZE
====                                    =====   ======  ====    ======  ====


  b15. . . . . . . . . . . . . . . . .  MEMBER   -----  FIELD    0001H  1.5
  b16. . . . . . . . . . . . . . . . .  MEMBER   -----  FIELD    0001H  1.6
  b17. . . . . . . . . . . . . . . . .  MEMBER   -----  FIELD    0001H  1.7
  b20. . . . . . . . . . . . . . . . .  MEMBER   -----  FIELD    0002H  1.0
  b21. . . . . . . . . . . . . . . . .  MEMBER   -----  FIELD    0002H  1.1
  b22. . . . . . . . . . . . . . . . .  MEMBER   -----  FIELD    0002H  1.2
  b23. . . . . . . . . . . . . . . . .  MEMBER   -----  FIELD    0002H  1.3
  b24. . . . . . . . . . . . . . . . .  MEMBER   -----  FIELD    0002H  1.4
  b25. . . . . . . . . . . . . . . . .  MEMBER   -----  FIELD    0002H  1.5
  b26. . . . . . . . . . . . . . . . .  MEMBER   -----  FIELD    0002H  1.6
  b27. . . . . . . . . . . . . . . . .  MEMBER   -----  FIELD    0002H  1.7
  b30. . . . . . . . . . . . . . . . .  MEMBER   -----  FIELD    0003H  1.0
  b31. . . . . . . . . . . . . . . . .  MEMBER   -----  FIELD    0003H  1.1
  b32. . . . . . . . . . . . . . . . .  MEMBER   -----  FIELD    0003H  1.2
  b33. . . . . . . . . . . . . . . . .  MEMBER   -----  FIELD    0003H  1.3
  b34. . . . . . . . . . . . . . . . .  MEMBER   -----  FIELD    0003H  1.4
  b35. . . . . . . . . . . . . . . . .  MEMBER   -----  FIELD    0003H  1.5
  b36. . . . . . . . . . . . . . . . .  MEMBER   -----  FIELD    0003H  1.6
  b37. . . . . . . . . . . . . . . . .  MEMBER   -----  FIELD    0003H  1.7
VSTDLIB_IE . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00A8H  1
tVStdIrqStateType. . . . . . . . . . .  TYPEDEF  -----  U_CHAR   -----  1
tDBCVersionTag . . . . . . . . . . . .  * TAG *  -----  STRUCT   -----  8
  kYear. . . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0000H  1
  kMonth . . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0001H  1
  kWeek. . . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0002H  1
  kDay . . . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0003H  1
  kNumber. . . . . . . . . . . . . . .  MEMBER   -----  U_LONG   0004H  4
tDBCVersion. . . . . . . . . . . . . .  TYPEDEF  -----  STRUCT   -----  8
  kYear. . . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0000H  1
  kMonth . . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0001H  1
  kWeek. . . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0002H  1
  kDay . . . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0003H  1
  kNumber. . . . . . . . . . . . . . .  MEMBER   -----  U_LONG   0004H  4
tCanQueueElementType . . . . . . . . .  TYPEDEF  -----  U_CHAR   -----  1
CanChipDataPtr . . . . . . . . . . . .  TYPEDEF  -----  PTR      -----  3
CanChipMsgPtr. . . . . . . . . . . . .  TYPEDEF  -----  PTR      -----  3
CanChipRegPtr. . . . . . . . . . . . .  TYPEDEF  -----  PTR      -----  3
CanChipReg16Ptr. . . . . . . . . . . .  TYPEDEF  -----  PTR      -----  3
CanChipReg32Ptr. . . . . . . . . . . .  TYPEDEF  -----  PTR      -----  3
CanIntCtrl8Ptr . . . . . . . . . . . .  TYPEDEF  -----  PTR      -----  3
CanIntCtrl16Ptr. . . . . . . . . . . .  TYPEDEF  -----  PTR      -----  3
CanInitHandle. . . . . . . . . . . . .  TYPEDEF  -----  U_CHAR   -----  1
CanChannelHandle . . . . . . . . . . .  TYPEDEF  -----  U_CHAR   -----  1
CanObjectHandle. . . . . . . . . . . .  TYPEDEF  -----  U_CHAR   -----  1
CanTransmitHandle. . . . . . . . . . .  TYPEDEF  -----  U_INT    -----  2
CanReceiveHandle . . . . . . . . . . .  TYPEDEF  -----  U_INT    -----  2
CanSignedTxHandle. . . . . . . . . . .  TYPEDEF  -----  CHAR     -----  1
CanSignedRxHandle. . . . . . . . . . .  TYPEDEF  -----  CHAR     -----  1
tCanTxId0. . . . . . . . . . . . . . .  TYPEDEF  -----  U_INT    -----  2
tCanIdType . . . . . . . . . . . . . .  TYPEDEF  -----  U_INT    -----  2
tCanRxId0. . . . . . . . . . . . . . .  TYPEDEF  -----  U_INT    -----  2
tCanHLIntOld . . . . . . . . . . . . .  TYPEDEF  -----  U_CHAR   -----  1
tCanLLCanIntOld. . . . . . . . . . . .  TYPEDEF  -----  U_CHAR   -----  1
tCanMsgTransmitStruct. . . . . . . . .  TYPEDEF  -----  STRUCT   -----  14
  IdRaw. . . . . . . . . . . . . . . .  MEMBER   -----  U_INT    0000H  2
  IdRawExt . . . . . . . . . . . . . .  MEMBER   -----  U_INT    0002H  2
  reserved . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0004H  1
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 517 

NAME                                    CLASS   MSPACE  TYPE    OFFSET  SIZE
====                                    =====   ======  ====    ======  ====


  DlcRaw . . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0005H  1
  DataFld. . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0006H  8
tTxMsgObj. . . . . . . . . . . . . . .  TYPEDEF  -----  STRUCT   -----  14
  Id . . . . . . . . . . . . . . . . .  MEMBER   -----  UNION    0000H  4
  Dlc. . . . . . . . . . . . . . . . .  MEMBER   -----  U_INT    0004H  2
  Data . . . . . . . . . . . . . . . .  MEMBER   -----  UNION    0006H  8
tRxMsgObj. . . . . . . . . . . . . . .  TYPEDEF  -----  STRUCT   -----  16
  Id . . . . . . . . . . . . . . . . .  MEMBER   -----  UNION    0000H  4
  Dlc. . . . . . . . . . . . . . . . .  MEMBER   -----  U_INT    0004H  2
  Data . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0006H  8
  MessageCntrl . . . . . . . . . . . .  MEMBER   -----  U_INT    000EH  2
tCanTxInfoStruct . . . . . . . . . . .  TYPEDEF  -----  STRUCT   -----  5
  pChipData. . . . . . . . . . . . . .  MEMBER   -----  PTR      0000H  3
  Handle . . . . . . . . . . . . . . .  MEMBER   -----  U_INT    0003H  2
tCanTxConfInfoStruct . . . . . . . . .  TYPEDEF  -----  STRUCT   -----  9
  Channel. . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0000H  1
  Handle . . . . . . . . . . . . . . .  MEMBER   -----  U_INT    0001H  2
  pChipMsgObj. . . . . . . . . . . . .  MEMBER   -----  PTR      0003H  3
  pChipData. . . . . . . . . . . . . .  MEMBER   -----  PTR      0006H  3
tCanRxInfoStruct . . . . . . . . . . .  TYPEDEF  -----  STRUCT   -----  9
  Channel. . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0000H  1
  pChipMsgObj. . . . . . . . . . . . .  MEMBER   -----  PTR      0001H  3
  pChipData. . . . . . . . . . . . . .  MEMBER   -----  PTR      0004H  3
  Handle . . . . . . . . . . . . . . .  MEMBER   -----  U_INT    0007H  2
CanRxInfoStructPtr . . . . . . . . . .  TYPEDEF  -----  PTR      -----  3
CanTxInfoStruct. . . . . . . . . . . .  TYPEDEF  -----  STRUCT   -----  5
  pChipData. . . . . . . . . . . . . .  MEMBER   -----  PTR      0000H  3
  Handle . . . . . . . . . . . . . . .  MEMBER   -----  U_INT    0003H  2
CanTxInfoStructPtr . . . . . . . . . .  TYPEDEF  -----  PTR      -----  3
ApplCanMsgRcvFct . . . . . . . . . . .  TYPEDEF  -----  PTR      -----  3
ApplRangeFct . . . . . . . . . . . . .  TYPEDEF  -----  PTR      -----  3
ApplPrecopyFct . . . . . . . . . . . .  TYPEDEF  -----  PTR      -----  3
ApplIndicationFct. . . . . . . . . . .  TYPEDEF  -----  PTR      -----  3
ApplConfirmationFct. . . . . . . . . .  TYPEDEF  -----  PTR      -----  3
ApplPreTransmitFct . . . . . . . . . .  TYPEDEF  -----  PTR      -----  3
ApplChannelFct . . . . . . . . . . . .  TYPEDEF  -----  PTR      -----  3
tCanStructRxIdType . . . . . . . . . .  TYPEDEF  -----  STRUCT   -----  2
  Id0. . . . . . . . . . . . . . . . .  MEMBER   -----  U_INT    0000H  2
_c_MDPS11_msgTypeTag . . . . . . . . .  * TAG *  -----  STRUCT   -----  8
  unused0. . . . . . . . . . . . . . .  MEMBER   -----  FIELD    0000H  8.0
  unused1. . . . . . . . . . . . . . .  MEMBER   -----  FIELD    0001H  8.0
  unused2. . . . . . . . . . . . . . .  MEMBER   -----  FIELD    0002H  8.0
  unused3. . . . . . . . . . . . . . .  MEMBER   -----  FIELD    0003H  8.0
  unused4. . . . . . . . . . . . . . .  MEMBER   -----  FIELD    0004H  8.0
  unused5. . . . . . . . . . . . . . .  MEMBER   -----  FIELD    0005H  8.0
  unused6. . . . . . . . . . . . . . .  MEMBER   -----  FIELD    0006H  8.0
  unused7. . . . . . . . . . . . . . .  MEMBER   -----  FIELD    0007H  5.0
  CF_Mdps_Type . . . . . . . . . . . .  MEMBER   -----  FIELD    0007H  2.5
  unused8. . . . . . . . . . . . . . .  MEMBER   -----  FIELD    0007H  1.7
_c_MDPS11_msgType. . . . . . . . . . .  TYPEDEF  -----  STRUCT   -----  8
  unused0. . . . . . . . . . . . . . .  MEMBER   -----  FIELD    0000H  8.0
  unused1. . . . . . . . . . . . . . .  MEMBER   -----  FIELD    0001H  8.0
  unused2. . . . . . . . . . . . . . .  MEMBER   -----  FIELD    0002H  8.0
  unused3. . . . . . . . . . . . . . .  MEMBER   -----  FIELD    0003H  8.0
  unused4. . . . . . . . . . . . . . .  MEMBER   -----  FIELD    0004H  8.0
  unused5. . . . . . . . . . . . . . .  MEMBER   -----  FIELD    0005H  8.0
  unused6. . . . . . . . . . . . . . .  MEMBER   -----  FIELD    0006H  8.0
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 518 

NAME                                    CLASS   MSPACE  TYPE    OFFSET  SIZE
====                                    =====   ======  ====    ======  ====


  unused7. . . . . . . . . . . . . . .  MEMBER   -----  FIELD    0007H  5.0
  CF_Mdps_Type . . . . . . . . . . . .  MEMBER   -----  FIELD    0007H  2.5
  unused8. . . . . . . . . . . . . . .  MEMBER   -----  FIELD    0007H  1.7
_c_HU_MON_PE_01_msgTypeTag . . . . . .  * TAG *  -----  STRUCT   -----  1
  HU_TYPE. . . . . . . . . . . . . . .  MEMBER   -----  FIELD    0000H  8.0
_c_HU_MON_PE_01_msgType. . . . . . . .  TYPEDEF  -----  STRUCT   -----  1
  HU_TYPE. . . . . . . . . . . . . . .  MEMBER   -----  FIELD    0000H  8.0
_c_CGW4_msgTypeTag . . . . . . . . . .  * TAG *  -----  STRUCT   -----  7
  unused0. . . . . . . . . . . . . . .  MEMBER   -----  FIELD    0000H  8.0
  unused1. . . . . . . . . . . . . . .  MEMBER   -----  FIELD    0001H  8.0
  unused2. . . . . . . . . . . . . . .  MEMBER   -----  FIELD    0002H  8.0
  unused3. . . . . . . . . . . . . . .  MEMBER   -----  FIELD    0003H  8.0
  unused4. . . . . . . . . . . . . . .  MEMBER   -----  FIELD    0004H  8.0
  unused5. . . . . . . . . . . . . . .  MEMBER   -----  FIELD    0005H  8.0
  unused6. . . . . . . . . . . . . . .  MEMBER   -----  FIELD    0006H  7.0
  CF_Gway_Navi_On_Off. . . . . . . . .  MEMBER   -----  FIELD    0006H  1.7
_c_CGW4_msgType. . . . . . . . . . . .  TYPEDEF  -----  STRUCT   -----  7
  unused0. . . . . . . . . . . . . . .  MEMBER   -----  FIELD    0000H  8.0
  unused1. . . . . . . . . . . . . . .  MEMBER   -----  FIELD    0001H  8.0
  unused2. . . . . . . . . . . . . . .  MEMBER   -----  FIELD    0002H  8.0
  unused3. . . . . . . . . . . . . . .  MEMBER   -----  FIELD    0003H  8.0
  unused4. . . . . . . . . . . . . . .  MEMBER   -----  FIELD    0004H  8.0
  unused5. . . . . . . . . . . . . . .  MEMBER   -----  FIELD    0005H  8.0
  unused6. . . . . . . . . . . . . . .  MEMBER   -----  FIELD    0006H  7.0
  CF_Gway_Navi_On_Off. . . . . . . . .  MEMBER   -----  FIELD    0006H  1.7
_c_CGW2_msgTypeTag . . . . . . . . . .  * TAG *  -----  STRUCT   -----  4
  unused0. . . . . . . . . . . . . . .  MEMBER   -----  FIELD    0000H  8.0
  unused1. . . . . . . . . . . . . . .  MEMBER   -----  FIELD    0001H  8.0
  unused2. . . . . . . . . . . . . . .  MEMBER   -----  FIELD    0002H  8.0
  unused3. . . . . . . . . . . . . . .  MEMBER   -----  FIELD    0003H  2.0
  CF_Gway_CountryCfg . . . . . . . . .  MEMBER   -----  FIELD    0003H  3.2
  unused4. . . . . . . . . . . . . . .  MEMBER   -----  FIELD    0003H  3.5
_c_CGW2_msgType. . . . . . . . . . . .  TYPEDEF  -----  STRUCT   -----  4
  unused0. . . . . . . . . . . . . . .  MEMBER   -----  FIELD    0000H  8.0
  unused1. . . . . . . . . . . . . . .  MEMBER   -----  FIELD    0001H  8.0
  unused2. . . . . . . . . . . . . . .  MEMBER   -----  FIELD    0002H  8.0
  unused3. . . . . . . . . . . . . . .  MEMBER   -----  FIELD    0003H  2.0
  CF_Gway_CountryCfg . . . . . . . . .  MEMBER   -----  FIELD    0003H  3.2
  unused4. . . . . . . . . . . . . . .  MEMBER   -----  FIELD    0003H  3.5
_c_CLU15_msgTypeTag. . . . . . . . . .  * TAG *  -----  STRUCT   -----  5
  unused0. . . . . . . . . . . . . . .  MEMBER   -----  FIELD    0000H  8.0
  unused1. . . . . . . . . . . . . . .  MEMBER   -----  FIELD    0001H  8.0
  unused2. . . . . . . . . . . . . . .  MEMBER   -----  FIELD    0002H  8.0
  unused3. . . . . . . . . . . . . . .  MEMBER   -----  FIELD    0003H  8.0
  unused4. . . . . . . . . . . . . . .  MEMBER   -----  FIELD    0004H  1.0
  CF_Clu_LanguageInfo. . . . . . . . .  MEMBER   -----  FIELD    0004H  5.1
  unused5. . . . . . . . . . . . . . .  MEMBER   -----  FIELD    0004H  2.6
_c_CLU15_msgType . . . . . . . . . . .  TYPEDEF  -----  STRUCT   -----  5
  unused0. . . . . . . . . . . . . . .  MEMBER   -----  FIELD    0000H  8.0
  unused1. . . . . . . . . . . . . . .  MEMBER   -----  FIELD    0001H  8.0
  unused2. . . . . . . . . . . . . . .  MEMBER   -----  FIELD    0002H  8.0
  unused3. . . . . . . . . . . . . . .  MEMBER   -----  FIELD    0003H  8.0
  unused4. . . . . . . . . . . . . . .  MEMBER   -----  FIELD    0004H  1.0
  CF_Clu_LanguageInfo. . . . . . . . .  MEMBER   -----  FIELD    0004H  5.1
  unused5. . . . . . . . . . . . . . .  MEMBER   -----  FIELD    0004H  2.6
_c_PGS_GST_msgTypeTag. . . . . . . . .  * TAG *  -----  STRUCT   -----  8
  PGS_GST_Byte0_TPCI . . . . . . . . .  MEMBER   -----  FIELD    0000H  8.0
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 519 

NAME                                    CLASS   MSPACE  TYPE    OFFSET  SIZE
====                                    =====   ======  ====    ======  ====


  PGS_GST_Byte1_Data . . . . . . . . .  MEMBER   -----  FIELD    0001H  8.0
  PGS_GST_Byte2_Data . . . . . . . . .  MEMBER   -----  FIELD    0002H  8.0
  PGS_GST_Byte3_Data . . . . . . . . .  MEMBER   -----  FIELD    0003H  8.0
  PGS_GST_Byte4_Data . . . . . . . . .  MEMBER   -----  FIELD    0004H  8.0
  PGS_GST_Byte5_Data . . . . . . . . .  MEMBER   -----  FIELD    0005H  8.0
  PGS_GST_Byte6_Data . . . . . . . . .  MEMBER   -----  FIELD    0006H  8.0
  PGS_GST_Byte7_Data . . . . . . . . .  MEMBER   -----  FIELD    0007H  8.0
_c_PGS_GST_msgType . . . . . . . . . .  TYPEDEF  -----  STRUCT   -----  8
  PGS_GST_Byte0_TPCI . . . . . . . . .  MEMBER   -----  FIELD    0000H  8.0
  PGS_GST_Byte1_Data . . . . . . . . .  MEMBER   -----  FIELD    0001H  8.0
  PGS_GST_Byte2_Data . . . . . . . . .  MEMBER   -----  FIELD    0002H  8.0
  PGS_GST_Byte3_Data . . . . . . . . .  MEMBER   -----  FIELD    0003H  8.0
  PGS_GST_Byte4_Data . . . . . . . . .  MEMBER   -----  FIELD    0004H  8.0
  PGS_GST_Byte5_Data . . . . . . . . .  MEMBER   -----  FIELD    0005H  8.0
  PGS_GST_Byte6_Data . . . . . . . . .  MEMBER   -----  FIELD    0006H  8.0
  PGS_GST_Byte7_Data . . . . . . . . .  MEMBER   -----  FIELD    0007H  8.0
_c_SAS1_msgTypeTag . . . . . . . . . .  * TAG *  -----  STRUCT   -----  2
  SAS_Angle_0. . . . . . . . . . . . .  MEMBER   -----  FIELD    0000H  8.0
  SAS_Angle_1. . . . . . . . . . . . .  MEMBER   -----  FIELD    0001H  8.0
_c_SAS1_msgType. . . . . . . . . . . .  TYPEDEF  -----  STRUCT   -----  2
  SAS_Angle_0. . . . . . . . . . . . .  MEMBER   -----  FIELD    0000H  8.0
  SAS_Angle_1. . . . . . . . . . . . .  MEMBER   -----  FIELD    0001H  8.0
_c_MDPS11_bufTag . . . . . . . . . . .  * TAG *  -----  UNION    -----  8
  _c . . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  8
  MDPS11 . . . . . . . . . . . . . . .  MEMBER   -----  STRUCT   0000H  8
_c_MDPS11_buf. . . . . . . . . . . . .  TYPEDEF  -----  UNION    -----  8
  _c . . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  8
  MDPS11 . . . . . . . . . . . . . . .  MEMBER   -----  STRUCT   0000H  8
_c_HU_MON_PE_01_bufTag . . . . . . . .  * TAG *  -----  UNION    -----  1
  _c . . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  1
  HU_MON_PE_01 . . . . . . . . . . . .  MEMBER   -----  STRUCT   0000H  1
_c_HU_MON_PE_01_buf. . . . . . . . . .  TYPEDEF  -----  UNION    -----  1
  _c . . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  1
  HU_MON_PE_01 . . . . . . . . . . . .  MEMBER   -----  STRUCT   0000H  1
_c_CGW4_bufTag . . . . . . . . . . . .  * TAG *  -----  UNION    -----  7
  _c . . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  7
  CGW4 . . . . . . . . . . . . . . . .  MEMBER   -----  STRUCT   0000H  7
_c_CGW4_buf. . . . . . . . . . . . . .  TYPEDEF  -----  UNION    -----  7
  _c . . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  7
  CGW4 . . . . . . . . . . . . . . . .  MEMBER   -----  STRUCT   0000H  7
_c_CGW2_bufTag . . . . . . . . . . . .  * TAG *  -----  UNION    -----  4
  _c . . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  4
  CGW2 . . . . . . . . . . . . . . . .  MEMBER   -----  STRUCT   0000H  4
_c_CGW2_buf. . . . . . . . . . . . . .  TYPEDEF  -----  UNION    -----  4
  _c . . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  4
  CGW2 . . . . . . . . . . . . . . . .  MEMBER   -----  STRUCT   0000H  4
_c_CLU15_bufTag. . . . . . . . . . . .  * TAG *  -----  UNION    -----  5
  _c . . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  5
  CLU15. . . . . . . . . . . . . . . .  MEMBER   -----  STRUCT   0000H  5
_c_CLU15_buf . . . . . . . . . . . . .  TYPEDEF  -----  UNION    -----  5
  _c . . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  5
  CLU15. . . . . . . . . . . . . . . .  MEMBER   -----  STRUCT   0000H  5
_c_PGS_GST_bufTag. . . . . . . . . . .  * TAG *  -----  UNION    -----  8
  _c . . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  8
  PGS_GST. . . . . . . . . . . . . . .  MEMBER   -----  STRUCT   0000H  8
_c_PGS_GST_buf . . . . . . . . . . . .  TYPEDEF  -----  UNION    -----  8
  _c . . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  8
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 520 

NAME                                    CLASS   MSPACE  TYPE    OFFSET  SIZE
====                                    =====   ======  ====    ======  ====


  PGS_GST. . . . . . . . . . . . . . .  MEMBER   -----  STRUCT   0000H  8
_c_SAS1_bufTag . . . . . . . . . . . .  * TAG *  -----  UNION    -----  2
  _c . . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  2
  SAS1 . . . . . . . . . . . . . . . .  MEMBER   -----  STRUCT   0000H  2
_c_SAS1_buf. . . . . . . . . . . . . .  TYPEDEF  -----  UNION    -----  2
  _c . . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  2
  SAS1 . . . . . . . . . . . . . . . .  MEMBER   -----  STRUCT   0000H  2
_c_PGS_GST_RDS_msgTypeTag. . . . . . .  * TAG *  -----  STRUCT   -----  8
  PGS_GST_Byte0_TPCI . . . . . . . . .  MEMBER   -----  FIELD    0000H  8.0
  PGS_GST_Byte1_Data . . . . . . . . .  MEMBER   -----  FIELD    0001H  8.0
  PGS_GST_Byte2_Data . . . . . . . . .  MEMBER   -----  FIELD    0002H  8.0
  PGS_GST_Byte3_Data . . . . . . . . .  MEMBER   -----  FIELD    0003H  8.0
  PGS_GST_Byte4_Data . . . . . . . . .  MEMBER   -----  FIELD    0004H  8.0
  PGS_GST_Byte5_Data . . . . . . . . .  MEMBER   -----  FIELD    0005H  8.0
  PGS_GST_Byte6_Data . . . . . . . . .  MEMBER   -----  FIELD    0006H  8.0
  PGS_GST_Byte7_Data . . . . . . . . .  MEMBER   -----  FIELD    0007H  8.0
_c_PGS_GST_RDS_msgType . . . . . . . .  TYPEDEF  -----  STRUCT   -----  8
  PGS_GST_Byte0_TPCI . . . . . . . . .  MEMBER   -----  FIELD    0000H  8.0
  PGS_GST_Byte1_Data . . . . . . . . .  MEMBER   -----  FIELD    0001H  8.0
  PGS_GST_Byte2_Data . . . . . . . . .  MEMBER   -----  FIELD    0002H  8.0
  PGS_GST_Byte3_Data . . . . . . . . .  MEMBER   -----  FIELD    0003H  8.0
  PGS_GST_Byte4_Data . . . . . . . . .  MEMBER   -----  FIELD    0004H  8.0
  PGS_GST_Byte5_Data . . . . . . . . .  MEMBER   -----  FIELD    0005H  8.0
  PGS_GST_Byte6_Data . . . . . . . . .  MEMBER   -----  FIELD    0006H  8.0
  PGS_GST_Byte7_Data . . . . . . . . .  MEMBER   -----  FIELD    0007H  8.0
_c_GST1_RDS_msgTypeTag . . . . . . . .  * TAG *  -----  STRUCT   -----  8
  FRM_FORMAT . . . . . . . . . . . . .  MEMBER   -----  FIELD    0000H  8.0
  SID. . . . . . . . . . . . . . . . .  MEMBER   -----  FIELD    0001H  8.0
  REQ_RESPONSE . . . . . . . . . . . .  MEMBER   -----  FIELD    0002H  8.0
  Reserved_GST1_1. . . . . . . . . . .  MEMBER   -----  FIELD    0003H  8.0
  Reserved_GST1_2. . . . . . . . . . .  MEMBER   -----  FIELD    0004H  8.0
  Reserved_GST1_3. . . . . . . . . . .  MEMBER   -----  FIELD    0005H  8.0
  Reserved_GST1_4. . . . . . . . . . .  MEMBER   -----  FIELD    0006H  8.0
  Reserved_GST1_5. . . . . . . . . . .  MEMBER   -----  FIELD    0007H  8.0
_c_GST1_RDS_msgType. . . . . . . . . .  TYPEDEF  -----  STRUCT   -----  8
  FRM_FORMAT . . . . . . . . . . . . .  MEMBER   -----  FIELD    0000H  8.0
  SID. . . . . . . . . . . . . . . . .  MEMBER   -----  FIELD    0001H  8.0
  REQ_RESPONSE . . . . . . . . . . . .  MEMBER   -----  FIELD    0002H  8.0
  Reserved_GST1_1. . . . . . . . . . .  MEMBER   -----  FIELD    0003H  8.0
  Reserved_GST1_2. . . . . . . . . . .  MEMBER   -----  FIELD    0004H  8.0
  Reserved_GST1_3. . . . . . . . . . .  MEMBER   -----  FIELD    0005H  8.0
  Reserved_GST1_4. . . . . . . . . . .  MEMBER   -----  FIELD    0006H  8.0
  Reserved_GST1_5. . . . . . . . . . .  MEMBER   -----  FIELD    0007H  8.0
_c_GST_PGS_RDS_msgTypeTag. . . . . . .  * TAG *  -----  STRUCT   -----  8
  GST_PGS_Byte0_TPCI . . . . . . . . .  MEMBER   -----  FIELD    0000H  8.0
  GST_PGS_Byte1_Data . . . . . . . . .  MEMBER   -----  FIELD    0001H  8.0
  GST_PGS_Byte2_Data . . . . . . . . .  MEMBER   -----  FIELD    0002H  8.0
  GST_PGS_Byte3_Data . . . . . . . . .  MEMBER   -----  FIELD    0003H  8.0
  GST_PGS_Byte4_Data . . . . . . . . .  MEMBER   -----  FIELD    0004H  8.0
  GST_PGS_Byte5_Data . . . . . . . . .  MEMBER   -----  FIELD    0005H  8.0
  GST_PGS_Byte6_Data . . . . . . . . .  MEMBER   -----  FIELD    0006H  8.0
  GST_PGS_Byte7_Data . . . . . . . . .  MEMBER   -----  FIELD    0007H  8.0
_c_GST_PGS_RDS_msgType . . . . . . . .  TYPEDEF  -----  STRUCT   -----  8
  GST_PGS_Byte0_TPCI . . . . . . . . .  MEMBER   -----  FIELD    0000H  8.0
  GST_PGS_Byte1_Data . . . . . . . . .  MEMBER   -----  FIELD    0001H  8.0
  GST_PGS_Byte2_Data . . . . . . . . .  MEMBER   -----  FIELD    0002H  8.0
  GST_PGS_Byte3_Data . . . . . . . . .  MEMBER   -----  FIELD    0003H  8.0
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 521 

NAME                                    CLASS   MSPACE  TYPE    OFFSET  SIZE
====                                    =====   ======  ====    ======  ====


  GST_PGS_Byte4_Data . . . . . . . . .  MEMBER   -----  FIELD    0004H  8.0
  GST_PGS_Byte5_Data . . . . . . . . .  MEMBER   -----  FIELD    0005H  8.0
  GST_PGS_Byte6_Data . . . . . . . . .  MEMBER   -----  FIELD    0006H  8.0
  GST_PGS_Byte7_Data . . . . . . . . .  MEMBER   -----  FIELD    0007H  8.0
_c_HU_MON_PE_01_RDS_msgTypeTag . . . .  * TAG *  -----  STRUCT   -----  1
  HU_TYPE. . . . . . . . . . . . . . .  MEMBER   -----  FIELD    0000H  8.0
_c_HU_MON_PE_01_RDS_msgType. . . . . .  TYPEDEF  -----  STRUCT   -----  1
  HU_TYPE. . . . . . . . . . . . . . .  MEMBER   -----  FIELD    0000H  8.0
_c_CGW4_RDS_msgTypeTag . . . . . . . .  * TAG *  -----  STRUCT   -----  7
  unused0. . . . . . . . . . . . . . .  MEMBER   -----  FIELD    0000H  8.0
  unused1. . . . . . . . . . . . . . .  MEMBER   -----  FIELD    0001H  8.0
  unused2. . . . . . . . . . . . . . .  MEMBER   -----  FIELD    0002H  8.0
  unused3. . . . . . . . . . . . . . .  MEMBER   -----  FIELD    0003H  8.0
  unused4. . . . . . . . . . . . . . .  MEMBER   -----  FIELD    0004H  8.0
  unused5. . . . . . . . . . . . . . .  MEMBER   -----  FIELD    0005H  8.0
  unused6. . . . . . . . . . . . . . .  MEMBER   -----  FIELD    0006H  7.0
  CF_Gway_Navi_On_Off. . . . . . . . .  MEMBER   -----  FIELD    0006H  1.7
_c_CGW4_RDS_msgType. . . . . . . . . .  TYPEDEF  -----  STRUCT   -----  7
  unused0. . . . . . . . . . . . . . .  MEMBER   -----  FIELD    0000H  8.0
  unused1. . . . . . . . . . . . . . .  MEMBER   -----  FIELD    0001H  8.0
  unused2. . . . . . . . . . . . . . .  MEMBER   -----  FIELD    0002H  8.0
  unused3. . . . . . . . . . . . . . .  MEMBER   -----  FIELD    0003H  8.0
  unused4. . . . . . . . . . . . . . .  MEMBER   -----  FIELD    0004H  8.0
  unused5. . . . . . . . . . . . . . .  MEMBER   -----  FIELD    0005H  8.0
  unused6. . . . . . . . . . . . . . .  MEMBER   -----  FIELD    0006H  7.0
  CF_Gway_Navi_On_Off. . . . . . . . .  MEMBER   -----  FIELD    0006H  1.7
_c_CGW2_RDS_msgTypeTag . . . . . . . .  * TAG *  -----  STRUCT   -----  4
  unused0. . . . . . . . . . . . . . .  MEMBER   -----  FIELD    0000H  8.0
  unused1. . . . . . . . . . . . . . .  MEMBER   -----  FIELD    0001H  8.0
  unused2. . . . . . . . . . . . . . .  MEMBER   -----  FIELD    0002H  8.0
  unused3. . . . . . . . . . . . . . .  MEMBER   -----  FIELD    0003H  2.0
  CF_Gway_CountryCfg . . . . . . . . .  MEMBER   -----  FIELD    0003H  3.2
  unused4. . . . . . . . . . . . . . .  MEMBER   -----  FIELD    0003H  3.5
_c_CGW2_RDS_msgType. . . . . . . . . .  TYPEDEF  -----  STRUCT   -----  4
  unused0. . . . . . . . . . . . . . .  MEMBER   -----  FIELD    0000H  8.0
  unused1. . . . . . . . . . . . . . .  MEMBER   -----  FIELD    0001H  8.0
  unused2. . . . . . . . . . . . . . .  MEMBER   -----  FIELD    0002H  8.0
  unused3. . . . . . . . . . . . . . .  MEMBER   -----  FIELD    0003H  2.0
  CF_Gway_CountryCfg . . . . . . . . .  MEMBER   -----  FIELD    0003H  3.2
  unused4. . . . . . . . . . . . . . .  MEMBER   -----  FIELD    0003H  3.5
_c_CLU15_RDS_msgTypeTag. . . . . . . .  * TAG *  -----  STRUCT   -----  5
  unused0. . . . . . . . . . . . . . .  MEMBER   -----  FIELD    0000H  8.0
  unused1. . . . . . . . . . . . . . .  MEMBER   -----  FIELD    0001H  8.0
  unused2. . . . . . . . . . . . . . .  MEMBER   -----  FIELD    0002H  8.0
  unused3. . . . . . . . . . . . . . .  MEMBER   -----  FIELD    0003H  8.0
  unused4. . . . . . . . . . . . . . .  MEMBER   -----  FIELD    0004H  1.0
  CF_Clu_LanguageInfo. . . . . . . . .  MEMBER   -----  FIELD    0004H  5.1
  unused5. . . . . . . . . . . . . . .  MEMBER   -----  FIELD    0004H  2.6
_c_CLU15_RDS_msgType . . . . . . . . .  TYPEDEF  -----  STRUCT   -----  5
  unused0. . . . . . . . . . . . . . .  MEMBER   -----  FIELD    0000H  8.0
  unused1. . . . . . . . . . . . . . .  MEMBER   -----  FIELD    0001H  8.0
  unused2. . . . . . . . . . . . . . .  MEMBER   -----  FIELD    0002H  8.0
  unused3. . . . . . . . . . . . . . .  MEMBER   -----  FIELD    0003H  8.0
  unused4. . . . . . . . . . . . . . .  MEMBER   -----  FIELD    0004H  1.0
  CF_Clu_LanguageInfo. . . . . . . . .  MEMBER   -----  FIELD    0004H  5.1
  unused5. . . . . . . . . . . . . . .  MEMBER   -----  FIELD    0004H  2.6
_c_MDPS11_RDS_msgTypeTag . . . . . . .  * TAG *  -----  STRUCT   -----  8
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 522 

NAME                                    CLASS   MSPACE  TYPE    OFFSET  SIZE
====                                    =====   ======  ====    ======  ====


  unused0. . . . . . . . . . . . . . .  MEMBER   -----  FIELD    0000H  8.0
  unused1. . . . . . . . . . . . . . .  MEMBER   -----  FIELD    0001H  8.0
  unused2. . . . . . . . . . . . . . .  MEMBER   -----  FIELD    0002H  8.0
  unused3. . . . . . . . . . . . . . .  MEMBER   -----  FIELD    0003H  8.0
  unused4. . . . . . . . . . . . . . .  MEMBER   -----  FIELD    0004H  8.0
  unused5. . . . . . . . . . . . . . .  MEMBER   -----  FIELD    0005H  8.0
  unused6. . . . . . . . . . . . . . .  MEMBER   -----  FIELD    0006H  8.0
  unused7. . . . . . . . . . . . . . .  MEMBER   -----  FIELD    0007H  5.0
  CF_Mdps_Type . . . . . . . . . . . .  MEMBER   -----  FIELD    0007H  2.5
  unused8. . . . . . . . . . . . . . .  MEMBER   -----  FIELD    0007H  1.7
_c_MDPS11_RDS_msgType. . . . . . . . .  TYPEDEF  -----  STRUCT   -----  8
  unused0. . . . . . . . . . . . . . .  MEMBER   -----  FIELD    0000H  8.0
  unused1. . . . . . . . . . . . . . .  MEMBER   -----  FIELD    0001H  8.0
  unused2. . . . . . . . . . . . . . .  MEMBER   -----  FIELD    0002H  8.0
  unused3. . . . . . . . . . . . . . .  MEMBER   -----  FIELD    0003H  8.0
  unused4. . . . . . . . . . . . . . .  MEMBER   -----  FIELD    0004H  8.0
  unused5. . . . . . . . . . . . . . .  MEMBER   -----  FIELD    0005H  8.0
  unused6. . . . . . . . . . . . . . .  MEMBER   -----  FIELD    0006H  8.0
  unused7. . . . . . . . . . . . . . .  MEMBER   -----  FIELD    0007H  5.0
  CF_Mdps_Type . . . . . . . . . . . .  MEMBER   -----  FIELD    0007H  2.5
  unused8. . . . . . . . . . . . . . .  MEMBER   -----  FIELD    0007H  1.7
_c_SAS1_RDS_msgTypeTag . . . . . . . .  * TAG *  -----  STRUCT   -----  2
  SAS_Angle_0. . . . . . . . . . . . .  MEMBER   -----  FIELD    0000H  8.0
  SAS_Angle_1. . . . . . . . . . . . .  MEMBER   -----  FIELD    0001H  8.0
_c_SAS1_RDS_msgType. . . . . . . . . .  TYPEDEF  -----  STRUCT   -----  2
  SAS_Angle_0. . . . . . . . . . . . .  MEMBER   -----  FIELD    0000H  8.0
  SAS_Angle_1. . . . . . . . . . . . .  MEMBER   -----  FIELD    0001H  8.0
_c_RDS1_bufTag . . . . . . . . . . . .  * TAG *  -----  UNION    -----  8
  _c . . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  8
  PGS_GST. . . . . . . . . . . . . . .  MEMBER   -----  STRUCT   0000H  8
_c_RDS1_buf. . . . . . . . . . . . . .  TYPEDEF  -----  UNION    -----  8
  _c . . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  8
  PGS_GST. . . . . . . . . . . . . . .  MEMBER   -----  STRUCT   0000H  8
_c_RDS23_bufTag. . . . . . . . . . . .  * TAG *  -----  UNION    -----  8
  _c . . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  8
  GST1 . . . . . . . . . . . . . . . .  MEMBER   -----  STRUCT   0000H  8
_c_RDS23_buf . . . . . . . . . . . . .  TYPEDEF  -----  UNION    -----  8
  _c . . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  8
  GST1 . . . . . . . . . . . . . . . .  MEMBER   -----  STRUCT   0000H  8
_c_RDS24_bufTag. . . . . . . . . . . .  * TAG *  -----  UNION    -----  8
  _c . . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  8
  GST_PGS. . . . . . . . . . . . . . .  MEMBER   -----  STRUCT   0000H  8
_c_RDS24_buf . . . . . . . . . . . . .  TYPEDEF  -----  UNION    -----  8
  _c . . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  8
  GST_PGS. . . . . . . . . . . . . . .  MEMBER   -----  STRUCT   0000H  8
_c_RDS25_bufTag. . . . . . . . . . . .  * TAG *  -----  UNION    -----  1
  _c . . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  1
  HU_MON_PE_01 . . . . . . . . . . . .  MEMBER   -----  STRUCT   0000H  1
_c_RDS25_buf . . . . . . . . . . . . .  TYPEDEF  -----  UNION    -----  1
  _c . . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  1
  HU_MON_PE_01 . . . . . . . . . . . .  MEMBER   -----  STRUCT   0000H  1
_c_RDS26_bufTag. . . . . . . . . . . .  * TAG *  -----  UNION    -----  7
  _c . . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  7
  CGW4 . . . . . . . . . . . . . . . .  MEMBER   -----  STRUCT   0000H  7
_c_RDS26_buf . . . . . . . . . . . . .  TYPEDEF  -----  UNION    -----  7
  _c . . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  7
  CGW4 . . . . . . . . . . . . . . . .  MEMBER   -----  STRUCT   0000H  7
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 523 

NAME                                    CLASS   MSPACE  TYPE    OFFSET  SIZE
====                                    =====   ======  ====    ======  ====


_c_RDS27_bufTag. . . . . . . . . . . .  * TAG *  -----  UNION    -----  4
  _c . . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  4
  CGW2 . . . . . . . . . . . . . . . .  MEMBER   -----  STRUCT   0000H  4
_c_RDS27_buf . . . . . . . . . . . . .  TYPEDEF  -----  UNION    -----  4
  _c . . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  4
  CGW2 . . . . . . . . . . . . . . . .  MEMBER   -----  STRUCT   0000H  4
_c_RDS28_bufTag. . . . . . . . . . . .  * TAG *  -----  UNION    -----  5
  _c . . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  5
  CLU15. . . . . . . . . . . . . . . .  MEMBER   -----  STRUCT   0000H  5
_c_RDS28_buf . . . . . . . . . . . . .  TYPEDEF  -----  UNION    -----  5
  _c . . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  5
  CLU15. . . . . . . . . . . . . . . .  MEMBER   -----  STRUCT   0000H  5
_c_RDS29_bufTag. . . . . . . . . . . .  * TAG *  -----  UNION    -----  8
  _c . . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  8
  MDPS11 . . . . . . . . . . . . . . .  MEMBER   -----  STRUCT   0000H  8
_c_RDS29_buf . . . . . . . . . . . . .  TYPEDEF  -----  UNION    -----  8
  _c . . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  8
  MDPS11 . . . . . . . . . . . . . . .  MEMBER   -----  STRUCT   0000H  8
_c_RDS30_bufTag. . . . . . . . . . . .  * TAG *  -----  UNION    -----  2
  _c . . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  2
  SAS1 . . . . . . . . . . . . . . . .  MEMBER   -----  STRUCT   0000H  2
_c_RDS30_buf . . . . . . . . . . . . .  TYPEDEF  -----  UNION    -----  2
  _c . . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  2
  SAS1 . . . . . . . . . . . . . . . .  MEMBER   -----  STRUCT   0000H  2
tTpCopyToCanInfoStruct_s . . . . . . .  * TAG *  -----  STRUCT   -----  9
  Channel. . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0000H  1
  pDestination . . . . . . . . . . . .  MEMBER   -----  PTR      0001H  3
  pSource. . . . . . . . . . . . . . .  MEMBER   -----  PTR      0004H  3
  Length . . . . . . . . . . . . . . .  MEMBER   -----  U_INT    0007H  2
tTpCopyToCanInfoStruct . . . . . . . .  TYPEDEF  -----  STRUCT   -----  9
  Channel. . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0000H  1
  pDestination . . . . . . . . . . . .  MEMBER   -----  PTR      0001H  3
  pSource. . . . . . . . . . . . . . .  MEMBER   -----  PTR      0004H  3
  Length . . . . . . . . . . . . . . .  MEMBER   -----  U_INT    0007H  2
TpCopyToCanInfoStructPtr . . . . . . .  TYPEDEF  -----  PTR      -----  3
tWFTmaxType. . . . . . . . . . . . . .  TYPEDEF  -----  U_CHAR   -----  1
kTpFalse . . . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
kTpTrue. . . . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
tpBool . . . . . . . . . . . . . . . .  TYPEDEF  -----  U_CHAR   -----  1
tTpConnectionHandle. . . . . . . . . .  TYPEDEF  -----  U_CHAR   -----  1
canuintCPUtype . . . . . . . . . . . .  TYPEDEF  -----  U_CHAR   -----  1
cansintCPUtype . . . . . . . . . . . .  TYPEDEF  -----  CHAR     -----  1
tTpEngineTimer . . . . . . . . . . . .  TYPEDEF  -----  U_CHAR   -----  1
tTpBufferPtr . . . . . . . . . . . . .  TYPEDEF  -----  STRUCT   -----  6
  DataCanBufferPtr . . . . . . . . . .  MEMBER   -----  PTR      0000H  3
  DataApplBufferPtr. . . . . . . . . .  MEMBER   -----  PTR      0003H  3
tTpRxInfoStruct. . . . . . . . . . . .  TYPEDEF  -----  STRUCT   -----  12
  DataBufferPtr. . . . . . . . . . . .  MEMBER   -----  STRUCT   0000H  6
  DataIndex. . . . . . . . . . . . . .  MEMBER   -----  U_INT    0006H  2
  DataLength . . . . . . . . . . . . .  MEMBER   -----  U_INT    0008H  2
  sequencenumber . . . . . . . . . . .  MEMBER   -----  FIELD    000AH  4.0
  stuffbits1 . . . . . . . . . . . . .  MEMBER   -----  FIELD    000AH  4.4
  ApplGetBufferStatus. . . . . . . . .  MEMBER   -----  FIELD    000BH  2.0
tTpTxInfoStruct. . . . . . . . . . . .  TYPEDEF  -----  STRUCT   -----  10
  DataBufferPtr. . . . . . . . . . . .  MEMBER   -----  PTR      0000H  3
  DataIndex. . . . . . . . . . . . . .  MEMBER   -----  U_INT    0003H  2
  DataLength . . . . . . . . . . . . .  MEMBER   -----  U_INT    0005H  2
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 524 

NAME                                    CLASS   MSPACE  TYPE    OFFSET  SIZE
====                                    =====   ======  ====    ======  ====


  BlockSize. . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0007H  1
  STMin. . . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0008H  1
  sequencenumber . . . . . . . . . . .  MEMBER   -----  FIELD    0009H  4.0
  stuffbits1 . . . . . . . . . . . . .  MEMBER   -----  FIELD    0009H  4.4
DescBool . . . . . . . . . . . . . . .  TYPEDEF  -----  U_CHAR   -----  1
DescBitType. . . . . . . . . . . . . .  TYPEDEF  -----  U_CHAR   -----  1
t_AddrInfoIsoTpTag . . . . . . . . . .  * TAG *  -----  STRUCT   -----  1
  Dummy. . . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0000H  1
t_AddrInfoIsoTp. . . . . . . . . . . .  TYPEDEF  -----  STRUCT   -----  1
  Dummy. . . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0000H  1
kDescUsdtNetworkOk . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
kDescUsdtNetworkFailed . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
kDescUsdtNetBufferUnderrun . . . . . .  E_CONST  -----  U_CHAR   -----  1
kDescUsdtNetworkAbort. . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
t_descUsdtNetResult. . . . . . . . . .  TYPEDEF  -----  U_CHAR   -----  1
t_descHandle . . . . . . . . . . . . .  TYPEDEF  -----  U_CHAR   -----  1
t_descUsdtNetBusHandle . . . . . . . .  TYPEDEF  -----  U_CHAR   -----  1
kDescUsdtNetReqTypePhysical. . . . . .  E_CONST  -----  U_CHAR   -----  1
kDescUsdtNetReqTypeFunctional. . . . .  E_CONST  -----  U_CHAR   -----  1
kDescUsdtNetReqTypeInternal. . . . . .  E_CONST  -----  U_CHAR   -----  1
t_descUsdtNetReqType . . . . . . . . .  TYPEDEF  -----  U_CHAR   -----  1
kDescUsdtResponseNone. . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
kDescUsdtResponsePositive. . . . . . .  E_CONST  -----  U_CHAR   -----  1
kDescUsdtResponseRingBuffer. . . . . .  E_CONST  -----  U_CHAR   -----  1
kDescUsdtResponseNegative. . . . . . .  E_CONST  -----  U_CHAR   -----  1
kDescUsdtResponseNegativeRCR_RP. . . .  E_CONST  -----  U_CHAR   -----  1
kDescUsdtResponseNegativeApplRCR_RP. .  E_CONST  -----  U_CHAR   -----  1
kDescUsdtResponseRoe . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
kDescUsdtResponsePeriodic. . . . . . .  E_CONST  -----  U_CHAR   -----  1
kDescUsdtResponseSpontaneous . . . . .  E_CONST  -----  U_CHAR   -----  1
kDescUsdtResponseSpontaneousAppl . . .  E_CONST  -----  U_CHAR   -----  1
t_descUsdtNetResType . . . . . . . . .  TYPEDEF  -----  U_CHAR   -----  1
DescUsdtNetMsg . . . . . . . . . . . .  TYPEDEF  -----  PTR      -----  3
kDescUsdtNetBusTypeNone. . . . . . . .  E_CONST  -----  U_CHAR   -----  1
kDescUsdtNetBusTypeIsoTp . . . . . . .  E_CONST  -----  U_CHAR   -----  1
t_descUsdtNetBusType . . . . . . . . .  TYPEDEF  -----  U_CHAR   -----  1
t_descUsdtNetAddrInfoTag . . . . . . .  * TAG *  -----  UNION    -----  1
  isoTp. . . . . . . . . . . . . . . .  MEMBER   -----  STRUCT   0000H  1
t_descUsdtNetAddrInfo. . . . . . . . .  TYPEDEF  -----  UNION    -----  1
  isoTp. . . . . . . . . . . . . . . .  MEMBER   -----  STRUCT   0000H  1
t_descUsdtNetBus . . . . . . . . . . .  TYPEDEF  -----  STRUCT   -----  4
  comChannel . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0000H  1
  testerId . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0001H  1
  busType. . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0002H  1
  addressingInfo . . . . . . . . . . .  MEMBER   -----  UNION    0003H  1
DescContextActivity. . . . . . . . . .  TYPEDEF  -----  U_CHAR   -----  1
DescMsgItem. . . . . . . . . . . . . .  TYPEDEF  -----  U_CHAR   -----  1
DescMsg. . . . . . . . . . . . . . . .  TYPEDEF  -----  PTR      -----  3
DescConstPtr . . . . . . . . . . . . .  TYPEDEF  -----  PTR      -----  3
DescMsgLen . . . . . . . . . . . . . .  TYPEDEF  -----  U_INT    -----  2
DescStateGroup . . . . . . . . . . . .  TYPEDEF  -----  U_INT    -----  2
DescNegResCode . . . . . . . . . . . .  TYPEDEF  -----  U_CHAR   -----  1
DescMsgAddInfo . . . . . . . . . . . .  TYPEDEF  -----  STRUCT   -----  1
  reqType. . . . . . . . . . . . . . .  MEMBER   -----  FIELD    0000H  2.0
  resOnReq . . . . . . . . . . . . . .  MEMBER   -----  FIELD    0000H  2.2
  suppPosRes . . . . . . . . . . . . .  MEMBER   -----  FIELD    0000H  1.4
DescMsgContext . . . . . . . . . . . .  TYPEDEF  -----  STRUCT   -----  15
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 525 

NAME                                    CLASS   MSPACE  TYPE    OFFSET  SIZE
====                                    =====   ======  ====    ======  ====


  reqData. . . . . . . . . . . . . . .  MEMBER   -----  PTR      0000H  3
  reqDataLen . . . . . . . . . . . . .  MEMBER   -----  U_INT    0003H  2
  resData. . . . . . . . . . . . . . .  MEMBER   -----  PTR      0005H  3
  resDataLen . . . . . . . . . . . . .  MEMBER   -----  U_INT    0008H  2
  msgAddInfo . . . . . . . . . . . . .  MEMBER   -----  STRUCT   000AH  1
  busInfo. . . . . . . . . . . . . . .  MEMBER   -----  STRUCT   000BH  4
DescMainHandler. . . . . . . . . . . .  TYPEDEF  -----  PTR      -----  3
DescInitParam. . . . . . . . . . . . .  TYPEDEF  -----  U_CHAR   -----  1
DescOemCommControlInfo . . . . . . . .  TYPEDEF  -----  STRUCT   -----  3
  dummy_gap. . . . . . . . . . . . . .  MEMBER   -----  FIELD    0000H  2.0
  rxPathState. . . . . . . . . . . . .  MEMBER   -----  FIELD    0000H  2.2
  txPathState. . . . . . . . . . . . .  MEMBER   -----  FIELD    0000H  2.4
  msgTypes . . . . . . . . . . . . . .  MEMBER   -----  FIELD    0000H  2.6
  subNetNumber . . . . . . . . . . . .  MEMBER   -----  FIELD    0001H  4.0
  reqCommChannel . . . . . . . . . . .  MEMBER   -----  FIELD    0001H  4.4
  commCtrlChannel. . . . . . . . . . .  MEMBER   -----  FIELD    0002H  4.0
kDescSaStatusOk. . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
kDescSaStatusNok . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
DescSecurityAccessStatus . . . . . . .  TYPEDEF  -----  U_CHAR   -----  1
DescSecurityAccessContext. . . . . . .  TYPEDEF  -----  STRUCT   -----  7
  securityLevel. . . . . . . . . . . .  MEMBER   -----  U_INT    0000H  2
  status . . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0002H  1
  dataLen. . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0003H  1
  dataPtr. . . . . . . . . . . . . . .  MEMBER   -----  PTR      0004H  3
IltRxTimeoutCounter. . . . . . . . . .  TYPEDEF  -----  U_CHAR   -----  1
IlGetRxSAS_Angle . . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
IlTxModeCopyFct. . . . . . . . . . . .  TYPEDEF  -----  PTR      -----  3
IlIndicationFct. . . . . . . . . . . .  TYPEDEF  -----  PTR      -----  3
IlTimeoutIndicationFct . . . . . . . .  TYPEDEF  -----  PTR      -----  3
IlConfirmationFct. . . . . . . . . . .  TYPEDEF  -----  PTR      -----  3
Il_Status. . . . . . . . . . . . . . .  TYPEDEF  -----  CHAR     -----  1
Il_Boolean . . . . . . . . . . . . . .  TYPEDEF  -----  CHAR     -----  1
IlTransmitHandle . . . . . . . . . . .  TYPEDEF  -----  U_CHAR   -----  1
IlReceiveHandle. . . . . . . . . . . .  TYPEDEF  -----  U_CHAR   -----  1
IlStartStopHndType . . . . . . . . . .  * TAG *  -----  STRUCT   -----  2
  start. . . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0000H  1
  stop . . . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0001H  1
IlStartStopHnd . . . . . . . . . . . .  TYPEDEF  -----  STRUCT   -----  2
  start. . . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0000H  1
  stop . . . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0001H  1
IlRxTimeoutHandle. . . . . . . . . . .  TYPEDEF  -----  U_CHAR   -----  1
EEPROM_Update_Mode . . . . . . . . . .  EXTERN   XDATA  U_CHAR   -----  1
DTC_Set_Off. . . . . . . . . . . . . .  STATIC   XDATA  U_CHAR   022AH  1
DTC_Write_Set. . . . . . . . . . . . .  STATIC   XDATA  U_CHAR   022BH  1
DTC_Err_Sensor_Reset . . . . . . . . .  STATIC   XDATA  U_CHAR   022CH  1
Calibration_Data . . . . . . . . . . .  STATIC   XDATA  ARRAY    022DH  3
IGN_ON_Status. . . . . . . . . . . . .  PUBLIC   XDATA  U_CHAR   0230H  1
Optical_Axis_Data. . . . . . . . . . .  EXTERN   XDATA  ARRAY    -----  9
_?ix1000 . . . . . . . . . . . . . . .  STATIC   CODE   ARRAY    0000H  3
_?ix1001 . . . . . . . . . . . . . . .  STATIC   CODE   ARRAY    0003H  18
_?ix1002 . . . . . . . . . . . . . . .  STATIC   CODE   ARRAY    0015H  256
_?ix1003 . . . . . . . . . . . . . . .  STATIC   CODE   ARRAY    0115H  26
_?ix1004 . . . . . . . . . . . . . . .  STATIC   CODE   ARRAY    012FH  26
_?ix1005 . . . . . . . . . . . . . . .  STATIC   CODE   ARRAY    0149H  26
_?ix1006 . . . . . . . . . . . . . . .  STATIC   CODE   ARRAY    0163H  39
_?ix1007 . . . . . . . . . . . . . . .  STATIC   CODE   ARRAY    018AH  6
_?ix1008 . . . . . . . . . . . . . . .  STATIC   CODE   ARRAY    0190H  38
C51 COMPILER V9.51   MGR_DIAG                                                              11/17/2023 15:12:39 PAGE 526 

NAME                                    CLASS   MSPACE  TYPE    OFFSET  SIZE
====                                    =====   ======  ====    ======  ====


_?ix1009 . . . . . . . . . . . . . . .  STATIC   CODE   ARRAY    01B6H  16


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   6442    ----
   CONSTANT SIZE    =    454    ----
   XDATA SIZE       =    561     539
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
